# Detected language: en (p=1.00)

[0.00s -> 9.48s]  Let's look at the first of three properties that cryptography can provide—confidentiality,
[9.48s -> 12.00s]  also called secrecy.
[12.00s -> 18.28s]  The basic way you achieve confidentiality is through encryption.
[18.28s -> 21.84s]  Because cryptography has a firm mathematical basis, and because it's important to be
[21.84s -> 25.40s]  precise given the dangers of using it haphazardly, I'm going to introduce some
[25.40s -> 26.40s]  terms.
[27.40s -> 30.44s]  I'm going to start with symmetric encryption.
[30.44s -> 36.26s]  In symmetric encryption, two parties share some secret key k.
[36.26s -> 40.26s]  So let's suppose we have a message m, we want to transmit confidentially, and the
[40.26s -> 42.16s]  key k.
[42.16s -> 47.72s]  m is called the plaintext, or cleartext—it's the thing we want to keep secret.
[47.72s -> 54.56s]  To encrypt, we call the function e, passing the message m, and the key k.
[54.56s -> 57.52s]  This produces a ciphertext c.
[57.52s -> 61.60s]  If our encryption algorithm is secure, then it's intractable for someone to figure
[61.60s -> 65.76s]  out the cleartext from the ciphertext unless they have the key.
[65.76s -> 71.72s]  So we can transfer the ciphertext c over the network—adversaries can look at it,
[71.72s -> 75.44s]  but they can't read the original message m.
[75.44s -> 80.96s]  To decrypt the ciphertext, we call the decrypt function d, also passing the key
[80.96s -> 82.24s]  k.
[82.32s -> 85.40s]  This returns the original cleartext m.
[85.40s -> 90.16s]  The goal is that you can only decrypt the message, or learn anything about it, if you
[90.16s -> 92.88s]  have the right key k.
[92.88s -> 97.28s]  Of course someone could try every k, so you pick a key big enough that exhaustively
[97.28s -> 99.36s]  searching the space is intractable.
[99.36s -> 105.72s]  For example, make the key 128 or 256 bits.
[105.72s -> 112.40s]  Because e and d take the same key k, we call this symmetric, or shared-key encryption.
[112.40s -> 115.24s]  There are other cryptosystems that don't use symmetric keys, and we'll cover them
[115.24s -> 116.84s]  later.
[116.84s -> 127.36s]  Examples of symmetric encryption algorithms are AES, Blowfish, DES, and RC4.
[127.36s -> 133.40s]  A one-time pad is a perfectly secret but generally impractical encryption algorithm.
[133.44s -> 137.32s]  We generate a perfectly random stream of bits as our key k.
[137.32s -> 141.72s]  The sender and receiver somehow exchange its key securely beforehand.
[141.72s -> 145.52s]  For example, through a handshake and a USB drive.
[145.52s -> 150.20s]  To encrypt, we XOR our message m with the key k.
[150.20s -> 156.30s]  To decrypt, we XOR our ciphertext c with the key k.
[156.30s -> 161.84s]  This algorithm is perfectly secure in that if we have the ciphertext but not the key,
[162.28s -> 164.40s]  then any m is equally likely.
[164.40s -> 167.28s]  Furthermore, this algorithm is really fast.
[167.28s -> 170.24s]  All we have to do is XOR.
[170.24s -> 174.66s]  So if you're a super-secret spy who wants to send a short message, one-time pads are
[174.66s -> 175.66s]  great.
[175.66s -> 177.56s]  But not so in general practice.
[177.56s -> 182.76s]  The problem with one-time pads is that your key k is the same size as the message
[182.76s -> 183.76s]  m.
[183.76s -> 187.36s]  To send a gigabyte of data, you need a gigabyte-long key.
[187.36s -> 188.76s]  This is not practical.
[189.68s -> 193.72s]  We'd like to be able to send small keys that encrypt large amounts of data, yet are
[193.72s -> 195.48s]  still intractable to crack.
