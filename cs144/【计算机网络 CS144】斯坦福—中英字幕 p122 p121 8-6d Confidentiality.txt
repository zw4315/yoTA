# Detected language: en (p=1.00)

[0.00s -> 7.68s]  So, one-time paths are generally impractical. Instead, what we want is a cryptosystem where
[7.68s -> 15.04s]  we can distribute a small key, k, say 128 or 256 bits. We somehow share this key beforehand,
[15.04s -> 19.04s]  for example over the phone, or write it down and exchange it with a handshake.
[19.04s -> 25.18s]  We then use this k to encrypt a much larger message m. We then call encrypt e,
[25.18s -> 29.74s]  passing the plaintext message m and the clear k to produce the ciphertext c.
[29.74s -> 36.26s]  Now, unlike a one-time pad, it might be that there is only one possible m that produces
[36.26s -> 41.42s]  the ciphertext. But, we believe it is computationally tractable to find this m.
[41.42s -> 48.10s]  You could try all possible keys, but decrypting two of the 128 or 300 undecillion keys would
[48.10s -> 51.02s]  take a very, very long time.
[51.02s -> 54.66s]  Suppose you only take a single instruction to decrypt the message. Let's suppose your
[54.66s -> 60.10s]  processor core is 4 GHz, and let's suppose your processor has 4 billion cores, it would
[60.10s -> 66.22s]  still take 4 billion of these computers 31 years to decrypt such a message.
[66.22s -> 72.12s]  There are two kinds of symmetric ciphers, stream and block.
[72.12s -> 76.34s]  Stream ciphers generate a pseudo-random pad, a pseudo-random sequence of bits based
[76.34s -> 80.22s]  on the key. You then encrypt decrypt by XORing with the stream like a one-time
[81.22s -> 85.54s]  pad. But it is not a one-time pad. Immediately mistrust anyone who says it is, because they
[85.54s -> 88.06s]  don't know what they're talking about.
[88.06s -> 92.08s]  Generally speaking, stream ciphers have run into lots of problems in practice.
[92.08s -> 97.94s]  Problems with stream ciphers typically stem from repetition. If you reuse the same pseudo-random
[97.94s -> 101.78s]  sequence of bits, for example reuse the same key on two different messages, then
[101.78s -> 106.54s]  adversaries can launch attacks like I showed with a two-time pad. The initial Wi-Fi encryption
[106.86s -> 110.96s]  protocol WEP, for example, used a stream cipher. It was shown to be broken in about 2001 when
[110.96s -> 117.98s]  Wi-Fi was starting to take off, and was replaced by WPA in 2003 and WPA2 in 2004.
[117.98s -> 124.98s]  WPA2 uses something called a block cipher. A block cipher operates on fixed-sized blocks
[126.42s -> 133.42s]  of data, say 64 bits or 128 bits. A block cipher maps a plain text block to a cipher
[133.78s -> 139.10s]  text block. There are many block ciphers. Today, you should generally use AES, the
[139.10s -> 142.10s]  Advanced Encryption Standard.
[142.10s -> 149.10s]  I'm going to walk through the basics of how one block cipher, Blowfish, works, but
[150.46s -> 154.90s]  be careful. I'm not explaining the algorithm in its entirety. I'm just trying to give
[154.90s -> 158.24s]  you a feel for what a block cipher looks like and how it works. I've left out
[158.24s -> 162.50s]  a lot of details, which if you don't pay attention to, the cipher might not be secure.
[162.50s -> 167.50s]  You should rely on existing implementations and use suggestions.
[167.50s -> 174.50s]  Here are the basics of the Blowfish block cipher. It uses something called a Feistel
[175.78s -> 179.78s]  network. A Feistel network, or Feistel cipher, is one where encryption and decryption use
[179.78s -> 184.58s]  the same computational structure. Specifically, decrypting Blowfish looks just like the
[184.58s -> 189.26s]  inverse of encrypting, except that the function f is different. So to decrypt, you
[189.42s -> 194.18s]  decipher text c at the bottom, and reverse all the arrows, and the clear text m comes
[194.18s -> 196.54s]  out at the top.
[196.54s -> 202.54s]  To use Blowfish, you take the original key and derive the function f and 18 sub-keys,
[202.54s -> 208.54s]  p1 through p18. You take your plain text block of 64 bits and divide it into two
[208.54s -> 215.54s]  parts, the left half l0 and the right hand r0. Both l0 and r0 are 32 bits long.
[215.54s -> 220.54s]  You then process l0 and r0 through 16 iterations of the structure shown here on the left.
[220.54s -> 225.54s]  You XOR the left hand with the key p, without key p. You pass this value through the
[225.54s -> 230.54s]  function f and XOR that with the right hand value. The right hand value becomes
[230.54s -> 235.54s]  the left hand value, and vice versa. Then, in the final step, you XOR the left hand
[235.54s -> 240.54s]  value with p18, and the right hand value with p17. This produces two different
[240.54s -> 245.54s]  32-bit values which concatenate into the ciphertext c.
