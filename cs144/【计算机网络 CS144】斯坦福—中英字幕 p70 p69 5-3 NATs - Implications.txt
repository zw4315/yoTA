# Detected language: en (p=1.00)

[0.00s -> 5.00s]  So, NATs provide a really useful service. They allow you to share an IP address
[5.00s -> 10.00s]  among many hosts, which is useful today given that IP addresses are becoming more
[10.00s -> 13.00s]  scarce. They also can provide some other useful
[13.00s -> 16.00s]  services, such as a limited degree of security and firewalling.
[16.00s -> 19.00s]  So, there are a lot of implications to what happens when you're behind a NAT.
[19.00s -> 22.00s]  So, this video is going to go into what some of those implications are and
[22.00s -> 26.00s]  how some modern applications today try to deal with them when they're
[26.00s -> 29.00s]  obstructions. So, the first implication of applications
[29.00s -> 34.00s]  of a translator's translator is that, generally speaking incoming connections
[34.00s -> 38.00s]  you can't have an incoming connection. So, we saw this back when we talked about
[38.00s -> 40.00s]  Skype. What happens is when you want to open a
[40.00s -> 44.00s]  call to somebody who's behind a NAT, you can't directly open a TCP connection
[44.00s -> 48.00s]  to them because there's no mapping. So, let's walk through how that works.
[48.00s -> 54.00s]  So, here we have an SSH server or we have a server sitting behind a NAT.
[54.00s -> 59.00s]  Here's server A. And it has, it happens to be running an
[59.00s -> 63.00s]  SSH server on port 22. And it has, you know, opened a
[63.00s -> 66.00s]  connection to this server S. It's browsing the web.
[66.00s -> 69.00s]  You know, it does a web connection. This is great.
[69.00s -> 79.00s]  So now, what happens when host B wants to open an SSH connection to host A?
[80.00s -> 84.00s]  Well, the problem is it's going to be sending a packet to this NAT.
[84.00s -> 91.00s]  And whatever happens, somehow this packet needs to be translated to be going to
[91.00s -> 97.00s]  10.0.0.101 port 22. But there's no mapping for that.
[97.00s -> 101.00s]  SSH is a server. It doesn't issue connection requests
[101.00s -> 103.00s]  out. It receives connection requests.
[103.00s -> 108.00s]  And so, the NAT has no mapping. And so, because there's no mapping to
[108.00s -> 114.00s]  10.0.0.101 port 22, B effectively can't open an SSH connection, right?
[114.00s -> 119.00s]  The NAT allows connections out. It does not allow connections in.
[122.00s -> 126.00s]  And so, this poses all kinds of complications for applications where, you
[126.00s -> 130.00s]  know, what happens if, say, I'm running Skype and I would like to make a phone
[130.00s -> 134.00s]  call if the other node's behind the NAT, I can't open a connection to that node.
[134.00s -> 137.00s]  And so, it really restricts the kinds of services that you can deploy.
[137.00s -> 141.00s]  You have to jump through a bunch of hoops in order to make applications work
[141.00s -> 145.00s]  when they're sitting behind NATs. But so, this is the number one
[145.00s -> 149.00s]  implication of sitting behind a NAT to an application, which is that
[149.00s -> 153.00s]  essentially, if you're behind a NAT, generally speaking, other nodes, unless
[153.00s -> 157.00s]  you coordinate very carefully, and I'll show some ways you can do it, you
[157.00s -> 160.00s]  can't open, nobody can open a connection to you.
[160.00s -> 163.00s]  So, the first approach, and I talked about this briefly in the Skype lecture
[163.00s -> 165.00s]  before, is something called connection reversal.
[165.00s -> 171.00s]  So, imagine that A is sitting behind a NAT, and B wants to open a connection to
[171.00s -> 175.00s]  A. Well, B can't because the NAT has no
[175.00s -> 179.00s]  mapping, these packs will bounce off, you know, bounce off, you get ICMP
[179.00s -> 182.00s]  errors. And so, what you can do is have some
[182.00s -> 186.00s]  kind of reversal service or some kind of rendezvous service where both A and B
[186.00s -> 189.00s]  are connected to the rendezvous service.
[189.00s -> 193.00s]  And when B wants to open a connection to A, what it actually sends is, it
[193.00s -> 197.00s]  sends a request, hey A, I want a connection.
[202.00s -> 208.00s]  The rendezvous service can forward this request on, then A can open a connection
[208.00s -> 211.00s]  to B. This is called connection reversal,
[211.00s -> 215.00s]  because B wants to open a connection to A, but because it can't because of
[215.00s -> 218.00s]  the NAT. So instead, you reverse the connection
[218.00s -> 222.00s]  and have A open a connection to B. And to do this, you need some kind of
[222.00s -> 224.00s]  rendezvous service that too can communicate.
[224.00s -> 228.00s]  But they both open outgoing connections to rendezvous service, and then requests
[228.00s -> 231.00s]  are forwarded in that way. So this is, for example, one of the
[231.00s -> 234.00s]  things that Skype does. So another approach, and this is also
[234.00s -> 238.00s]  what Skype does, is if both hosts are behind a NAT, well, this means that
[238.00s -> 242.00s]  neither of them can directly open a connection to the other.
[242.00s -> 245.00s]  In both cases, the connection request will fail.
[245.00s -> 249.00s]  There's no mapping on the NAT, generally speaking, and so it fails.
[249.00s -> 258.00s]  So instead, what you do is you have both of them connect to some relay R.
[261.00s -> 265.00s]  And then the relay R forwards traffic between those two connections.
[265.00s -> 270.00s]  So, data that streams in from A's connection, that R receives, then forwards
[270.00s -> 274.00s]  to the connection to B, data that comes in from B's connection, R receives
[274.00s -> 277.00s]  and forwards to A. But here's this example of suddenly
[277.00s -> 280.00s]  this is no longer end-to-end. We now have introduced this additional
[280.00s -> 283.00s]  host in the center, and who knows what could go wrong.
[283.00s -> 287.00s]  So certainly if you're doing this, it's good to encrypt your traffic, unless,
[287.00s -> 290.00s]  unless you trust the relay. But there's a way where if both hosts
[290.00s -> 293.00s]  are behind a NAT, they can still open connections to one another.
[293.00s -> 296.00s]  Admittedly, through a third host that is, and does have a publicly
[296.00s -> 300.00s]  route-applied B address, and which is not sitting behind a NAT.
[300.00s -> 304.00s]  So that's sort of some basic things that you can do, say, at the TCP level
[304.00s -> 307.00s]  and et cetera. It turns out that if you really need to
[307.00s -> 313.00s]  open up direct connections, there are more aggressive and tricky things you can do.
[313.00s -> 316.00s]  One of which is called NAT hole punching.
[316.00s -> 320.00s]  And so the basic idea here is that we have these two clients that are
[320.00s -> 323.00s]  sitting behind that. It's client A and client B.
[323.00s -> 326.00s]  And they want to open up direct connections to one another.
[326.00s -> 330.00s]  Or a direct connection between each other. They don't want to go through some
[330.00s -> 335.00s]  external rendezvous service or relay. And so what they do is they first talk
[335.00s -> 340.00s]  with some external server to figure out what, you know, some sort of server here
[340.00s -> 344.00s]  to figure out what their external address and ports are.
[344.00s -> 349.00s]  So client B says, aha, if I send you packets, say, from UDP port 6000, the
[349.00s -> 355.00s]  server will then report back at the message saying, aha, well these packets
[355.00s -> 362.00s]  you're sending, I see them coming from 76, 18, 117, 20 port 9091.
[362.00s -> 370.00s]  So the client B knows that 10.1.1.9 port 6000 appears externally to the world as
[370.00s -> 376.00s]  76, 18, 17, 20, 9091. And A does the same thing.
[376.00s -> 386.00s]  So it'll find out that, you know, its packets look like 34.22.8 port 30,005.
[386.00s -> 394.00s]  So now, in these cases, both clients A and B have sent packets over the NAT
[394.00s -> 400.00s]  from this internal address port pair to this, to an external IP address on port.
[400.00s -> 405.00s]  And the NATs have created mappings. So they have mappings internally.
[405.00s -> 410.00s]  For this internal address port. And let's just say that they're full
[410.00s -> 415.00s]  cone NATs, just for simplicity's sake. This means that these mappings are now
[415.00s -> 418.00s]  active on the NATs. And so it's possible now, if
[418.00s -> 423.00s]  communicating with the server, client B can ask the server, hey, what's client
[423.00s -> 428.00s]  A's public IP address and port? Based on that, the server could say,
[428.00s -> 433.00s]  well, it's 128.34.22.8, you know, port 30,005.
[433.00s -> 443.00s]  Ah, then client B could send traffic to that public IP address and port pair, and
[443.00s -> 449.00s]  it could traverse the NAT mapping. Similarly, A could ask the server, hey,
[449.00s -> 452.00s]  what's B's public IP address and port pair?
[452.00s -> 459.00s]  Then send traffic to 76181720, port 9091, and have it traverse the mapping and go
[459.00s -> 463.00s]  to client B. This is assuming that those mappings
[463.00s -> 465.00s]  are full cone. These are full cone NATs.
[465.00s -> 467.00s]  Let's say that they're not full cone NATs.
[467.00s -> 472.00s]  Well, it turns out you can still do some tricks where the server can tell
[472.00s -> 477.00s]  client A and client B again what the public IP address port pairs are of the
[477.00s -> 481.00s]  other clients. And then the clients can try sending
[481.00s -> 486.00s]  traffic to each other simultaneously. And so client B will start sending
[486.00s -> 491.00s]  traffic to 12834.22.8, port 3005 from its port 6000.
[491.00s -> 497.00s]  Simultaneously, client A will start sending traffic to 76181720, port 9091
[497.00s -> 502.00s]  from its IP address and port. What's gonna happen is that if we say
[502.00s -> 507.00s]  had a restricted cone NAT or even a port restricted NAT, when those packets,
[507.00s -> 511.00s]  outgoing packets traverse the NAT, the NAT's gonna set up a mapping.
[511.00s -> 516.00s]  It's gonna say, aha, I see that you, client A, are sending traffic to this
[516.00s -> 520.00s]  external IP address and port. I'll create a mapping for you so things
[520.00s -> 523.00s]  are translated properly. Similarly, this NAT on the right is
[523.00s -> 525.00s]  gonna do when client B sends the traffic.
[525.00s -> 530.00s]  And so by knowing what the external address and ports are of the other
[530.00s -> 533.00s]  side, they can force the NAT to set up a mapping.
[533.00s -> 539.00s]  So one question is, is there a kind of NAT, or what kinds of NATs would this not
[539.00s -> 546.00s]  work for? This model where client A and client B simultaneously send traffic to
[546.00s -> 552.00s]  the external IP address and port that map to an internal IP address and port
[552.00s -> 557.00s]  on each of these clients, which were determined earlier by communicating with
[557.00s -> 560.00s]  the server. So giving me these different kinds of
[560.00s -> 566.00s]  NAT for which this would not work. So it turns out this will work for full
[566.00s -> 571.00s]  cone NATs, cuz the mappings will work fine even if the, the source IP address
[571.00s -> 575.00s]  and port are different. Work for restricted cone NATs, cuz again,
[575.00s -> 579.00s]  we've set up these mappings, which will include the external IP address of
[579.00s -> 583.00s]  the other NAT. It'll work for port restricted NATs,
[583.00s -> 587.00s]  because again, these packets are gonna be coming from the right UDP ports.
[587.00s -> 591.00s]  The one class of NAT it won't work for is a symmetric NAT, because when these
[591.00s -> 596.00s]  clients talk to the server to figure out their IP address and port, their external
[596.00s -> 601.00s]  ones, that mapping won't hold when they start talking to another NAT.
[601.00s -> 606.00s]  So just because the server saw port 30005, when client A then tries to send
[606.00s -> 611.00s]  traffic to the NAT on the right, this, the NAT is not gonna reuse port
[611.00s -> 614.00s]  30005. It's gonna allocate a new external port
[614.00s -> 617.00s]  and so it won't work. So this is one reason why symmetric NATs
[617.00s -> 619.00s]  are really frowned upon in the Internet today.
[619.00s -> 625.00s]  So we talked about implications of NATs to applications and how they have to do
[625.00s -> 630.00s]  things to set up mappings or either use relays or rendezvous services.
[630.00s -> 635.00s]  So there's another, perhaps even deeper implication of NATs which is to
[635.00s -> 638.00s]  transport. So if you think for a second, for a
[638.00s -> 643.00s]  NAT to set up a mapping, it needs to know what the transport protocol is.
[643.00s -> 646.00s]  It needs to know the transport protocol's headers.
[646.00s -> 650.00s]  So for example, when it sets up a UDP or TCP mapping, the NAT needs to know
[650.00s -> 654.00s]  that this is a TCP segment, this is a UDP segment, this is where the port
[654.00s -> 658.00s]  number is in that segment, this is what I need to rewrite, this is how
[658.00s -> 661.00s]  checksums are calculated. And without that, it can't do it.
[661.00s -> 665.00s]  So if you deploy, if you say write a new transport protocol that uses a
[665.00s -> 669.00s]  transport protocol identifier in an IP packet and you try to get it to
[669.00s -> 671.00s]  traverse a NAT, a NAT will discard it.
[671.00s -> 677.00s]  It doesn't know the packet format. And so in this way, you can't really deploy
[677.00s -> 680.00s]  a new transport protocol on the internet today.
[680.00s -> 684.00s]  Sort of, there's a chicken and egg problem where the people developing NAT
[684.00s -> 688.00s]  software and maintaining the NAT software will not add support for a new
[688.00s -> 691.00s]  transport protocol until it's very, very popular.
[691.00s -> 694.00s]  But it won't become very popular until it works across NATs.
[694.00s -> 699.00s]  And so there's this sort of this debate and philosophical discussion, right, in
[699.00s -> 705.00s]  the early, you know, mid-2000s about how NATs mean that we're basically stuck
[705.00s -> 710.00s]  with TCP, UDP, and ICMP, right? To have an application work for real on the
[710.00s -> 715.00s]  internet at large, it has to use one of those three transport protocols.
[715.00s -> 720.00s]  And so, really, NATs today, we're not gonna see any new transport protocols on
[720.00s -> 724.00s]  the internet. And so this leads to this really big philosophical debate
[724.00s -> 728.00s]  that's especially occurring as NATs deployed in the early 2000s about, on one
[728.00s -> 732.00s]  another, how they're insanely useful. You can reuse addresses, there's security.
[732.00s -> 736.00s]  You know, if I'm sitting behind a NAT, and I happen to have some vulnerable
[736.00s -> 740.00s]  open ports, say on my Linux machine or my Windows machine, since there's no
[740.00s -> 744.00s]  mapping, attackers from outside on the broader internet can't, can't
[744.00s -> 748.00s]  compromise me, right? Sort of gives this very simple, I mean, very
[748.00s -> 752.00s]  sledgehammer-y, but, but very effective just for end users, security,
[752.00s -> 755.00s]  right? Not opening connections can be good.
[755.00s -> 759.00s]  But, there's also tremendous, they're also tremendously painful, especially
[759.00s -> 762.00s]  before NATs started to have standard behavior.
[762.00s -> 766.00s]  Developing applications is really hard. Imagine if somebody calls you and says,
[766.00s -> 770.00s]  hey, your application doesn't work, you know, sometimes the connection drops.
[770.00s -> 774.00s]  And it could be something like, it happens to be that it's when their
[774.00s -> 778.00s]  client is transitioning from one server to another, and the NAT is using a
[778.00s -> 782.00s]  symmetric, is a symmetric NAT, such that, you know, the ports are being
[782.00s -> 786.00s]  disconnected and the connection breaks. Really hard to debug.
[786.00s -> 791.00s]  And so one example, there's this really famous example of something called speak
[791.00s -> 794.00s]  freely, which is this pre-Skype voice over IP.
[794.00s -> 797.00s]  And basically the guy said, hey, I'm gonna stop developing speak freely
[797.00s -> 800.00s]  because, you know, it just doesn't work under NATs and there's no way to
[800.00s -> 803.00s]  make them work with NATs. It's before people figured out all the
[803.00s -> 806.00s]  hole punching and before the behavior was standard enough to do so.
[806.00s -> 809.00s]  And so there was this huge philosophical debate, NAT's good, NAT's bad, they
[809.00s -> 812.00s]  break the end-to-end argument. But really, it's really, it's very
[812.00s -> 814.00s]  interesting, but it turns out to be pointless.
[814.00s -> 816.00s]  I mean, NATs are here to stay. They're deployed.
[816.00s -> 820.00s]  They will always be deployed. Their advantages generally are considered
[820.00s -> 823.00s]  to outweigh the disadvantages. People are gonna deploy them and they
[823.00s -> 826.00s]  want them to work and you have to work around them.
[826.00s -> 829.00s]  But, so what this means is that we, you know, sort of historically talk
[829.00s -> 831.00s]  about the Internet as having a narrow wasted IP.
[831.00s -> 834.00s]  There's a single unifying protocol which then allows you to have many
[834.00s -> 837.00s]  transport protocols above, many link protocols below.
[837.00s -> 841.00s]  But NATs have changed that. And so really, in a practical sense,
[841.00s -> 846.00s]  the new hourglass includes not only layer three, but also layer four.
[846.00s -> 850.00s]  Because for practical concerns, we're not gonna see new transport protocols
[850.00s -> 854.00s]  implemented or deployed. You can build protocols on top of UDP
[854.00s -> 856.00s]  and that's generally what's done today.
[856.00s -> 860.00s]  Since GDP just provides a nice datagram service, rather than using a transport
[860.00s -> 865.00s]  identifier at three, at layer three, you use a port at layer four.
[865.00s -> 870.00s]  But this is the world as it is, that now the new hourglass of the Internet,
[870.00s -> 876.00s]  because of network address translation, is IP, then with ICMP, TCP, and UDP.
[876.00s -> 880.00s]  So you can see how this technology actually has caused an
[880.00s -> 883.00s]  architectural shift within the Internet, within the past decade.
