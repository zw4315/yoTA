# Detected language: en (p=1.00)

[0.00s -> 4.00s]  So in this video, we'll talk about fragmentation and assembly.
[4.00s -> 8.00s]  So here's the basic problem that fragmentation and assembly try to solve.
[8.00s -> 12.00s]  Let's say that myth, I'm using some machine in Stanford, and the myth
[12.00s -> 15.00s]  cluster, and I want to request a webpage from Google.
[15.00s -> 20.00s]  And Google's webpage that it sends this HTTP response is ten kilobytes long.
[20.00s -> 23.00s]  Well, a ten kilobyte chunk of data is pretty big.
[23.00s -> 28.00s]  And the problem is that there might be some hop along the path from Google to
[28.00s -> 33.00s]  myth that can't support a ten kilobyte packet. In fact, Ethernet, the maximum
[33.00s -> 37.00s]  transfer unit at many speeds of Ethernet support is 1500 bytes.
[37.00s -> 42.00s]  And so what I need to do is take this ten kilobyte packet and break it into a
[42.00s -> 47.00s]  series of chunks, smaller pieces called fragments, which the network can support.
[47.00s -> 51.00s]  So imagine like the extreme case, if Google, if I'm downloading something
[51.00s -> 54.00s]  really big, I don't want to be sending one gigabyte packets.
[54.00s -> 58.00s]  They're going to occupy the, the channel for huge amounts of time, so I want to
[58.00s -> 62.00s]  break things into smaller chunks. So in this case, if I had, say, an
[62.00s -> 67.00s]  Ethernet frame size of 1.5 kilobytes, I'll need to split this ten kilobytes
[67.00s -> 73.00s]  into seven, seven fragments. Where these first six could be 1.5 each,
[73.00s -> 77.00s]  and the last one, say, is one. One kilobyte.
[77.00s -> 83.00s]  So that's the process of fragmentation. And these fragments arrive at myth, and
[83.00s -> 86.00s]  its job is to assemble, and this is assembly.
[86.00s -> 91.00s]  So to take these seven fragments, two, three, four, five, six, seven, and
[91.00s -> 95.00s]  reassemble them to the original ten kilobytes of data.
[95.00s -> 100.00s]  And so generally speaking, fragmentation and assembly occur when a higher layers
[100.00s -> 104.00s]  data unit is larger than what the low, a lower layer can support.
[104.00s -> 108.00s]  So fragmentation, the process of taking a large chunk of data and
[108.00s -> 112.00s]  breaking it into smaller pieces that the lower layer, layer can support.
[112.00s -> 116.00s]  And assembly is in the process of taking these fragments and reassembling them
[116.00s -> 120.00s]  into the original data. This occurs in many different places
[120.00s -> 124.00s]  and networks at, at different layers. For example, it can occur at the
[124.00s -> 128.00s]  transport layer. So TCP does this when it takes a
[128.00s -> 134.00s]  stream of data, it breaks it into segments which are then transmitted and
[134.00s -> 139.00s]  reassembled at the other side into a reliable stream.
[139.00s -> 144.00s]  And this assembly is now occurring end-to-end between the two TCP endpoints,
[144.00s -> 149.00s]  such that a given TCP segment, once it's generated by an endpoint, is then
[149.00s -> 152.00s]  indivisible and arrives at the other end.
[152.00s -> 156.00s]  You never see a segment broken into two separate segments.
[156.00s -> 160.00s]  Although underneath it might be broken into packets or frames, as we'll show.
[160.00s -> 165.00s]  Contrast the network layer, it's operating on a host-to-host basis.
[165.00s -> 169.00s]  This is unlike TCP, where once a segment is sent, that is the segment the endpoint
[169.00s -> 173.00s]  will receive if it arrives. With IP, at the network layer, it's
[173.00s -> 177.00s]  possible that some intermediate node takes the packet and breaks it up.
[177.00s -> 182.00s]  So an RP packet traversing the network at some intermediate point might be broken
[182.00s -> 187.00s]  into multiple IP fragments, which then the endpoint has to reassemble into the
[187.00s -> 191.00s]  original IP packet. And so this is at the network layer
[191.00s -> 196.00s]  and so it can occur within the network. Finally, it can also occur at the link
[196.00s -> 200.00s]  layer. So one example is there's a link layer
[200.00s -> 205.00s]  called Zigbee or 802.15.4 that has a very small frame size of approximately
[205.00s -> 208.00s]  120 bytes. 127, but that doesn't, you have to
[208.00s -> 212.00s]  include the header in that. And there are times when you want to
[212.00s -> 217.00s]  send large packets on this frame size, like an IPv6 packet which can be
[217.00s -> 222.00s]  distributed at 1280 bytes. And so what happens is that the IP layer
[222.00s -> 228.00s]  passes a 1280 byte packet to 6LOPAN called IPv6 low power personal network.
[228.00s -> 234.00s]  It's to link layer support for IPv6. And 6LOPAN at the link layer breaks it
[234.00s -> 240.00s]  up into fragments, which are then sent over the link, reassembled at the other
[240.00s -> 243.00s]  end of the link into an original packet.
[243.00s -> 247.00s]  So in this case, the fragments are purely on the link, and the network layer
[247.00s -> 250.00s]  doesn't see it. In the IP case, the network layer sees
[250.00s -> 252.00s]  it. The transport case, transport layer
[252.00s -> 256.00s]  sees it, but the other, the actual transport segments are not broken.
[256.00s -> 258.00s]  So let's walk through a concrete example.
[258.00s -> 262.00s]  So the most, one of the really common cases of fragmentation, or rather it's
[262.00s -> 266.00s]  not common, people try to avoid it, but it's a very simple mechanism, so
[266.00s -> 270.00s]  it's good to explain, is how fragmentation works in IP, in the internet
[270.00s -> 273.00s]  protocol. So here, let's imagine we have a route
[273.00s -> 278.00s]  between, across three hops, where the first and second, the first and third
[278.00s -> 282.00s]  hops use Ethernet with a maximum transfer unit of 1500 bytes.
[282.00s -> 286.00s]  But the middle hop uses a point to point link with a maximum transfer unit
[286.00s -> 290.00s]  of 576 bytes. This means that at the link layer, the
[290.00s -> 295.00s]  frames can only support, say, 576 bytes of data, or 1500 bytes of data in their
[295.00s -> 298.00s]  payload. So what happens now is, I, some
[298.00s -> 302.00s]  application, the host on the left wants to send a 1400 byte payload.
[302.00s -> 307.00s]  And so on the first hop, this is fine. We can take a 1400 byte payload, an IP
[307.00s -> 311.00s]  header is 20 bytes, and so we have 1420 bytes.
[311.00s -> 317.00s]  We can then put that in Ethernet frame, 1420, fits just fine inside Ethernet.
[317.00s -> 321.00s]  But what happens when we hit the second host?
[321.00s -> 326.00s]  We can't take this 1400 byte payload and put it into a PPP frame, because it
[326.00s -> 330.00s]  won't fit. So what IP does, is it takes the
[330.00s -> 333.00s]  original packet and splits it into three fragments.
[333.00s -> 337.00s]  So this is something which is going to occur here at this node.
[337.00s -> 341.00s]  This node is going to receive an IP packet of 14, with a 1400 byte payload
[341.00s -> 345.00s]  in this given IP header. Then realizing it should go over this
[345.00s -> 349.00s]  PPP link, we'll take it and generate three separate IP packets.
[349.00s -> 354.00s]  I'll show how they're formatted in a minute, as separate PPP frames with
[354.00s -> 360.00s]  smaller payloads. In this case, 512, 512, and 376 bytes.
[360.00s -> 366.00s]  But so the trick though is that once this packet has been fragmented at this
[366.00s -> 371.00s]  second node, those fragments then pass through the network unchanged.
[371.00s -> 375.00s]  So the third node here does not reassemble them.
[375.00s -> 381.00s]  Instead, what's going to happen is that it's going to just forward them along
[381.00s -> 386.00s]  these three IP fragments inside Ethernet frames and forward them along to the
[386.00s -> 390.00s]  destination. And then hopefully, the destination will
[390.00s -> 395.00s]  receive all of them and reassemble the original data of 1400 bytes.
[395.00s -> 401.00s]  So how does this work? So if we look at an IP header there are
[401.00s -> 405.00s]  a couple fields in it which allow this to happen.
[405.00s -> 410.00s]  So basically there's the ident field in an IP packet here.
[410.00s -> 415.00s]  And the ident field is what allows the fragmentation assembly layer in IP or the
[415.00s -> 419.00s]  fragmentation assembly in IP to be able to tell whether or not these are
[419.00s -> 423.00s]  fragments of the same original packet. So before fragmentation, we're going to
[423.00s -> 428.00s]  see a packet that looks like this, where it's ident to say some value x.
[428.00s -> 432.00s]  And remember here, this is the more fragment bit of the IP header.
[432.00s -> 435.00s]  This was zero here. This is the more fragment bit.
[435.00s -> 439.00s]  And there's the offset field. So this original packet, this is
[439.00s -> 442.00s]  just another identifier. There are no fragments.
[442.00s -> 446.00s]  There's an offset of zero. And it's just a 1400 byte fragment.
[446.00s -> 450.00s]  But then after the packet is fragmented, the more fragment bit is set for all
[450.00s -> 454.00s]  but the last fragment. So here, this first fragment here
[454.00s -> 458.00s]  and the second fragment both have the more fragment bit set to indicate that
[458.00s -> 462.00s]  more fragments are coming. The last one does not.
[462.00s -> 468.00s]  And then the offset field tells a receiver where this data begins.
[468.00s -> 472.00s]  And so as we can see here, this is a 512 bytes of payload.
[472.00s -> 480.00s]  And so this goes from offset zero to 511. Now the second fragment is going to
[480.00s -> 485.00s]  start at byte 512 and goes from byte 512 to 1024.
[485.00s -> 488.00s]  And so the offset field is what indicates this.
[488.00s -> 492.00s]  So the offset field is not in terms of bytes but rather in eight byte chunks.
[492.00s -> 497.00s]  And so 64 times eight is 512. And so this tells a receiver that
[497.00s -> 503.00s]  this second fragment occurs at offset 512 within the packets at offset zero.
[503.00s -> 506.00s]  And then this is of course at offset 1024.
[506.00s -> 509.00s]  The ident field is identical in all three fragments.
[509.00s -> 514.00s]  And so this means that now an, an endpoint receiving these three fragments
[514.00s -> 518.00s]  can properly reassemble the original IP datagram.
[518.00s -> 523.00s]  And so the combination of the ident field and the source address is what
[523.00s -> 527.00s]  allows it to cluster these three fragments together.
[527.00s -> 532.00s]  And now since the offset field's encoded in eight byte chunks, that means that
[532.00s -> 537.00s]  each of these chunks, these fragments must be a multiple of eight byte long,
[537.00s -> 539.00s]  eight bytes long except for the last one.
[539.00s -> 543.00s]  So fragmentation is, in the IP case, really helpful because it means that an
[543.00s -> 548.00s]  endpoint can generate an IP packet without having to worry about what the
[548.00s -> 552.00s]  intermediate maximum transfer units of the links are.
[552.00s -> 556.00s]  So it's a great way for an endpoint to generate packets without having to know
[556.00s -> 560.00s]  properties of the entire path, especially if say the path is dynamic.
[560.00s -> 565.00s]  That being said, in practice systems really try to avoid IP fragmentation.
[565.00s -> 569.00s]  And the reason is that you've suddenly taken one packet and made it into
[569.00s -> 572.00s]  multiple packets. And so now the chances that any one of
[572.00s -> 574.00s]  those packets might be dropped goes up.
[574.00s -> 577.00s]  If say, let's say, you know, one percent of all packets are dropped,
[577.00s -> 580.00s]  suddenly you're increasing the probability that any, that one of those three
[580.00s -> 584.00s]  and therefore will be dropped and therefore the whole original packet will
[584.00s -> 585.00s]  have to be lost.
[585.00s -> 588.00s]  IP doesn't support any reliability or retransmission of these fragments.
[588.00s -> 592.00s]  So if one fragment is lost, generally you have to retransmit all of them
[592.00s -> 594.00s]  that's up to a higher layer.
[594.00s -> 597.00s]  So generally you want to avoid IP fragmentation.
[597.00s -> 602.00s]  So one interesting trick that our approach that TCP sometimes uses is to
[602.00s -> 606.00s]  actually choose a segment size to avoid fragmentation.
[606.00s -> 611.00s]  Since TCP segments can be of any size that TCP wants, what it does is it tries
[611.00s -> 616.00s]  to generate segments which will fit inside IP packets and not fragment on the
[616.00s -> 620.00s]  path to destination. And the way it can do this is by
[620.00s -> 625.00s]  setting the don't fragment bit. And so say a TCP connection when it
[625.00s -> 630.00s]  opens up, it can say choose, well I'm going to try sending let's just say a
[630.00s -> 633.00s]  standard Ethernet frame of 1500 bytes.
[633.00s -> 636.00s]  I'm going to set the, the don't fragment bit.
[636.00s -> 641.00s]  And if it gets an ICMP error saying oh, you know, couldn't you know, this thing
[641.00s -> 645.00s]  couldn't, I had to fragment it and I couldn't, then it says ah, I'll try
[645.00s -> 648.00s]  something else. There must be some smaller like, oh, I'll
[648.00s -> 650.00s]  see if maybe there's a 512 byte PPP link.
[650.00s -> 652.00s]  There's a bunch of ways you can search for this.
[652.00s -> 654.00s]  One is to do a binary search that's expensive.
[654.00s -> 657.00s]  You can also try common sizes like 1500 bytes.
[657.00s -> 660.00s]  There's an RFC that talks about the options.
[660.00s -> 664.00s]  There's an approach where TCP can actually sense the connection, sense the
[664.00s -> 668.00s]  properties of the path for connection and based on that pick an optimal
[668.00s -> 672.00s]  segment size such that it doesn't have fragmentation but it's also able to
[672.00s -> 676.00s]  minimize header overhead. It has as much payload per header given
[676.00s -> 679.00s]  that it's minimizing the number of segments that it sends.
