# Detected language: en (p=1.00)

[0.00s -> 4.00s]  So in this video, I'm going to give a brief overview of the TCP header. If you
[4.00s -> 8.00s]  want more information, there's, of course, tons of documentation online, but this
[8.00s -> 12.00s]  is just a brief summary of kind of what the fields in the header and their
[12.00s -> 16.00s]  meaning. A standard TCP header is 20 bytes long. So we can see here that
[16.00s -> 20.00s]  there are five rows of four octets each. Additionally, you can have
[20.00s -> 25.00s]  options after the TCP header. I'm not going to go into any of those now. The
[25.00s -> 29.00s]  basic TCP header you see in most connections is 20 bytes long. So the
[29.00s -> 34.00s]  first two fields in TCP are the source port and destination port. Each of these
[34.00s -> 39.00s]  are 16 bits or two octets. So we talk about connecting to the web port, port
[39.00s -> 45.00s]  80. That's the destination port, say, of 80. The next two fields are the TCP
[45.00s -> 50.00s]  sequence numbers. So these denote from the source of this packet to its
[50.00s -> 56.00s]  destination, what is the sequence number of the data contained in this segment, as
[56.00s -> 62.00s]  well as what is the acknowledgement number from that end point. So for
[62.00s -> 68.00s]  example, if I have, if I want to acknowledge that it received up to byte
[68.00s -> 75.00s]  5,000 and then this is sequence number 4,000, then as I said, I will send
[75.00s -> 82.00s]  sequence number 4,000, acknowledgement number 5,000. The sequence number denotes
[82.00s -> 87.00s]  what the sequence number is of the first byte of the data region which
[87.00s -> 94.00s]  follows the segment header. So if I had a sequence number of 4,000 and there were
[94.00s -> 102.00s]  500 bytes of data, then this would mean byte 4,000 to 4,499. Now the
[102.00s -> 109.00s]  acknowledgement number acknowledges the last byte received plus one. And so if I
[109.00s -> 116.00s]  were to send this segment 4,000 to 4,499 and the other side received it, it would
[116.00s -> 124.00s]  send an acknowledgement number of 4,500. That is, in TCP, the ACK is not for the
[124.00s -> 130.00s]  last byte received, but that plus one. What is the next byte that is needed?
[130.00s -> 134.00s]  So when we talk about TCP ACK packets, what these are is these are TCP
[134.00s -> 138.00s]  segments that have no data. All they're doing is counting the acknowledgement
[138.00s -> 141.00s]  number. This happens if, say, traffic is unidirectional. I'm sending lots of data
[141.00s -> 144.00s]  in one direction, but there isn't data coming back. If the flow is
[144.00s -> 147.00s]  bi-directional, then these acknowledgement numbers are just going to
[147.00s -> 152.00s]  be added or padded onto, or not padded, but incorporated into the data segments
[152.00s -> 156.00s]  as they're being sent. So after the sequence number and acknowledgement
[156.00s -> 161.00s]  number, we have a bunch of fields. Let's start with the checksum. So the
[161.00s -> 168.00s]  checksum is computed over the TCP pseudo-header, which is the TCP header,
[168.00s -> 175.00s]  as well as some of the IP header. This is where I just add a little bit of
[175.00s -> 181.00s]  additional resilience for the IP header, the IP addresses, etc. So the checksum
[181.00s -> 186.00s]  covers this pseudo-header, the TCP header, and then the data within the TCP
[186.00s -> 190.00s]  segment. And so the checksum actually in some way stretches before the packet to
[190.00s -> 194.00s]  this pseudo-header, filled in from the IP header, and then stretches to the end of
[194.00s -> 199.00s]  the segment. Simple ones complement checksum. The window field is the flow
[199.00s -> 204.00s]  control window. It tells the endpoint, so the flow control window, the window
[204.00s -> 209.00s]  field within a packet is telling the other endpoint how much received buffer
[209.00s -> 214.00s]  space its sender has. So if you say, say, a window of 20,000, that means
[214.00s -> 218.00s]  that there cannot be more than 20,000 outstanding unacknowledged bytes in
[218.00s -> 224.00s]  this connection, in that direction. So these bits here, U, A, P, R, S, and F,
[224.00s -> 230.00s]  are control bits. So let's start with some of the sort of less, less common
[230.00s -> 235.00s]  ones. So there's U, which is the urgent bit. That means that this data
[235.00s -> 239.00s]  is particularly urgent. So hey, let's let's get to the application quickly.
[239.00s -> 245.00s]  Then there's P, which is the push bit. So the push bit says, hey, please push
[245.00s -> 251.00s]  this data to the receiving application. So the other four bits, there's the ACK bit,
[251.00s -> 257.00s]  the reset bit, the SYN bit, and the FIN bit. So the ACK bit, here, this bit
[257.00s -> 263.00s]  is set to one if the acknowledgement number field is valid. So the ACK bit is
[263.00s -> 268.00s]  generally set to one for every single segment, except for the first one that
[268.00s -> 273.00s]  initiates a connection. Because when you initiate a connection, you don't know
[273.00s -> 277.00s]  what the other side's sequence number is, so you can't acknowledge anything. So the
[277.00s -> 281.00s]  ACK bit is not set. So when we talk about TCP setup, we see that the first
[281.00s -> 285.00s]  packet sent does not have the ACK bit set, but all other packets in the
[285.00s -> 290.00s]  connection through its termination have the ACK bit set. The SYN and FIN bits
[290.00s -> 295.00s]  are used to set up and tear down connections accordingly, or, respectively.
[295.00s -> 301.00s]  So the SYN bit says, hey, this is my starting sequence number. Please
[301.00s -> 306.00s]  synchronize to this number. And so when you first open a connection, you send a
[306.00s -> 310.00s]  packet with the ACK bit not set, but with the SYN bit set, and then a
[310.00s -> 314.00s]  sequence number. And you're telling the end point, I would like to
[314.00s -> 318.00s]  synchronize you to this sequence number, which represents my first byte
[318.00s -> 322.00s]  of data. The other side can then respond and say, all right, I'm going to
[322.00s -> 325.00s]  acknowledge that sequence number and send you one of mine. In this case, both
[325.00s -> 329.00s]  those fields are valid. To which then you can respond and say, okay, I'm
[329.00s -> 333.00s]  going to acknowledge your sequence number. Now we synchronize. We both know when the
[333.00s -> 337.00s]  bytes start. So one of the things is that, you can imagine, I could always just
[337.00s -> 340.00s]  start my sequence number at zero for every connection in both directions, but
[340.00s -> 342.00s]  there turn out to be real security problems with doing that. That means
[342.00s -> 345.00s]  people can guess what your sequence number is. They can start interspersing
[345.00s -> 349.00s]  packets. It's generally seen as a bad idea. Also because if you have lots of
[349.00s -> 352.00s]  short-lived connections, these packets with similar sequence numbers can be
[352.00s -> 356.00s]  long-lived in the network, and you want to be able to filter them out. So
[357.00s -> 361.00s]  the, the F is for fin. This is for tearing down a connection. So when you set
[361.00s -> 365.00s]  the fin bit, you're telling the other side, I have no more data to send. And
[365.00s -> 369.00s]  so often the exchange is you send the fin, they acknowledge the fin, they send
[369.00s -> 373.00s]  later you a fin with no more data to send, and then you acknowledge that fin.
[373.00s -> 379.00s]  The final bit is R, the reset bit, which says we need to reset this
[379.00s -> 385.00s]  connection. Something wrong has gone on. So if the urgent bit is set, then
[385.00s -> 391.00s]  this urgent pointer points where in the segment that urgent data is. Finally we
[391.00s -> 397.00s]  have the offset field. So the offset field is needed because it's possible for
[397.00s -> 402.00s]  TCP to have options. And you don't know from this header necessarily where the
[402.00s -> 406.00s]  options are, so what the offset tells you is at what offset within the
[406.00s -> 410.00s]  segment does data begin. So if you have options, then the offset tells you
[410.00s -> 415.00s]  the size of those options and your TCP stack knows to look inside their four
[415.00s -> 420.00s]  options. The options are padded to be four bytes, four octets wide. So that's
[420.00s -> 424.00s]  the basic TCP header. We have the source and destination ports, the
[424.00s -> 428.00s]  sequence numbers, both for the data and then for the acknowledgements of the
[428.00s -> 433.00s]  data that you've received. The offset field to tell you where data begins,
[433.00s -> 437.00s]  the urgent and push bits for urgent data or data you want to push to the
[437.00s -> 441.00s]  application. The acknowledgement bit indicating the acknowledgement number is
[441.00s -> 445.00s]  valid. The sin bit for synchronizing the sequence number. The fin bit for
[445.00s -> 449.00s]  tearing down a connection and saying that this, there's no more data to send.
[449.00s -> 453.00s]  The reset bit for resetting a connection. The window for flow control.
[453.00s -> 457.00s]  Check sum for making sure that there aren't errors in the data. An urgent
[457.00s -> 460.00s]  pointer for the urgent bit. And then options.
[467.00s -> 472.00s]  .
[472.00s -> 477.00s]  .
[477.00s -> 482.00s]  .
[482.00s -> 487.00s]  .
[487.00s -> 492.00s]  .
