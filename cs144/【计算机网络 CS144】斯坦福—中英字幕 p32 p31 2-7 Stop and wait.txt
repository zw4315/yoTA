# Detected language: en (p=1.00)

[0.00s -> 5.00s]  This video is about flow control, one of the basic building blocks of reliable,
[5.00s -> 9.00s]  efficient communication. Describes the basics of flow control as
[9.00s -> 13.00s]  well as its simplest implementation, something called the stop and wait
[13.00s -> 16.00s]  protocol. The basic problem flow control tries
[16.00s -> 20.00s]  to solve is when a sender can send data faster than the receiver can
[20.00s -> 23.00s]  process it. So here we have a case where the
[23.00s -> 29.00s]  sender A can send some 500,000 packets per second, but the receiver B can only
[29.00s -> 34.00s]  receive 200,000 packets per second. This might be because B has a slower
[34.00s -> 38.00s]  processor, its networking card isn't as good, or for whatever reason.
[38.00s -> 43.00s]  And so the issue is that if A sends data at this full rate of 500,000 packets
[43.00s -> 48.00s]  per second, then 300,000 of those are going to have to be dropped to B.
[48.00s -> 52.00s]  That is, B will not be able to process them, and so only 40% of the
[52.00s -> 56.00s]  packets will come through. This is a lot of wasted effort on A's
[56.00s -> 60.00s]  network, and it's also going to completely saturate B's.
[60.00s -> 65.00s]  There's no reason for A to be sending data faster than the rate at which B can
[65.00s -> 69.00s]  receive it. And so the basic approach the flow
[69.00s -> 73.00s]  control takes is to make it so the sender doesn't send packets faster than
[73.00s -> 77.00s]  the receiver can process them. The way this usually works is the
[77.00s -> 81.00s]  receiver gives the sender some kind of feedback, whether it's implicit feedback
[81.00s -> 85.00s]  or explicit, whether it's to slow down or speed up or to set a rate.
[85.00s -> 89.00s]  So two basic approaches used in most protocols today.
[89.00s -> 93.00s]  The first, stop and wait, we'll talk about in this video, which is very
[93.00s -> 96.00s]  simple, very simple to implement, very simple finite state machine.
[96.00s -> 100.00s]  The second is what's called sliding window, which we'll talk about in a
[100.00s -> 104.00s]  later video, which is a bit more complex but can provide better
[104.00s -> 107.00s]  performance. So just a refresher on finite state
[107.00s -> 109.00s]  machine diagrams. So when we draw a finite state
[109.00s -> 112.00s]  machine of a protocol, we show the states that it can enter.
[112.00s -> 114.00s]  Here's state one, state two, state three.
[114.00s -> 118.00s]  And then edges between the states have two pieces of information.
[118.00s -> 123.00s]  First, the event that can cause a state transition on top and then below,
[123.00s -> 127.00s]  the action the protocol takes on making that state transition.
[127.00s -> 130.00s]  The stop and wait algorithm is very simple.
[130.00s -> 135.00s]  It has at most one packet in flight at any time from the sender to the
[135.00s -> 138.00s]  receiver. So the basic algorithm is the sender
[138.00s -> 142.00s]  sends one packet, it then waits for an acknowledgement from the receiver.
[142.00s -> 146.00s]  When it receives the acknowledgement, it then, if it has more data to
[146.00s -> 150.00s]  send, sends another packet. If it waits for some time and
[150.00s -> 153.00s]  reaches a timeout and hasn't heard an acknowledgement, then it
[153.00s -> 155.00s]  assumes that the packet has been lost.
[155.00s -> 158.00s]  It has left the network. It was dropped on a router or it was
[158.00s -> 161.00s]  dropped to the receiver, something happened, and where the
[161.00s -> 164.00s]  acknowledgement was dropped. And it resends the data.
[164.00s -> 167.00s]  So there's a timeout at which point it tries again.
[167.00s -> 171.00s]  That's the basic algorithm. So the receiver has a one state
[171.00s -> 173.00s]  finite state machine which is wait for packets.
[173.00s -> 177.00s]  When it receives new data it sends an acknowledgement or when it
[177.00s -> 181.00s]  receives data it sends an acknowledgement for that data and if
[181.00s -> 186.00s]  the data is new it delivers that data to the application.
[186.00s -> 189.00s]  The sender finite state machine has two states.
[189.00s -> 192.00s]  The first state, it's waiting for data from the applications.
[192.00s -> 196.00s]  This is where it's ready to send but the data, the application is not yet
[196.00s -> 201.00s]  provided with data to send. When the application calls send,
[201.00s -> 205.00s]  the protocol sends a packet with that data or as much as it can
[205.00s -> 208.00s]  fit in the packet. It then enters the wait for act
[208.00s -> 211.00s]  state. In this state, there are two transitions.
[211.00s -> 214.00s]  The first is if it receives an acknowledgement.
[214.00s -> 217.00s]  If the protocol receives an acknowledgement, then it does
[217.00s -> 219.00s]  nothing and goes back to wait for data.
[219.00s -> 221.00s]  If there's more data to send, it'll send new data.
[221.00s -> 224.00s]  Or if there's no more data to send, it'll wait until the
[224.00s -> 227.00s]  protocol's sent. The second transition is when there's a
[227.00s -> 229.00s]  timeout. So this is the case where it has
[229.00s -> 232.00s]  sent a packet of data but it hasn't received the acknowledgement.
[232.00s -> 235.00s]  It's waiting and it's waiting and it's waiting and it times out.
[235.00s -> 238.00s]  So then it just tries resending. So it wants to pick this timeout so
[238.00s -> 241.00s]  that it's conservative. It's pretty sure that the data or
[241.00s -> 243.00s]  the subsequent acknowledgement has been lost.
[243.00s -> 246.00s]  So it only has one packet in the network at any time.
[246.00s -> 248.00s]  So that's the basic stop and wait algorithm.
[248.00s -> 253.00s]  So here are four sample executions. The first is when there's no
[253.00s -> 255.00s]  loss. Everything works perfectly.
[255.00s -> 258.00s]  The sender sends its data, the receiver receives it, sends
[258.00s -> 261.00s]  acknowledgement, and now the sender, if it had more data,
[261.00s -> 265.00s]  could send more. Second case, data is lost.
[265.00s -> 268.00s]  Now the sender sends data. It's lost in the network.
[268.00s -> 272.00s]  So the sender times out and tries resending the data.
[272.00s -> 275.00s]  So it's sitting in that waiting for act state.
[275.00s -> 281.00s]  The timeout hits and it resends. Here's a third case where the
[281.00s -> 285.00s]  data is successfully delivered but the acknowledgement is lost.
[285.00s -> 288.00s]  So now the sender is in the wait for act state.
[288.00s -> 290.00s]  It times out. It resends the data.
[290.00s -> 294.00s]  And then this causes the receiver to send a new acknowledgement.
[294.00s -> 299.00s]  At which point then the sender gets the acknowledgement and continues as in
[299.00s -> 303.00s]  the first case. So the fourth case is a little more
[303.00s -> 307.00s]  complicated and actually shows a failure with this, the basic
[307.00s -> 312.00s]  algorithm as I described it before. Which is the sender sends some data and
[312.00s -> 316.00s]  the receiver sends an acknowledgement. But let's say something happens in the
[316.00s -> 319.00s]  network. Suddenly a link becomes very slow or
[319.00s -> 324.00s]  there's a big queue somewhere in the network and the acknowledgement is delayed
[324.00s -> 328.00s]  past the time of the timeout. And so the sender sends some data and
[328.00s -> 332.00s]  acknowledgement comes but the sender resends the data before the
[332.00s -> 336.00s]  acknowledgement arrives. The acknowledgement then arrives very
[336.00s -> 339.00s]  quickly. And so now the sender knows that the
[339.00s -> 343.00s]  data was acknowledged and it sends another data packet.
[343.00s -> 347.00s]  But let's say that in fact this data packet is lost.
[347.00s -> 353.00s]  So now this first retransmission, this first retransmission of the first data
[353.00s -> 357.00s]  packet arrives at the receiver, the receiver acknowledges it.
[357.00s -> 363.00s]  The sender doesn't know whether this acknowledgement here, this act, is for
[363.00s -> 369.00s]  the retransmission here of the data or it's for the new data packet.
[369.00s -> 374.00s]  And so here we can have an error where if it assumes it was for the
[374.00s -> 379.00s]  retransmission of the of the old data, it certainly needs to keep track of
[379.00s -> 382.00s]  that, something the finance data machines need to keep track of.
[382.00s -> 385.00s]  If it assumes it's for the new data, it might, that data might not have
[385.00s -> 387.00s]  arrived. It could be assuming the data has
[387.00s -> 391.00s]  arrived, which it hasn't. So this is a basic problem that comes
[391.00s -> 395.00s]  up in any reliable protocol. It comes up in flow control.
[395.00s -> 399.00s]  Which is how do you detect duplicates? How do you know when acknowledgements
[399.00s -> 404.00s]  are from retransmissions or duplicated copies of packets versus new data?
[404.00s -> 408.00s]  And so in the case of stop and wait, we can solve this problem with a one
[408.00s -> 411.00s]  bit counter. And so the idea is that use this one
[411.00s -> 414.00s]  bit counter on all data acknowledgement and acknowledgement packets.
[414.00s -> 418.00s]  So a sender sends data zero, then it receives act zero, data one, act one,
[418.00s -> 422.00s]  data zero, act zero. And so now the receiver can tell if this
[422.00s -> 426.00s]  is new data or a duplicate. And so in that prior case I showed,
[426.00s -> 430.00s]  it would be able to distinguish between the acknowledgement for the
[430.00s -> 434.00s]  retransmission of packet zero and the acknowledgement for the first
[434.00s -> 438.00s]  transmission of packet one. Now a single bit counter makes a couple
[438.00s -> 441.00s]  of simplifying assumptions. This doesn't work all the time.
[441.00s -> 445.00s]  Like what if a packet is delayed from many round trip times?
[445.00s -> 451.00s]  For example, that this data zero is delayed all the way here, and then the
[451.00s -> 457.00s]  receiver acts it, but it turns out it's actually just a copy of old data.
[457.00s -> 462.00s]  And so this particular one bit counter approach makes two simplifying
[462.00s -> 466.00s]  assumptions. First, the network isn't duplicating
[466.00s -> 469.00s]  packets itself. Second, the packets are not being
[469.00s -> 473.00s]  delayed for multiple timeouts. Now you can solve these problems by
[473.00s -> 477.00s]  increasing the sequence number space, but for the simplifying assumptions to
[477.00s -> 482.00s]  the simple protocol operating environment, this one bit counter can help a lot.
