# Detected language: en (p=1.00)

[0.00s -> 6.48s]  So, let's suppose we have a good block cipher. How do we use it? Messages are typically longer
[6.48s -> 11.12s]  than one 64 or 128-bit block.
[11.12s -> 15.76s]  One straightforward approach is something called ECB, or electronic codebook mode.
[15.76s -> 21.60s]  This is simple. We take our message M and break it into blocks, M1, M2, M3, M4.
[21.60s -> 28.66s]  We encrypt each one individually, so M1 becomes C1, M2 becomes C2, etc.
[28.66s -> 32.58s]  This is fast, because we can do them all in parallel, something great on modern multi-core
[32.58s -> 37.90s]  processors. Assuming that our encryption algorithm is secure, then an adversary can't decrypt
[37.90s -> 42.86s]  any block, and so our message is secure. Furthermore, we can reuse our keys, since
[42.86s -> 50.50s]  every block encrypted with the cipher will be secure. Simple, fast, and secure.
[50.50s -> 56.62s]  Nope, it's not secure at all. Using electronic codebook mode, an attacker will learn of
[56.66s -> 63.58s]  repeated plaintext blocks. Since encryption is deterministic, then if M1 equals M2, C1 will
[63.58s -> 69.58s]  equal C2. For example, if we're transmitting a sparse file, this is really bad. An adversary
[69.58s -> 73.06s]  can see where the non-zero regions of the file are.
[73.06s -> 78.06s]  Here's a visual example of the problem using an image of Tux. The center image
[78.06s -> 82.98s]  shows the result of encrypting the image on the left with ECB. Identical regions
[82.98s -> 86.98s]  of the image, such as the whitespace, show up identically, and you can see a general
[86.98s -> 92.34s]  outline of Tux. The image on the right is more like what we want, where there's
[92.34s -> 99.34s]  no pattern, and an adversary can't learn anything from the ciphertext.
[102.58s -> 107.18s]  One way to achieve this desired degree of confidentiality is cipher block chaining
[107.22s -> 114.22s]  or CBC mode. In CBC mode, you choose an initialization vector IV, the same size as the block. You
[116.46s -> 122.34s]  XOR M1 with this initialization vector and encrypt the result of that to produce
[122.34s -> 129.34s]  C1. You then take C1 and XOR it with M2 before encrypting it to produce C2.
[131.70s -> 136.26s]  If you want to use a key to encrypt only one message, then IV can be zero. The basic
[136.30s -> 141.26s]  danger is that you don't want to reuse an initialization vector. Suppose you do.
[141.26s -> 147.46s]  So you set IV to be zero for one message, then reuse an IV of zero for a second message.
[147.46s -> 151.06s]  If the plaintexts are identical, then the ciphertext will be identical, and you've
[151.06s -> 158.06s]  leaked information to the adversary.
[158.14s -> 165.14s]  If we use CBC mode on the Tux image, we end up computing the ciphertext on the right.
[165.54s -> 170.50s]  So problem solved. But again, for this to work across multiple messages and remain
[170.50s -> 177.50s]  secure, you need to be careful about how you pick and use initialization vectors.
[180.14s -> 183.62s]  Electronic codebook mode and cipher block chaining mode are just two ways to use block
[183.62s -> 187.62s]  ciphers. There are many more with different properties, strengths and weaknesses.
[187.62s -> 191.26s]  Cipher feedback mode, for example, XORs the message with an encryption of the prior
[191.26s -> 195.82s]  ciphertext. This is useful if the message isn't a multiple of the block size and you
[195.82s -> 198.02s]  don't want to pad it with zeros.
[198.02s -> 202.30s]  In ECB and CBC mode, you pass the message block to encrypt, so you can't trim the
[202.30s -> 204.42s]  ciphertext.
[204.42s -> 209.22s]  Or there's output feedback mode, where you repeatedly encrypt the initialization vector
[209.22s -> 211.42s]  and use it like a stream cipher.
[211.42s -> 215.54s]  Or counter mode, where you encrypt incrementing values of the key and XOR them with message
[215.54s -> 222.02s]  blocks. This is easily parallelizable, but means that you can only use a key for one
[222.02s -> 226.70s]  message unless you do something smart with the value i.
[226.70s -> 231.50s]  So let's do one final quiz. Suppose we have a shared secret key, which only you
[231.50s -> 236.94s]  and the other party know. You encrypt your messages with a good cipher using CBC mode
[236.94s -> 243.94s]  and transmit those messages over a network. Are these messages secure?
