# Detected language: en (p=1.00)

[0.00s -> 8.72s]  53 is represented in little endian. 53 is 3 times 16 plus 5, and so 0x35, the least
[8.72s -> 14.12s]  significant byte, is in the first byte, so it's little endian.
[14.12s -> 24.48s]  4,116 is big endian. 4,116 is equal to 4,096 plus 20, so the two bytes are 0x10
[24.48s -> 32.84s]  for 4,096, and 0x14 for 20, with 0x10 being the byte representing the more significant
[32.84s -> 40.80s]  bits, those are 4,096. So the hexadecimal is 0x1014. This means the most significant
[40.80s -> 45.40s]  byte, 0x10, comes first, and it's big endian.
[45.40s -> 50.40s]  5 is big endian. The least significant byte is last, and it has the highest address.
[50.92s -> 59.88s]  83,886 and 80 is little endian. It's 5 times 2 to the 24th, so this means that 0x05 is
[59.88s -> 69.08s]  the most significant byte. Finally, 305,414,945 is little endian.
[69.08s -> 72.36s]  Rather than try to figure out all of the digits on this one, I just looked at the
[72.36s -> 78.48s]  least significant bit. The least significant bit is either part of 0x21 at the lowest
[78.52s -> 84.60s]  address, or 0x12 at the highest address. If it's 0x21, then the least significant
[84.60s -> 91.24s]  bit is 1, and the number is odd. If it's 0x12, then the least significant bit is
[91.24s -> 100.24s]  0, and the number is even. Since 305,414,945 is odd, this means 0x21 is the least significant
[100.24s -> 104.84s]  byte, and the number is being stored in little endian, because this is at the lowest
[104.84s -> 105.72s]  memory address.
