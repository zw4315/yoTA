# Detected language: en (p=1.00)

[0.00s -> 5.84s]  Continuing on our theme on routing, in this video I'm going to tell you about the Link-State
[5.84s -> 9.84s]  algorithm, in particular Dijkstra's Shortest Path First algorithm.
[9.84s -> 15.08s]  This is an example of a Link-State protocol where the routers start by flooding to each
[15.08s -> 19.16s]  other all the information about the topology of the network, which links are there, which
[19.16s -> 22.64s]  links are up, which ones are down, and then from there each router is going to
[22.64s -> 28.04s]  calculate its shortest path tree from it to every other router.
[28.08s -> 33.16s]  Dijkstra's Shortest Path First algorithm is an example of what's more generally called
[33.16s -> 35.00s]  a Link-State algorithm.
[35.00s -> 39.00s]  In Link-State algorithms, the routers start by exchanging all of the Link-State.
[39.00s -> 42.92s]  In other words, they're going to learn the topology of the network by exchanging
[42.92s -> 46.88s]  with each other the state of the links connected to each router.
[46.88s -> 50.76s]  So a router is going to flood to every other router the state of the links connected
[50.76s -> 53.68s]  to it so that every router has a full topology map.
[53.68s -> 57.84s]  And they're going to do this periodically and whenever the Link-State changes so that
[57.84s -> 60.32s]  they get quick updates.
[60.32s -> 63.92s]  And then specific to Dijkstra's algorithm, we're going to run Dijkstra's algorithm.
[63.92s -> 67.96s]  In other words, once we've got that topology map, each router is going to independently
[67.96s -> 70.44s]  run Dijkstra's Shortest Path First algorithm.
[70.44s -> 74.04s]  If it was a different Link-State algorithm, then we'd run a different algorithm.
[74.04s -> 79.36s]  But because Dijkstra is so widely used, that's the example I'm going to be using here.
[79.36s -> 83.08s]  So at the end of the day, each router finds the minimum cost spanning tree to reach
[83.08s -> 85.52s]  every other router.
[85.52s -> 90.76s]  Let's work through an example of Dijkstra's algorithm on this topology here.
[90.76s -> 95.60s]  So this topology has eight routers connected by links that are annotated with the cost
[95.60s -> 97.82s]  of using those links.
[97.82s -> 103.08s]  And we're going to go through the example of finding the lowest cost spanning tree
[103.08s -> 106.04s]  from R8 to every other router.
[106.04s -> 108.88s]  So let me just draw an example of what that might look like.
[108.88s -> 113.76s]  This won't actually be the right one, but it will give us an example of how it might
[113.76s -> 115.80s]  look.
[115.80s -> 118.88s]  So it's going to start from here.
[118.88s -> 122.84s]  And maybe go out this way, go out this way, go out this way, go out this way.
[122.84s -> 125.36s]  Maybe we're going to have this one, this one, and this one.
[125.36s -> 127.44s]  So that would be a spanning tree.
[127.44s -> 129.64s]  It happens not to be the lowest cost spanning tree.
[129.64s -> 135.32s]  But we're going to calculate that using Dijkstra's algorithm in a moment.
[135.32s -> 137.52s]  So I'm just going to draw out how this will evolve.
[137.52s -> 141.36s]  I'm just going to go through the steps, and then I'll take you through a more formal
[141.36s -> 144.60s]  way of calculating it afterwards.
[144.60s -> 150.12s]  So let's start with R8, down in the bottom right hand corner.
[150.12s -> 154.96s]  In the first step of Dijkstra's algorithm, we're going to add the router that has
[154.96s -> 158.80s]  the lowest cost path back to R8.
[158.80s -> 162.76s]  And so that's R7, because it has a path of 1 back to R8.
[162.76s -> 168.68s]  So I'm going to draw that on here, R7, with a cost of 1.
[168.68s -> 173.56s]  Next I'm going to look at the router that will directly connect to this tree, this little
[173.56s -> 176.88s]  fledgling tree, with the lowest cost path back to R8.
[176.88s -> 182.16s]  I've got two choices, either R4, which will connect back with a cost of 2, or R6,
[182.16s -> 184.48s]  which will connect with a cost of 2.
[184.48s -> 186.80s]  So I'm going to just toss a coin and randomly pick R6.
[186.80s -> 192.04s]  It doesn't matter, so it's going to have a cost of 2.
[192.04s -> 195.82s]  Next I'm going to add the next router with the lowest cost path, and that's going
[195.82s -> 200.38s]  to be R4, clearly.
[200.38s -> 203.58s]  And each time I've added a router, I'm not going to consider adding it again, of course,
[203.58s -> 207.86s]  because I've already added it into this tree that is evolving in the bottom right
[207.86s -> 211.32s]  hand corner of the slide here.
[211.32s -> 215.98s]  Next I'm going to add the one with, I've added the ones with up to a cost of 2.
[215.98s -> 217.30s]  So is the one with a cost of 3?
[217.30s -> 218.30s]  No, there isn't.
[218.30s -> 219.74s]  Is there one with a cost of 4?
[219.74s -> 221.50s]  Yeah, I've got two candidates here.
[221.50s -> 224.38s]  I've got both R3 and R5.
[224.38s -> 225.38s]  Both will connect.
[225.94s -> 232.74s]  OK, well, I'll arbitrarily add R5 first, that has a cost of 4 back to R8, and then
[232.74s -> 236.82s]  I'll add R3.
[236.82s -> 239.34s]  Do I have one with a cost of 5?
[239.34s -> 240.62s]  Yes, I do.
[240.62s -> 247.54s]  I've got R2, that has a cost of 5.
[247.54s -> 250.18s]  That adds, that's cost of 5 back to R8.
[250.18s -> 252.46s]  Do I have one with a cost of 6?
[252.54s -> 257.02s]  Well, I've got two that have a cost of 6, but they're already connected into the tree
[257.02s -> 258.02s]  at a lower cost.
[258.02s -> 259.90s]  So R3 and R4.
[259.90s -> 262.26s]  So I'm not going to add those, they're already on the tree.
[262.26s -> 263.50s]  But I've also got R1.
[263.50s -> 267.66s]  I can now add that one in at a cost of 6.
[267.66s -> 270.78s]  So that's 1, 2, 3, 4, 5, 6.
[270.78s -> 273.30s]  I've now added them all, and I'm done.
[273.30s -> 280.22s]  Let's go through those steps, basically the same steps that I just went through, adding
[280.22s -> 282.78s]  each of those routers in turn.
[282.78s -> 286.38s]  So first of all, I added R6, because it has a cost of 2.
[286.38s -> 289.06s]  Then I added R4, because it has a cost of 2.
[289.06s -> 292.02s]  Then I added R5, because it has a cost of 4.
[292.02s -> 294.94s]  And then also R3, it has a cost of 4.
[294.94s -> 300.90s]  Then I added R2, and then finally I added R1, and then I'm done.
[300.90s -> 304.86s]  We can think of this more systematically by following through this table.
[305.86s -> 310.70s]  So I'm going to populate this table as I go, and then I'll show you what it looks like
[310.70s -> 314.58s]  fully populated afterwards.
[314.58s -> 319.22s]  So this is just going to repeat exactly what the steps I just did.
[319.22s -> 327.58s]  So I start with, at step 0, the candidate set of all those routers that directly connect
[327.58s -> 329.20s]  to R8.
[329.20s -> 333.62s]  So my shortest path set is going to be the set of routers that are in the shortest
[333.62s -> 334.62s]  path tree.
[334.62s -> 339.00s]  So I start with R8 in my shortest path set, and the candidate set are those that connect
[339.00s -> 343.94s]  to it directly to it, directly to the current fledgling subtree.
[343.94s -> 351.06s]  So that's R3, R5, R6, and R7, and I'm going to pick the one with the lowest cost path
[351.06s -> 352.06s]  back to R8.
[352.06s -> 355.66s]  That's clearly R7, so I'm going to add R7 in first.
[355.66s -> 361.38s]  So I've chosen R7, and in which case if I've chosen R7, I'm going to add it into my
[361.38s -> 362.58s]  shortest path set.
[362.58s -> 366.66s]  So my shortest path set is going to become R8 and R7.
[366.66s -> 372.58s]  My candidate set are the set of routers that directly connect to this subtree.
[372.58s -> 377.46s]  So the ones that directly connect are R3 and R5 still, of course, because I haven't
[377.46s -> 378.46s]  used them yet.
[378.46s -> 384.90s]  R6, because I haven't used that one yet, I've used R7, so now R4 becomes added
[384.90s -> 385.90s]  to the candidate set.
[385.90s -> 390.82s]  And I will pick from that set the one with the lowest cost path back to R8.
[390.82s -> 395.22s]  That could either be R4, which has a cost of two, or it can be R6, and I'm just going
[395.22s -> 399.46s]  to arbitrarily pick R6.
[399.46s -> 408.78s]  So now my shortest path set is going to be R8, and my candidate set is going to
[408.78s -> 412.82s]  be R3, R5.
[412.82s -> 415.26s]  I've used R6, so it'll have R4 in it.
[415.26s -> 419.86s]  And because I've added R6, well I'm adding no more routers in now to my candidate set,
[419.90s -> 421.54s]  so that's going to stay at the same thing.
[421.54s -> 422.54s]  And so on.
[422.54s -> 426.62s]  Eventually I will fill out the table until the very last one that I will add will be
[426.62s -> 429.50s]  in, I will choose R1 here.
[429.50s -> 434.02s]  And so at this point I will add one into my shortest path set, and then I'm going
[434.02s -> 435.02s]  to be done.
[435.02s -> 436.02s]  OK?
[436.02s -> 439.34s]  I'm going to add one router at each step.
[439.34s -> 443.18s]  I'm going to add the router that is the lowest cost path, and because that is its
[443.18s -> 446.06s]  lowest cost path, we know that we're done with that router, there's nothing else
[446.06s -> 447.06s]  left to do.
[447.30s -> 448.30s]  So it's nice and simple.
[448.30s -> 453.18s]  We'll always run the number of iterations equal to the number of routers in the network.
[453.18s -> 457.70s]  So if you fill out this table, you would find that it looks like this.
[457.70s -> 461.62s]  And so you can just check that that matches what I did earlier.
[461.62s -> 465.86s]  So if you run this algorithm, and we'll give you some exercises where you run through
[465.86s -> 470.62s]  and fill out tables like this, you will see, and after a few times that you've done
[470.62s -> 475.30s]  it, that oh yes, of course it's actually generating the full lowest cost minimum, the lowest
[475.34s -> 477.54s]  cost spanning tree.
[477.54s -> 480.98s]  So some questions worth asking about Dijkstra's algorithm.
[480.98s -> 483.30s]  First one, how long does the algorithm take to run?
[483.30s -> 485.22s]  Well, it's a nice simple answer.
[485.22s -> 490.30s]  By the end of the kth iteration, we've added k routers to the graph.
[490.30s -> 491.98s]  So we have n routers to start with.
[491.98s -> 495.46s]  It will always terminate after exactly n iterations.
[495.46s -> 497.98s]  Nice and easy.
[497.98s -> 503.74s]  What happens when link costs change, or when the routers or links fail?
[503.74s -> 504.98s]  Nice and easy again.
[504.98s -> 507.98s]  Every time there's a change in the link state, in other words, every time a link goes
[507.98s -> 513.86s]  up or down, the routers are going to flood that state to every other router in the network.
[513.86s -> 518.30s]  They then rerun Dijkstra's algorithm, calculate the lowest cost spanning tree out
[518.30s -> 521.58s]  to every other router, and we're back up and going again.
[521.58s -> 525.78s]  In other words, every time there's a change, we recalculate from scratch, and we move
[525.78s -> 526.78s]  on.
[526.78s -> 530.90s]  So we don't have to worry about the cases like bad news travels slowly, et cetera,
[530.90s -> 534.82s]  that we have to worry about with the Bellman-Ford algorithm, because everything is
[534.86s -> 539.66s]  recalculated from scratch every time there's a change.
[539.66s -> 543.02s]  So let's see how Dijkstra's algorithm is used in practice.
[543.02s -> 546.94s]  Dijkstra's algorithm is an example of a link state algorithm.
[546.94s -> 552.10s]  That means that the link state is known by every router, in other words, it's flooded
[552.10s -> 556.58s]  amongst the routers to make sure that all of the routers know the entire topology and
[556.58s -> 561.06s]  the state of the links in the network, and then each router independently calculates
[561.06s -> 566.78s]  the shortest path spanning tree from itself to every other router in the network.
[566.78s -> 572.34s]  Dijkstra's algorithm is the basis of the OSPF, or Open Shortest Path First algorithm,
[572.34s -> 575.74s]  a very widely used routing protocol in the internet, and we're going to see that
[575.74s -> 579.46s]  in a later video.
[579.46s -> 582.46s]  There's another way of thinking about Dijkstra's algorithm that I want to tell you about
[582.46s -> 583.46s]  next.
[583.46s -> 588.94s]  I first learned about this from Professor Jean Wollrand at Berkeley, and it's a very
[588.94s -> 590.94s]  nice way to think about what's going on.
[590.94s -> 597.86s]  So take a look at this example here, with a set of routers, interconnected by links,
[597.86s -> 601.82s]  and the red numbers as before represent the cost of each link.
[601.82s -> 606.54s]  And I'm actually going to represent them by tennis balls, the yellow routers,
[606.54s -> 610.58s]  and a white and a pink ball representing the top and the bottom, A and B.
[610.58s -> 617.64s]  And we're going to calculate the lowest cost spanning tree, and by connecting it by strings
[617.64s -> 623.10s]  between each ball, where the length of the string equals the cost shown in red.
[623.10s -> 626.92s]  So let's start with them down on the ground like this, and then if we tug and pull them
[626.92s -> 632.96s]  up by A, each link that goes toward, or each string that goes toward, is going to
[632.96s -> 638.86s]  be on that lowest cost spanning tree from A through the network.
[638.86s -> 643.56s]  So eventually we'll end up with something that looks like this, where A is connected
[643.56s -> 649.76s]  to B through R3 and R5, with a total cost of 9, and all the solid links here represent
[649.76s -> 653.00s]  the strings that will be tight.
[653.00s -> 657.04s]  All the ones that are dotted, the 2 and the bottom left hand corner, will be slack
[657.04s -> 660.28s]  or loose, because they're not on the lowest cost spanning tree.
[660.28s -> 665.16s]  I'm going to lift them up like this, and this is the same topology as before.
[665.16s -> 670.70s]  So A to R1 goes tight, then A to R2 and R3, and R1 goes tight, because they're
[670.70s -> 673.40s]  all on the least cost spanning tree.
[673.40s -> 678.98s]  Now A4 goes tight, and then R5, because they're all on the least cost spanning tree.
[678.98s -> 685.62s]  I lift it up further and eventually the line A, R3, R5, B will all go tight, because
[685.62s -> 690.88s]  they're all on the least cost spanning tree.
[690.88s -> 693.44s]  And that's the end of the video about Dijkstra's algorithm.
