# Detected language: en (p=1.00)

[0.00s -> 3.76s]  Continuing on a theme of routing, in this lecture I'm going to be telling you about
[3.76s -> 6.58s]  something called the Spanning Tree Protocol.
[6.58s -> 10.58s]  The Spanning Tree Protocol is actually used for Ethernet switches.
[10.58s -> 17.70s]  We normally think of routing as operating at the IP or the network layer, but any situation
[17.70s -> 22.22s]  where we want to send packets along a particular path that we choose carefully, we can think
[22.22s -> 23.54s]  of that as routing.
[23.54s -> 28.74s]  So Ethernet switches need to decide how to route or forward packets to the correct
[28.74s -> 30.84s]  set of destinations as well.
[30.84s -> 34.24s]  So that's what we're going to be looking at in this video.
[34.24s -> 38.52s]  So we're going to continue with this theme of routing, and I'm going to describe something
[38.52s -> 42.32s]  that at first won't seem like routing because we normally use the term routing
[42.32s -> 49.96s]  to refer to the network layer and IP addressing, but routing really means any mechanism for
[49.96s -> 55.92s]  delivering packets in a mindful way from a source to a destination.
[55.92s -> 58.72s]  And so in that sense, Ethernet routes packets too.
[58.72s -> 60.82s]  It's forwarding packets from a source to a destination.
[60.82s -> 64.38s]  It just happens to be doing this based on the Ethernet address.
[64.38s -> 69.82s]  So in this video, I'm going to be talking about how Ethernet forwards packets.
[69.82s -> 79.14s]  So we know how addresses are learned in Ethernet, but how does it prevent loops from happening?
[79.14s -> 84.18s]  We know that it will learn the address, and until it's learned the address and knows the correct
[84.18s -> 86.94s]  direction to send a packet, it will flood to everyone.
[86.94s -> 92.76s]  How do we make sure that those flooded messages, those broadcast messages, are not looping
[92.76s -> 93.76s]  in the network forever?
[93.76s -> 97.88s]  After all, there's no TTL field in Ethernet.
[97.88s -> 102.60s]  Ethernet does this by building a spanning tree over which packets are forwarded.
[102.60s -> 104.88s]  I'm going to see that specifically in a moment.
[104.88s -> 110.48s]  This works in quite a different way from what we've seen so far, because instead
[110.48s -> 117.62s]  of building a spanning tree per destination or per router, in Ethernet we're going to
[117.62s -> 119.90s]  build a single spanning tree for the entire network.
[119.90s -> 124.46s]  In other words, it's going to constrain the overall topology to only use those ports
[124.46s -> 127.74s]  belonging to a single spanning tree.
[127.74s -> 131.02s]  So just recall briefly how an Ethernet switch forwards packets.
[131.02s -> 136.76s]  First of all, it examines the header of each arriving Ethernet frame.
[136.76s -> 141.06s]  If it finds that the Ethernet destination address is in its forwarding table, it's
[141.06s -> 145.42s]  going to forward the frame to the correct outgoing port.
[145.42s -> 149.74s]  If the Ethernet destination address is not found in the table, it's going to broadcast
[149.74s -> 154.66s]  the frame to all outgoing ports, because it doesn't know which one to send it to.
[154.66s -> 156.54s]  It's just going to send it to everyone.
[156.54s -> 160.14s]  And now that we've learned about flooding, we can see why it would do that, because
[160.14s -> 165.12s]  we can be sure that it will reach its eventual destination.
[165.12s -> 169.86s]  And then it learns, entries in the table are learned by examining the Ethernet source address
[169.86s -> 170.86s]  of arriving packets.
[170.86s -> 176.20s]  In other words, when it looks at the source address, it will learn that in order to reach
[176.20s -> 182.18s]  that particular source address, it sends packets out through the port through which
[182.18s -> 183.82s]  that packet arrived.
[183.82s -> 187.86s]  So that must be on the direction between, towards the source.
[187.86s -> 193.24s]  But this all presupposes that packets don't loop in the network forever, and that in
[193.26s -> 200.04s]  fact, particularly in the learning process, that the Ethernet source address actually
[200.04s -> 205.70s]  is on the shortest path, or on a reasonable path, back towards that address.
[205.70s -> 210.06s]  So how does it know that?
[210.06s -> 214.46s]  And in fact, the whole learning process could lead to loops.
[214.46s -> 218.66s]  So let's see an example of what might happen.
[218.68s -> 225.68s]  If we have a network with, let's say that this is a source, and this is a destination,
[225.68s -> 233.68s]  and in between we have a sequence of switches, something like this, that are all connected,
[233.68s -> 234.68s]  like this.
[234.68s -> 240.78s]  So B is directly connected here, and then A is connected to a switch here.
[240.78s -> 247.44s]  In the learning process, as we've described, the first time that A sends to B, and let's
[247.50s -> 253.90s]  say it's going to send its packet in here, destined to B, this first switch is not going
[253.90s -> 259.24s]  to know where to send it, because it's never heard about A and B before, so it's going
[259.24s -> 264.74s]  to flood its message out all of these ports.
[264.74s -> 268.50s]  That's going to come down here, it's going to go out here, it's going to come down
[268.50s -> 275.26s]  here, but because what this switch here will do is send it out of all of the ports,
[275.28s -> 281.80s]  except the one that it heard from, this is also going to come from here back down here,
[281.80s -> 286.76s]  and go around this loop forever, and this one is going to go around this loop forever,
[286.76s -> 290.56s]  and there's another loop here, and so you can quickly get the picture, these packets
[290.56s -> 292.36s]  are going to go be looping around forever.
[292.36s -> 297.30s]  They are going to get delivered to B, B will respond and the address will get learned,
[297.30s -> 302.22s]  but in the meantime, we've created this huge loop of flooded addresses.
[302.22s -> 305.16s]  So we need to make sure that that doesn't happen.
[305.16s -> 310.46s]  The spanning tree protocol that I'm going to describe now was invented to solve this
[310.46s -> 311.46s]  problem.
[311.46s -> 316.74s]  So rather than deciding how we route along a spanning tree for each address, or to reach
[316.74s -> 323.34s]  each destination, it's going to build one spanning tree for the entire network.
[323.34s -> 331.96s]  So just to give you an example, I'm going to redraw a switch network here that has
[331.96s -> 336.70s]  a bunch of loops in it, it won't be exactly the same as the one before, but it's roughly
[336.70s -> 337.70s]  the same.
[337.70s -> 342.98s]  So here at A and B, what it's going to do is it's going to go through and disable
[342.98s -> 348.34s]  some ports in the network to prevent this loop from happening.
[348.34s -> 353.46s]  So one example of what it might do is essentially switch off this link here so that
[353.46s -> 360.70s]  the loop at the top is prevented, and it could switch off the link here and prevent
[360.70s -> 362.94s]  this loop down here.
[362.94s -> 371.72s]  So we end up with a spanning tree in this case, which is like this, of which all the
[371.72s -> 377.48s]  switches are on that spanning tree, so it spans its trees so that there are no loops.
[377.48s -> 381.62s]  And A and B can talk to each other over that spanning tree.
[381.62s -> 389.40s]  So it gives us a rough idea of what we're going to see next.
[389.40s -> 391.04s]  So preventing loops.
[391.04s -> 396.32s]  The spanning tree protocol, it's going to start by recognizing that the topology of
[396.32s -> 400.80s]  switches is a graph, and we've seen many examples of these before.
[400.80s -> 405.84s]  And the spanning tree protocol is going to find a subgraph that spans all of the vertices,
[405.84s -> 408.12s]  all of the switches, without creating any loops.
[408.12s -> 409.88s]  It's a spanning tree.
[409.88s -> 413.86s]  And the distributed protocol is going to run across all of these switches, and it's going
[413.86s -> 419.86s]  to start by deciding which switch is the root of the tree, of the single spanning tree
[419.86s -> 424.22s]  that it's going to create, and then which ports are allowed to forward packets along
[424.22s -> 426.46s]  the tree.
[426.46s -> 428.46s]  Let's look at an example here.
[428.46s -> 431.62s]  This is just an example spanning tree.
[431.62s -> 435.50s]  So the step one is it's going to pick a single root.
[435.50s -> 439.30s]  And the way that it's going to do this is just exchange ID numbers and pick the one
[439.30s -> 440.78s]  with the lowest ID.
[440.78s -> 446.14s]  So I'm just going to assume here that it's exchanged enough to decide that S1 is the
[446.14s -> 448.14s]  root.
[448.14s -> 453.38s]  And then it's going to forward packets on the ports on the shortest hop count path
[453.38s -> 455.52s]  to the root.
[455.52s -> 461.46s]  And so S6 would send along here, S2 would send along here, S4, we've seen many examples
[461.46s -> 466.90s]  of this now, of how to create this, S8, well there's a hop count of two here and
[466.90s -> 470.82s]  a hop count of two here that's somewhat arbitrarily decided it's going to send this
[470.82s -> 477.62s]  way, and then S3, that's got a hop count of two this way, and one, two, three this
[477.62s -> 482.08s]  way, so it will send this way, S9 will send this way.
[482.08s -> 485.90s]  So there's a spanning tree that covers all of them.
[485.90s -> 491.18s]  And here's an example of one that could be created.
[491.18s -> 494.62s]  It's almost the same as the one previously, because it had a couple of ties that I could
[494.62s -> 495.62s]  break.
[495.94s -> 499.94s]  So this is the logical spanning tree that has been created, and of course there are no
[499.94s -> 503.66s]  loops in it, and it spans all of the switches.
[503.66s -> 506.60s]  So the thing that remains to do is to figure out how does it do this?
[506.60s -> 509.50s]  We know what it's going to end up with, so how does it get there?
[509.50s -> 512.42s]  So let's take a look at how Spanning Tree Protocol works.
[512.42s -> 516.70s]  There's a little bit of detail here, and I'm going to go through this one step at
[516.70s -> 518.28s]  a time.
[518.28s -> 524.98s]  So the first thing that happens is that all switches broadcast a special type of packet
[525.18s -> 528.10s]  called a Bridge Protocol Data Unit.
[528.10s -> 533.02s]  Protocol Data Unit is just a little bit of an old-fashioned term for a packet, and Bridge
[533.02s -> 535.86s]  is an older name for switches.
[535.86s -> 541.70s]  Before Ethernet switches were popularized in the 1990s, they were called Bridges.
[541.70s -> 545.50s]  So Bridge Protocol Data Unit is usually abbreviated to BPDU.
[545.50s -> 549.98s]  This is the only context in which this term BPDU is used, so don't worry too much
[549.98s -> 550.98s]  about it.
[550.98s -> 554.60s]  It's essentially the special control messages that are sent around in order to build the
[554.60s -> 556.32s]  Spanning Tree.
[556.32s -> 559.80s]  The BPDU contains three pieces of information.
[559.80s -> 564.56s]  The ID of who it is that's sending it, and that's the switch ID.
[564.56s -> 569.60s]  So in my previous example, S1, S2, S3, it's usually actually derived from the MAC address,
[569.60s -> 575.80s]  just so that it's unique and it may be manually configured by the administrator, but we'll
[575.80s -> 580.78s]  just use these switch IDs on the PowerPoint pictures for now.
[580.78s -> 585.38s]  It contains the ID of who it currently believes to be the root, and we'll see how this
[585.38s -> 591.14s]  evolves in a moment, and it's the distance from the sender to the root.
[591.14s -> 596.04s]  In other words, what it believes is the distance from itself to the root, and this
[596.04s -> 601.74s]  is the best estimate that it has right now.
[601.74s -> 606.74s]  So to start with, every switch is going to boot up and think that it's the root, it's
[606.74s -> 607.94s]  going to claim that it's the root.
[608.10s -> 612.42s]  In other words, it's going to put its ID of its sender to be the same as the ID of the
[612.42s -> 616.46s]  root, and because they are one and the same, it's going to say the distance field to
[616.46s -> 621.06s]  zero because that's the distance from the sender to the root.
[621.06s -> 625.70s]  And every switch is going to broadcast this value until it hears a better value.
[625.70s -> 629.38s]  In other words, a root with a smaller ID would be the most likely case.
[629.38s -> 632.70s]  So if I'm currently advertising that I think that I'm root, and then somebody else
[632.74s -> 638.46s]  sends me a message and says, I'm the root, and its ID is lower than mine, then I will
[638.46s -> 643.42s]  start saying, OK, I believe that you're the root instead of me.
[643.42s -> 646.90s]  If there happens to be a root with the same ID, it's going to pick the one with
[646.90s -> 654.14s]  a shorter distance, and ties are going to be broken by the smaller ID of the sender.
[654.14s -> 658.36s]  So if a switch hears a better message, it's not only going to adopt that value as
[658.36s -> 663.28s]  the root, it's going to retransmit that message and it's going to add one to the
[663.28s -> 670.60s]  distance and say, I'm going to forward my ID as the sender, the newly learned ID
[670.60s -> 674.60s]  of the root, I'm going to add one to the value that was told to me because the
[674.60s -> 679.08s]  hop count is now increased by one, and I'm going to say that that is the distance
[679.08s -> 681.76s]  from the sender to the root.
[681.76s -> 687.92s]  So eventually, jumping down to here, eventually there will be only one root that will originate
[687.92s -> 691.92s]  these messages, and everybody else will retransmit them, because everybody will uniquely
[691.92s -> 696.60s]  pick the same switch ID as the root.
[696.60s -> 700.40s]  OK, now we know who the root is, we know how to figure out how the spanning tree
[700.40s -> 706.04s]  is built in order to send packets to and from that root.
[706.04s -> 710.04s]  So the root port is picked on every switch.
[710.04s -> 712.88s]  It's the port on a switch that is closest to the root.
[713.68s -> 718.76s]  In other words, it's the one through which the BPDU was heard that gave it that shortest
[718.76s -> 723.32s]  distance to the root, so that's a nice and easy thing to figure out.
[723.32s -> 727.64s]  And that will be the one through which it sends messages, forwards messages, to the
[727.64s -> 730.74s]  root or receives them from the root.
[730.74s -> 735.00s]  Not only the BPDUs, but also the forwarded packets.
[735.00s -> 738.24s]  The second type of port is what's called the designated port.
[738.24s -> 742.48s]  This is the port that neighbors agree to use in order to reach the port.
[742.48s -> 748.40s]  It's essentially the port through which packets destined to the root will be received at
[748.40s -> 754.92s]  this switch, and packets coming from the root will be forwarded onto this port in order
[754.92s -> 757.68s]  to reach the other switches.
[757.68s -> 761.48s]  All other ports are blocked from forwarding.
[761.48s -> 766.52s]  In other words, only those ports that are the root port or the designated port will
[766.52s -> 768.88s]  continue to forward regular packets.
[768.88s -> 771.04s]  All other ports are blocked from forwarding.
[771.12s -> 776.08s]  However, they will still send and receive BPDUs so that the control messages are still
[776.08s -> 780.64s]  sent and received, so that we can continue to build the spanning tree such that if
[780.64s -> 784.92s]  something changes, a switch goes down or a link goes down, everybody will converge
[784.92s -> 789.52s]  on a new spanning tree.
[789.52s -> 797.20s]  Okay, so eventually, locally, the switch will only forward on the ports that are root
[797.20s -> 799.28s]  ports and designated ports.
[801.36s -> 806.56s]  Let me finish this video on the Spanning Tree Protocol by telling you about a brief history.
[806.56s -> 810.48s]  Spanning Tree Protocol was originally invented in 1985 by Radia Perlman.
[810.48s -> 815.52s]  At that time, Ethernet switches were called bridges, and networks were beginning to be
[815.52s -> 818.00s]  built with a large number of bridges.
[818.00s -> 823.76s]  This was really before routing was very popular, and as a consequence, they really needed a
[823.76s -> 830.48s]  quick method for reliably building a spanning tree that all of the packets could follow
[831.20s -> 834.48s]  to prevent broadcast storms from escalating in the network.
[834.48s -> 837.20s]  It was standardized in 1990 by the IEEE.
[837.84s -> 842.00s]  Still, it converged relatively slowly, and as networks became bigger, this became more
[842.00s -> 842.96s]  and more of a problem.
[843.60s -> 848.48s]  The timers that were used were quite long, and the method takes quite a while to
[848.48s -> 852.24s]  converge, and so a more rapid version called the Rapid Spanning Tree Protocol was
[852.24s -> 854.40s]  introduced in 2004.
[854.40s -> 859.92s]  Still, this built a single tree for the entire network, and the path followed by packets
[860.00s -> 862.40s]  would often be a somewhat torturous path.
[862.40s -> 865.92s]  It's not necessarily the shortest path between the source and destination, because
[865.92s -> 868.24s]  those packets would always have to go through the route.
[868.96s -> 874.08s]  More recently, the Shortest Path Bridging Protocol was introduced just in 2012.
[875.04s -> 879.84s]  This uses our old friend, the Link State algorithm, a little bit like Dijkstra's
[879.84s -> 886.32s]  algorithm used in OSPF, in order to build a shortest path tree from each source to
[886.32s -> 887.28s]  each destination.
[887.84s -> 893.04s]  And so in the end, we've ended up with a method that is very similar to what's used
[893.04s -> 894.64s]  at Layer 3.
[894.64s -> 898.16s]  This will probably be rolled out and more widely adopted over the next few years.
[901.28s -> 902.64s]  That's the end of this video.
