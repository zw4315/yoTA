# Detected language: en (p=1.00)

[0.00s -> 4.58s]  So in this video, I'm going to talk about retransmission strategies for transport
[4.58s -> 8.86s]  protocols in order to achieve reliability, in particular for sliding
[8.86s -> 12.52s]  window protocols. The basic question is we have, with some
[12.52s -> 17.10s]  sliding window reliable transport, a window of packets that are in flight.
[17.10s -> 22.66s]  Say one, two, three, four. And we're using cumulative
[22.66s -> 27.60s]  acknowledgements. And so all we get is something back
[27.72s -> 33.24s]  back, two, back, three, back, four. Just the last byte that was successfully
[33.24s -> 37.18s]  received, the last packet that was successfully received.
[37.18s -> 41.96s]  We're maintaining a retransmission timer for each of these packets based on when
[41.96s -> 44.78s]  they were sent. And essentially maintaining a
[44.78s -> 48.60s]  conservative estimate of, if we haven't received an acknowledgement for the
[48.60s -> 52.42s]  packet by this time, then this means that it is almost certain that the
[52.42s -> 55.18s]  packet was lost, and so we should retransmit it.
[56.18s -> 60.18s]  And so the question is, given this set of parameters which are generally used for
[60.18s -> 63.18s]  reliable transport, how is the protocol going to behave?
[63.18s -> 66.18s]  What is its retransmission strategy going to look like?
[66.18s -> 70.18s]  So what we'll see is that there are essentially two strategies you end up
[70.18s -> 73.18s]  seeing, you end up, set up emerging from different protocols.
[73.18s -> 77.18s]  The first is we go go back in. So what we think is like go back in is
[77.18s -> 82.18s]  a very pessimistic approach, or pessimistic behavior, which is that if a
[82.18s -> 87.18s]  single packet is lost, then we're going to retransmit the entire outstanding window
[87.18s -> 88.18s]  of packets. Go back in.
[88.18s -> 92.18s]  So if the window is size N, we lose packet, some packet, we're going to go
[92.18s -> 95.18s]  back, end transmissions, retransmit all of them.
[95.18s -> 99.18s]  The second is selective repeat, which we, we think it is optimistic.
[101.18s -> 105.18s]  So where go back in assumes that if one packet is lost, all of them are lost
[105.18s -> 108.18s]  in the window. Selective repeat assumes that if one
[108.18s -> 110.18s]  packet is lost, only that packet was lost.
[110.18s -> 114.18s]  So in selective repeat, if we lose a packet, it's not acknowledged, we'll
[114.18s -> 117.18s]  retransmit that packet and only that packet.
[117.18s -> 122.18s]  So let's look at what go back in appears like what's the behavior that you see.
[122.18s -> 126.18s]  So let's say that we have a window of size equal to four.
[126.18s -> 131.18s]  And so the sender sends packet one, two, three, four.
[131.18s -> 137.18s]  And packet two is lost. So here are our four transmissions.
[137.18s -> 142.18s]  Well, in response to packet one, the receiver's going to send acknowledgement,
[142.18s -> 146.18s]  and acknowledgement one. But it's not going to send
[146.18s -> 150.18s]  acknowledgement two. And so what'll happen is at some
[150.18s -> 154.18s]  point, we're going to have retransmit timer go off.
[154.18s -> 159.18s]  And then in a go back in protocol, what the sender's going to do is it's
[159.18s -> 162.18s]  going to retransmit the entire outstanding window.
[162.18s -> 166.18s]  There's some kind of timing. And so don't forget, a window is going
[166.18s -> 170.18s]  to include five, because in response to this ACK one, it can send five.
[170.18s -> 175.18s]  But so the transmitter, seeing the packet was two was lost, is going to assume
[175.18s -> 179.18s]  that the entire window was lost, and retransmit the entire window.
[179.18s -> 183.18s]  This is very conservative, very, or very pessimistic.
[183.18s -> 187.18s]  So now let's see what a selective repeat protocol will do.
[187.18s -> 195.18s]  So again, N equals four. We transmit one, two, three, four.
[195.18s -> 201.18s]  One, two, three, four. Packet two is lost.
[201.18s -> 207.18s]  Packet one is acknowledged, which lets us send five.
[207.18s -> 214.18s]  In a selective repeat protocol, the transmitter is going to retransmit two,
[214.18s -> 221.18s]  and then will continue execution and transmit six, seven, eight, nine,
[221.18s -> 230.18s]  nine, dot, dot, dot, dot. So retransmit only the packets that were
[230.18s -> 234.18s]  not acknowledged. So one question that comes up is why,
[234.18s -> 239.18s]  given a selective repeat, doesn't, you know, sends fewer packets, why would you
[239.18s -> 243.18s]  ever want to do go back in? Well, there are a couple of reasons.
[243.18s -> 248.18s]  One is that selective repeat, if actually all of those packets were lost, if
[248.18s -> 252.18s]  packet two, three, four, or the packets two, three, four, and five were all lost.
[252.18s -> 255.18s]  In order to do each of these retransmissions involves timers and
[255.18s -> 257.18s]  round trip times, so it can be much slower.
[257.18s -> 261.18s]  If there's a burst of losses, a selective repeat protocol will often be slower to
[261.18s -> 265.18s]  recover, as opposed to go back in, who assumes that all the packets are lost,
[265.18s -> 268.18s]  it retransmits all of them, and it can get going faster.
[268.18s -> 271.18s]  And so there's a tradeoff here between sort of the amount of data that you
[271.18s -> 275.18s]  send, how quickly you send it, and then how much of it is wasted versus the
[275.18s -> 278.18s]  speed of recovery from significant errors.
[278.18s -> 282.18s]  So let's walk through two example transport protocols and their
[282.18s -> 286.18s]  configurations, and see how they behave, what happens.
[286.18s -> 290.18s]  So in this first one, our sender has a window of size N, and let's say that N
[290.18s -> 293.18s]  is equal to four, just like the prior examples.
[293.18s -> 297.18s]  And the receiver has a window of size one, so the receive window size is one.
[297.18s -> 303.18s]  So based on this, is the protocol gonna behave as go back in, or a selective
[303.18s -> 309.18s]  repeat? Well, so let's walk through what happens.
[309.18s -> 314.18s]  So the sender, let's say, is gonna send one, two, three, four.
[314.18s -> 321.18s]  One, two, three, four. And let's say that packet two is lost,
[321.18s -> 326.18s]  so it doesn't arrive. Well, the receiver is gonna acknowledge
[326.18s -> 333.18s]  one, which will allow the sender to send five.
[333.18s -> 337.18s]  But the receiver is not going to acknowledge two.
[337.18s -> 343.18s]  Now at some point, two's retransmission timer is going to fire,
[343.18s -> 351.18s]  and it'll retransmit two. But the thing is that because the
[351.18s -> 355.18s]  receiver has a receive window size of only one, it has been unable to buffer
[355.18s -> 361.18s]  packets three, four, and five. And so when it receives packet two,
[361.18s -> 367.18s]  it's going to act two. The sender has not received an
[367.18s -> 372.18s]  acknowledgement for three. It's gonna have to retransmit three.
[372.18s -> 377.18s]  And then the receiver can acknowledge three.
[377.18s -> 382.18s]  At some point, the sender can then start using its full window again,
[382.18s -> 385.18s]  but the point being that since this first two was lost,
[385.18s -> 388.18s]  three, four, and five couldn't be buffered.
[388.18s -> 392.18s]  The fact that the receiver has a window size of only one is gonna force,
[392.18s -> 395.18s]  force the sender to retransmit every single packet in the window.
[395.18s -> 399.18s]  So we're gonna see that this behaves as go back n.
[399.18s -> 402.18s]  So let's see a second example. So in this case, the sender has a
[402.18s -> 405.18s]  window size of n, and the receiver has a window size of n.
[405.18s -> 408.18s]  And let's say that for both of them, just again for simplicity's sake,
[408.18s -> 412.18s]  this is of size four. So in this case, will the protocol be
[412.18s -> 420.18s]  go back n or selective repeat? So let's walk through what happens.
[420.18s -> 425.18s]  We have again, one, two, three, four. Two is lost.
[425.18s -> 432.18s]  So we get an acknowledgement for two, for one, act one.
[432.18s -> 437.18s]  Results in packet five being sent. And at some point, two's retransmission
[437.18s -> 440.18s]  timer fires. So we resend two.
[440.18s -> 444.18s]  Now the receiver has been able to buffer these packets because it has a
[444.18s -> 447.18s]  window of size n. And so it had three packets buffered.
[447.18s -> 454.18s]  It can then, so here is its buffer. It had packets three, four, and five.
[454.18s -> 460.18s]  Packet two arrives. It can then acknowledge five.
[460.18s -> 463.18s]  So it might be that the sender was a little aggressive.
[463.18s -> 466.18s]  Maybe it did retransmit three or four or something.
[466.18s -> 471.18s]  But the point is that it doesn't have to. For this to operate correctly, if say it
[471.18s -> 475.18s]  just waited for the, those retransmission timers or it did slow
[475.18s -> 479.18s]  retransmissions, et cetera, that the sender is going to resend only packet
[479.18s -> 481.18s]  two. Only the outstanding packet that was not
[481.18s -> 484.18s]  acknowledged, the rest have been buffered to the receiver.
[484.18s -> 487.18s]  And so we see that this behaves as selective repeat.
[487.18s -> 492.18s]  So when you're implementing transport protocols, say if you're taking, if
[492.18s -> 496.18s]  you're, when you're doing lab two, one thing you want to think about is how you
[496.18s -> 500.18s]  handle your retransmission. So one of the really important things
[500.18s -> 504.18s]  is that you don't retransmit earlier than you should.
[504.18s -> 509.18s]  By which I mean it's not okay to say start a retransmit timer based on packet
[509.18s -> 513.18s]  one or packet two. And then when two's retransmit timer
[513.18s -> 517.18s]  fires, retransmit an entire window. Because it could very well be that
[517.18s -> 521.18s]  three, four, and five have been correctly received or something is going to
[521.18s -> 523.18s]  happen. But you're going to retransmit them
[523.18s -> 525.18s]  anyways. You're very aggressively putting
[525.18s -> 528.18s]  additional packets in the network. You're inflating the number of packets
[528.18s -> 530.18s]  in the network beyond your window size.
[530.18s -> 533.18s]  Three, four, and five could still be in the network, yet you're putting
[533.18s -> 537.18s]  additional copies of them. So in that way you want to be careful
[537.18s -> 540.18s]  about the number of packets you put in the network.
[540.18s -> 543.18s]  You want to be careful about your retransmission policy.
[543.18s -> 546.18s]  And so we'll see, what you can see is that on one hand you can assume,
[546.18s -> 549.18s]  try and be very conservative and say, look, if one packet was lost, I'm
[549.18s -> 551.18s]  going to have two others that were lost.
[551.18s -> 555.18s]  And then I'm going to retransmit the entire window with a go-back-end
[555.18s -> 557.18s]  policy. That will happen if, say, your
[557.18s -> 559.18s]  receiver has a window size of only one.
[559.18s -> 563.18s]  Or you can maybe be a bit slower and say, look, one packet was lost.
[563.18s -> 567.18s]  I'm going to wait for around trip time, transmit that, see if I get an
[567.18s -> 571.18s]  acknowledgement, see where the acknowledgement puts me, and then perhaps
[571.18s -> 575.18s]  just do a selective repeat and transmit only the packet that needs to be
[575.18s -> 576.18s]  transmitted.
[579.18s -> 581.18s]  Thank you.
