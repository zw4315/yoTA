# Detected language: en (p=1.00)

[0.00s -> 4.96s]  There's one last security primitive that's very common today.
[4.96s -> 9.24s]  Use it every time you establish an SSH or HTTP session.
[9.24s -> 11.24s]  They're certificates.
[11.24s -> 15.60s]  Public key cryptography lets us verify that someone with a private key associated with
[15.60s -> 18.00s]  a public key signed a document.
[18.00s -> 21.96s]  But how do we know what the right public key is?
[21.96s -> 26.76s]  How do we know that www.ebay.com has a public key?
[26.76s -> 32.00s]  The answer is certificates.
[32.00s -> 37.64s]  So let's say we want to securely communicate with a server such as www.amazon.com.
[37.64s -> 45.08s]  Now using public key cryptography, if I know www.amazon.com's public key, then I can communicate
[45.08s -> 47.64s]  securely with that server.
[47.64s -> 53.84s]  I can verify that www.amazon.com has the private key associated with the public key
[53.84s -> 54.84s]  I'm using.
[54.92s -> 59.08s]  We can then use public key encryption to exchange symmetric keys, all as well.
[59.08s -> 63.08s]  But there's a missing step here.
[63.08s -> 65.08s]  How do I get the server's public key?
[65.08s -> 67.12s]  Do I find it on a web page?
[67.12s -> 71.08s]  If I just found it somewhere random or insecure, then how can I be sure it's really that
[71.08s -> 78.76s]  server's public key and not an adversary pretending to be that server?
[78.76s -> 80.96s]  For example, imagine this very simple attack.
[81.08s -> 84.24s]  I want to communicate with a server, so I ask it for its public key.
[84.24s -> 89.84s]  It gives me the key, then I can verify that it has the associated private key.
[89.84s -> 92.16s]  This is completely open to a man-in-the-middle attack.
[92.16s -> 96.56s]  An attacker could pretend to be the server and give me its own public key.
[96.56s -> 99.48s]  I have no way of telling whose key is right.
[99.48s -> 104.46s]  The attacker looks just like the server, except that it has a different key.
[104.46s -> 108.72s]  The attacker then can open up a connection to the server and pretend to be you.
[108.72s -> 112.68s]  It sees everything you send, since you're communicating with it, and it forwards it
[112.68s -> 114.36s]  along to that server.
[114.36s -> 118.72s]  It can rewrite or suppress anything you send, or even insert new traffic, like passwords
[118.72s -> 120.92s]  and all kinds of stuff.
[120.92s -> 128.00s]  So what we need is some way to be able to receive the public key for www.amazon.com
[128.00s -> 131.52s]  and be reasonably sure it's actually www.amazon.com.
[132.52s -> 139.52s]  In the best case, I'd have someone I trust tell me what www.amazon.com's key is.
[144.52s -> 146.72s]  That's exactly what a certificate does.
[146.72s -> 151.44s]  Abstractly, a certificate is a digital document, just a chunk of bytes, that bind a name
[151.44s -> 152.80s]  to a value.
[152.80s -> 159.36s]  This document is signed by the private key k1-inverse.
[159.40s -> 163.76s]  If I already have the public key k1, then I can verify this was signed with the right
[163.76s -> 165.96s]  private key.
[165.96s -> 171.48s]  If I trust the party who has k1-inverse, then I can trust their claim that the name,
[171.48s -> 176.12s]  for example a hostname, has the public key k2.
[176.12s -> 182.66s]  I can then use k2 when communicating with N. In this way, I establish a chain of trust.
[182.66s -> 187.44s]  If I start with the public key of one party that I trust, then this party can
[187.52s -> 189.76s]  give me public keys for other parties.
[189.76s -> 195.76s]  Those parties could give me further public keys.
[195.76s -> 199.12s]  If you browse the web a lot, you've probably seen an error message like this one come up
[199.12s -> 200.54s]  many times.
[200.54s -> 202.24s]  This one is for Firefox.
[202.24s -> 206.00s]  It tells you that you can't trust that the site is secure.
[206.00s -> 207.20s]  Why?
[207.20s -> 211.72s]  Generally, you see this error because there's a mistake in certificates.
[211.72s -> 216.32s]  For example, the host at Stanford my research group runs, sing.stanford.edu.
[216.32s -> 222.04s]  It has a few other names, such as tinyOS.stanford.edu.
[222.04s -> 225.60s]  Stanford provided me with a certificate that says that these names are associated with
[225.60s -> 230.64s]  the server's public key.
[230.64s -> 236.94s]  But if I added a name to Stanford's DNS, such as badsing.stanford.edu, then this
[236.94s -> 238.96s]  certificate wouldn't have that name.
[238.96s -> 244.36s]  If you tried connecting to badsing.stanford.edu over HTTPS, you'd receive an error like
[244.36s -> 250.04s]  this one, because the certificate Stanford gave me doesn't cover that name.
[250.04s -> 253.64s]  So you often run into this error when someone has aliases for a host or has issued
[253.64s -> 256.44s]  a certificate for an old name and hasn't updated it.
[256.44s -> 261.28s]  But it could be an adversary, running a different server and trying to convince you it's trustable.
[261.28s -> 265.80s]  Generally speaking, seeing this error means someone has misconfigured their system for
[265.80s -> 266.80s]  security.
[267.64s -> 273.34s]  Whenever I see an error like this, I never say okay, even if it's just a little mistake.
[273.34s -> 279.56s]  Given how subtle and hard security is, and how obvious this mistake is, I don't want
[279.56s -> 282.56s]  to trust this server.
[282.56s -> 287.40s]  And so this is how things work today.
[287.40s -> 290.76s]  Everyone trusts a few signing authorities and knows their public keys.
[290.76s -> 294.52s]  These keys are hard baked into your browser or operating system, a good reason to check
[294.52s -> 296.72s]  your programs for integrity.
[296.72s -> 301.28s]  Here, let's take a look at the keys installed on my Mac.
[301.28s -> 314.76s]  I open up applications, utilities, keychain access, and you can see all these different
[314.76s -> 319.80s]  keys that are pre-installed on my Macintosh.
[319.80s -> 324.18s]  These are root keys, which they have already been installed, and so these are public keys
[324.18s -> 329.54s]  that I can trust.
[329.54s -> 333.90s]  There they are, the public keys hard baked into the operating system.
[333.90s -> 346.22s]  You can see Verisign down here, and up here, you can see Apple.
[346.22s -> 349.30s]  These root authorities can then sign keys for other parties.
[349.30s -> 350.94s]  For example, let's go to Google.
[350.94s -> 355.46s]  I'm accessing Google over HTTPS.
[355.46s -> 359.74s]  I've also installed a plugin for Firefox called Cypherfox that lets me look at certificate
[359.74s -> 360.74s]  details.
[360.74s -> 370.84s]  I can click on the lock, and now see the certificate.
[370.84s -> 379.38s]  You can see that www.google.com is signed by the Google Internet Authority, which is
[379.38s -> 386.90s]  in turn signed by the GeoTrust Global Certificate Authority.
[386.90s -> 391.02s]  Here is the certificate hierarchy.
[391.02s -> 396.34s]  Signing authorities are often called CAs for certificate authorities.
[396.34s -> 406.62s]  But realize that all a certificate says is that someone testifies a host has this key.
[406.62s -> 410.62s]  If there's an adversary along the certificate chain, then you could be fooled.
[410.62s -> 414.50s]  It turns out there are actually many different kinds of certificates for this reason.
[414.50s -> 419.00s]  Some, such as the one I have on sing.stanford.edu, doesn't require much more than filling out
[419.00s -> 420.54s]  a web form.
[420.54s -> 425.72s]  Others require paper validation and possibly meeting someone in person.
[425.72s -> 432.04s]  This is how TLS HTTPS worked today, when you see the padlock on your browser bar.
[432.04s -> 436.50s]  You connect to a server, and it provides a certificate with its public key.
[437.38s -> 441.06s]  If the certificate chain ends in a rude certificate authority that you trust, that
[441.06s -> 445.14s]  is, already have the public key for, so you can verify its signature, then you trust
[445.14s -> 448.14s]  the key in the certificate and encrypt data to the server.
[448.14s -> 450.78s]  I'll explain the details of this in the TLS video.
