# Detected language: en (p=1.00)

[0.00s -> 3.00s]  In this video, I'm going to talk about a slightly
[3.00s -> 6.00s]  advanced flow control algorithm called sliding
[6.00s -> 9.00s]  window, used in most high performance protocols
[9.00s -> 12.00s]  today. So, a simple flow control
[12.00s -> 15.00s]  algorithm, called stop and wait, has at most one
[15.00s -> 18.00s]  packet in flight at any time. So, this is the basic
[18.00s -> 20.00s]  simple protocol you might say, an algorithm you
[20.00s -> 22.00s]  might try to implement the first time you're
[22.00s -> 24.00s]  doing reliable communication. So, a sender sends a
[24.00s -> 27.00s]  packet or a chunk of data, the receiver sends an
[27.00s -> 29.00s]  acknowledgement, the sender, if it doesn't
[29.00s -> 31.00s]  receive the acknowledgement, times out, tries resending.
[31.00s -> 33.00s]  If it gets the acknowledgement, it sends more
[33.00s -> 35.00s]  data. And there's some issues with
[35.00s -> 37.00s]  duplicates. You can maintain a counter, a
[37.00s -> 39.00s]  one-bit counter to figure out if there's a
[39.00s -> 41.00s]  duplicate act or an active duplicate or new
[41.00s -> 44.00s]  data. As long as things aren't duplicated
[44.00s -> 46.00s]  for more than a round trip time, stop and
[46.00s -> 49.00s]  wait works. It's great. It's simple. So,
[49.00s -> 53.00s]  while stop and wait works correctly, it has one
[53.00s -> 55.00s]  major problem. Let's say you're trying to
[55.00s -> 58.00s]  communicate between Boston and San Francisco.
[58.00s -> 61.00s]  And how the bottleneck is, say, ten megabits per
[61.00s -> 64.00s]  second. So, there's a ten megabits per second
[64.00s -> 67.00s]  link here. Or let's say the Boston node
[67.00s -> 70.00s]  can receive a ten megabits per second.
[70.00s -> 72.00s]  That's the rate at which you can process
[72.00s -> 74.00s]  data. Your round trip time is 50
[74.00s -> 76.00s]  milliseconds. And let's just say, for
[76.00s -> 78.00s]  simplicity's sake, we're sending Ethernet
[78.00s -> 82.00s]  frames. So, that's the size of the data.
[82.00s -> 86.00s]  So, which are basically 1.5 kilobytes or 12
[86.00s -> 89.00s]  kilobytes. Now, a round trip times 50
[89.00s -> 92.00s]  milliseconds, that means that San Francisco can
[92.00s -> 94.00s]  send one packet, 50, and if that packet's
[94.00s -> 96.00s]  received successfully, 50 milliseconds later,
[96.00s -> 100.00s]  we'll get an acknowledgement. So, we have 1,000 milliseconds
[100.00s -> 103.00s]  per second divided by 50 milliseconds.
[103.00s -> 107.00s]  This means that we can send at most 20 packets
[107.00s -> 110.00s]  per second on this, on this path.
[110.00s -> 115.00s]  Now, 20 packets per second times 12 kilobytes
[115.00s -> 121.00s]  kilobytes per packet is equal to 240 kilobytes
[121.00s -> 126.00s]  kilobytes per second. So, this path between San
[126.00s -> 129.00s]  Francisco and Boston using a stop and wait protocol
[129.00s -> 132.00s]  can send at most 240 kilobytes per second,
[132.00s -> 135.00s]  assuming no packets are lost, constant RTT of 50
[135.00s -> 138.00s]  milliseconds. But the bottleneck is ten megabits
[138.00s -> 142.00s]  per second. This means that this stop and
[142.00s -> 147.00s]  wait protocol is using 2% of the capacity of what
[147.00s -> 151.00s]  the communication can be. So, stop and wait,
[151.00s -> 155.00s]  while it works, can be astoundingly inefficient.
[155.00s -> 159.00s]  San Francisco could be sending data much faster
[159.00s -> 162.00s]  than what stop and wait allows.
[162.00s -> 165.00s]  So, the basic solution that most protocols use
[165.00s -> 168.00s]  today for this problem is something called a sliding
[168.00s -> 170.00s]  window. And sliding windows are a
[170.00s -> 172.00s]  generalization of stop and waits, where a stop and
[172.00s -> 175.00s]  wait allows one packet in flight at any time.
[175.00s -> 178.00s]  A sliding window protocol allows up to n packets in
[178.00s -> 180.00s]  flight. So, when n equals, is equal to
[180.00s -> 183.00s]  one, a sliding window protocol behaves like stop
[183.00s -> 186.00s]  and wait. And so, let's say we have a
[186.00s -> 189.00s]  sliding window protocol with an n equal to, say, five
[189.00s -> 193.00s]  packets. This means that San Francisco can
[193.00s -> 198.00s]  have five packets in flight, and simultaneously there
[199.00s -> 203.00s]  can be five acknowledgements, maybe five
[203.00s -> 207.00s]  acknowledgements coming back from Boston.
[207.00s -> 212.00s]  And the idea here is that if you adapt, if you can
[212.00s -> 216.00s]  set n to be the correct value, then you can keep
[216.00s -> 221.00s]  the pipe full. That is, San Francisco could send
[221.00s -> 225.00s]  data to Boston at ten megabits per second.
[225.00s -> 229.00s]  So, let's say that's Boston's rate. And so, Boston can, by
[229.00s -> 232.00s]  configuring the sliding window size, can have San
[232.00s -> 236.00s]  Francisco send data at a rate equal to ten megabits
[236.00s -> 239.00s]  per second. And so, in this particular case,
[239.00s -> 242.00s]  right, if we have an RTT of 50 milliseconds and a
[242.00s -> 246.00s]  bottleneck of ten megabits per second, let's say that
[246.00s -> 250.00s]  we're sending Ethernet frames, right, ten kilobits
[250.00s -> 255.00s]  per packet. And we have twenty round trip times.
[255.00s -> 260.00s]  That essentially means that the sliding window is
[260.00s -> 265.00s]  gonna be ten megabits per second divided by twenty
[265.00s -> 270.00s]  round trip times, which is basically equal to, which
[270.00s -> 274.00s]  is equal to 500 kilobits per round trip time.
[274.00s -> 279.00s]  So we're looking at a sliding window of around 49,
[279.00s -> 284.00s]  sorry, around 41 packets. Right, 40 is 480 kilobits
[284.00s -> 289.00s]  per round trip time, so 41 would be 492.
[289.00s -> 293.00s]  And so, if we had a sliding window of 40 packets,
[293.00s -> 297.00s]  then we'd actually be able to sustain a ten megabit
[297.00s -> 301.00s]  connection from San Francisco to Boston with a round
[301.00s -> 304.00s]  trip time of 50 milliseconds. So, just to draw a
[304.00s -> 307.00s]  picture, kind of show what this looks like.
[307.00s -> 310.00s]  So here is the original, here's the stop and wait.
[310.00s -> 313.00s]  We have this one bit counter, data zero, ACK zero,
[313.00s -> 315.00s]  data one, ACK one, data zero, ACK zero.
[315.00s -> 319.00s]  So the sliding window, let's say we have a sliding
[319.00s -> 324.00s]  window of size three. Well, the sender will send
[324.00s -> 330.00s]  three packets. Let's call them D zero, D one, D
[330.00s -> 334.00s]  two, and the receiver can then acknowledge them.
[334.00s -> 341.00s]  ACK zero, ACK one, ACK two. Well, as soon as acknowledgement
[341.00s -> 344.00s]  zero arrives, the sender can send data three.
[344.00s -> 347.00s]  As soon as acknowledgement one arrives, the sender can
[347.00s -> 350.00s]  send data four. As soon as acknowledgement two
[350.00s -> 352.00s]  arrives, the sender can send data five.
[352.00s -> 355.00s]  This is the basic idea. Rather than having this one
[355.00s -> 358.00s]  packet, you could have many packets. So in the case of having a
[358.00s -> 361.00s]  sending window of size 40, you can imagine there are tons
[361.00s -> 363.00s]  and tons and tons of packets in flight.
[363.00s -> 366.00s]  So, let's look at more concretely what this
[366.00s -> 369.00s]  algorithm looks like for both the sender and the
[369.00s -> 371.00s]  receiver, just as we did for stop and wait.
[371.00s -> 374.00s]  So, a sliding window sender, first, in a sliding
[374.00s -> 377.00s]  window protocol, every segment has a sequence number.
[377.00s -> 380.00s]  So in protocols like TCP, this is usually done in
[380.00s -> 383.00s]  terms of bytes, because they can be variable size.
[383.00s -> 386.00s]  For simplicity's sake, we'll just do it in terms of
[386.00s -> 389.00s]  numbers. So, there's a sequence number for
[389.00s -> 392.00s]  every segment. So, the sender maintains three
[392.00s -> 396.00s]  variables, the size of its sending window, the last
[396.00s -> 400.00s]  acknowledgement it received from the receiver, and the
[400.00s -> 404.00s]  last segment it sent. And the sender's job is to
[404.00s -> 408.00s]  maintain this invariant that the last segment sent minus
[408.00s -> 411.00s]  the last acknowledgement received has to be less than
[411.00s -> 413.00s]  or equal to the send window size.
[413.00s -> 417.00s]  So, this means that if it has received packet N by
[417.00s -> 422.00s]  a packet with a sequence number of N, the sender
[422.00s -> 426.00s]  cannot send a packet past N plus SWS.
[426.00s -> 430.00s]  So, let's say we have a sending window is equal
[430.00s -> 434.00s]  to five, and the last acknowledgement that's been
[434.00s -> 439.00s]  received is equal to eleven. Then this means that the
[439.00s -> 444.00s]  sender cannot send a packet past twelve, thirteen, fourteen,
[444.00s -> 447.00s]  fifteen, sixteen. It's not allowed to send seventeen
[447.00s -> 450.00s]  until it gets the acknowledgement for twelve.
[450.00s -> 453.00s]  When you get a new acknowledgement, you advance
[453.00s -> 456.00s]  LAR as necessary, and you buffer up to sending
[456.00s -> 459.00s]  window size segments in case suddenly you get an
[459.00s -> 462.00s]  acknowledgement and then you want to send a whole
[462.00s -> 465.00s]  bunch of new data. Let's pretend for a second we
[465.00s -> 469.00s]  have a sending window equal to three. And so, here's
[469.00s -> 473.00s]  packets at zero, one, two, three. Say zero had been
[473.00s -> 477.00s]  sent and acknowledged. So, our sending window size
[477.00s -> 480.00s]  is three. The last acknowledgement for the
[480.00s -> 483.00s]  receiver is zero. So, LAR is equal to zero.
[483.00s -> 487.00s]  SWS is equal to three. This just means that the
[487.00s -> 491.00s]  last segment sent is equal to three. So, now when
[491.00s -> 495.00s]  an acknowledgement arrives, say for one, then the
[495.00s -> 499.00s]  sending window can advance, and so now the protocol
[499.00s -> 503.00s]  can send four. And let's say an acknowledgement
[503.00s -> 507.00s]  for four arrives, then the window can advance and
[507.00s -> 511.00s]  it can send five, six, and seven. Now, one thing
[511.00s -> 515.00s]  that's important here is that, let's say we have
[515.00s -> 518.00s]  a send window which includes five, six, and seven,
[518.00s -> 521.00s]  and five is lost, but six and seven arrive at the
[521.00s -> 524.00s]  receiver and are acknowledged. The sender cannot
[524.00s -> 527.00s]  advance the window past five until five is
[527.00s -> 529.00s]  acknowledged. And so, the window is what's
[529.00s -> 531.00s]  called stall. The window can stall, where
[531.00s -> 533.00s]  although most of the data in the window has
[533.00s -> 536.00s]  been delivered, it can't move past the first
[536.00s -> 538.00s]  unacknowledged piece of data. So, it can't
[538.00s -> 542.00s]  advance the window past that. The receiver also
[542.00s -> 546.00s]  maintains three variables. It has a receive window
[546.00s -> 549.00s]  size, the last acceptable segment, so this is the
[549.00s -> 552.00s]  last segment that it will receive and won't drop on
[552.00s -> 554.00s]  the floor. If it receives a segment past
[554.00s -> 556.00s]  this value, it'll assume something is wrong or
[556.00s -> 558.00s]  it's not going to buffer it and it'll just
[558.00s -> 560.00s]  discard it. Then there's a last segment
[560.00s -> 563.00s]  it's actually received. And so, the sender, the
[563.00s -> 566.00s]  receiver is then maintaining this invariant that the
[566.00s -> 569.00s]  last acceptable segment minus the last segment
[569.00s -> 572.00s]  received must be less than or equal to the
[572.00s -> 574.00s]  received window size. And so if you have a
[574.00s -> 577.00s]  received window size equal to five and a last
[577.00s -> 581.00s]  segment received equal to three, then it's not
[581.00s -> 585.00s]  going to accept anything past four, five, six,
[585.00s -> 588.00s]  seven, eight, right? So, if it receives
[588.00s -> 591.00s]  suddenly segment ten, it won't accept it and
[591.00s -> 595.00s]  it'll drop it. Now, if the received packet is
[595.00s -> 598.00s]  less than this acceptable segment, then it will
[598.00s -> 601.00s]  send an acknowledgement. And so, if it receives
[601.00s -> 606.00s]  any of these packets, it will send an acknowledgement.
[606.00s -> 610.00s]  Now, in the basic case, the way most sliding
[610.00s -> 613.00s]  window protocols work, these acknowledgements are
[613.00s -> 616.00s]  what are called cumulative acknowledgements, such
[616.00s -> 620.00s]  that you send an acknowledgement for not the
[620.00s -> 624.00s]  data you received, but rather, what is the end
[624.00s -> 628.00s]  of the contiguous data that you received that is
[628.00s -> 631.00s]  cumulative. If I acknowledge three, that means
[631.00s -> 634.00s]  that I have received three in everything before it,
[634.00s -> 637.00s]  not just three. And so it represents a cumulative
[637.00s -> 640.00s]  state of reception across the entire communication.
[640.00s -> 643.00s]  So in this example, if a receiver has received
[643.00s -> 646.00s]  one, two, three, and five, and then suddenly
[646.00s -> 649.00s]  receives five, it doesn't acknowledge five, it
[649.00s -> 652.00s]  acknowledges three. Now there are some protocols
[652.00s -> 655.00s]  that can do things like actually selective
[655.00s -> 658.00s]  acknowledgements, but the basic case is that you
[658.00s -> 660.00s]  use cumulative acknowledgements, which is
[660.00s -> 663.00s]  cumulatively, what is the contiguous chunk of
[663.00s -> 667.00s]  data that you've received. So one little detail
[667.00s -> 672.00s]  here. TCP doesn't acknowledge the data it's
[672.00s -> 676.00s]  received, but rather N plus one. So TCP
[676.00s -> 679.00s]  acknowledgements are in terms of bytes, and so
[679.00s -> 682.00s]  if TCP is received up to byte N, its
[682.00s -> 684.00s]  acknowledgement packets will say N plus one.
[684.00s -> 687.00s]  So it's the first byte of data that's expected.
[687.00s -> 689.00s]  So if you're ever looking at TCP trace or trying
[689.00s -> 691.00s]  to see how the TCP protocol works, just keep
[691.00s -> 694.00s]  this in mind. The acknowledgement value in the
[694.00s -> 697.00s]  TCP header isn't the last byte received, the
[697.00s -> 699.00s]  cumulative acknowledgement, rather the next byte,
[699.00s -> 702.00s]  the first missing byte. So one of the things we
[702.00s -> 705.00s]  talked about in the stop and wait protocol was
[705.00s -> 708.00s]  that a counter of size, a one bit counter was
[708.00s -> 710.00s]  sufficient assuming the packets weren't delayed
[710.00s -> 713.00s]  more than round trip time. So what about in sliding
[713.00s -> 715.00s]  window protocol? Suddenly we have a receive
[715.00s -> 717.00s]  window, we have a send window. How big is
[717.00s -> 720.00s]  sequence number space do we need? So a receive
[720.00s -> 722.00s]  window is always greater than one, send window
[722.00s -> 724.00s]  is always greater than one, greater than or
[724.00s -> 726.00s]  equal to one. And the receive window is
[726.00s -> 729.00s]  greater than, is less than or equal to the
[729.00s -> 732.00s]  send window. This is because if the receive
[732.00s -> 734.00s]  window is ever greater than the send window,
[734.00s -> 736.00s]  it's a waste. The send window, the sender
[736.00s -> 738.00s]  would never have those packets in flight, and
[738.00s -> 740.00s]  so there's this extra buffer space which will
[740.00s -> 743.00s]  never be used. However, there are cases where
[743.00s -> 745.00s]  the receive window can be smaller than the
[745.00s -> 747.00s]  send window, and the protocol still works.
[747.00s -> 749.00s]  So here's one interesting basic case of that
[749.00s -> 752.00s]  called go back in. Let's say we receive
[752.00s -> 755.00s]  window of size one and a sending window that's
[755.00s -> 758.00s]  larger than, larger than one. Well, in this
[758.00s -> 761.00s]  case, we're going to need sending window size
[761.00s -> 763.00s]  plus one sequence numbers. So what does this
[763.00s -> 765.00s]  protocol look like? Well, the sender say,
[765.00s -> 768.00s]  let's say as a send window size is equal to
[768.00s -> 771.00s]  three. So the sender sends zero, one, and
[771.00s -> 773.00s]  two. And let's say those are all
[773.00s -> 776.00s]  acknowledged, and so the receiver acknowledges
[776.00s -> 779.00s]  zero and acknowledges one and acknowledges
[779.00s -> 782.00s]  two. But when it acknowledges zero, the
[782.00s -> 785.00s]  sender's going to send three, slide the
[785.00s -> 788.00s]  window forward. When it acknowledges one, it's
[788.00s -> 791.00s]  going to send four. And when it acknowledges
[791.00s -> 794.00s]  two, it's going to send five. So now let's
[794.00s -> 797.00s]  say that the sender is dropped. Now the
[797.00s -> 800.00s]  sender, the receiver, is going to still
[800.00s -> 803.00s]  receive four and five, and so it can act
[803.00s -> 806.00s]  two. It's going to send act two, act
[806.00s -> 809.00s]  two. The sender's going to time out
[809.00s -> 812.00s]  and resend three. So this is called a go
[812.00s -> 815.00s]  back end protocol. Because the receive
[815.00s -> 818.00s]  window was size one, the receiver could not
[818.00s -> 821.00s]  buffer four or five. And so when a single
[821.00s -> 823.00s]  packet is lost, in this case three, the
[823.00s -> 826.00s]  sender has to go back in. It has to retransmit
[826.00s -> 828.00s]  the entire send window with the packets.
[828.00s -> 830.00s]  It has to retransmit three, it'll have to
[830.00s -> 832.00s]  retransmit four, and it'll have to
[832.00s -> 834.00s]  retransmit five. In contrast, if the
[834.00s -> 836.00s]  receive window size had been three, then
[836.00s -> 838.00s]  the receiver could have buffered four and
[838.00s -> 840.00s]  five, the sender would only have had to
[840.00s -> 842.00s]  retransmit three, then you get an act
[842.00s -> 845.00s]  five, and it could go on and send six,
[845.00s -> 848.00s]  seven, nine, eight. And so here, in the case
[848.00s -> 851.00s]  of a go back end protocol, you need the
[851.00s -> 854.00s]  send window size plus one sequence numbers.
[854.00s -> 857.00s]  Because you imagine, if you have only the
[857.00s -> 860.00s]  send window size, there's zero, one, two.
[860.00s -> 863.00s]  And then, remember what happened in stop
[863.00s -> 866.00s]  and wait, when there's a packet delayed
[866.00s -> 869.00s]  where, hey, let's say that the act for
[869.00s -> 872.00s]  zero is delayed, there's a timeout, you
[872.00s -> 875.00s]  retransmit zero. Now you can't distinguish
[875.00s -> 878.00s]  whether or not the delayed acknowledgement
[878.00s -> 881.00s]  was for the retransmission or for the old
[881.00s -> 883.00s]  data. Generally speaking, if the two
[883.00s -> 885.00s]  windows are the same size, you need
[885.00s -> 888.00s]  twice basically their sum. And so that's
[888.00s -> 890.00s]  the generalization, that you need RWS
[890.00s -> 892.00s]  plus SWS sequence numbers. You need sequence
[892.00s -> 894.00s]  number space as least as big as the
[894.00s -> 897.00s]  sum of the window sizes. So, that's the
[897.00s -> 900.00s]  basic sliding window algorithm, and the
[900.00s -> 902.00s]  algorithms that the sender and the
[902.00s -> 904.00s]  receiver use, and how the sender manages
[904.00s -> 907.00s]  the window. What does this look like in
[907.00s -> 910.00s]  TCP? So, TCP is a sliding window protocol,
[910.00s -> 913.00s]  and uses that for flow control. And so,
[913.00s -> 916.00s]  here's the TCP header. And so, the way
[916.00s -> 919.00s]  TCP works is the set, the receiver
[919.00s -> 922.00s]  specifies a flow control window using
[922.00s -> 924.00s]  the window field, this in terms of
[924.00s -> 926.00s]  bytes. And so, it basically says, this
[926.00s -> 929.00s]  is the buffer size that I have on the
[929.00s -> 932.00s]  receiver, and so the set of packets that
[932.00s -> 935.00s]  I will accept. And the basic rule is
[935.00s -> 937.00s]  that, here are the data sequence number
[937.00s -> 939.00s]  and the acknowledgement sequence number.
[939.00s -> 942.00s]  And so, a TCP receiver will only handle
[942.00s -> 945.00s]  data equal to the acknowledge sequence
[945.00s -> 948.00s]  number plus the window. And so, the
[948.00s -> 952.00s]  sender isn't allowed to send data past
[952.00s -> 956.00s]  ACK plus window. That's to make sure it
[956.00s -> 959.00s]  doesn't send data which the receiver is
[959.00s -> 961.00s]  not going to buffer. And so, this is a
[961.00s -> 964.00s]  way for the receiver to essentially set
[964.00s -> 967.00s]  what the send window size is. So, let's
[967.00s -> 970.00s]  walk through an example. So here, again,
[970.00s -> 973.00s]  I'm going to talk in terms of packets
[973.00s -> 975.00s]  rather than bytes like in TCP. And
[975.00s -> 978.00s]  here's the sequence number space for
[978.00s -> 981.00s]  the packets from, you know, zero up to
[981.00s -> 984.00s]  29. So, let's say that we have a
[984.00s -> 988.00s]  receive window size equal to two. And
[988.00s -> 992.00s]  a send window size equal to three.
[993.00s -> 998.00s]  So, communication begins, and the sender
[998.00s -> 1002.00s]  is going to send zero, one, and two.
[1002.00s -> 1006.00s]  Let's say all three of those packets
[1006.00s -> 1009.00s]  arrive. And so, the receiver receives
[1009.00s -> 1011.00s]  zero. It's going to acknowledge zero.
[1011.00s -> 1013.00s]  It's then going to receive one,
[1013.00s -> 1015.00s]  acknowledge one, receive two, and
[1015.00s -> 1018.00s]  acknowledge two. When the sender hears
[1018.00s -> 1021.00s]  ACK zero, it'll advance the window.
[1021.00s -> 1024.00s]  The send window, and it'll send three.
[1024.00s -> 1027.00s]  When it hears the acknowledgement for
[1027.00s -> 1030.00s]  one, it'll advance the window and
[1030.00s -> 1032.00s]  send four. When it hears the
[1032.00s -> 1035.00s]  acknowledgement for two, it'll advance
[1035.00s -> 1038.00s]  the window and send five. Now, let's
[1038.00s -> 1041.00s]  say that packet three arrives successfully
[1041.00s -> 1045.00s]  and is acknowledged, but packet four is
[1045.00s -> 1048.00s]  lost in the network. So now we have
[1048.00s -> 1053.00s]  this case where, ACK three has been
[1053.00s -> 1057.00s]  sent, packet four is lost, then packet
[1057.00s -> 1061.00s]  five arrives at the receiver. Now, the
[1061.00s -> 1064.00s]  receiver is going to send another
[1064.00s -> 1067.00s]  acknowledgement three, again, because of
[1067.00s -> 1070.00s]  cumulative acknowledgements. And so now
[1070.00s -> 1074.00s]  the, the sender heard ACK three, then
[1074.00s -> 1079.00s]  another ACK three, waits, times out,
[1079.00s -> 1084.00s]  and resends four. So it'll resend four.
[1084.00s -> 1089.00s]  And let's say four arrives. Now, this
[1089.00s -> 1092.00s]  receiver can acknowledge four, so it
[1092.00s -> 1095.00s]  can ACK four, but because its receive
[1095.00s -> 1098.00s]  window was of size two, it actually had
[1098.00s -> 1101.00s]  five buffered, and so it can also
[1101.00s -> 1105.00s]  acknowledge four, and so it'll send ACK
[1105.00s -> 1109.00s]  five. So, a sliding window flow control
[1109.00s -> 1112.00s]  algorithm allows an unacknowledged, so a
[1112.00s -> 1114.00s]  whole window of unacknowledged packets
[1114.00s -> 1116.00s]  to be in flight. And so what this
[1116.00s -> 1118.00s]  allows is if you can set that window
[1118.00s -> 1121.00s]  size appropriately, it allows a sender to
[1121.00s -> 1124.00s]  be able to actually fully utilize the
[1124.00s -> 1126.00s]  capacity that the receiver has, unlike a
[1126.00s -> 1128.00s]  stop and wait protocol where you can
[1128.00s -> 1130.00s]  have at most one packet in flight.
[1130.00s -> 1132.00s]  When acknowledgements arrive for new
[1132.00s -> 1134.00s]  data, the sender advances the window.
[1134.00s -> 1136.00s]  Generally, sliding window protocols use
[1136.00s -> 1138.00s]  cumulative acknowledgements. And the
[1138.00s -> 1140.00s]  exact sequence number space you use
[1140.00s -> 1143.00s]  depends on the window sizes. So it
[1143.00s -> 1145.00s]  turns out TCP uses a large sequence
[1145.00s -> 1148.00s]  number space just for, for ease of
[1148.00s -> 1150.00s]  use and to really be robust against
[1150.00s -> 1152.00s]  heavily delayed packets. If you're
[1152.00s -> 1154.00s]  implementing your own protocol, you may
[1154.00s -> 1156.00s]  be able to get away with something a
[1156.00s -> 1157.00s]  little bit smaller.
[1160.00s -> 1162.00s]  Thank you.
