# Detected language: en (p=1.00)

[0.00s -> 3.92s]  Now that you've learned about the four-layer Internet model, we're going to focus on the
[3.92s -> 5.28s]  network layer.
[5.28s -> 7.24s]  This is the most important layer of the Internet.
[7.24s -> 10.16s]  In fact, to many people, it is the Internet.
[10.16s -> 14.00s]  Whenever we use the Internet, we're required to use the Internet protocol to send and
[14.00s -> 16.60s]  receive our packets.
[16.60s -> 21.08s]  You remember that we say that each layer provides a service to the layer above.
[21.08s -> 24.54s]  In order to correctly use a layer, we need a good understanding of the service that
[24.54s -> 25.54s]  it provides.
[25.54s -> 29.60s]  Therefore, in this video, I'm going to walk through the service provided by the Internet
[29.60s -> 31.00s]  protocol.
[31.00s -> 35.84s]  IP datagrams consist of a header and some data.
[35.84s -> 40.18s]  When the transport layer has data to send, it hands a transport segment to the network
[40.18s -> 42.26s]  layer below.
[42.26s -> 47.60s]  The network layer puts the transport segment inside a new IP datagram that it creates.
[47.60s -> 52.56s]  IP's job is to deliver the datagram to the other end of the Internet.
[52.56s -> 58.96s]  But first, the IP datagram has to make it over the first link to the first router.
[58.96s -> 63.86s]  So IP sends the datagram to the link layer that puts it inside a link frame, such as
[63.86s -> 67.84s]  an Ethernet packet, and then ships it off to the first router.
[67.84s -> 72.84s]  The IP service can be characterized by four properties listed here.
[72.84s -> 75.20s]  It sends datagrams from end-host to end-host.
[75.20s -> 78.64s]  It is unreliable, but makes the best effort to deliver the datagrams.
[78.64s -> 82.92s]  The network maintains no per-flow state associated with the datagrams.
[82.92s -> 86.80s]  Let's take a look at each one of these in turn as listed in the table.
[87.64s -> 90.68s]  First, IP is a datagram service.
[90.68s -> 97.00s]  When we ask IP to send some data for us, it creates a datagram and puts our data inside.
[97.00s -> 100.96s]  The datagram is a packet that is routed individually through the network based on
[100.96s -> 102.44s]  the information in its header.
[102.44s -> 105.76s]  In other words, the datagram is self-contained.
[105.76s -> 111.60s]  The header contains the IP address of the destination, which we abbreviate here as IPDA
[111.60s -> 113.64s]  for IP destination address.
[113.64s -> 119.32s]  And the forwarding decision at each router is based on this IPDA.
[119.32s -> 124.00s]  The datagram header also contains an IP source address, or IP SA, saying where the
[124.00s -> 130.32s]  packet came from, so the receiver knows where to send any response.
[130.32s -> 133.84s]  Datagrams are routed hop-by-hop through the network from one router to the next,
[133.84s -> 137.84s]  all the way from the IP source address to the IP destination address.
[137.84s -> 141.92s]  We'll learn more about how routers work later, but for now it's enough to know
[141.92s -> 146.32s]  that each router contains a forwarding table that tells it where to send packets next
[146.32s -> 149.52s]  after it matches a given destination address.
[149.52s -> 151.20s]  The router doesn't know the whole path.
[151.20s -> 155.76s]  It simply uses the destination address to index into its own forwarding table so that
[155.76s -> 160.48s]  it can forward the packet to the next hop along the path towards its final destination.
[160.48s -> 165.40s]  Hop-by-pop, step-by-step, the packet makes its way from the source to the destination,
[165.40s -> 170.28s]  using only the destination address in the datagram.
[170.28s -> 174.48s]  You'll often hear the analogy made between how IP datagrams are routed and how letters
[174.48s -> 176.56s]  are routed by the postal service.
[176.56s -> 178.32s]  It's a good analogy.
[178.32s -> 181.40s]  In the postal service, we put a letter into the mailbox with the address of the
[181.40s -> 186.48s]  destination, and the letter is routed, invisibly to us, hop-by-hop, from sorting office
[186.48s -> 189.40s]  to sorting office until it reaches its destination.
[189.40s -> 193.44s]  Neither the sender or the receiver know, or need to know, the path taken by the
[193.44s -> 197.32s]  letters in the postal service, or by datagrams in the Internet.
[197.32s -> 206.92s]  The IP service model provides a service, which includes the routing to the destination.
[206.92s -> 213.00s]  The second aspect of the IP service model, and perhaps most surprisingly, is IP is unreliable.
[213.00s -> 217.44s]  IP makes no promise that packets will be delivered to the destination.
[217.44s -> 221.20s]  They could be delivered late, out of sequence, or never delivered at all.
[221.20s -> 225.80s]  It's possible that a packet will be duplicated along the way, for example by a misbehaving
[225.80s -> 226.80s]  router.
[226.80s -> 233.24s]  The only thing to remember is that IP is unreliable and makes no guarantees.
[233.24s -> 238.20s]  But it won't drop datagrams arbitrarily just because it feels like it.
[238.20s -> 240.44s]  That's if you believe networks have feelings.
[240.44s -> 245.60s]  IP does make the promise to only drop datagrams if necessary.
[245.60s -> 249.36s]  For example, the packet queue in a router might fill up because of congestion, forcing
[249.36s -> 251.60s]  the router to drop the next arriving packet.
[251.60s -> 253.96s]  IP won't make any attempt to resend the data.
[253.96s -> 257.52s]  In fact, IP doesn't even tell the source that the packet was dropped.
[257.52s -> 262.40s]  Similarly, a faulty routing table might cause a packet to be sent to the wrong destination,
[262.40s -> 264.72s]  or cause a packet to be duplicated by mistake.
[264.72s -> 269.34s]  IP doesn't make any promises that these errors won't happen, nor does it detect
[269.34s -> 270.64s]  them when they do.
[270.64s -> 277.68s]  But IP does make the promise to only make these errors and drop packets when necessary.
[277.68s -> 282.30s]  In fact, the IP datagram service is very much like the basic postal service.
[282.34s -> 286.26s]  The basic postal service makes no promise that our letters will be delivered on time,
[286.26s -> 290.18s]  or that if we send two or three letters back-to-back on consecutive days, that they
[290.18s -> 292.62s]  will be received in the order they were sent.
[292.62s -> 295.82s]  And it makes no promise that they will be delivered at all, unless we pay for a more
[295.82s -> 299.30s]  expensive end-to-end service to guarantee delivery.
[299.30s -> 304.60s]  Really, when it comes down to it, IP is an extremely simple, minimal service.
[304.60s -> 307.88s]  It maintains no state at all related to a communication.
[307.88s -> 313.32s]  We say that a communication service is connectionless, because it doesn't start by establishing
[313.32s -> 317.52s]  some end-to-end state associated with the communication.
[317.52s -> 321.00s]  In other words, when we make a Skype call, lasting several minutes and consisting of
[321.00s -> 326.56s]  many IP datagrams, the IP layer maintains no knowledge of the call, and simply routes
[326.56s -> 335.00s]  each datagram individually and independently of all the others.
[335.00s -> 338.42s]  You might be wondering why the IP service is so simple.
[338.42s -> 341.96s]  After all, it is the foundation of the entire Internet.
[341.96s -> 347.16s]  Every communication over the Internet users must use the IP service.
[347.16s -> 352.70s]  Given how important the Internet is, wouldn't it have been better to make IP reliable?
[352.70s -> 358.88s]  After all, we did say that most applications want a reliable byte communication service.
[358.88s -> 363.92s]  There are several reasons the IP service model was designed to be so simple.
[363.92s -> 370.04s]  First, to keep the network simple, dumb and minimal – faster, more streamlined and
[370.04s -> 373.28s]  lower cost to build and maintain.
[373.28s -> 378.40s]  It was believed that if the network is kept simple, with very few features and requirements,
[378.40s -> 382.80s]  then packets could be delivered very quickly and at low cost to the destination.
[382.80s -> 386.80s]  The thinking was that a simple network could be made to run very fast using dedicated
[386.80s -> 390.76s]  hardware, and given that the network is implemented by a large number of routers
[390.76s -> 396.08s]  scattered throughout the network, if they could be kept simple, then they are more likely
[396.08s -> 402.40s]  to be reliable, more affordable, easier to maintain, and will need to be upgraded
[402.40s -> 405.66s]  less often.
[405.66s -> 408.06s]  Second is the end-to-end principle.
[408.06s -> 414.38s]  The end-to-end principle states that, where possible, implement features in the end hosts.
[414.38s -> 418.38s]  In the design of communication systems, such as the Internet, there is a well-known principle
[418.38s -> 423.34s]  called the end-to-end principle that says, if you can correctly implement features at
[423.34s -> 425.42s]  the endpoints, then you should.
[425.42s -> 430.44s]  We will study the end-to-end principle in more depth in later videos, but the basic
[430.44s -> 434.94s]  idea is to place as much intelligence as possible at the endpoints – in our case,
[434.94s -> 437.36s]  the source and destination computers.
[437.36s -> 441.28s]  This can have several advantages, such as making sure the feature is implemented correctly
[441.28s -> 445.52s]  for the application, and it is easier to evolve and improve a feature if it is implemented
[445.52s -> 451.24s]  in software on end computers, rather than baked into the hardware of the Internet.
[451.24s -> 454.92s]  In the case of the Internet, it was decided that features such as reliable communications
[454.92s -> 459.26s]  and controlling congestion should be done at the endpoints by the source and destination
[459.26s -> 461.64s]  computers, and not by the network.
[461.64s -> 466.80s]  At the time, it was quite a radical suggestion, and very different design choice from the
[466.80s -> 470.72s]  telephone system, the largest existing network at the time, which was originally
[471.16s -> 475.12s]  built on the idea of simple handsets and a complicated feature-rich network of telephone
[475.12s -> 477.12s]  switches.
[477.12s -> 480.40s]  In later videos, we will be studying the end-to-end principle as one of the important
[480.40s -> 482.88s]  architectural principles of communication systems.
[482.88s -> 486.24s]  We will see many examples of the end-to-end principle in action.
[486.24s -> 490.16s]  For example, when we study the transport layer, we will see how the end hosts build
[490.16s -> 497.16s]  a reliable communication service over the unreliable IP network service.
[498.16s -> 505.16s]  A simple IP service also allows a variety of reliable or unreliable services to be built
[505.52s -> 508.04s]  on top.
[508.04s -> 513.24s]  If IP was reliable, in other words, if any missing packets were retransmitted automatically,
[513.24s -> 517.00s]  then it would not be ideal for some services.
[517.00s -> 521.88s]  For example, in real-time applications like a video chat, there might be no point in
[521.88s -> 526.92s]  retransmitting lost data, because it might arrive too late to be useful.
[526.92s -> 531.20s]  Instead, the application might choose to show a few blank pixels, or use the pixels from
[531.20s -> 533.36s]  the frame before.
[533.36s -> 537.88s]  By not providing any reliability guarantees, IP lets the application choose the reliability
[537.88s -> 540.88s]  service it needs.
[540.88s -> 546.32s]  Finally, IP works over any link layer.
[546.32s -> 549.92s]  IP makes very few assumptions about the link layer.
[549.92s -> 554.14s]  IP makes very little expectation at all of the link layer below.
[554.14s -> 559.22s]  The link could be wired or wireless and requires no retransmission or control of congestion.
[559.22s -> 562.62s]  Some people have said IP is so simple and makes so few assumptions about the underlying
[562.62s -> 564.94s]  link layer that you could run IP over carrier pigeons.
[564.94s -> 569.80s]  In fact, there is even an Internet standard telling you how to do it.
[569.80s -> 574.82s]  Making IP run over any link layer made sense, because the Internet was created specifically
[574.82s -> 583.90s]  to interconnect existing networks.
[583.90s -> 589.14s]  In addition to the basic, unreliable, best-effort, connectionless datagram service, IP also provides
[589.14s -> 592.24s]  a few other carefully chosen services.
[592.24s -> 597.54s]  The designers of IP tried very hard to find a balance between providing the bare minimum
[597.54s -> 602.14s]  needed to make communications work, while not providing such a bare-bones service that
[602.14s -> 604.78s]  it doesn't really work at all.
[604.78s -> 608.70s]  I'm going to describe five features here, and you'll learn about each one of these
[608.70s -> 610.26s]  features in later videos.
[610.26s -> 614.30s]  So I won't go into a lot of details here, but I will briefly describe each one so you
[614.30s -> 617.94s]  can understand the scope of the complete IP service.
[617.94s -> 622.70s]  First, IP tries to prevent packets from looping forever.
[622.70s -> 626.86s]  Because IP routers forward packets hop-by-hop across the Internet, it is possible for
[626.86s -> 631.50s]  the forwarding table in a router to be wrong, causing a packet to start looping round
[631.50s -> 634.94s]  and around, following the same path.
[634.94s -> 638.56s]  This is most likely to happen when the forwarding tables are changing, and they temporarily
[638.56s -> 642.18s]  get into an inconsistent state.
[642.18s -> 646.20s]  Rather than try to prevent loops from ever happening, which would take a lot of complexity,
[646.20s -> 650.84s]  IP uses a very simple mechanism to catch and then delete packets that appear to be
[650.84s -> 652.82s]  stuck in a loop.
[652.82s -> 658.16s]  To do this, IP simply adds a hop-count field in the header of every datagram.
[658.16s -> 661.70s]  It's called the Time-to-Live, or TTL, field.
[661.70s -> 666.50s]  It starts out at a number like 128, and then it is decremented by every router it
[666.50s -> 667.50s]  passes through.
[667.58s -> 672.30s]  If it reaches zero, IP concludes that it must be stuck in a loop, and the router drops the
[672.30s -> 673.30s]  datagram.
[673.30s -> 676.46s]  It is a simple mechanism, typical of IP.
[676.46s -> 679.02s]  It doesn't guarantee that loops won't happen.
[679.02s -> 682.82s]  It just tries to limit the damage caused by a flood of endlessly looping packets in
[682.82s -> 683.82s]  the network.
[687.66s -> 690.90s]  IP will fragment packets if they are too long.
[690.90s -> 694.76s]  IP is designed to run over any kind of link.
[694.76s -> 697.94s]  Most links have a limit on the size of the packets that they can carry.
[697.94s -> 703.16s]  For example, Ethernet can only carry packets shorter than 1500 bytes.
[703.16s -> 707.58s]  If an application has more than 1500 bytes to send, it has to be broken into 1500-byte
[707.58s -> 711.00s]  pieces before sending in an IP datagram.
[711.00s -> 715.62s]  Now along the path towards the destination, a 1500-byte datagram might need to go over
[715.62s -> 720.88s]  a link that can only carry smaller packets, let's say 1000 bytes long.
[720.88s -> 726.12s]  The router connecting the two links will fragment the data into two smaller datagrams.
[726.12s -> 731.24s]  IP provides some header fields, that we will see in a minute, to help the router fragment
[731.24s -> 735.88s]  the datagram into two self-contained IP datagrams, while providing the information
[735.88s -> 740.36s]  the end host needs to correctly reassemble the data again.
[740.36s -> 746.84s]  IP uses a header checksum to reduce the chances of delivering a datagram to the wrong
[746.84s -> 748.48s]  destination.
[748.48s -> 753.80s]  IP includes a checksum field in the datagram header to try and make sure that datagrams
[753.80s -> 756.68s]  are delivered to the right location.
[756.68s -> 760.12s]  It could be quite a security problem if packets are accidentally and frequently sent
[760.12s -> 764.92s]  to the wrong place because of a mistake by a router along the way.
[764.92s -> 769.80s]  Fourth, there are two versions of IP in use today.
[769.80s -> 774.20s]  IPv4, which is used today by over 90% of end hosts.
[774.20s -> 777.96s]  It uses the 32-bit addresses you are probably familiar with.
[777.96s -> 782.36s]  Because we are running out of IPv4 addresses, the Internet is in a gradual transition to
[782.36s -> 787.56s]  IPv6, which uses 128-bit addresses instead.
[787.56s -> 792.04s]  You will be learning about the details of IPv4 and IPv6 in later videos.
[792.04s -> 796.72s]  Finally, IP allows new fields to be added to the datagram header.
[796.72s -> 800.60s]  In practice, this is a bit of a mixed blessing.
[800.60s -> 804.12s]  On the one hand, it allows new features to be added to the header that turn out to
[804.12s -> 807.54s]  be important, but weren't in the original standard.
[807.54s -> 812.24s]  On the other hand, these fields need processing, and so require extra features in the routers
[812.24s -> 817.06s]  along the path, breaking the goal of a simple, dumb, minimal forwarding path.
[817.06s -> 823.98s]  In practice, very few options are used or processed by the routers.
[823.98s -> 829.46s]  I am now going to show you the IPv4 header and explain what all the fields do.
[829.46s -> 835.74s]  I don't need you to remember where all the fields are, but I do want you to know
[835.74s -> 843.22s]  what each field does, because it helps you understand the scope of the IP service model.
[843.22s -> 847.18s]  It should help cement your understanding and make it really clear that IP doesn't do
[847.18s -> 848.18s]  a lot.
[848.18s -> 850.26s]  It is a deliberately simple service.
[850.26s -> 855.78s]  Here is a picture of an IPv4 header, which is the most common header in use today.
[855.78s -> 861.28s]  I have drawn it here in 32-bit words, with bit 0 the first to be sent onto the wire
[861.28s -> 863.78s]  up in the top left corner.
[863.78s -> 866.58s]  The shaded portion is the IPv4 header.
[866.58s -> 870.58s]  It is followed by the data.
[870.58s -> 876.14s]  The most important fields in the IP header are the destination IP address, the source
[876.14s -> 881.54s]  IP address, the protocol ID that tells us what is inside the data field.
[881.54s -> 886.36s]  Essentially, it allows the destination host to demultiplex arriving data, sending them
[886.36s -> 889.62s]  to the correct code to process the packet.
[889.62s -> 895.46s]  If the protocol ID has the value 6, for example, then it tells us that the data contains
[895.46s -> 901.06s]  a TCP segment, and so we can safely pass the datagram to the TCP code, and it will
[901.06s -> 904.38s]  be able to parse the segment correctly.
[904.38s -> 910.22s]  The Internet Assigned Numbers Authority defines over 140 different values of protocol
[910.22s -> 914.98s]  ID representing different transport protocols.
[914.98s -> 918.42s]  The version field tells us which version of IP we are using.
[918.42s -> 923.34s]  Currently, the legal values are IPv4 and IPv6.
[923.34s -> 924.94s]  This header is an IPv4 header.
[924.94s -> 929.18s]  We will see IPv6 headers in a later video.
[929.18s -> 935.66s]  The total packet length can be up to 64 kilobytes, including the header and all the data.
[935.66s -> 939.66s]  The time-to-live, or TTL, field helps us to prevent packets accidentally looping
[939.66s -> 941.70s]  in the network forever.
[941.70s -> 944.90s]  Every router is required to decrement the TTL field.
[944.90s -> 948.12s]  If it reaches zero, the router should drop the packet.
[948.12s -> 952.20s]  This way, when the source sends the packet with a fixed TTL value, it is guaranteed to
[952.20s -> 959.72s]  be destroyed by a router if it starts to travel in loops.
[959.72s -> 964.16s]  Sometimes a packet is too long for the link it is about to be sent on.
[964.16s -> 969.16s]  The packet ID, flags, and fragment offset all help routers to fragment IP packets into
[969.16s -> 973.00s]  smaller self-contained datagrams if need be.
[973.00s -> 977.62s]  We will learn how fragmentation works in a later video.
[977.62s -> 983.30s]  The type of service field gives a hint to routers about how important this packet is.
[983.30s -> 985.78s]  The header length tells us how big the header is.
[985.78s -> 989.70s]  Some headers have optional extra fields to carry extra information.
[989.70s -> 994.72s]  Finally, a checksum is calculated over the whole header, so just in case the header
[994.72s -> 1001.62s]  is corrupted, we are not likely to deliver a packet to the wrong destination by mistake.
[1001.62s -> 1004.24s]  So in summary, IP is very important.
[1004.24s -> 1008.32s]  We use it every time we send and receive packets in the Internet.
[1008.32s -> 1012.68s]  IP provides a deliberately simple service.
[1012.68s -> 1016.24s]  It is a simple, dumb, minimal service with four main features.
[1016.24s -> 1019.20s]  It sends datagrams, hop-by-hop, across the Internet.
[1019.20s -> 1021.96s]  The service is unreliable and best effort.
[1021.96s -> 1026.00s]  There is no per-flow state making the protocol connectionless.
[1026.00s -> 1031.50s]  At this point, you should feel comfortable with what the IP protocol is, what its service
[1031.50s -> 1035.86s]  model is, and how it fits into the Internet four-layer hierarchy.
[1035.86s -> 1042.10s]  If you have doubts, I suggest you re-watch this video and the one before it on the four-layer model.
[1042.10s -> 1046.30s]  You will also find lots of good references about how IPv4 works.
[1046.30s -> 1051.28s]  Any good networking textbook will devote considerable space to explaining what IP is and why
[1051.28s -> 1052.52s]  it was designed this way.
[1052.52s -> 1057.18s]  For example, Chapter 4 of the sixth edition of Computer Networking, a Top-Down Approach
[1057.18s -> 1058.74s]  by Crose and Ross.
[1058.74s -> 1061.18s]  You will also find a brief explanation on Wikipedia.
