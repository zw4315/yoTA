# Detected language: en (p=1.00)

[0.00s -> 5.00s]  This video is about the architectural principle we call encapsulation.
[5.00s -> 10.00s]  Encapsulation is the result of what happens when you combine layering and packet switching.
[10.00s -> 14.00s]  We want to break up our data into discrete units that we call packets.
[14.00s -> 18.00s]  However, each packet contains data from multiple layers.
[18.00s -> 22.00s]  When you send a TCP segment, for example, it's sitting inside an IP packet,
[22.00s -> 25.00s]  which is in turn sitting inside an Ethernet frame.
[25.00s -> 27.00s]  Encapsulation is how this works.
[27.00s -> 31.00s]  Encapsulation is the principle by which you organize information in packets
[31.00s -> 35.00s]  so that you can maintain layers, yet let them share the contents of your packets.
[37.00s -> 42.00s]  Recall that layering lets you take a complex system and break it down into smaller parts.
[42.00s -> 46.00s]  Each layer provides a service, an abstraction of the network to the layers above.
[46.00s -> 49.00s]  It provides this abstraction by using the layer below it.
[49.00s -> 53.00s]  Each layer is self-contained, so as long as it provides the surface expected of it,
[53.00s -> 55.00s]  layers above don't need to worry about how.
[55.00s -> 59.00s]  This separation of concerns means each layer can evolve independently.
[59.00s -> 65.00s]  Just as IP at the network layer doesn't need to have to worry about changes to TCP at the transport layer,
[65.00s -> 70.00s]  application layers such as HTTP don't have to worry about changes to TCP.
[70.00s -> 75.00s]  For example, the past few years, most operating systems have changed the exact TCP algorithms they used
[75.00s -> 78.00s]  to better handle increasing network speeds.
[78.00s -> 82.00s]  But a web browser works fine using both the old algorithms and the new ones.
[82.00s -> 86.00s]  Note that this picture of layers uses the 7-layer OSI model.
[87.00s -> 90.00s]  So let's scrunch back down to the 4-layer model.
[90.00s -> 94.00s]  Encapsulation is the principle that lets us take protocol layers
[94.00s -> 97.00s]  and let them easily share the storage within a packet.
[97.00s -> 100.00s]  It's how layering manifests in the actual data representation.
[100.00s -> 104.00s]  The way this works is each protocol layer has some headers,
[104.00s -> 108.00s]  followed by its payload, followed by some footers.
[108.00s -> 112.00s]  For example, an IP packet header has a source address and a destination address.
[112.00s -> 118.00s]  To send a TCP segment with IP, we make the TCP format the payload of the IP packet.
[118.00s -> 122.00s]  In this way, the IP packet encapsulates the TCP segment.
[122.00s -> 127.00s]  IP doesn't know or care what its payload is, it just delivers packets to an end host.
[127.00s -> 130.00s]  When the packet arrives, the host looks inside the payload,
[130.00s -> 134.00s]  sees that it's a TCP segment, and processes it accordingly.
[135.00s -> 137.00s]  So here's a more complete example.
[137.00s -> 142.00s]  Let's say that you're browsing the web using a computer connected through Wi-Fi, wireless Ethernet.
[143.00s -> 146.00s]  Your web browser generates an HTTP GET request.
[146.00s -> 150.00s]  This GET request is the payload of a TCP segment.
[150.00s -> 155.00s]  The TCP segment encapsulating the HTTP GET becomes the payload of an IP packet.
[156.00s -> 161.00s]  This IP packet, in turn, encapsulating the TCP segment and the HTTP GET
[161.00s -> 163.00s]  is the payload of a Wi-Fi frame.
[164.00s -> 168.00s]  If you were to look at the bytes your computer sends, they'd look like this.
[169.00s -> 172.00s]  The outermost encapsulating format is the Wi-Fi frame,
[172.00s -> 176.00s]  inside of which is an IP packet, inside of which is a TCP segment,
[176.00s -> 179.00s]  inside of which, finally, is the HTTP GET.
[180.00s -> 184.00s]  So how Nick has drawn this packet brings up something you might find very confusing.
[184.00s -> 187.00s]  It turns out there are two ways to draw packets.
[187.00s -> 190.00s]  The difference comes from the background and what part of the system you work on.
[190.00s -> 193.00s]  Nick has drawn the packets here, where the headers are on the right,
[193.00s -> 198.00s]  the first bit of the packet is on the right, and the last bit of the packet is on the left.
[198.00s -> 200.00s]  This makes total sense.
[200.00s -> 204.00s]  As a router or switch sends a packet, we draw the packet moving from left to right.
[204.00s -> 208.00s]  So the first bit to leave the router or switch is the one at the far right.
[209.00s -> 212.00s]  But I draw packets the other way, where the headers are on the left,
[212.00s -> 214.00s]  and the footers are on the right, like this.
[215.00s -> 217.00s]  This second approach comes from software.
[217.00s -> 221.00s]  It's what you'll see when you read IETF documents and many other protocol specifications.
[221.00s -> 225.00s]  The idea is that the beginning of the packet comes at address zero.
[225.00s -> 228.00s]  So the first byte of the header is at address zero.
[228.00s -> 230.00s]  Since addresses increase from left to right,
[230.00s -> 232.00s]  this means the beginning of the packet is on the left,
[232.00s -> 234.00s]  and the end of the packet is on the right.
[234.00s -> 236.00s]  Of course, there isn't a right way or a wrong way here.
[236.00s -> 240.00s]  Both ways of drawing packets are valuable and depend on what you're using the drawing for.
[240.00s -> 242.00s]  So you should be comfortable with both.
[242.00s -> 244.00s]  I'll generally draw headers on the right.
[244.00s -> 246.00s]  And I'll generally draw them on the left.
[246.00s -> 248.00s]  Nick's background is electrical engineering and switch design.
[248.00s -> 251.00s]  Mine is computer science and protocol software.
[254.00s -> 259.00s]  So now let's go back to Nick's example of an HTTP GET inside a TCP segment,
[259.00s -> 261.00s]  inside an IP packet, inside a Wi-Fi frame.
[261.00s -> 264.00s]  Let's see what this looks like in an actual network with Wireshark.
[264.00s -> 266.00s]  Before we started this recording,
[266.00s -> 269.00s]  I turned on Wireshark and recorded a packet trace of a web request.
[269.00s -> 271.00s]  Let's look at just one packet.
[272.00s -> 276.00s]  Here, we can see how Wireshark tells us that it's an Ethernet frame,
[276.00s -> 279.00s]  inside which is an IP packet,
[279.00s -> 281.00s]  inside which is a TCP segment,
[281.00s -> 283.00s]  inside which is an HTTP GET.
[283.00s -> 286.00s]  If I click on each of these protocol headers,
[286.00s -> 290.00s]  then Wireshark actually highlights where they are in the packet bytes.
[290.00s -> 292.00s]  These gobbledygook below.
[292.00s -> 294.00s]  Wi-Fi comes first.
[294.00s -> 297.00s]  Inside Wi-Fi is IP.
[297.00s -> 300.00s]  Inside IP is TCP.
[300.00s -> 305.00s]  And inside TCP, we can see the text of our HTTP GET.
[305.00s -> 308.00s]  This very simple approach of encapsulating protocols within each other
[308.00s -> 310.00s]  gives you tremendous flexibility.
[310.00s -> 313.00s]  So far we've been talking about the four-layer model
[313.00s -> 315.00s]  as something completely static and inflexible.
[315.00s -> 317.00s]  In practice, it's not like that.
[317.00s -> 321.00s]  You can actually use encapsulation to recursively layer protocols.
[321.00s -> 325.00s]  For example, something that's very commonly used today
[325.00s -> 327.00s]  in offices of businesses
[327.00s -> 331.00s]  is something called a virtual private network, or VPN.
[331.00s -> 334.00s]  With a virtual private network, you open a secure network
[334.00s -> 337.00s]  with a secure connection to a network you trust, such as your office.
[337.00s -> 341.00s]  For example, using Transport Layer Security, TLS.
[341.00s -> 344.00s]  When you communicate with the Internet and send IP packets,
[344.00s -> 346.00s]  rather than send them normally,
[346.00s -> 349.00s]  you send them inside this VPN connection.
[349.00s -> 352.00s]  So the IP packets go to your office network.
[352.00s -> 355.00s]  At that point, the office network can route them normally.
[355.00s -> 357.00s]  This lets you do things like access
[357.00s -> 360.00s]  private protected network resources inside your office.
[360.00s -> 363.00s]  So rather than sprinkle network protections everywhere,
[363.00s -> 365.00s]  you just have to be careful with one service,
[365.00s -> 367.00s]  the service that lets people log into the network
[367.00s -> 369.00s]  over the virtual private network.
[369.00s -> 372.00s]  You do this with a virtual private network, or VPN gateway,
[372.00s -> 375.00s]  a computer that accepts connections from permitted VPN clients
[375.00s -> 378.00s]  and forwards their traffic into the private network.
[378.00s -> 380.00s]  So what does that look like?
[380.00s -> 383.00s]  Let's say I'm accessing my internal company website.
[383.00s -> 385.00s]  My web browser generates an HTTP GET.
[385.00s -> 388.00s]  Like usual, it puts this inside a TCP segment,
[388.00s -> 390.00s]  which it puts inside an IP packet
[390.00s -> 393.00s]  destined to the company's internal web server.
[393.00s -> 397.00s]  But rather than put this IP packet inside a link layer or frame,
[397.00s -> 400.00s]  I can't directly communicate with the internal web server.
[400.00s -> 406.00s]  My computer puts this IP packet inside a TLS segment, a secure segment.
[406.00s -> 409.00s]  TLS protects the message and keeps it secret.
[409.00s -> 412.00s]  This TLS session is inside a TCP stream
[412.00s -> 415.00s]  that terminates at the virtual private network gateway.
[415.00s -> 418.00s]  So the outer TCP segment is inside an IP packet
[418.00s -> 421.00s]  destined to the virtual private network gateway.
[421.00s -> 424.00s]  We put this outer IP packet inside a link frame
[424.00s -> 426.00s]  and send it to the next hop normally.
[426.00s -> 428.00s]  So it looks like this.
[429.00s -> 431.00s]  HTTP
[431.00s -> 433.00s]  inside TCP
[433.00s -> 435.00s]  inside IP
[435.00s -> 437.00s]  inside TLS
[437.00s -> 439.00s]  inside TCP
[439.00s -> 441.00s]  inside IP
[441.00s -> 442.00s]  inside...
[442.00s -> 444.00s]  Now you've learned about encapsulation,
[444.00s -> 447.00s]  the principle that unifies layering and packet switching.
[447.00s -> 449.00s]  Encapsulation is how we take protocol layers
[449.00s -> 451.00s]  and assemble them into packets in a way that's flexible
[451.00s -> 454.00s]  and maintains their separation of concerns.
[454.00s -> 456.00s]  You saw an example of how a computer
[456.00s -> 458.00s]  can encapsulate a ...
[458.00s -> 460.00s]  OK, I'm going to start this slide again.
[468.00s -> 470.00s]  Now you've heard about encapsulation,
[470.00s -> 473.00s]  the principle that unifies layering and packet switching.
[473.00s -> 475.00s]  Encapsulation is how we take protocol layers
[475.00s -> 477.00s]  and assemble them into packets
[477.00s -> 479.00s]  in a way that's flexible and maintains
[479.00s -> 481.00s]  the separation of concerns.
[481.00s -> 483.00s]  You saw an example of a computer
[483.00s -> 485.00s]  that encapsulates a web request,
[485.00s -> 487.00s]  as well as an example of how one can use encapsulation
[487.00s -> 489.00s]  in a more complex way
[489.00s -> 491.00s]  for something like a virtual private network.
