# Detected language: en (p=1.00)

[0.00s -> 4.00s]  In this unit, you learn how to answer the following question.
[4.00s -> 7.00s]  How should packets from A reach B?
[7.00s -> 14.00s]  Or in the multicast case, how should packets from A reach B, C, and perhaps other end hosts too?
[14.00s -> 21.00s]  We started by studying four basic approaches used when routing unicast packets from one end host to another.
[21.00s -> 25.00s]  First, we can flood packets over every link in the network.
[25.00s -> 31.00s]  When a packet arrives to a router, it's replicated to all of the interfaces except the one it arrived on.
[31.00s -> 39.00s]  This guarantees that a flooded packet will eventually traverse every link, and will therefore reach any and every end host in the network.
[39.00s -> 46.00s]  It's clearly very inefficient and expensive, and needs to be coupled with a mechanism to prevent packets from looping forever.
[46.00s -> 53.00s]  Flooding is used during times of uncertainty, when the topology is changing and we have no other way to be sure that we can reach every other host.
[53.00s -> 60.00s]  For example, when OSPF routers are exchanging link state, they flood the link state packets throughout the OSPF domain,
[60.00s -> 65.00s]  so the topology is known to every router, even when the topology has changed.
[65.00s -> 68.00s]  Second, we can use source routing.
[68.00s -> 76.00s]  In source routing, the source host puts into the header of every packet a list of hops the packet should traverse through the network.
[76.00s -> 80.00s]  Clearly this is possible if the end host knows the entire topology.
[80.00s -> 87.00s]  Source routing means we don't need to exchange routing table information in the network. The routers don't need to contain a forwarding table at all.
[87.00s -> 93.00s]  In fact, arguably, source routing is very much in keeping with the strong end-to-end principle.
[93.00s -> 96.00s]  We shouldn't burden the network with having to know all the paths.
[96.00s -> 101.00s]  But in practice, source routing is rarely used for a number of reasons.
[101.00s -> 103.00s]  The biggest reason is security.
[103.00s -> 108.00s]  Network operators don't like source routing because it requires them to expose the full topology of their network,
[108.00s -> 112.00s]  and never open it up so end hosts can send packets wherever they want.
[112.00s -> 118.00s]  The Internet designers felt it was a worthwhile optimization for the routers to maintain a forwarding table,
[118.00s -> 123.00s]  to avoid having to distribute full up-to-date topology information to all the end hosts.
[123.00s -> 129.00s]  Third, the routers can contain forwarding tables, which they clearly do today.
[129.00s -> 132.00s]  Rather than relying on the source to provide the routing information,
[132.00s -> 136.00s]  the forwarding table in the router contains the address of the destination,
[136.00s -> 142.00s]  and an indication of which interface to exit the router in order to move one step closer to the destination.
[142.00s -> 146.00s]  Today, all Ethernet switches and Internet routers use forwarding tables.
[146.00s -> 150.00s]  The job of the routing algorithm is to populate the forwarding tables.
[150.00s -> 159.00s]  Finally, you learned how unicast routing algorithms usually build a spanning tree, with the destination at the root of the tree.
[160.00s -> 163.00s]  It's a tree because we don't want loops.
[163.00s -> 169.00s]  It's spanning because it provides a way for all source end hosts to reach a given destination.
[169.00s -> 174.00s]  Generally speaking, routing algorithms used in the Internet, such as OSPF and RIP,
[174.00s -> 179.00s]  populate the forwarding tables so as to create a spanning tree across the network.
[179.00s -> 183.00s]  Usually the spanning tree we build is a minimum-cost spanning tree,
[183.00s -> 188.00s]  where we are trying to minimize the hop count, delay, or the distance traveled by packets.
[188.00s -> 193.00s]  You learned about two algorithms widely used to build the forwarding tables in routers.
[193.00s -> 198.00s]  The first is the Bellman-Ford algorithm, which is usually referred to as a distance vector algorithm.
[198.00s -> 203.00s]  Each router constructs a vector of distances from itself to every other router in the network.
[203.00s -> 210.00s]  In successive steps, the routers exchange their vectors so as to find the neighbor that is closest to each destination.
[210.00s -> 215.00s]  After a number of iterations, equal to no more than the longest loop-free path in the topology,
[215.00s -> 218.00s]  the algorithm will settle on a set of forwarding tables in each router
[218.00s -> 223.00s]  that tells it how to route packets along the shortest path to every destination.
[223.00s -> 227.00s]  The Bellman-Ford algorithm was the basis for RIP, the Routing Information Protocol,
[227.00s -> 230.00s]  which was the first widely used routing algorithm in the Internet.
[230.00s -> 233.00s]  The good thing about RIP is that its algorithm is distributed.
[233.00s -> 237.00s]  The routers work together to build a complete set of forwarding tables.
[237.00s -> 239.00s]  This is important in the early days of the Internet,
[239.00s -> 242.00s]  when the routers were assumed to have very little computing power.
[242.00s -> 248.00s]  However, RIP has many problems trying to converge on the right answer when the network topology is changing.
[248.00s -> 253.00s]  We saw examples of the so-called counting to infinity problem in which bad news travels slowly,
[253.00s -> 256.00s]  and methods such as poison reverse to try and overcome it.
[256.00s -> 264.00s]  Today, RIP is rarely used and has mostly been replaced by OSPF and an algorithm called ISIS.
[265.00s -> 270.00s]  OSPF is based on the second algorithm, Dijkstra's shortest path-first algorithm.
[270.00s -> 275.00s]  Dijkstra's algorithm assumes that every router has the computational power to construct its own routing table,
[275.00s -> 278.00s]  if it is given a complete topology.
[278.00s -> 281.00s]  The routers learn the topology by exchanging link state information,
[281.00s -> 284.00s]  basically a binary indication of which links are present and working.
[284.00s -> 288.00s]  Once they have the topology, every router sets about calculating its own forwarding table
[288.00s -> 291.00s]  so as to reach every other end host in the network.
[291.00s -> 293.00s]  Dijkstra's algorithm is deceptively simple and fast.
[293.00s -> 298.00s]  As a result, OSPF is very widely used in enterprises and college campuses today.
[301.00s -> 307.00s]  In addition to RIP and OSPF, we started four other aspects of routing.
[307.00s -> 313.00s]  You learned how the Internet uses hierarchical routing to break routing down into more manageable, locally controlled problems.
[313.00s -> 320.00s]  Each autonomous system, or AS, chooses an inter-domain routing algorithm to route packets inside its AS.
[320.00s -> 323.00s]  For example, Stanford uses OSPF on campus.
[323.00s -> 327.00s]  Every AS is required to use BGP, the Border Gateway Protocol,
[327.00s -> 331.00s]  in order to exchange routing information with other ASs in the Internet.
[332.00s -> 338.00s]  BGP is the only sanctioned way to exchange routing information between autonomous systems in the Internet today.
[338.00s -> 343.00s]  Basically, every AS advertises its neighbors to its neighbors.
[343.00s -> 347.00s]  The path packets will reach to every prefix in the Internet.
[347.00s -> 352.00s]  The path is the set of the ASs the packet will pass through along the way.
[352.00s -> 360.00s]  We learned how every BGP router can use a locally defined policy to decide which route advertisement to accept and use to route packets.
[361.00s -> 364.00s]  You also learned briefly about multicast routing.
[364.00s -> 370.00s]  Multicast routing is an optimization added to a network to avoid the source having to send a packet multiple times to a set of destinations.
[370.00s -> 378.00s]  Multicast was all the rage in the 1990s because it was thought that many applications, such as internet TV, would use multicast delivery.
[378.00s -> 386.00s]  Although many multicast routing algorithms were invented and standardized, as you learned in the video, they are not widely used today.
[386.00s -> 390.00s]  This is because most applications and services, such as video streaming,
[390.00s -> 395.00s]  offer us the convenience of streaming us what we want, when we want, with a single unicast connection.
[395.00s -> 402.00s]  Most of the time, there are far too few people watching the same video at the same time for it to be worth supporting the optimization in the network.
[403.00s -> 406.00s]  Finally, we learned about the Spanning Tree Protocol.
[406.00s -> 413.00s]  This isn't actually an internet routing protocol per se, because it is a mechanism used by Ethernet networks to avoid creating routing loops.
[413.00s -> 422.00s]  The Spanning Tree Protocol allows a set of switches to construct a single spanning tree with one switch at the root in order to prevent packets from looping in the network.
