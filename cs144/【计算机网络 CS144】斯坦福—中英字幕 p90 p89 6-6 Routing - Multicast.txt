# Detected language: en (p=1.00)

[0.00s -> 6.26s]  In an earlier video about the basics of routing, I told you about what multicast routing is
[6.26s -> 7.26s]  in principle.
[7.26s -> 10.06s]  In this video, I'm going to be telling you about a number of techniques related
[10.06s -> 13.14s]  to IP multicast.
[13.14s -> 17.48s]  So far, we've assumed that all packets go to a single destination, or that they're
[17.48s -> 18.48s]  unicast.
[18.48s -> 23.86s]  There are some applications where we want packets to be duplicated to a number of hosts,
[23.86s -> 25.18s]  to a set of hosts.
[25.34s -> 34.86s]  For example, A might want to send to B, C and X and E without sending to D.
[34.86s -> 40.02s]  For example, it could be a broadcast TV, where B, C, X and E are all watching the same TV
[40.02s -> 41.02s]  or radio station.
[41.02s -> 45.18s]  It could be a video conference among a number of participants, it could be automatic updates
[45.18s -> 48.22s]  to a large number of hosts, and so on.
[48.22s -> 54.86s]  So while we could easily send packets one at a time to each destination, as I showed,
[54.86s -> 60.70s]  it's natural to ask if the network can or should do the replication for us.
[60.70s -> 71.38s]  So for example, if the network was to duplicate the packets at R1 here, then it can more
[71.38s -> 74.02s]  efficiently deliver to the end hosts.
[74.02s -> 78.74s]  A only sends one packet, yet the packets are delivered correctly to all of the end
[78.74s -> 81.18s]  destinations.
[81.18s -> 84.30s]  So in this video, I'm going to look at a number of techniques for doing this.
[84.74s -> 91.54s]  I'm going to start with the general techniques and principles, and then move on to the practice,
[91.54s -> 94.26s]  what is actually done in the internet.
[94.26s -> 98.78s]  So we already saw one way in which packets could be delivered to a large number of hosts,
[98.78s -> 101.64s]  with a rather simplistic approach of flooding.
[101.64s -> 111.38s]  So in flooding, I've got a source, A, and it's sending through the network to a number
[111.38s -> 115.30s]  of routers, let's say to B down here.
[115.30s -> 122.42s]  I said that if the network is flooding, if we use flooding as an approach to reach B,
[122.42s -> 128.06s]  then packets from A could simply be replicated at each router along the path, by sending
[128.06s -> 132.82s]  out of every interface except the one through which the packet arrived.
[132.82s -> 137.74s]  So packets from A could come down to this first router, go out this way and this way,
[137.74s -> 142.02s]  and then when it gets to this router, it could be sent out this way and this way,
[142.02s -> 148.14s]  and likewise here, and eventually clearly the packet is going to get delivered to B.
[148.14s -> 150.64s]  In fact, it will be delivered to every leaf in the network.
[150.64s -> 158.38s]  The basic problem with flooding is that packets, when there are loops in the topology, packets
[158.38s -> 163.82s]  can loop forever, because when it gets packets coming from this direction, hit this router,
[163.82s -> 166.94s]  this router will say, aha, the packet came in through this interface, I'm going
[166.94s -> 171.34s]  to send out of all of the interfaces except the one through which it came, and then of
[171.34s -> 173.46s]  course it's going to keep looping forever.
[173.46s -> 177.94s]  So we saw in the Spanning Tree protocol how these loops were broken.
[177.94s -> 182.54s]  We're going to look at a different way that they can be avoided in the first place.
[182.54s -> 186.82s]  And that approach is called reverse path broadcast.
[186.82s -> 194.78s]  And this is the basis for the early multicast methods that were used in the internet.
[194.78s -> 198.34s]  The first technique I'm going to be describing is called reverse path broadcast, also known
[198.34s -> 199.70s]  as reverse path forwarding.
[199.70s -> 206.10s]  It's a very clever technique that's widely used and was used in the very first internet
[206.10s -> 207.66s]  multicast routing protocols.
[207.66s -> 213.94s]  And it builds on a very simple observation, and that observation is that before A has
[213.94s -> 220.22s]  even started sending multicast, the network will have already built a unicast, minimum
[220.22s -> 224.54s]  cost Spanning Tree, covering all of the hosts that A can reach.
[224.54s -> 229.10s]  And we saw how that was done in the unicast routing protocols earlier.
[229.10s -> 237.38s]  So for example, R1 already knows what the minimum cost Spanning Tree is for all of
[237.38s -> 242.70s]  the packets going towards A. So there is essentially a minimum cost Spanning Tree in
[242.70s -> 250.86s]  the network that has been built by all of the routers together on how to reach A.
[250.86s -> 259.24s]  So A can use that as a loop-free method in order to deliver packets to everybody else.
[259.24s -> 266.30s]  So first let me describe the broadcast case, which is like flooding but without the
[266.30s -> 269.54s]  loop packets lasting forever.
[269.54s -> 277.80s]  So imagine now that A is sending a packet to everybody else, and that packet is going
[277.80s -> 282.28s]  to have an address in it, and I'll talk about the addresses later, so it's going
[282.28s -> 286.28s]  to have a group address corresponding to who it's sending to, but it'll have the source
[286.28s -> 288.92s]  address A in it.
[288.92s -> 293.82s]  And because this packet came from A, the routers at each hop along the way can ask
[293.82s -> 300.68s]  the question, is the interface over which this packet arrives, so this interface here,
[300.68s -> 305.80s]  is it on the shortest path Spanning Tree from me to A?
[305.80s -> 310.82s]  And you can look that up in its forwarding table to see whether, if it was sending a
[310.82s -> 317.00s]  unicast packet to A, rather than a multicast packet from A, if it was sending a unicast
[317.00s -> 324.12s]  packet to A, is this the interface through which it would depart from this router?
[324.12s -> 329.20s]  So it looks up the source address in its table, and it's going to look that up in
[329.20s -> 333.80s]  its forwarding table, and if this is the interface through which it would send it,
[333.80s -> 339.48s]  if it was sending a unicast, then it will accept it and send it out of every other interface.
[339.48s -> 341.92s]  So it will send it out of every other interface.
[341.92s -> 346.34s]  Likewise, when it gets to R2, R2 will ask the same question.
[346.34s -> 350.64s]  If it was sending a unicast packet to A, is this the interface through which it
[350.64s -> 351.64s]  would send it?
[351.64s -> 355.84s]  The answer is yes, so therefore it will send it out of every other interface.
[355.84s -> 359.40s]  So it's a little bit like flooding, but it's asking a more detailed question.
[359.40s -> 363.84s]  Is this the interface through which I would send it, if it was a unicast packet going
[363.84s -> 366.80s]  to A?
[366.80s -> 373.08s]  So you can see here that R3 would also ask the same question, and it would say yes,
[373.08s -> 377.56s]  this is the interface through which I would send it to A, so therefore I am going to
[377.56s -> 379.52s]  send it out of all of the other ports.
[379.52s -> 384.88s]  However, when this packet reaches R2, it will come through this interface, which is
[384.88s -> 389.00s]  not on the green shortest path tree, back to A.
[389.12s -> 391.60s]  So therefore R2 will drop that packet.
[391.60s -> 392.92s]  It won't send it.
[392.92s -> 395.78s]  And you can see that it's just broken the loop.
[395.78s -> 397.68s]  Same thing will happen over here at R8.
[397.68s -> 401.48s]  This is not on the green shortest path tree, so that packet will be dropped.
[401.48s -> 406.06s]  And you can convince yourself that there, in fact, will be no loops, because packets
[406.06s -> 410.20s]  will follow that spanning tree that has already been built.
[410.20s -> 415.00s]  This is a clever idea, and you can see why it's called reverse path broadcast,
[415.00s -> 420.12s]  because it's using the spanning tree that is in the opposite direction.
[420.12s -> 425.52s]  Now this is all very well as a means for broadcast, but we're talking about multicast.
[425.52s -> 432.00s]  In this particular case, the packet would have been delivered to all of the end hosts,
[432.00s -> 435.72s]  whereas in fact, we wanted it to be delivered to every end host except D.
[435.72s -> 439.84s]  That was the set of hosts that we were trying to deliver to.
[439.84s -> 446.76s]  So as a simple extension to this, there is something that's called pruning, and it's usually
[446.76s -> 454.12s]  referred to as reverse path broadcast plus pruning, or RPB plus pruning, in which those
[454.12s -> 460.08s]  routers that don't have any connected hosts interested in receiving the packet, so in
[460.08s -> 468.00s]  our case D is not part of the multicast group, so R6 would send what's called a prune message,
[468.00s -> 472.92s]  which I'll just show as a dotted line, so it will send prune, and say, hey, I actually
[472.92s -> 478.16s]  don't have any end hosts interested in receiving this, please don't send me multicast
[478.16s -> 482.00s]  packets for this group address anymore.
[482.00s -> 489.08s]  And so it will prune G and say, I have no interest in this.
[489.08s -> 496.00s]  So in this case, this would then be removed from the reverse path broadcast tree, and
[496.00s -> 499.88s]  now that tree will only reach the end hosts that are interested in it.
[499.88s -> 503.68s]  So it's a way of decreasing the inefficiency of broadcast.
[503.68s -> 511.08s]  However, it clearly has the inefficiency still that to start with, every router will
[511.08s -> 513.16s]  hear about it before it starts pruning.
[513.16s -> 519.12s]  So in a very, very large network, this is probably impractical.
[519.12s -> 525.10s]  So in summary, reverse path broadcast plus pruning, packets are delivered loop-free to
[525.10s -> 527.06s]  every end host.
[527.06s -> 533.50s]  Routers with no interested hosts attached to them will send prune messages back towards
[533.50s -> 534.66s]  the source.
[534.66s -> 538.90s]  And of course they can use the unicast address of the source in order to send that prune
[538.90s -> 542.98s]  message so that it will follow the tree back towards the source.
[542.98s -> 547.86s]  The resulting tree is the minimum cost spanning tree from the source to the set of interested
[547.86s -> 548.86s]  hosts.
[548.86s -> 552.98s]  So it's an efficient way, an efficient tree that we end up with, although the method
[552.98s -> 556.34s]  to get there is a little inefficient, because we have to start by communicating to all
[556.34s -> 560.72s]  of the routers in the network.
[560.72s -> 567.02s]  One question that you may be wondering is, do we build one tree, or do we build several
[567.02s -> 568.14s]  trees?
[568.14s -> 577.08s]  In my example, I showed A wanting to send to this set of destinations B, C, X and E.
[577.08s -> 583.36s]  But what if it's a video conference, and after A has spoken and sent packets to everybody
[583.36s -> 586.44s]  else, what if it's B's turn to send?
[586.44s -> 592.02s]  What is the tree, the multicast tree, that packets from B should follow?
[592.02s -> 597.36s]  So going from B back to A again, they would follow the same way, B to C and B
[597.36s -> 598.86s]  to X.
[598.86s -> 603.30s]  But going from B to E, it would seem more likely that the packets will flow this way.
[603.30s -> 607.78s]  In other words, the tree is specific to a source.
[607.78s -> 611.74s]  The shortest path tree is specific to a source, and that should be clear from my previous
[611.74s -> 617.02s]  example of the reverse path broadcast, in which the packets are going to follow the
[617.02s -> 620.22s]  shortest path spanning tree in the opposite direction.
[620.22s -> 624.96s]  And so given that there will be a shortest path spanning tree from every source and
[624.96s -> 630.80s]  to every destination, it's not surprising that the packets will take a different path.
[630.80s -> 635.82s]  So ideally we would build a separate tree for every sender, a source-specific tree,
[635.82s -> 640.62s]  so that all packets follow the shortest path spanning tree to the end hosts.
[640.62s -> 646.68s]  But in communications where the multicast group of end hosts is very small, it might
[646.68s -> 652.00s]  be easier, instead of building a whole load of trees, one for every source, to establish
[652.00s -> 654.64s]  some rendezvous points.
[654.64s -> 656.98s]  And we'll see an example of this later.
[656.98s -> 664.38s]  So for example, we might elect R5 as a rendezvous, through which all of the multicast packets
[664.38s -> 665.38s]  are going to go.
[665.38s -> 670.72s]  So when everyone's sending a multicast, they could send them to R5, and then R5
[670.72s -> 674.92s]  would build a shortest path spanning tree to everybody else within the group.
[674.92s -> 679.72s]  Now there's one shortest path spanning tree from R5, the rendezvous point to everybody,
[679.72s -> 687.60s]  and that everybody uses the normal unicast routing method in order to reach R5.
[687.60s -> 692.08s]  So there's really a design choice in practice as to whether we maintain one tree, or one
[692.08s -> 695.72s]  for every source.
[695.72s -> 698.76s]  So I've told you a little bit about some of the techniques and principles, and I'm
[698.76s -> 703.28s]  going to tell you a little bit about the practice how multicast is used in the Internet
[703.28s -> 705.28s]  today.
[705.28s -> 708.32s]  So one thing I haven't mentioned so far is about addresses.
[708.32s -> 714.00s]  There is a class of IPv4 addresses that are different from the unicast addresses.
[714.00s -> 718.28s]  They're a set of class T. There are 16 bits, so there are 2 to the 16 different multicast
[718.28s -> 724.18s]  addresses, and they don't correspond to a particular location on the topology, like
[724.18s -> 725.92s]  a unicast address does.
[725.92s -> 727.76s]  They refer to a group.
[727.76s -> 734.00s]  So every recipient of packets within a group will receive packets with that same multicast
[734.00s -> 735.00s]  address.
[735.00s -> 737.72s]  So it's a little bit like an indirection.
[737.72s -> 742.36s]  The router will look up on the label, and in fact routers typically maintain an entry
[742.36s -> 748.16s]  for each tuple of multicast address and source pair, so that they can route packets on the
[748.16s -> 753.04s]  source-specific tree.
[753.04s -> 757.42s]  We also need a way for hosts to indicate their interest in joining a group.
[757.42s -> 761.32s]  One of the interesting things about multicast is that generally the source does not need
[761.32s -> 764.24s]  to know who the packets are being delivered to.
[764.24s -> 765.24s]  It's the network.
[765.24s -> 767.28s]  It's the tree that figures that out.
[767.28s -> 771.48s]  So each of the leaves of the tree, each of the hosts, needs to indicate an interest
[771.48s -> 776.48s]  in receiving packets, and it does this by using IGMP, the Internet Group Management
[776.48s -> 780.44s]  Protocol, RFC 3376.
[780.44s -> 785.16s]  So this is a protocol that runs between the host, between an end host, and its directly
[785.16s -> 787.80s]  attached router.
[787.80s -> 793.36s]  The hosts periodically will ask to receive packets belonging to a particular multicast
[793.36s -> 794.36s]  group.
[794.56s -> 800.24s]  The routers will probe, or will send out a request to all of the hosts connected to
[800.24s -> 804.44s]  them and say, what multicast groups are you interested in?
[804.44s -> 811.52s]  And then the host will respond and will say which groups they want to receive from.
[811.52s -> 815.36s]  And if they don't receive any reply after a while, then the membership times out.
[815.36s -> 818.84s]  In other words, it says, I will no longer deliver packets belonging to this multicast
[818.84s -> 820.48s]  group if no one is interested in it.
[820.48s -> 823.80s]  This is an example of what's called soft state.
[823.80s -> 830.32s]  The state is only maintained, it isn't explicitly removed, it will just time out if no one actually
[830.32s -> 834.28s]  renews their interest in receiving it.
[834.28s -> 837.84s]  So let me tell you about multicast routing in the Internet very briefly.
[837.84s -> 843.36s]  The very first multicast routing protocol was called DVMRP, the Distance Vector Multicast
[843.36s -> 847.28s]  Routing Protocol, described in RFC 1075.
[847.28s -> 853.16s]  It was first introduced in the 1980s, and it basically used the Reverse Path Broadcast
[853.16s -> 854.28s]  plus prune.
[854.28s -> 858.04s]  So it was based on this observation, hence the distance vector name at the beginning.
[858.04s -> 862.36s]  It's based on the observation that the unicast routing protocol has already built the tree
[862.36s -> 865.12s]  for us, we're just going to use it in the reverse direction.
[865.12s -> 871.16s]  An alternative is called Protocol Independent Multicast, or PIM.
[871.16s -> 876.28s]  This recognizes two different modes of multicast, one called Dense Mode, in which all of
[876.28s -> 881.24s]  the routers, or a very large number of the routers, are expected to be involved in multicast.
[881.24s -> 886.48s]  In which case, RPP plus prune is fine, because most of the routers will be involved
[886.48s -> 888.56s]  and very few of them will need to prune.
[888.56s -> 896.00s]  So that uses DVMRP, or something very similar to DVMRP, and is described in RFC 3973.
[896.00s -> 903.04s]  An alternative way is called Sparse Mode PIM, in which a relatively small number
[903.04s -> 907.40s]  of the routers are expected to be involved in the multicast, and therefore it will be
[907.40s -> 911.92s]  very inefficient to do the RPP plus prune, because there would be way too many prune
[911.92s -> 914.20s]  messages in the network.
[914.20s -> 919.68s]  And in this case, it explicitly builds rendezvous points through which the packets
[919.68s -> 924.48s]  that are sent will join a small set of spanning trees from the rendezvous points
[924.48s -> 928.28s]  to all of the destinations of a group.
[928.28s -> 932.84s]  And so a lot of work went into how you pick these rendezvous points.
[932.84s -> 936.64s]  It's a fairly subtle problem in its own right.
[936.64s -> 946.96s]  So DVMRP and PIM, so really overall there are three widely used protocols described in
[946.96s -> 950.72s]  the three RFCs mentioned here.
[950.72s -> 955.60s]  In practice multicast is used a little less than was originally expected.
[955.60s -> 960.58s]  It was originally anticipated that it would be used for a very large amount of communication
[960.58s -> 964.76s]  in the Internet, because at the time that multicast was first conceived, it was still
[964.76s -> 970.04s]  the case that the majority of communications in the world were for TV and radio that
[970.04s -> 971.96s]  were broadcast medium.
[971.96s -> 976.32s]  And so it was anticipated that this would be a very common type of communication.
[976.32s -> 980.04s]  And in fact, in practice, this has turned out to be less true than was originally
[980.04s -> 981.04s]  thought.
[981.04s -> 985.28s]  And it seems that over the last 20 or so years, communication has become much more
[985.28s -> 986.28s]  individualized.
[986.28s -> 991.32s]  We tend to ask for content that we specifically want to watch at a specific time.
[991.32s -> 996.68s]  There's less interest in broadcast than there used to be, except for events like sporting
[996.68s -> 1004.28s]  events, big political rallies, or a rocket launching or something like that.
[1004.28s -> 1011.28s]  So this individualized time shifting that's commonplace today has really reduced the
[1011.28s -> 1014.48s]  demand for multicast in the network.
[1014.48s -> 1019.40s]  Also, some of the earlier implementations were pretty inefficient, like DVMRP, and were found
[1019.40s -> 1021.04s]  to have scaling problems.
[1021.04s -> 1025.90s]  And so it reduced some of the interest or the enthusiasm that people had for introducing
[1025.90s -> 1026.90s]  multicast.
[1026.90s -> 1033.04s]  Today, it is used for some broadcast IPTV dissemination.
[1033.04s -> 1039.12s]  And some applications do sort of an application layer specific multicast, not using the network
[1039.12s -> 1045.40s]  infrastructure, but building their own overlay tree for themselves.
[1045.40s -> 1049.32s]  Multicast also raises some interesting questions.
[1049.32s -> 1054.24s]  And they're really to do with the state that one would have to maintain in order to
[1054.24s -> 1059.66s]  maintain reliable TCP-like communications with an end host.
[1059.66s -> 1063.28s]  So for example, imagine that a source is sending to hundreds or thousands or hundreds
[1063.28s -> 1065.76s]  of thousands of destinations in a group.
[1065.76s -> 1073.14s]  If it wanted that communication to be reliable, in which it was keeping track of which packets
[1073.14s -> 1078.02s]  had been reliably received at which destinations, this would be a horrendous task for a single
[1078.02s -> 1079.50s]  source to manage.
[1079.50s -> 1084.50s]  In fact, anything that requires state like flow control or supporting different rates
[1084.50s -> 1088.78s]  to different end users, it's not clear how to do that either, or how to make it
[1088.78s -> 1090.22s]  secure.
[1090.22s -> 1092.70s]  All of these are quite big problems.
[1092.70s -> 1095.78s]  There's been lots of interest from a research point of view.
[1095.78s -> 1099.34s]  But generally speaking, there aren't considered to be good solutions to these.
[1099.34s -> 1104.94s]  So generally multicast is used for delivering data that is primarily in one direction.
[1104.94s -> 1110.26s]  For example, like TV in which that data is being moved from a source without modification
[1110.26s -> 1113.74s]  to a set of end hosts.
[1113.74s -> 1115.50s]  And that's the end of the video on multicast.
