# Detected language: en (p=1.00)

[0.00s -> 4.04s]  So in this video, I'm going to dig into the details of TCP connection setup and
[4.04s -> 6.08s]  tear down. This is a deeper look than sort of the
[6.08s -> 10.04s]  initial service model we presented, looking at a couple of edge cases and
[10.04s -> 13.04s]  the entire TCP state diagram. We're going to look at through a
[13.04s -> 16.08s]  handshake, something called simultaneous open, which turns out to be really
[16.08s -> 20.04s]  important today in peer to peer applications, and actually show the full
[20.04s -> 23.04s]  TCP state machine for connection setup and tear down.
[23.04s -> 26.04s]  So the high level problem here is if we want to communicate reliably, it turns
[26.04s -> 29.04s]  out it's very helpful to have state on one or both ends of the connection.
[29.04s -> 33.04s]  You can in fact turn, turns out you can communicate reliably with having something
[33.04s -> 36.04s]  stateless on one end or the other, but it's much less efficient.
[36.04s -> 40.04s]  Having a little bit of state is great. It'll make you have much better
[40.04s -> 44.04s]  throughput, etc. But if we have this state, there's
[44.04s -> 46.04s]  this problem of how do we set up that state?
[46.04s -> 48.04s]  What is it? So connection establishment.
[48.04s -> 53.04s]  But then also, given the state's going to stick, take up RAM in your machine,
[53.04s -> 57.04s]  when can you tear it down? When is, can you sort of garbage collect
[57.04s -> 60.04s]  this state and reuse it? So examples of this, the memory structure
[60.04s -> 63.04s]  is using for your TCP connection, the buffers, or also the port numbers that
[63.04s -> 66.04s]  you've used. So there are these problems of
[66.04s -> 71.04s]  connection establishment and tear down. So here's the standard TCP header with
[71.04s -> 75.04s]  its standard 20 byte payload, and then options.
[78.04s -> 82.04s]  So for connection setup, as we've seen before, there are four parts of the
[82.04s -> 85.04s]  header that are used. The sequence number, the acknowledgement
[85.04s -> 89.04s]  number, the ACK bit, and the SYN bit. So here, I'm going to walk through the
[89.04s -> 93.04s]  three-way handshake in a little bit more detail as to what happens in the packets
[93.04s -> 96.04s]  that are exchanged. So recall, in the standard three-way
[96.04s -> 99.04s]  handshake model, we have an active opener and a passive opener.
[99.04s -> 103.04s]  The passive opener is sitting, listening, waiting for connection requests, such
[103.04s -> 106.04s]  as, say, a web server. The active opener is the one who
[106.04s -> 109.04s]  initiates the request to start the connection.
[110.04s -> 115.04s]  So in the first step, the active opener sends a TCP segment with the SYN bit set
[115.04s -> 120.04s]  to indicate that it's synchronizing the passive side to the beginning of its
[120.04s -> 124.04s]  stream. It's saying, what is the first
[124.04s -> 127.04s]  sequence number of my stream? So let's call it S sub A.
[129.04s -> 133.04s]  So you do this rather than just say, assume zero for a bunch of reasons.
[133.04s -> 137.04s]  Number one, it's very helpful to randomize your starting sequence number
[137.04s -> 140.04s]  for security reasons. It means that people can't guess where
[140.04s -> 143.04s]  your stream starts and try to insert data on you.
[143.04s -> 147.04s]  Also, it's useful if there happen to be old packets flying around the Internet,
[147.04s -> 149.04s]  which sometimes happens. You could have tremendous delay
[149.04s -> 151.04s]  somewhere. If you randomize your starting
[151.04s -> 155.04s]  sequence number, then it becomes very unlikely that some random segment, or
[155.04s -> 161.04s]  perhaps a corrupted segment, is going to overlap your own sequence window.
[161.04s -> 165.04s]  So the active side sends a SYN saying, this is my starting sequence number, S
[165.04s -> 170.04s]  sub A. The passive side responds, also with a
[170.04s -> 174.04s]  SYN, saying, okay, that's, I'm going to synchronize you.
[174.04s -> 178.04s]  My starting sequence number is, let's say, S sub P for passive.
[178.04s -> 182.04s]  But I'm also going to set the ACK bit, which means that the acknowledgement
[182.04s -> 184.04s]  sequence number in the packet is valid.
[184.04s -> 190.04s]  And I'm going to ACK SA plus one. Recall that a node acknowledges not the
[190.04s -> 194.04s]  last byte received, but rather the first byte that hasn't been received.
[194.04s -> 199.04s]  So by sending ACK SA plus one, the passive side has acknowledged that it
[199.04s -> 203.04s]  received the SYN, which is effectively byte S sub A.
[203.04s -> 208.04s]  The active side then responds. It doesn't need to send a SYN, because
[208.04s -> 212.04s]  it's synchronized. So it sends a packet with sequence
[212.04s -> 216.04s]  number SP plus one, that's commonly the, what's used.
[216.04s -> 223.04s]  And ACK, S, I'm sorry, sends a packet with SA plus one, which is
[223.04s -> 229.04s]  connected with SA plus one, and ACK SP plus one.
[229.04s -> 233.04s]  And so now, it's acknowledging, saying, I have received your SYN, and I'm
[233.04s -> 236.04s]  acknowledging that. Now, this initial packet, the
[236.04s -> 240.04s]  sequence number is SA plus one, but it tends to be of zero length.
[240.04s -> 244.04s]  So if there were a byte in the packet, it would be SA plus one.
[244.04s -> 247.04s]  But it's not, and so it's of length zero.
[247.04s -> 251.04s]  This is just a simple control packet. And so, there's the sequence number of
[251.04s -> 254.04s]  which the bytes would start, but there are no bytes.
[254.04s -> 259.04s]  So that's the basic connection setup. SYN, SYN ACK, ACK, A, A plus one, P, P
[259.04s -> 264.04s]  plus one, and then an empty segment just for connection establishment.
[264.04s -> 268.04s]  So it turns out TCP also supports another way of opening a connection,
[268.04s -> 272.04s]  something that's called simultaneous open, which as I said, is used a lot,
[272.04s -> 276.04s]  as we'll see later in the course, in peer-to-peer applications, to
[276.04s -> 279.04s]  reverse things called network address translation boxes.
[279.04s -> 283.04s]  And so, the way simultaneous open works, is this happens if both the active, if
[283.04s -> 287.04s]  the two sides, we call them active and passive, but now they're really both
[287.04s -> 290.04s]  active, both know each other's port numbers.
[290.04s -> 294.04s]  So, the node on the left knows that the port that the node on the right is
[294.04s -> 298.04s]  issuing a connection request from, the node on the right knows the same for the
[298.04s -> 301.04s]  node on the left, and so they're using the correct port numbers.
[301.04s -> 304.04s]  And they do this, they negotiate the SA beforehand.
[304.04s -> 310.04s]  So, what happens with simultaneous open, is both sides send SYNs at the same time.
[310.04s -> 314.04s]  And so here, the one on the left sends a SYN.
[314.04s -> 320.04s]  Let's call it just SA again, SA. But at the same time, the node on the
[320.04s -> 327.04s]  right sends a SYN, S sub P. Well, the node on the left responds,
[327.04s -> 339.04s]  and it sends SYN, S sub A, ACK, S sub P plus one.
[339.04s -> 350.04s]  Similarly, the node on the right responds with SYN, S sub P, ACK, S sub A, plus one.
[350.04s -> 352.04s]  At this point, we've now established the connection.
[352.04s -> 354.04s]  Both sides are synchronized. Note the starting sequence numbers.
[354.04s -> 357.04s]  They've acknowledged that. But note that this takes four messages
[357.04s -> 360.04s]  rather than three. So, let's see this just a standard
[360.04s -> 364.04s]  three-way handshake in practice. So, here I've opened up Wireshark
[364.04s -> 367.04s]  filtering on port 80 and a certain IP address.
[367.04s -> 372.04s]  And so, I'm just going to telnet to port 80 on that host, and we'll see the
[372.04s -> 375.04s]  SYN, SYN ACK, ACK setup. And so, there it is.
[375.04s -> 379.04s]  So, here's the first packet sent from my host to the destination.
[379.04s -> 384.04s]  And we see that it's an HTP, port 80, SYN, sequence number zero, and there's no ACK
[384.04s -> 386.04s]  sent. There's no ACK bit, and so the
[386.04s -> 389.04s]  acknowledgement field is invalid, so it's not displayed.
[389.04s -> 393.04s]  Now, it turns out the sequence number in this packet isn't actually zero.
[393.04s -> 397.04s]  What tools like Wireshark do just to make things easier to read is they use
[397.04s -> 400.04s]  relative sequence numbers. They show you what the sequence
[400.04s -> 403.04s]  number is relative to the beginning of the stream.
[403.04s -> 406.04s]  And since we're just starting the scene, we see sequence number zero.
[406.04s -> 411.04s]  If we dig inside the packet down here at the bottom, you can see Wireshark tells
[411.04s -> 414.04s]  you sequence number zero, relative sequence number.
[414.04s -> 418.04s]  And if we then look at the actual field, it's CCBD1DBB.
[418.04s -> 424.04s]  And so, it's much larger than zero. Now, what we then see is for the
[424.04s -> 432.04s]  second packet that's acknowledging this, it's going to acknowledge with CCBD1DBC.
[432.04s -> 435.04s]  Here, again, it's using relative ACK numbers, but that's what we see.
[435.04s -> 440.04s]  CCBD1DBC. It's also sending a, a SIN.
[440.04s -> 444.04s]  So, here's the SIN ACK. And so, the sequence number, again, a
[444.04s -> 449.04s]  relative sequence number of zero, but it's 341135AE.
[449.04s -> 452.04s]  So, this is from my host to the server.
[452.04s -> 456.04s]  This is the server back of the SIN ACK. Then, my host responds with an ACK.
[456.04s -> 460.04s]  And so, you can see sequence number one, acknowledgement number one.
[460.04s -> 463.04s]  So, it's acknowledging the SIN that was sent from the server.
[463.04s -> 466.04s]  And it gives us sequence number one, but it's a length of zero.
[466.04s -> 470.04s]  And so, it's saying, aha, you know, I, this packet contains the stream starting
[470.04s -> 473.04s]  at byte one, but there's nothing in it, so there's actually no data yet.
[473.04s -> 475.04s]  So, there we see a simple three-way handshake.
[475.04s -> 478.04s]  So, now let's look at a TCP connection when there is data.
[478.04s -> 482.04s]  So, we're going to see the SIN, SIN ACK, and then some data communication.
[482.04s -> 485.04s]  So, I'm going to do the same thing as before, except this time, rather than
[485.04s -> 489.04s]  telnetting to port 80, where there's no data transferred, I'm just going to
[489.04s -> 500.04s]  do a standard web request to port 80. And so, here we see a TCP connection.
[500.04s -> 505.04s]  And so, here we have the SIN, SIN ACK, ACK, so now the connection's been
[505.04s -> 508.04s]  established, and then data transmission starts.
[508.04s -> 511.04s]  And so, here's a packet showing it's HTTP.
[511.04s -> 517.04s]  And if you look inside, this particular TCP segment sees sequence number one.
[517.04s -> 521.04s]  So, it's the start of the data stream, length 474.
[521.04s -> 525.04s]  So, this particular chunk of data was 474 bytes long.
[525.04s -> 529.04s]  So, the next sequence number would be 475, still ACK one.
[529.04s -> 533.04s]  And so, there's the data that we're sending as this request to the web
[533.04s -> 538.04s]  server, then the web server responds, and it responds with ACK 475.
[538.04s -> 544.04s]  All right, so the next byte it expects is 475, but sequence number one.
[544.04s -> 548.04s]  So, this is just length zero. This ACK, it has no data in it.
[548.04s -> 552.04s]  This is what we call, sort of, just an ACK packet, right?
[552.04s -> 556.04s]  And so, it has no TCP segment data, but is acknowledging the data that it's
[556.04s -> 560.04s]  received. The next packet, though, from the server
[560.04s -> 564.04s]  actually has data in it. So, we can see here, length 1448, but
[564.04s -> 570.04s]  sequence number one. So, it's one to 1449.
[570.04s -> 574.04s]  And here's the next TCP segment. And then we see here, putting that
[574.04s -> 578.04s]  together, there's the HTTP response, which it's put together.
[578.04s -> 581.04s]  And so, there we see the connection establishment, and now the sequence and
[581.04s -> 584.04s]  acknowledgement number spaces are walking forward according to the data
[584.04s -> 587.04s]  communication. So, next we're going to look at how
[587.04s -> 591.04s]  TCP tears down a connection. Like connection setup, this uses the
[591.04s -> 594.04s]  sequence number and acknowledgement number fields.
[594.04s -> 597.04s]  But unlike connection setup, which uses the synchronization bit to
[597.04s -> 601.04s]  synchronize sequence numbers, connection tear down uses the fin bit to denote
[601.04s -> 604.04s]  that there's no more data to send. So, it uses the ACK and fin bits.
[604.04s -> 608.04s]  And so, when TCP sends a packet with a fin bit, what this means is that that
[608.04s -> 612.04s]  sender has no more data to send. This is the end of the stream.
[612.04s -> 617.04s]  This is caused when you say call close or shut down in the application.
[617.04s -> 621.04s]  But TCP connections, like most reliable connections, are bidirectional.
[621.04s -> 625.04s]  And so, it's not until both sides have nothing to send that you actually
[625.04s -> 628.04s]  terminate the connection. Because it's going to be one side is done,
[628.04s -> 632.04s]  but the other side has more to send. And so, it's not until both sides have,
[632.04s -> 635.04s]  have finned and you've acknowledged those that you can tear things down.
[635.04s -> 640.04s]  So, a typical tear down exchange looks like this, where we say if A and B who
[640.04s -> 645.04s]  are communicating, and A closes first. And so, it sends a packet with the fin
[645.04s -> 649.04s]  bit, with sequence number S sub A, and acknowledging S sub B.
[649.04s -> 652.04s]  B then sends a packet to acknowledge this fin.
[652.04s -> 657.04s]  So, acts S sub A plus one. Then at some point later, B decides it
[657.04s -> 661.04s]  needs to close its side of the connection. So, it sends a fin, sequence
[661.04s -> 666.04s]  number S sub B, acknowledgement S sub one, and still acknowledging S A plus one.
[666.04s -> 669.04s]  Which then A responds saying, ah, I'll acknowledge S B plus one.
[669.04s -> 673.04s]  So, fin, like sin, represents of the last byte of the connection.
[673.04s -> 677.04s]  The way that you, like sin represents the first byte, the way you acknowledge
[677.04s -> 681.04s]  it is by acknowledging plus one. With fin, you acknowledge that you
[681.04s -> 685.04s]  accept it by acknowledging plus one. Of course, you don't, you can also have
[685.04s -> 689.04s]  simultaneous close where they send the fins in parallel and the same exchange
[689.04s -> 692.04s]  occurs. Great, so now we've exchanged these
[692.04s -> 696.04s]  messages and we've acknowledged them. When can we actually tear down the
[696.04s -> 699.04s]  connection? When can we actually delete the state?
[699.04s -> 702.04s]  When can we reuse the ports? It turns out to be non-trivial.
[702.04s -> 706.04s]  You can't do it immediately. So, for example, what happens if this
[706.04s -> 710.04s]  final act is lost in the network? So, I've sent fin, then I receive
[710.04s -> 714.04s]  a fin, and I act it. I can't immediately tear down my
[714.04s -> 717.04s]  connection, because what happens if that act is lost?
[717.04s -> 721.04s]  The other side's never gonna hear it. It's never gonna know whether the
[721.04s -> 725.04s]  connection was torn down. Another issue is it could be that we
[725.04s -> 729.04s]  do a fin, fin act, and acknowledge and tear down, and then the same port
[729.04s -> 733.04s]  pair, the same port pair is used immediately for a new connection.
[733.04s -> 737.04s]  We wanna make sure that we don't by accident then corrupt the data because
[737.04s -> 741.04s]  the sequence number of spaces overlap. So, the solution that's used is the
[741.04s -> 744.04s]  active closer goes into something called time wait.
[744.04s -> 748.04s]  And what this means is that if I'm the person who sends the fin first, then
[748.04s -> 752.04s]  once the connection is torn down, I have to wait a little while before I
[752.04s -> 756.04s]  can reuse my state. And so, you keep the socket around for
[756.04s -> 760.04s]  two, what's sort of maximum segment lifetimes, or two times, or what you'd
[760.04s -> 764.04s]  expect to be the longest time segments might live in the network, which is
[764.04s -> 769.04s]  the number of say, a minute or so. So, this approach of two maximum
[769.04s -> 772.04s]  segment lifetimes can pose problems with servers.
[772.04s -> 776.04s]  In particular, if I have a server and it has tons and tons of sockets which
[776.04s -> 780.04s]  are in this time wait state, this can slow things down if the server was the
[780.04s -> 783.04s]  one closing first. So, there are tricks.
[783.04s -> 786.04s]  You can send a reset and delete the socket.
[786.04s -> 790.04s]  You can set an option to make the, the linger time to be zero.
[790.04s -> 794.04s]  Another issue is the US might not let you reuse a port because it's still in use.
[794.04s -> 798.04s]  There is an option you can do called SO reuse outer that'll let you rebind a port
[798.04s -> 800.04s]  number. This is useful if, say, you're just
[800.04s -> 804.04s]  debugging something and, gosh, I don't want to wait two hours just because I
[804.04s -> 807.04s]  happen to have finned in this, in this order.
[807.04s -> 810.04s]  So, let's see what a connection teardown looks like.
[810.04s -> 814.04s]  So, here's a basic connection setup, sin, sin ack, ack, and then here's the
[814.04s -> 817.04s]  teardown. So, because we are, avoid our exchanging
[817.04s -> 821.04s]  data, we have the acknowledgement bit set. So, here's the fin.
[821.04s -> 825.04s]  Here's the initial fin from my host when I close the connection.
[825.04s -> 829.04s]  And so, it sets the fin bit, ack one, sequence number one, ack one.
[829.04s -> 833.04s]  Then, the server in response is also closing.
[833.04s -> 837.04s]  So, it sends a fin, sequence number one, ack two.
[837.04s -> 841.04s]  So, it's acknowledging my fin. And then, my host responds with an ack
[841.04s -> 844.04s]  for that fin, sequence number two, ack two.
[844.04s -> 848.04s]  So, here's a simple three-way handshake for tearing down the connection fin,
[848.04s -> 853.04s]  acknowledging some prior data, acknowledging the fin, sending your own
[853.04s -> 857.04s]  fin, and then acknowledging the fin. So now, if we put all of this
[857.04s -> 861.04s]  together, we could see what the full TCP finite state machine looks like.
[861.04s -> 864.04s]  And so, this is something you're going to come across many, many times.
[864.04s -> 867.04s]  This is well-established finite state machine that really sort of lays the
[867.04s -> 870.04s]  ground for how you want to set up reliable connections.
[870.04s -> 873.04s]  And so, I'm going to walk through it. It looks pretty complicated when you
[873.04s -> 876.04s]  first see it, but it's because there are a couple of cases.
[876.04s -> 880.04s]  And actually, given what we've presented before, it should all be pretty simple.
[880.04s -> 882.04s]  So first, we're starting in the close state.
[882.04s -> 884.04s]  So, this is when there are no connections open.
[884.04s -> 888.04s]  You know, I'm just sitting there. I, my application's not trying to open
[888.04s -> 893.04s]  a connection. So then, the first transition here to
[893.04s -> 896.04s]  the listen state, this is the passive openers.
[896.04s -> 899.04s]  This is a server. A server's listening for connections.
[899.04s -> 903.04s]  So you can see, the action is listen, and there's no packets exchanged.
[903.04s -> 906.04s]  If you close it, you then return to the close state.
[906.04s -> 909.04s]  So this, if I'm listening for connections, I hear nothing, I return to
[909.04s -> 912.04s]  the close state. The other transition out of the close
[912.04s -> 915.04s]  state is the active open. So here's the connect.
[915.04s -> 918.04s]  And connect causes a sin packet to be sent.
[918.04s -> 921.04s]  So this is step one of the three-way handshake.
[921.04s -> 925.04s]  So you send a sin, and you're now in the sin send state, sin sent state.
[925.04s -> 928.04s]  So this is the active side. These red lines are showing the
[928.04s -> 931.04s]  active opener of the three-way connection.
[931.04s -> 935.04s]  So sin sent. Then, if you receive a sin in ACK, so
[935.04s -> 940.04s]  this is the stage two, you send an ACK, and now the connection's established.
[940.04s -> 944.04s]  So this path here, this is the active opener.
[944.04s -> 948.04s]  Now let's watch the passive opener. So the passive opener's in the listen
[948.04s -> 951.04s]  state, and it receives a sin from an active opener.
[951.04s -> 955.04s]  In response, it sends a sin ACK, and it enters the sin receive state.
[955.04s -> 959.04s]  Then, if it receives an acknowledgement for its sin, there's a stage three of
[959.04s -> 962.04s]  the three-way handshake. It's the reflection of this step here.
[962.04s -> 967.04s]  Then the connection's been established. Now, if you're in the listen state,
[967.04s -> 972.04s]  it's possible that you can also call send, which would then result in sending
[972.04s -> 975.04s]  a sin message. Or you can also, in that way, you're
[975.04s -> 979.04s]  then going to, even though you're in the listen state, you can actively open
[979.04s -> 984.04s]  an active and open state. So now, there's one more path here,
[984.04s -> 990.04s]  which I mentioned, the four-way simultaneous open, which is this.
[993.04s -> 996.04s]  And so this is when both sides have sent sin.
[996.04s -> 1000.04s]  So we're just looking at one side of the connection, and in response to a sin,
[1000.04s -> 1004.04s]  you get a sin from the other side. And so this is the two sins crossing.
[1004.04s -> 1008.04s]  So in response, you send sin plus ACK, sin received, then you ACK.
[1008.04s -> 1012.04s]  And so there's the four messages. Each has sent a sin, each has received
[1012.04s -> 1017.04s]  a sin, and then received a sin, they send a sin ACK, and there's an ACK,
[1017.04s -> 1021.04s]  and data exchange can occur. And so now we're in the established state.
[1021.04s -> 1025.04s]  Now, of course, you can always transition out, like closes and resets.
[1025.04s -> 1028.04s]  But so now at this point, we've gone through connection establishment.
[1037.04s -> 1039.04s]  Now we're going to go into connection tear down.
[1043.04s -> 1048.04s]  And so there are two cases here. One is that if we're the active closer,
[1048.04s -> 1052.04s]  here, we call close. That results in a fin message being
[1052.04s -> 1054.04s]  sent. A fin, packed with a fin bit.
[1054.04s -> 1058.04s]  We now enter fin weight one. The other is if we receive a fin,
[1058.04s -> 1062.04s]  then we acknowledge it. And we're now in the passive close
[1062.04s -> 1066.04s]  state where the other side is closed. And then we call, when we actually
[1066.04s -> 1069.04s]  call close, we'll send fin, send a less ACK, and be closed.
[1069.04s -> 1073.04s]  And so here at close weight is we are still allowed to send data, right, until
[1073.04s -> 1076.04s]  we call close. This is the other side is closed,
[1076.04s -> 1079.04s]  but we haven't. So now, when close is called, we're
[1079.04s -> 1082.04s]  in the fin one state. And there are a bunch of transitions
[1082.04s -> 1084.04s]  out of that. One is that we receive a fin.
[1084.04s -> 1088.04s]  So we've sent a fin, received a fin. So this is the example I showed with
[1088.04s -> 1090.04s]  the TCP tear down. So we've sent a fin, we receive a
[1090.04s -> 1093.04s]  fin, we acknowledge it, we're now in the closing state, we then
[1093.04s -> 1098.04s]  transition to time weight. Another is that we receive a fin,
[1098.04s -> 1102.04s]  plus an ACK. So we can just acknowledge that, and
[1102.04s -> 1107.04s]  enter time weight. The final one is that we receive an
[1107.04s -> 1110.04s]  ACK but no fin. So this is, we have closed our
[1110.04s -> 1113.04s]  side of the connection, the other side hasn't.
[1113.04s -> 1117.04s]  And so it's sort of the, this state here is correlated with this state here.
[1117.04s -> 1121.04s]  Then when we do receive the fin, we acknowledge it and enter the time
[1121.04s -> 1125.04s]  weight state. And then we have the time up before
[1125.04s -> 1129.04s]  the close and recover the state. So you can ask, what's the difference
[1129.04s -> 1132.04s]  between this transition to closing and time weight?
[1132.04s -> 1136.04s]  The reason is that this transition to closing is when the two fins pass each
[1136.04s -> 1138.04s]  other. So I send a fin, the other side fin
[1138.04s -> 1141.04s]  sends me a fin but hasn't acknowledged my fin.
[1141.04s -> 1144.04s]  This is the difference between fin slash ACK and fin plus ACK slash ACK.
[1144.04s -> 1147.04s]  And so then I wait for that fin to be acknowledged and then
[1147.04s -> 1150.04s]  transition to time weight. So this is the full TCP finite state
[1150.04s -> 1152.04s]  machine. It looks really complicated and it
[1152.04s -> 1156.04s]  does have one, two, three, four, five, six, seven, eight, nine, ten, eleven, twelve
[1156.04s -> 1158.04s]  states. But when you realize it breaks in
[1158.04s -> 1161.04s]  these two parts, connection establishment and connection tear down, and really
[1161.04s -> 1165.04s]  there's just a bunch of different possible ways the fins can be exchanged,
[1165.04s -> 1169.04s]  it's actually not that complicated. And so I encourage you to open up
[1169.04s -> 1172.04s]  Wireshark and just open up a couple of web connections or see what, what's
[1172.04s -> 1175.04s]  happening with your TCP connections. And you'll be able to see how those
[1175.04s -> 1179.04s]  different connections are traversing this finite state machine.
[1182.04s -> 1184.04s]  Thank you.
