# Detected language: en (p=1.00)

[0.00s -> 5.88s]  In the last video, you learned how a variety of different applications, such as BitTorrent,
[5.88s -> 10.64s]  Skype and the Web, all communicate over the internet using a very similar model, basically
[10.64s -> 13.60s]  a bi-directional, reliable byte stream.
[13.60s -> 18.06s]  It takes a lot of different pieces working together to create this reliable communication
[18.06s -> 20.60s]  model for our applications.
[20.60s -> 24.68s]  But even though we use a huge variety of different internet applications, sending
[24.68s -> 29.62s]  many kinds of data at very different speeds, there are surprisingly strong similarities
[29.62s -> 32.78s]  in the way applications send and receive data.
[32.78s -> 36.54s]  For example, applications want to send and receive data without having to worry about
[36.54s -> 40.96s]  the path or route that the data takes across the internet.
[40.96s -> 45.38s]  And almost all applications want to be confident that their data is correctly received, with
[45.38s -> 52.00s]  any lost or corrupted data automatically re-transmitted until it is received correctly.
[52.00s -> 56.82s]  The early internet pioneers created the four-layer internet model to describe the hierarchy
[56.82s -> 61.18s]  of operations that make up the internet, so that applications can reuse the same building
[61.18s -> 65.26s]  blocks over and over again, without having to create them from scratch for every new
[65.26s -> 67.14s]  application.
[67.14s -> 70.18s]  Layering is a really important and frequently used concept in networking, and we'll be
[70.18s -> 72.86s]  seeing it many times throughout this course.
[72.86s -> 76.70s]  There's even a video devoted just to the concept of layering.
[76.70s -> 79.82s]  Let's look at what each layer of the four-layer internet model does.
[79.82s -> 83.86s]  It helps to remember that all four layers are there to enable applications in the
[83.86s -> 86.62s]  end hosts to communicate reliably.
[86.62s -> 89.34s]  To explain how it works, I'm going to start at the bottom layer.
[89.34s -> 93.30s]  We'll see that each layer has a different responsibility, with each layer building a
[93.30s -> 97.78s]  service on top of the one below, all the way to the top, where we have the bi-directional,
[97.78s -> 100.38s]  reliable byte-stream communication between applications.
[100.38s -> 103.10s]  OK, let's start with the link layer.
[103.10s -> 107.18s]  The internet is made up of end hosts, links, and routers.
[107.18s -> 109.94s]  Data is delivered hop-by-hop over each link and turn.
[109.94s -> 112.10s]  Data is delivered in packets.
[112.10s -> 116.30s]  A packet is a self-contained unit consisting of the data we want to be delivered, along
[116.30s -> 120.46s]  with a header that tells the network where the packet is to be delivered, where it came
[120.46s -> 124.18s]  from, and so on.
[124.18s -> 127.62s]  The link layer's job is to carry the data over one link at a time.
[127.62s -> 129.66s]  You've probably heard of Ethernet and Wi-Fi.
[129.66s -> 134.54s]  These are two examples of different link layers.
[134.54s -> 139.26s]  The next layer up is, for us, the most important layer, the network layer.
[139.26s -> 143.78s]  The network layer's job is to deliver packets end-to-end, across the internet from
[143.78s -> 146.10s]  the source to the destination.
[146.10s -> 148.66s]  A packet is an important building block in the network.
[148.66s -> 152.98s]  A packet is the name we give to that collection of data, with a header that describes what
[152.98s -> 156.82s]  the data is, where it's going, and where it came from, as we saw in the last slide.
[156.82s -> 161.58s]  You'll often see packets drawn like this.
[161.58s -> 164.02s]  Network layer packets are called datagrams.
[164.02s -> 169.70s]  They consist of some data and a header containing the to and from addresses, just like we
[169.70s -> 173.90s]  put the to and from addresses in a letter.
[173.90s -> 179.58s]  The network hands the datagram to the link layer, telling it to send the datagram over
[179.58s -> 180.58s]  the first link.
[180.58s -> 183.82s]  In other words, the link layer is providing a service to the network layer.
[183.82s -> 188.76s]  Essentially, the link layer is saying, if you give me a datagram to send, I'll transmit
[188.76s -> 193.02s]  it over one link for you.
[193.02s -> 194.86s]  At the other end of the link is a router.
[194.86s -> 199.06s]  The link layer of the router accepts the datagram from the link and hands it up to
[199.06s -> 201.86s]  the network layer inside the router.
[201.86s -> 205.54s]  The network layer on the router examines the destination address of the datagram, and
[205.54s -> 210.66s]  is responsible for routing the datagram one hop at a time towards its eventual destination.
[210.66s -> 218.02s]  It does this by sending it to the link layer again, to carry it over the next link,
[218.02s -> 221.66s]  which is passed to the network layer at the next router, and so on, until it reaches
[221.66s -> 227.38s]  the network layer at the destination eventually.
[227.38s -> 231.02s]  Notice that the network layer does not need to concern itself with how the link layer
[231.06s -> 233.18s]  sends the datagram over each link.
[233.18s -> 236.30s]  In fact, different link layers work in very different ways.
[236.30s -> 239.62s]  Ethernet and Wi-Fi are clearly very different, and we'll be learning about them in more
[239.62s -> 241.14s]  detail later.
[241.14s -> 245.46s]  This separation of concerns between the network layer and the link layer allows each to
[245.46s -> 249.66s]  focus on its job, without worrying about how the other layer works.
[249.66s -> 253.66s]  It also means that a single network layer has a common way to talk to many different
[253.66s -> 257.04s]  link layers by simply handing them datagrams to send.
[257.04s -> 262.28s]  This separation of concerns is made possible by the modularity of each layer, and a common,
[262.28s -> 267.74s]  well-defined API to the layer below.
[267.74s -> 270.44s]  In the Internet, the network layer is special.
[270.44s -> 274.20s]  When we send packets into the Internet, we must use the Internet Protocol.
[274.20s -> 278.24s]  It is the Internet Protocol, or IP, that holds the Internet together.
[278.24s -> 282.08s]  We'll learn more about the details of IP in later videos, but for now, it's good
[282.08s -> 286.16s]  to know some basic facts about IP.
[286.28s -> 291.28s]  First of all, IP makes a best-effort attempt to deliver our datagrams to the other end.
[291.28s -> 293.16s]  But it makes no promises.
[293.16s -> 296.28s]  Second, IP datagrams can get lost.
[296.28s -> 299.04s]  They can be delivered out of order, and they can be corrupted.
[299.04s -> 302.86s]  There are no guarantees.
[302.86s -> 304.74s]  This may come as a surprise.
[304.74s -> 308.76s]  You might be asking, how can the Internet work at all when the packets are not guaranteed
[308.76s -> 310.36s]  to be delivered?
[310.36s -> 316.08s]  Well, if an application wants a guarantee that its data will be retransmitted when necessary,
[316.08s -> 320.84s]  and will be delivered to the application in order, and without corruption, then it needs
[320.84s -> 323.20s]  another Protocol running on top of IP.
[323.20s -> 328.36s]  That's the job of the transport layer.
[328.36s -> 332.72s]  The most common transport layer is TCP, or the Transmission Control Protocol.
[332.72s -> 337.36s]  You've probably heard of TCP IP, which is when an application uses both TCP and
[337.36s -> 339.36s]  IP together.
[339.36s -> 343.88s]  TCP's job is to make sure that the data sent by an application at one end of the
[343.88s -> 348.40s]  Internet is correctly delivered in the right order to the application at the other end
[348.40s -> 349.84s]  of the Internet.
[349.84s -> 354.60s]  If the network layers drop some datagrams, TCP will transmit them multiple times if
[354.60s -> 356.12s]  need be.
[356.12s -> 359.72s]  If the network layer delivers them out of order, perhaps because two packets follow
[359.72s -> 363.82s]  a different path to their destination, TCP will put the data back into the correct
[363.82s -> 364.82s]  order again.
[364.82s -> 369.56s]  In later videos, you'll learn a lot about TCP and how it works.
[369.56s -> 374.56s]  For now, the main thing you need to remember is that TCP provides a service to an application
[374.56s -> 378.92s]  that guarantees correct, in-order delivery of data running on top of the network layer
[378.92s -> 380.50s]  service.
[380.50s -> 387.16s]  The network layer is providing an unreliable datagram delivery service underneath.
[387.16s -> 391.28s]  As I'm sure you can imagine, applications such as a web client or an email client
[391.28s -> 393.88s]  find TCP very useful indeed.
[393.88s -> 397.96s]  By employing TCP to make sure data is delivered correctly, they don't have to worry about
[397.96s -> 401.24s]  implementing all of the mechanisms inside the application.
[401.24s -> 404.94s]  They can take advantage of the huge effort that other developers have put into correctly
[404.94s -> 410.28s]  implementing TCP over the years, and then reuse it to deliver the data correctly.
[410.28s -> 414.68s]  Reuse is a big advantage of layering.
[414.68s -> 418.38s]  But not all applications need data to be delivered correctly.
[418.38s -> 422.96s]  For example, if a video conference application is sending a snippet of video in a packet,
[422.96s -> 426.76s]  there may be no point waiting for the packet to be retransmitted multiple times.
[426.80s -> 428.56s]  Better to just move on.
[428.56s -> 432.28s]  Some applications just don't need the TCP service.
[432.28s -> 436.56s]  If an application doesn't need reliable delivery, it can use the much simpler UDP
[436.56s -> 438.96s]  or user datagram protocol instead.
[438.96s -> 443.64s]  UDP is an alternative transport layer that bundles up application data and hands it
[443.64s -> 446.16s]  to the network layer for delivery to the other end.
[446.16s -> 449.00s]  UDP offers no delivery guarantees at all.
[449.00s -> 454.28s]  In other words, an application has the choice of at least two different transport layer
[454.32s -> 457.00s]  services, TCP and UDP.
[457.00s -> 460.84s]  There are in fact many other choices too, but these are the most commonly used transport
[460.84s -> 463.12s]  layer services.
[463.12s -> 469.12s]  Finally, we have the application layer at the top of the four-layer model.
[469.12s -> 473.16s]  There are of course many thousands of applications using the Internet.
[473.16s -> 477.96s]  While each application is different, it can reuse the transport layer by using the well-defined
[477.96s -> 483.80s]  API from the application layer to the TCP or UDP service beneath.
[483.80s -> 488.76s]  As we saw in the last video, applications typically want a bidirectional, reliable byte stream
[488.76s -> 491.04s]  between two endpoints.
[491.04s -> 494.80s]  They can send whatever byte stream they want, and applications have their own protocol
[494.80s -> 501.04s]  to define the syntax and semantics of data flowing between the two endpoints.
[501.04s -> 505.00s]  For example, as we saw in the last video, when a web client requests a page from a
[505.00s -> 508.92s]  web server, the web client sends a GET request.
[508.92s -> 513.24s]  This is one of the commands of the Hypertext Transfer Protocol, or HTTP.
[513.24s -> 519.12s]  HTTP dictates that the GET command is sent as an ASCII string, along with the URL of
[519.12s -> 522.30s]  the page being requested.
[522.30s -> 527.12s]  As far as the application layer is concerned, the GET request is sent directly to its peer
[527.12s -> 532.32s]  at the other end, the web server application.
[532.32s -> 536.16s]  The application doesn't need to know how the data got there, or how many times it
[536.16s -> 537.68s]  needed to be retransmitted.
[537.68s -> 542.32s]  At the web client, the application layer hands the GET request to the TCP layer, which
[542.32s -> 545.52s]  provides the service of making sure it is reliably delivered.
[545.52s -> 549.12s]  It does this using the services of the network layer, which in turn uses the services of
[549.12s -> 550.68s]  the link layer.
[550.68s -> 553.64s]  We say that each layer communicates with its peer layer.
[553.64s -> 557.08s]  It's as if each layer is only communicating with the same layer at the other end of
[557.08s -> 565.00s]  the link or Internet, without regard for how the layer below gets the data there.
[565.00s -> 569.40s]  Putting it all together, then, network engineers find it convenient to arrange all the functions
[569.40s -> 571.72s]  that make up the Internet into layers.
[571.72s -> 576.44s]  At the top is the application, such as BitTorrent or Skype or the World Wide Web, which talks
[576.44s -> 579.12s]  to its peer layer at the destination.
[579.12s -> 583.34s]  When the application has data to send, it hands the data to the transport layer, which
[583.34s -> 587.88s]  has the job of delivering the data, reliably or not, to the other end.
[587.88s -> 592.12s]  The transport layer sends data to the other end by handing it to the network layer,
[592.12s -> 595.48s]  which has the job of breaking the data into packets, each with the correct destination
[595.48s -> 596.48s]  addressed.
[596.48s -> 599.16s]  Finally, the packets are handed to the link layer, which has the responsibility of delivering
[599.16s -> 603.00s]  the packet from one hop to the next along its path.
[603.00s -> 605.84s]  The data makes its way, hop by hop, from one router to the next.
[605.84s -> 608.80s]  The network layer forwards it to the next router, one at a time, until it reaches
[608.80s -> 609.80s]  the destination.
[609.80s -> 616.04s]  There, the data is passed up the layers until it reaches the application.
[616.04s -> 620.96s]  In summary, applications, bidirectional reliable byte stream between applications, typically
[620.96s -> 626.00s]  but not always, and they use application-specific semantics, which we'll be learning about
[626.00s -> 629.44s]  later, such as HTTP or BitTorrent.
[629.44s -> 633.56s]  The transport layer typically guarantees correct in-order delivery of data end-to-end
[633.56s -> 637.44s]  and controls congestion, although some applications don't need this, and so they can use
[637.44s -> 640.24s]  a different transport layer instead.
[640.24s -> 643.30s]  The network layer delivers datagrams end-to-end.
[643.30s -> 646.44s]  It's providing a best-effort delivery service with no guarantees.
[646.44s -> 648.90s]  We must use the Internet protocol.
[648.90s -> 652.50s]  The link layer delivers data over a single link between an end host and a router, or
[652.50s -> 654.94s]  between two routers.
[654.94s -> 659.92s]  There's two extra things I'd like you to know.
[659.92s -> 665.54s]  The first is that IP is often referred to as the thin waste of the Internet.
[665.54s -> 670.00s]  This is because if we want to use the Internet, we have to use the Internet protocol.
[670.00s -> 671.74s]  We have no choice.
[671.74s -> 674.02s]  But we have lots of choices for link layers.
[674.02s -> 680.02s]  IP runs over many, many different link layers, such as Ethernet, Wi-Fi, DSL, 3G cellular,
[680.02s -> 681.86s]  and so on.
[681.86s -> 686.74s]  And on top of the IP layer, we can choose between many different transport layers.
[686.74s -> 689.28s]  We already heard about TCP and UDP.
[689.28s -> 692.70s]  There's also RTP for real-time data, and many others too.
[692.70s -> 699.38s]  And of course, there are tens of thousands of different applications sitting on top.
[699.38s -> 703.22s]  The second thing I want you to know is that in the 1980s, the International Standards
[703.22s -> 709.64s]  Organization, or ISO, created a seven-layer model to represent any type of network.
[709.64s -> 714.82s]  It was called the seven-layer Open Systems Interconnection, or OSI, model.
[714.82s -> 717.74s]  We don't need to spend any time or not in this course, because it's been replaced
[717.74s -> 721.62s]  by the four-layer Internet model for all intents and purposes.
[721.62s -> 725.58s]  But if you're interested, you'll find any networking textbook and Wikipedia describes
[725.58s -> 730.42s]  the seven layers in lots and lots of detail.
[730.42s -> 734.66s]  The seven-layer model defines layers that were combined in the four-layer Internet model
[734.66s -> 735.66s]  later.
[735.66s -> 741.78s]  For example, what we call the link layer today was separated into the link layer
[741.78s -> 746.12s]  that defined the framing format, and the physical layer that defined things like the
[746.12s -> 751.06s]  voltage levels on the cable or the physical dimensions of a connector.
[751.06s -> 756.62s]  The network layer is pretty much the same in both models.
[756.62s -> 763.54s]  The transport and applications layer is each represented by two layers in the OSI models.
[763.54s -> 768.78s]  These are examples of commonly used Internet protocols, for example, HTTP, which passes
[768.78s -> 776.38s]  most of its data in the protocol in ASCII, and how they map to the OSI numbering scheme.
[776.38s -> 780.34s]  Today the only real legacy of the seven-layer OSI model that you need to know about is
[780.34s -> 782.10s]  the numbering system.
[782.10s -> 787.74s]  You'll often hear network engineers refer to the network layer as layer three, even
[787.74s -> 791.70s]  though it's the second layer up from the bottom in the Internet model.
[791.70s -> 798.54s]  Similarly, you'll hear people refer to Ethernet as layer two, and you'll hear
[798.54s -> 800.86s]  application referred to as layer seven.
