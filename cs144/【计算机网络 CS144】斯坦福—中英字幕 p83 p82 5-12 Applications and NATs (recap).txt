# Detected language: en (p=1.00)

[0.00s -> 9.00s]  In this unit, you learn about some of the major applications in the Internet today and how NATs, or Network Address Translators, can complicate them.
[9.00s -> 18.00s]  Nowadays, a new NAT you buy tends to be reasonably well behaved, but there are still many old NATs out there that have some troublesome or difficult behavior.
[18.00s -> 25.00s]  Let's start with NATs. In this unit, you learn what a Network Address Translator is and how it works.
[25.00s -> 32.00s]  It's a router that allows many devices to share one IP address. It does this by rewriting packets as they pass through it.
[32.00s -> 39.00s]  And that device has an external address to communicate with the outside world, which is a publicly routable IP address.
[39.00s -> 50.00s]  It manages a set, or a subnet, of private internal addresses. For example, all the IP addresses starting with 10, or all the IP addresses starting with 192.168.
[50.00s -> 62.00s]  The NAT device assigns one of the private addresses to itself, for example 192.168.0.1, and then assigns the remaining addresses to the devices in the internal network.
[62.00s -> 70.00s]  If you have a home Wi-Fi router, it probably acts as a NAT device as well, using the 192.168 subnet of IPv4 addresses.
[70.00s -> 81.00s]  You learn that when a NAT routes a packet from the internal network to the external internet, it modifies the packet header so that it looks like the packet is coming from the NAT's single external IP.
[81.00s -> 88.00s]  It's essentially multiplexing all the packets from different internal addresses onto one external IP address.
[88.00s -> 96.00s]  For this to work, it needs a way to distinguish the reply packets flowing in the other direction, so that it can correctly forward them to the correct internal device.
[96.00s -> 103.00s]  NAT devices do this by modifying the transport port numbers to encode which internal device the transport flow comes from.
[103.00s -> 108.00s]  This means a NAT is aware of the transport layer headers and modifies them, too.
[108.00s -> 114.00s]  When a packet arrives from the external internet, it checks if the transport port number matches a mapping to an internal device.
[114.00s -> 118.00s]  If it does, it modifies it and forwards it to the internal network.
[118.00s -> 126.00s]  Because a NAT device typically only creates a map from internal IP addresses to external port numbers when packets are flowing towards the outside world,
[126.00s -> 132.00s]  it doesn't know what to do with packets showing up from the outside world that are trying to reach an internal device.
[132.00s -> 141.00s]  To some, this is a security benefit. By default, you can only create outgoing connections, protecting your internal devices from attack from the outside world.
[141.00s -> 148.00s]  But to others, this is a nuisance, because you can't initiate a new TCP connection from the outside world to the inside.
[148.00s -> 151.00s]  The NAT will drop the TCP SYN packet.
[151.00s -> 157.00s]  There are lots of different NAT designs, and many ways to map the IP addresses to outgoing port numbers,
[157.00s -> 161.00s]  and we saw some of them in this unit, each with its own complications.
[161.00s -> 168.00s]  The general consensus is that simple, less restrictive mappings are better, because they give the appearance of end-to-end connectivity.
[169.00s -> 175.00s]  You also learned about some of the techniques people use to work around NATs, like NAT hole-punching and simultaneous open.
[175.00s -> 186.00s]  But the main takeaway from this unit is NATs make it hard to deploy applications in the internet that require a TCP connection to be set up from the outside world to devices behind NATs.
[186.00s -> 192.00s]  And it's hard to deploy new transport protocols, because the NAT devices don't know how to process them.
[192.00s -> 199.00s]  In general, when people have created new transport protocols, they either masquerade as TCP, or run on top of UDP.
[203.00s -> 207.00s]  You learned about the Domain Name System, an application that uses UDP.
[207.00s -> 212.00s]  On one hand, it's critical infrastructure, without which the internet would be much less useful.
[212.00s -> 215.00s]  On the other, it's just an application.
[216.00s -> 227.00s]  You learned that the basic idea of the Domain Name System is that you can add hierarchical names, such as www.stanford.edu, to different kinds of information, called records.
[227.00s -> 233.00s]  For example, you can ask what the IPv4 address of www.stanford.edu is.
[233.00s -> 236.00s]  You can ask what the name server for stanford.edu is.
[236.00s -> 240.00s]  You can ask what the mail server for cs.stanford.edu is.
[241.00s -> 245.00s]  You learned that the Domain Name System works through a hierarchy of servers.
[245.00s -> 263.00s]  For example, to find the address for www.stanford.edu, you first ask a root server, where you can find out about the .edu, then ask .edu, where you can find out about stanford, then finally ask stanford for the address of www.stanford.edu.
[263.00s -> 272.00s]  Each of these records, the address records and the name server records, on each step can be cached, often for a long while, to reduce load.
[272.00s -> 281.00s]  To make this caching work even better, often many clients share a resolver, a computer who queries the domain name service, for you.
[281.00s -> 286.00s]  That way, it can cache all of those results and share them among clients.
[286.00s -> 296.00s]  That way, all of Stanford only needs to do a single lookup for Google as long as the record lasts, rather than having every laptop contacting Google's DNS servers.
[299.00s -> 304.00s]  HTTP is the Hypertext Transfer Protocol. It runs on TCP.
[304.00s -> 312.00s]  We've been using the same version of HTTP, that's version 1.1, for almost 20 years now. Basically, it's unchanged.
[312.00s -> 321.00s]  You learn that HTTP is a request-response protocol. Both request and response are in ASCII text, which is useful because it's very easy to read.
[321.00s -> 327.00s]  You learn that one of the big improvements in HTTP 1.1 was something called Keepalive.
[327.00s -> 333.00s]  In HTTP 1.0, each request was made on a separate TCP connection.
[333.00s -> 339.00s]  So to download a page with 40 resources on it, your client had to open 40 TCP connections.
[339.00s -> 345.00s]  HTTP 1.1 allows a client to request many resources all on the same connection.
[345.00s -> 352.00s]  This means less time is spent in the 3-way handshake, and the TCP connection has more time to grow its congestion window.
[352.00s -> 359.00s]  You learn ways to roughly calculate the download times for downloading a complete page and all of its resources.
[359.00s -> 366.00s]  Using this, you saw how connection setup time can be a significant overhead for TCP connections that transfer only a little bit of data.
[366.00s -> 373.00s]  Finally, you heard a little bit about SPDY, the protocol that's become the basis of HTTP 2.0.
[376.00s -> 382.00s]  The third application you learned about was BitTorrent. Like HTTP, BitTorrent uses TCP.
[382.00s -> 391.00s]  But unlike HTTP, which is a client-server application, BitTorrent is a large collection of collaborating clients called a swarm.
[391.00s -> 400.00s]  You use BitTorrent to share large, say 100-megabyte files. BitTorrent breaks these files up into smaller chunks called pieces.
[400.00s -> 406.00s]  You learn that each BitTorrent client opens connections to score sometimes as many as 100 other clients.
[406.00s -> 416.00s]  A client requests data from other clients using a rarest-first policy, so it tries to avoid a piece disappearing from the swarm and also to remove bottlenecks.
[417.00s -> 425.00s]  You also learn that while BitTorrent is happy to request data from lots of peers, it's very careful about whom it sends data to.
[425.00s -> 432.00s]  BitTorrent tries to set up an incentive system where you want to contribute data and let others transfer from you.
[432.00s -> 438.00s]  So the way it works is a node will send data to the P peers who are sending it the most data.
[438.00s -> 443.00s]  That way, the best way to get data from a peer is to send it data.
[444.00s -> 453.00s]  To better figure out who those best peers are, BitTorrent occasionally starts sending to a new random peer in order to discover new potential partners in exchange.
[453.00s -> 456.00s]  This algorithm is called the tit-for-tat algorithm.
[459.00s -> 462.00s]  So you've seen three major applications on the Internet today.
[462.00s -> 469.00s]  You've seen how the simple abstractions that UDP and TCP provide can be used in complex ways for very interesting applications.
[469.00s -> 478.00s]  You also learned how network address translators can complicate applications by making it hard to discover peers or open connections, as well as a few techniques for working around them.
[478.00s -> 488.00s]  You now should have a good understanding of some of the techniques you can use and challenges you might run into when you go out and develop the next generation of Internet applications.
