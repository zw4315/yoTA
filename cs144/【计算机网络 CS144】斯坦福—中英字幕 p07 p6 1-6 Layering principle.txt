# Detected language: en (p=1.00)

[0.00s -> 3.88s]  In the last few videos, you've seen many references to layering, particularly in the
[3.88s -> 6.98s]  video describing the four-layer Internet model.
[6.98s -> 11.36s]  Layering is a very widely used principle, and has been used in networking for decades,
[11.36s -> 12.64s]  predating the Internet.
[12.64s -> 17.96s]  In fact, layering is a design principle used widely outside networking as well.
[17.96s -> 22.08s]  It's commonly used as a design principle in many types of computer system.
[22.08s -> 25.68s]  There are lots of reasons for layering, and we'll explore some of them in this
[25.68s -> 26.68s]  video.
[27.52s -> 30.90s]  We'll explore what layering is, we'll look at some of the simple examples of layering
[30.90s -> 35.68s]  in communication and computer systems, and we'll explain why so many systems are layered,
[35.68s -> 40.96s]  either by natural happenstance or deliberately by design.
[40.96s -> 43.92s]  Let's start with a definition of layering.
[43.92s -> 48.56s]  Layering is the name we give to the organization of a system into a number of separate functional
[48.56s -> 51.90s]  components or layers.
[51.90s -> 54.92s]  The layers are hierarchical, and they communicate sequentially.
[55.16s -> 61.48s]  In other words, each layer has an interface only to the layer directly above and below.
[61.48s -> 66.24s]  Each layer provides a well-defined service to the layer above, using the services provided
[66.24s -> 71.50s]  by layers below, and its own private processing.
[71.50s -> 76.16s]  There are many examples of layering in everyday life, particularly when one service is deliberately
[76.16s -> 78.96s]  or naturally layered on top of another.
[78.96s -> 83.74s]  For example, if you're looking for airplane tickets, you might visit a brokerage website
[83.74s -> 87.18s]  such as Google Flights, Hipmunk or Kayak.
[87.18s -> 91.26s]  These websites let you find tickets across a wide range of airlines by communicating with
[91.26s -> 93.14s]  a single service.
[93.14s -> 96.30s]  You could instead go to the website of every airline to query what tickets they
[96.30s -> 97.58s]  have available.
[97.58s -> 101.90s]  The brokerage website is providing you a service layer on top of each airline, abstracting
[101.90s -> 105.86s]  away the details of each airline's website for you.
[105.86s -> 110.10s]  If we look under the covers of each airline, they fly different types of airplanes over
[110.10s -> 111.40s]  different routes.
[111.40s -> 114.92s]  The airplane takes care of the details of providing the service and offers you the simple
[114.92s -> 119.40s]  abstraction of a ticket valid for a particular flight to take you between two airports.
[119.40s -> 124.16s]  They're hiding many other details too, such as how they provide the awful food
[124.16s -> 125.24s]  they serve.
[125.24s -> 130.28s]  In many cases, they have a number of suppliers to provide meals, drinks, fuel and so on.
[130.28s -> 134.00s]  Each of those are naturally hidden from us, the consumer.
[134.00s -> 138.96s]  This separation of concerns allows each layer in the hierarchy to focus on doing its
[138.96s -> 146.36s]  job well and provide a well-defined service to the layer above.
[146.36s -> 152.84s]  Another well-known example of layering closer to the internet is the postal service.
[152.84s -> 157.52s]  Imagine that I have a book that I want to send to Phil.
[157.52s -> 162.12s]  I place the book in an envelope, add Phil's address and mine, and then hand it over
[162.12s -> 166.16s]  to Olive to take to the mailbox.
[166.16s -> 172.40s]  The postal service sorts the mail, then sends it by a variety of different means, airplanes,
[172.40s -> 178.20s]  mail, trucks, trains, etc., until it reaches a sorting office near Phil.
[178.20s -> 186.12s]  The mailman delivers the letter to Phil, who opens it and finds the book inside.
[186.12s -> 188.04s]  The service is clearly layered.
[188.04s -> 194.20s]  At the top, I don't care how the letters get from me to Phil, whether they go by airplane,
[194.20s -> 198.88s]  truck or hovercraft, and I don't care about the route that the book takes, or how many
[198.88s -> 201.68s]  sorting offices it passes through along the way.
[201.68s -> 205.24s]  I don't mind whether Olive walks, skips, bicycles or runs to the mailbox.
[205.24s -> 208.64s]  I don't care which mailbox she posts the letter in.
[208.64s -> 214.28s]  I want the lower layers to abstract away the details for me, providing me with a simple
[214.28s -> 215.80s]  service model.
[215.80s -> 219.80s]  I put the book in an envelope and the layers below deliver it to Phil.
[219.80s -> 223.52s]  In turn, Olive doesn't need to know how the postal service delivers the letter.
[223.52s -> 227.24s]  She simply communicates with the layer below by posting the letter.
[227.24s -> 230.72s]  Phil just wants the book.
[230.72s -> 234.64s]  Notice that each layer communicates only with the layers above and below.
[234.64s -> 239.28s]  If the postal service deploys new trains, or starts using a different airline freight
[239.28s -> 241.52s]  service, Phil and I don't need to know about it.
[241.52s -> 245.98s]  In other words, because communication is simply up and down, with a well-defined interface
[245.98s -> 250.76s]  between layers, we can improve each layer independently over time.
[250.76s -> 255.52s]  For example, if I want faster, guaranteed delivery, I could hand the envelope to a carrier
[255.52s -> 258.00s]  such as DHL or FedEx.
[258.00s -> 259.44s]  The interface is almost the same.
[259.44s -> 263.20s]  I simply give them an envelope and money.
[263.20s -> 265.88s]  Layering is deliberately designed into many computer systems.
[265.88s -> 269.48s]  When we write programs, this is TY editing a program.
[269.48s -> 273.48s]  We create source code using a language that abstracts away the details of the operating
[273.48s -> 277.32s]  system, how virtual memory works, and how the low-level details of the hardware.
[277.88s -> 282.84s]  Okay, so C isn't great at hiding the details, but many other languages, such as Java and
[282.84s -> 287.16s]  Python, deliberately shield us from how the lower layers work.
[287.16s -> 291.12s]  As a programmer, we communicate with the layer below, the compiler, by handing it
[291.12s -> 292.52s]  our source code.
[292.52s -> 295.92s]  The compiler is a self-contained functional component that is responsible for several
[295.92s -> 303.44s]  tasks such as lexical analysis, parsing our code, pre-processing declarations, and
[303.44s -> 306.60s]  code generation and optimization.
[306.60s -> 312.36s]  The compiler generates object code, which it then passes to the linker.
[312.36s -> 315.88s]  The linker links together the compiled object files and libraries.
[315.88s -> 318.64s]  It generates an executable file.
[318.64s -> 323.56s]  The CPU, real or virtual, then executes the code.
[323.56s -> 327.44s]  If you have experience writing computer programs, the benefits of layering are fairly clear
[327.44s -> 329.04s]  in this example.
[329.04s -> 333.60s]  Layering breaks down the overall problem of writing programs that execute on hardware
[333.60s -> 339.96s]  into modules, or functional components, each with a well-defined role and providing a well-defined
[339.96s -> 342.36s]  service to the layer above.
[342.36s -> 346.32s]  It also provides a clear separation of concerns.
[346.32s -> 350.24s]  The compiler can focus on lexical analysis, parsing, and so on.
[350.24s -> 353.72s]  The linker can focus on efficiently piecing objects together.
[353.72s -> 357.64s]  Neither has to worry about the job of the other, and each can be improved, upgraded,
[357.64s -> 361.56s]  and replaced over time as technology and know-how progresses.
[361.56s -> 367.40s]  For example, we might swap out a commercial C compiler with GCC, or vice versa, without
[367.40s -> 374.24s]  needing to change the linker or the language we use.
[374.24s -> 378.52s]  When Nick first drafted these slides, I was excited that he put compilers in as an example
[378.52s -> 379.52s]  of layering.
[379.52s -> 383.20s]  They're a great example of both the benefits of layering, as well as how sometimes you
[383.20s -> 388.48s]  need to break layering despite the very negative consequences.
[388.48s -> 391.52s]  So let's take the C programming language as an example.
[391.52s -> 395.16s]  Generally speaking, a piece of C code can be compiled for almost any processor.
[395.16s -> 399.68s]  We can take C code like the statement I++ and compile it for an ARM processor in a
[399.68s -> 406.08s]  phone, an x86-64 processor in a laptop, or a microcontroller in an ultra-modern dishwasher.
[406.08s -> 412.04s]  In this way, the C code is hardware-independent, and so it keeps the layering here.
[412.04s -> 417.62s]  But sometimes we need our C code to do something special that only our processor can do.
[417.62s -> 422.82s]  For example, an x86-64 processor has all kinds of special instructions that a microcontroller
[422.82s -> 424.06s]  doesn't.
[424.06s -> 428.66s]  C allows you to include assembly code directly.
[428.66s -> 432.50s]  Software like operating system kernels such as Linux and Windows use this for some of
[432.50s -> 434.50s]  their lowest-level implementations.
[434.50s -> 439.78s]  The layering that C provides hides this detail so it doesn't let you do so directly,
[439.78s -> 442.30s]  but you have to do so to achieve your goal.
[442.30s -> 445.54s]  So OS kernels include assembly code.
[445.54s -> 448.82s]  By doing so, this means that the code is no longer layer-independent.
[448.82s -> 453.42s]  The Linux context switch assembly written for ARM only works for ARM.
[453.42s -> 457.14s]  So you have to write a version of this code for each layer.
[457.14s -> 461.22s]  If Linux wants to run on a new processor, developers need to write new assembly code
[461.22s -> 463.86s]  for that processor.
[463.86s -> 467.62s]  So this is a great example because it shows the benefits of layers that separate concerns
[467.62s -> 472.30s]  and simplify your system, just as programming C is easier than assembly.
[472.30s -> 475.82s]  But sometimes you have to break the layer boundaries.
[475.82s -> 477.86s]  Doing so has a huge cost.
[477.86s -> 482.42s]  Suddenly you are no longer independent of the lower layer, greatly limiting flexibility.
[482.42s -> 488.22s]  So sometimes you have to do it, but do so only when you really, really have to.
[488.22s -> 493.14s]  As we'll see, a lot of the practical, operational challenges on the internet today result from
[493.14s -> 497.38s]  people breaking layering and assuming things above and below their service interface.
[497.38s -> 503.58s]  There is a continual tension to improve the internet by making cross-layer optimizations
[503.58s -> 507.06s]  and the resulting loss of flexibility.
[507.06s -> 511.58s]  We'll see one really telling example of this with something called NATs, or Network
[511.58s -> 516.34s]  Address Translators, tremendously useful devices that have unfortunately made it almost
[516.34s -> 521.02s]  impossible to add new transport protocols to the internet.
[521.02s -> 526.30s]  So in summary, there are five main reasons we use layering in computer systems.
[526.30s -> 527.70s]  Modularity.
[527.70s -> 531.50s]  It breaks down the system into smaller, more manageable modules.
[531.50s -> 533.82s]  It's a well-defined service.
[533.82s -> 537.18s]  Each layer provides a well-defined service to the layer above.
[537.18s -> 539.18s]  Reuse.
[539.18s -> 543.26s]  A layer above can rely on all the hard work put in by others to implement the layers
[543.26s -> 544.26s]  below.
[544.26s -> 548.78s]  It saves us the time to write each layer whenever we build a new system.
[548.78s -> 550.58s]  Separation of concerns.
[550.58s -> 554.98s]  Each layer can focus on its own job without having to worry about how other layers do
[554.98s -> 555.98s]  theirs.
[555.98s -> 560.14s]  The only communication is up and down the layers, so it helps keep one layer's processing
[560.14s -> 565.30s]  and data local and internal where possible, minimizing the complex interactions between
[565.30s -> 566.30s]  layers.
[566.30s -> 571.22s]  Fifth, it allows continuous improvement of each function.
[571.22s -> 577.18s]  A sixth benefit is specific to layered communication systems such as the internet.
[577.18s -> 579.86s]  That is, peer-to-peer communications.
[579.86s -> 583.80s]  In the four-layer internet model, we saw how each layer communicates with its peer
[583.80s -> 589.32s]  on another system, using the delivery service provided by the layers below.
[589.32s -> 594.48s]  Similarly, in the mail example, Phil and I were communicating with each other as users
[594.48s -> 597.32s]  without worrying about how the communication service works.
