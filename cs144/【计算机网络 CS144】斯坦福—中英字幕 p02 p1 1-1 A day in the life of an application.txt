# Detected language: en (p=1.00)

[0.00s -> 6.28s]  What ultimately makes networks interesting are the applications that use them.
[6.28s -> 10.12s]  David Clark, one of the key contributors to the Internet's design, once wrote,
[10.12s -> 14.34s]  The current exponential growth of the network seems to show that connectivity is its
[14.34s -> 19.34s]  own reward, and it is more valuable than any individual application, such as mail
[19.34s -> 21.62s]  or the World Wide Web.
[21.62s -> 25.06s]  Connectivity is the idea that two computers in different parts of the world can connect
[25.06s -> 27.42s]  to one another and exchange data.
[27.44s -> 30.92s]  If you connect your computer to the Internet, you could suddenly talk with all of the other
[30.92s -> 32.84s]  computers connected to the Internet.
[32.84s -> 36.64s]  Let's look at exactly what that means and how some modern applications, the World Wide
[36.64s -> 40.72s]  Web, Skype, and BitTorrent use it.
[40.72s -> 44.60s]  The tremendous power of networked applications is that you can have multiple computers,
[44.60s -> 48.36s]  each with their own private data, each perhaps owned and controlled by different
[48.36s -> 50.66s]  people, exchange information.
[50.66s -> 54.52s]  Unlike your local applications, which can only access data that resides on your local
[54.52s -> 58.66s]  system, networked applications can exchange data across the world.
[58.66s -> 62.18s]  For example, think of using a web browser to read a magazine.
[62.18s -> 66.74s]  The server is run by the publisher, which has all of the magazine articles, and it
[66.74s -> 69.24s]  might also have all of the articles from past issues.
[69.24s -> 72.86s]  As articles are corrected or added, you can immediately see the newer versions and newer
[72.86s -> 73.86s]  content.
[73.86s -> 76.94s]  The entire back catalog of articles might be too much for you to download, so you can
[76.94s -> 77.94s]  load them on demand.
[77.94s -> 81.82s]  If you didn't have a network, then you need someone to send you a DVD or USB stick
[81.82s -> 84.34s]  with the latest issue.
[84.34s -> 88.80s]  So the basic model is that you have two computers, each running a program locally, and these
[88.80s -> 91.68s]  two programs communicate over the network.
[91.68s -> 99.52s]  The most common communication model used is a bidirectional, reliable stream of bytes.
[99.52s -> 104.52s]  So program A, running on computer A, can write data, which goes over the network,
[104.52s -> 109.36s]  such that then program B, running on computer B, can read it.
[109.38s -> 115.02s]  Similarly, program B can write data that program A can read.
[115.02s -> 118.70s]  There are other modes of communication, which we'll talk about later in the course, but
[118.70s -> 123.42s]  a reliable, bidirectional byte stream is by far the most common one used in networks
[123.42s -> 124.42s]  today.
[124.42s -> 127.24s]  Let's walk through what this looks like.
[127.24s -> 133.64s]  Computer B, on the right, is waiting for other computers to connect to it.
[133.64s -> 138.00s]  Computer A, on the left, wants to communicate with B.
[138.02s -> 144.02s]  For example, though it's drawn here as a server, it could be a mobile phone running a web browser.
[144.02s -> 147.26s]  A and B set up a connection.
[147.26s -> 151.90s]  Now, when A writes data to the connection, this data travels over the network and B
[151.90s -> 153.94s]  can read it.
[153.94s -> 159.50s]  Similarly, if B writes data to the connection, that data travels over the network and A can
[159.50s -> 163.02s]  read it.
[163.02s -> 165.86s]  Either side can close the connection.
[165.86s -> 170.28s]  For example, when the web browser is done requesting data from the web server, it can
[170.28s -> 172.32s]  close the connection.
[172.32s -> 176.88s]  Similarly, if the server wants to, it can close the connection as well.
[176.88s -> 180.40s]  If you've ever seen an error message in a web browser saying,
[180.40s -> 182.98s]  Connection reset by peer, that's what this means.
[182.98s -> 186.86s]  The web server closed the connection when the web browser wasn't expecting it.
[186.86s -> 189.12s]  Of course, the server can refuse the connection as well.
[189.12s -> 193.14s]  You've probably seen connection refuse messages, or have a browser wait for a long time because
[193.14s -> 197.06s]  the server isn't even responding with the refusal.
[197.06s -> 200.42s]  Now that we've seen the basic way networked applications communicate, let's look at our
[200.42s -> 203.38s]  first example, the World Wide Web.
[203.38s -> 208.10s]  The World Wide Web uses something called HTTP, which stands for Hypertext Transfer
[208.10s -> 209.42s]  Protocol.
[209.42s -> 214.86s]  When you see HTTP colon slash slash in your browser, that means it's communicating using
[214.86s -> 217.66s]  HTTP.
[217.66s -> 221.62s]  We'll dig much deeper into the details of HTTP later in the course when we cover
[221.62s -> 222.62s]  applications.
[223.10s -> 230.14s]  In HTTP, a client opens a connection to a server and sends commands to it.
[230.14s -> 234.46s]  The most common command is GET, which requests a page.
[234.46s -> 239.70s]  HTTP was designed to be a document-centric way for programs to communicate.
[239.70s -> 246.38s]  For example, if I type http www.stanford.edu in my browser, the browser opens a connection
[246.38s -> 253.64s]  to the server, www.stanford.edu, and sends a GET request for the root page of the site.
[253.64s -> 257.90s]  The server receives the request, checks if it's valid, and the user can access that
[257.90s -> 259.74s]  page and sends a response.
[259.74s -> 262.74s]  The response has a numeric code associated with it.
[262.74s -> 266.90s]  For example, if the server sends a 200 OK response to a GET, this means that the
[266.90s -> 273.78s]  request is accepted and the rest of the response has the document data.
[273.78s -> 278.70s]  In the example of the www.stanford.edu web page, a 200 OK response would include the
[278.70s -> 283.34s]  hypertext that describes the main Stanford page, the other kinds of requests such as
[283.34s -> 287.58s]  PUT, DELETE, and INFO, as well as other responses such as 400, which means that there
[287.58s -> 291.78s]  was a bad request, maybe it was malformed.
[291.78s -> 296.86s]  Because HTTP is document-centric, client requests name a file.
[296.86s -> 300.02s]  HTTP is all an ASCII text, it's human readable.
[300.02s -> 306.14s]  For example, the beginning of a GET request for Stanford looks like this.
[306.14s -> 312.34s]  The beginning of a response to a successful request looks like this.
[312.34s -> 314.62s]  The basic model is simple.
[314.62s -> 319.14s]  A client sends a request by writing to the connection, the server reads this request,
[319.14s -> 325.86s]  processes it, and writes a response to the connection, which the client then reads.
[325.86s -> 328.58s]  Let's look at a second application, BitTorrent.
[328.58s -> 331.58s]  BitTorrent is a program that allows people to share and exchange large files.
[331.58s -> 335.70s]  Unlike the web, where a client requests documents from a server, in BitTorrent a client
[335.70s -> 337.46s]  requests documents from other clients.
[337.46s -> 342.34s]  So that a single client can request from many others in parallel, BitTorrent breaks
[342.34s -> 345.50s]  files up into chunks of data called pieces.
[345.50s -> 349.38s]  When a client downloads a complete piece from another client, it then tells other
[349.38s -> 352.42s]  clients it has that piece that they can download it to.
[352.42s -> 356.10s]  These collections of collaborating clients are called swarms.
[356.10s -> 360.14s]  So we talk about a client joining or leaving the swarm.
[360.14s -> 364.98s]  BitTorrent uses the exact same mechanism as the World Wide Web, a reliable bi-directional
[364.98s -> 368.50s]  byte stream, but it uses it in a slightly more complex way.
[368.50s -> 373.02s]  When a client wants to download a file, it first has to find something called a torrent
[373.02s -> 374.02s]  file.
[374.02s -> 377.46s]  Usually you find this using the World Wide Web and download it using, you guessed
[377.46s -> 379.50s]  it, HTTP.
[379.50s -> 384.10s]  The torrent file describes some information about the data file you want to download.
[384.14s -> 388.94s]  It also tells BitTorrent about who the tracker is for that torrent.
[388.94s -> 393.54s]  A tracker is a node that keeps track, hence the name, of what clients are members of
[393.54s -> 395.90s]  the swarm.
[395.90s -> 401.58s]  To join a torrent, your client contacts the tracker, again over HTTP, to request
[401.58s -> 404.74s]  the list of other clients.
[404.74s -> 408.70s]  Your client opens connections to some of these other clients and starts requesting
[408.70s -> 410.30s]  pieces of the file.
[410.30s -> 413.38s]  These clients, in turn, can request pieces on their own.
[413.38s -> 418.14s]  Furthermore, when a new client joins the swarm, the tracker might tell this new client
[418.14s -> 419.82s]  to connect to your client.
[419.82s -> 423.74s]  So rather than a single connection between a client and a server, you have a dense graph
[423.74s -> 428.66s]  of connections between clients dynamically exchanging data.
[428.66s -> 431.82s]  For a third and final application, let's look at Skype, the popular voice chat and
[431.82s -> 432.82s]  video service.
[432.82s -> 437.10s]  Skype is a proprietary system, it doesn't have any official documentation on how it
[437.10s -> 438.10s]  works internally.
[438.10s -> 441.90s]  In 2008, some researchers at Columbia figured out mostly how it works by looking at where
[441.90s -> 444.22s]  and when Skype clients send messages.
[444.22s -> 446.62s]  The messages were encrypted, though, so they couldn't look inside.
[446.62s -> 451.46s]  In 2011, however, Efim Bushmanov reverse engineered the protocol and published open
[451.46s -> 452.46s]  source code.
[452.46s -> 455.54s]  So now we have a better sense of how the protocol works.
[455.54s -> 458.86s]  In its most simple mode, when you want to call someone in Skype, it's a simple
[458.86s -> 462.26s]  client-server exchange, sort of like HTTP.
[462.26s -> 467.50s]  You, the caller, open a connection to the recipient.
[467.54s -> 472.78s]  If the recipient accepts your call, you start exchanging voice, video, or chat data.
[472.78s -> 476.02s]  But unlike the web, where there's a client and a server, in the Skype case you have
[476.02s -> 477.66s]  two clients.
[477.66s -> 480.98s]  So rather than having a personal computer request something from a dedicated server,
[480.98s -> 484.26s]  you have two personal computers requesting data from each other.
[484.26s -> 490.26s]  This difference turns out to have a really big implication to how Skype works.
[490.26s -> 495.46s]  The complication comes from something called a NAT, or Network Address Translator.
[495.46s -> 497.02s]  NATs are everywhere today.
[497.06s -> 499.50s]  A small home wireless router is a NAT.
[499.50s -> 502.74s]  When a mobile phone connects to the internet, it's behind a NAT.
[502.74s -> 505.58s]  We'll cover them in greater detail later in the course, but for now, all you need
[505.58s -> 509.70s]  to know is that if you're behind a NAT, then you can open connections out to the
[509.70s -> 510.70s]  internet.
[510.70s -> 514.82s]  But other nodes on the internet can't easily open connections to you.
[514.82s -> 519.98s]  In this example, this means that client B can open connections to other nodes freely.
[519.98s -> 523.62s]  But it's very hard for other nodes to open connections to client B.
[523.62s -> 526.02s]  That's what this red-green gradient is showing.
[526.02s -> 529.34s]  Connections coming from the green side work fine, but connections coming from the red
[529.34s -> 530.34s]  side don't.
[530.34s -> 535.38s]  So the complication here is that if client A wants to call client B, it can't open
[535.38s -> 536.38s]  a connection.
[536.38s -> 537.74s]  It can't go through the NAT.
[537.74s -> 540.90s]  Skype has to work around this.
[540.90s -> 542.74s]  It does so using something called a rendezvous server.
[542.74s -> 546.94s]  When you log into Skype, your client opens connections to a network of control servers.
[546.94s -> 551.26s]  In this case, client B opens a connection to the rendezvous server.
[551.26s -> 555.26s]  This works fine because the server isn't behind a NAT, and so client B can open connections
[555.26s -> 557.02s]  without any problems.
[557.02s -> 562.02s]  When a client A calls client B, it sends a message to the rendezvous server.
[562.02s -> 565.94s]  Since the server has an open connection to client B, it tells me that there's a call
[565.94s -> 567.34s]  request from A.
[567.34s -> 569.38s]  Call dialog pops up on client B.
[569.38s -> 575.98s]  If client B accepts the call, then it opens a connection to client A.
[575.98s -> 579.34s]  Client A was trying to open a connection to client B, but since B was behind a NAT,
[579.34s -> 580.34s]  it couldn't.
[580.34s -> 583.78s]  So instead, it sends a message to a computer that client B is already connected to, which
[583.78s -> 587.14s]  then asks client B to open a connection back to client A.
[587.14s -> 590.86s]  Since client A isn't behind a NAT, this connection can open normally.
[590.86s -> 595.22s]  This is called a reverse connection because it reverses the expected direction for initiating
[595.22s -> 596.94s]  the connection.
[596.94s -> 600.66s]  Client A is trying to connect to client B, but instead client B opens a connection to
[600.66s -> 602.34s]  client A.
[602.34s -> 605.94s]  This happens in Skype because Skype clients are typically personal machines.
[605.94s -> 608.86s]  It's rare for publicly accessible web servers to be behind NATs.
[608.86s -> 612.14s]  Since you want the server to be accessed by everyone on the internet, putting it behind
[612.14s -> 613.64s]  a NAT is a bad idea.
[613.64s -> 616.48s]  Therefore, opening connections to web servers is easy.
[616.48s -> 619.72s]  Personal computers, however, are often behind NATs for security and other reasons.
[619.72s -> 624.80s]  Therefore, Skype has to incorporate some new communication patterns to work around them.
[624.80s -> 627.30s]  So what does Skype do if both clients are behind NATs?
[627.30s -> 628.96s]  We can't reverse the connection.
[628.96s -> 633.04s]  Client A can't open a connection to client B, and client B can't open a connection
[633.04s -> 635.12s]  to client A.
[635.12s -> 639.96s]  To handle this case, Skype introduces a second kind of server, called a relay.
[639.96s -> 641.48s]  Relays can't be behind NATs.
[641.48s -> 645.52s]  If both client A and client B are behind NATs, then they communicate through a relay.
[645.52s -> 649.08s]  They both open connections to the relay.
[649.08s -> 653.84s]  When client A sends data, the relay forwards it to client B through the connection that
[653.84s -> 655.12s]  B opened.
[655.12s -> 659.40s]  Similarly, when client B sends data, the relay forwards it to client A through the
[659.40s -> 662.66s]  connection client A opened.
[662.66s -> 667.54s]  In summary, we've seen the most common communication model of network applications, a reliable bi-directional
[667.54s -> 668.54s]  byte stream.
[668.60s -> 671.18s]  This allows two programs running on different computers to exchange data.
[671.18s -> 675.78s]  It abstracts away the entire network to a simple read-write relationship.
[675.78s -> 679.38s]  Although it's a very simple communication model, it can be used in very inventive and
[679.38s -> 680.38s]  complex ways.
[680.38s -> 683.34s]  We looked at three examples, the World Wide Web, BitTorrent, and Skype.
[683.34s -> 685.38s]  The World Wide Web is a client-server model.
[685.38s -> 688.08s]  The client opens a connection to a server and requests documents.
[688.08s -> 690.42s]  The server responds with the documents.
[690.42s -> 693.58s]  BitTorrent is a peer-to-peer model, where swarms of clients open connections to each
[693.58s -> 697.82s]  other and exchange pieces of data, creating a dense network of connections.
[697.82s -> 699.22s]  Skype is a mix of the two.
[699.22s -> 702.90s]  When Skype clients can communicate directly, they do so in a peer-to-peer fashion.
[702.90s -> 706.42s]  But sometimes the clients aren't able to open connections directly, and instead go
[706.42s -> 708.62s]  through rendezvous or relay servers.
[708.62s -> 712.34s]  You can see how what looks like a very simple abstraction, a bi-directional, reliable
[712.34s -> 715.22s]  byte stream, can be used in many interesting ways.
[715.22s -> 718.84s]  By changing how programs open connections and what different programs do, we can create
[718.84s -> 723.66s]  complex applications ranging from document retrieval to swarming downloads to IP telephony.
[723.66s -> 727.10s]  Trackers in BitTorrent, for example, have very different data and a very different
[727.10s -> 730.38s]  role than the clients, just as Skype has relays and rendezvous servers in addition
[730.38s -> 731.10s]  to its clients.
