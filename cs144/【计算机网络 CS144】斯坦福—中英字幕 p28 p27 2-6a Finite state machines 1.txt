# Detected language: en (p=1.00)

[0.00s -> 4.88s]  I'm going to explain finite state machines, something very commonly used when specifying
[4.88s -> 9.18s]  network protocols and systems. I'll also explain the common way they're drawn in network
[9.18s -> 12.76s]  protocols. I'll conclude by showing you the finite state machine that's part of
[12.76s -> 18.32s]  the TCP specification, which defines how TCP connections are set up and torn down.
[18.32s -> 23.68s]  So you'll see how you can describe something like the 3-way handshake of TCP in a finite
[23.68s -> 26.96s]  state machine. As the name suggests, a finite state machine
[26.96s -> 31.92s]  is composed of a finite number of states. A state is a particular configuration of the
[31.92s -> 35.18s]  system. I'm going to start with an abstract example.
[35.18s -> 42.10s]  In this example, we have three states. State 1, state 2, and state 3. So our system can
[42.10s -> 46.96s]  be in one of these three states. Edges between the states define how we transition
[46.96s -> 52.44s]  between them. When we draw an edge, we first specify what events cause the transition
[52.44s -> 57.96s]  to occur. Below this, we can state what actions the system will take when that transition
[57.96s -> 62.32s]  occurs. This second part is optional, because not all transitions have actions associated
[62.32s -> 68.12s]  with them. But if there is an action, you should specify it. Otherwise, you have
[68.12s -> 73.16s]  an incomplete specification, and people might not test or implement it correctly. If the
[73.16s -> 77.84s]  system is in a state, and an event arrives for which there is no transition described,
[77.84s -> 83.92s]  then the behavior of the FSM is undefined. There can be multiple transitions from a single
[83.92s -> 88.76s]  state. So here we have a second transition from state 1, a different event that will
[88.76s -> 95.32s]  take the system into state 3. For any given state, the transition for an event must
[95.32s -> 102.56s]  be unique. In this example, an event can cause state 1 to transition to state 2, or
[102.56s -> 107.08s]  transition to state 3. But you can't have the same event associated with both transitions,
[107.28s -> 111.28s]  otherwise the transition is ambiguous. If the event occurs, would you be in state 2 or state
[111.28s -> 118.36s]  3? The system can only be in one state. So let's walk through an example, an HTTP
[118.36s -> 123.04s]  request. In practice, HTTP requests are a bit more complex than this, there are all
[123.04s -> 128.76s]  kinds of options, so for this example, let's use a very simple form. Let's describe
[128.76s -> 134.64s]  our system this way. In our starting state, we are viewing a page, or otherwise idle.
[134.64s -> 140.20s]  When we want to load a new page, we transition to the page requesting state. So the event
[140.20s -> 147.00s]  is load new page, and the action is open a connection to the web server. Once we've
[147.00s -> 151.04s]  opened a connection, we're now in the page requesting state. We'll transition
[151.04s -> 155.04s]  back to the idle state when the connection closes, or when we finish requesting every
[155.04s -> 162.08s]  resource on the page. We need one more state, which describes where we are in requesting
[162.08s -> 167.64s]  a page. On the event of having more resources to request, we take the action of requesting
[167.64s -> 174.20s]  a resource with an HTTP GET. This puts us in the requesting pending state. On the
[174.20s -> 180.24s]  event of receiving the response, our system transitions back to the page requesting state.
[180.24s -> 188.84s]  So here we have a three state system, idle, page requesting, and request pending. On
[188.84s -> 192.72s]  one hand, this is a nice simple FSM, but if you were to try to implement it, it leaves
[192.72s -> 196.72s]  a lot unsaid. Specifically, we have four events in the system, page request, more
[196.72s -> 202.12s]  requests, receive response, and connection closed. So what happens if the connection
[202.12s -> 206.96s]  close event arrives when we're in the request pending state, or when we receive
[206.96s -> 210.96s]  a page request while in the page requesting state, or receive a response while in the
[210.96s -> 216.96s]  idle state? If you want to be completely explicit and careful, you should specify
[216.96s -> 222.68s]  what happens on each state for every event. But this can lead to complicated FSM's
[222.68s -> 228.38s]  which have tons of edges. So often, instead, you'll write down just the common cases
[228.38s -> 234.04s]  in the FSM, for ease of understanding, and have some supporting text about other
[234.04s -> 239.96s]  transitions. Or, in some cases, it can even be acceptable to leave something undefined.
[239.96s -> 244.08s]  The Internet Engineering Task Force, for example, the IETF, often doesn't completely
[244.20s -> 249.00s]  specify every FSM. The idea is that by specifying only the parts that are necessary for
[249.00s -> 253.00s]  interoperability, you can leave the specification flexible for future exploration.
[253.00s -> 258.00s]  If people use the protocol, they'll figure out if something is important, and if so,
[258.00s -> 264.00s]  can specify the extra part later. So let's walk through a real example of an FSM,
[264.00s -> 269.00s]  probably the most famous FSM on the Internet. This diagram here describes the finite
[269.12s -> 275.12s]  state machine of TCP. I know it looks very complicated. It has 12 states, but we'll
[275.12s -> 280.12s]  walk through it bit by bit, and you'll see how it all fits together.
[280.12s -> 285.12s]  First off, the diagram really has four parts, which we can look at separately.
[285.12s -> 290.12s]  These top four states are what describe how you open a TCP connection.
[292.12s -> 297.12s]  This center state, established, is when TCP is sending and receiving data.
[299.12s -> 303.12s]  It's after the connection has been established, but before it's been closed.
[303.12s -> 308.12s]  These six states describe how connections close.
[309.12s -> 314.12s]  This state at the bottom, closed, denotes the connection is closed and the node can forget about it.
[315.12s -> 320.12s]  Note that the top state is also the closed state, before we open the connection.
[321.12s -> 326.12s]  Recall that you start a TCP connection with a three-way handshake, SYN, SYNAC, ACK.
[326.24s -> 331.24s]  The client, or active opener, sends a SYN, synchronization message,
[332.24s -> 335.24s]  to a program listening for connection requests.
[336.24s -> 341.24s]  When this node receives a SYN, it responds with a SYNAC, synchronizing and acknowledging the original synchronization.
[342.24s -> 347.24s]  The active opener, on receiving the SYNAC, responds with an acknowledgement, an ACK.
[348.24s -> 354.24s]  The state diagram here describes how TCP behaves on both sides of the TCP three-way handshake.
[354.36s -> 358.36s]  A passive opener is a listener, it's a server.
[359.36s -> 363.36s]  It listens for requests for connections from active openers, clients.
[364.36s -> 372.36s]  So when a program calls listen, the socket transitions from the orange closed state to the yellow listen state.
[373.36s -> 377.36s]  The protocol takes no actions when this happens, it doesn't send any messages.
[378.36s -> 383.36s]  If the server calls close on the socket when it's in the listen state, it transitions immediately to the close state.
[384.36s -> 393.36s]  Let's walk through the three-way handshake, starting with a first step, when a client tries to open a connection and sends a SYN packet to the server.
[394.36s -> 401.36s]  We can see that this first transition for the client side of the connection is this orange arrow from closed to the SYN send state.
[404.36s -> 413.36s]  This happens when the client program calls connect, the event, and the client sends a SYN message.
[414.36s -> 422.36s]  Once the first SYN is sent, the client is in the SYN send state and the server is in the listen state.
[423.36s -> 428.36s]  When the SYN arrives at the server, this leads to this blue transition.
[429.36s -> 433.36s]  You can see the event is receiving a SYN message.
[434.36s -> 440.36s]  The action is to send a SYN ACK message in response, now the server is in the SYN receive state.
[440.48s -> 445.48s]  Let's jump back to the client. Remember, it was in the SYN send state.
[446.48s -> 451.48s]  Now, when it receives the SYN ACK from the server, it transitions to the establish state.
[452.48s -> 457.48s]  Its action is to send an ACK message, the third message of the SYN SYN ACK ACK handshake.
[458.48s -> 460.48s]  Now the client can start sending data to the server.
[461.48s -> 464.48s]  Finally, let's go back to the server, which is in the SYN receive state.
[465.48s -> 469.48s]  When it receives the ACK from the client, it transitions to the establish state and it can send data.
