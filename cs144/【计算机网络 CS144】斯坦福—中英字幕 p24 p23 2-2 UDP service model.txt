# Detected language: en (p=1.00)

[0.00s -> 6.00s]  In this video you're going to be learning about the second transport layer, UDP, or the User Datagram Protocol.
[6.00s -> 11.00s]  UDP is used by applications that don't need the guaranteed delivery service of TCP,
[11.00s -> 16.00s]  either because the application handles retransmissions in its own private way,
[16.00s -> 19.00s]  or simply just doesn't need reliable delivery.
[19.00s -> 24.00s]  UDP is much, much simpler than TCP, which is why this video is much shorter.
[24.00s -> 32.00s]  All UDP does is take application data and create a UDP datagram, then hands it to the network layer.
[32.00s -> 37.00s]  The UDP datagram simply identifies the application that the data should be sent to at the other end.
[37.00s -> 39.00s]  That's really about it.
[39.00s -> 46.00s]  As we have come to expect, the UDP datagram is encapsulated inside the data field of the IP datagram.
[46.00s -> 52.00s]  UDP provides a very simple service that should be clear from the small number of fields in the UDP header.
[52.00s -> 57.00s]  Unlike TCP that has over 10 header fields, UDP has just 4.
[57.00s -> 61.00s]  The source port indicates which application the data comes from.
[61.00s -> 66.00s]  If the far end replies, it will send a datagram with this port number as the destination
[66.00s -> 70.00s]  so that it can find its way back to the correct application at A.
[70.00s -> 76.00s]  The destination port indicates which application the data should be delivered to at the other end host.
[76.00s -> 79.00s]  The port numbers in UDP serve the same purpose as in TCP.
[79.00s -> 84.00s]  They direct incoming packets to the correct application process.
[84.00s -> 91.00s]  The 16-bit length field specifies the length of the whole UDP datagram, header plus data, in bytes.
[91.00s -> 96.00s]  The value must be at least 8 bytes because that is the length of the UDP header.
[96.00s -> 100.00s]  The UDP checksum is optional when using IPv4.
[100.00s -> 104.00s]  If the sender doesn't include a checksum, the field is filled with all zeros.
[104.00s -> 109.00s]  If a UDP checksum is used, then it's calculated over the UDP header and data.
[109.00s -> 117.00s]  In fact, the UDP checksum calculation also includes a portion of the IPv4 header as well, as shown here.
[117.00s -> 122.00s]  The calculation includes the IP source and destination addresses, and the protocol ID,
[122.00s -> 126.00s]  which has the value of 17 and tells us that the IP datagram carries UDP data.
[126.00s -> 132.00s]  You might be wondering why the UDP checksum includes part of the IP header.
[132.00s -> 135.00s]  Doesn't that violate the clean separation of layers?
[135.00s -> 137.00s]  Yes, it does.
[137.00s -> 141.00s]  The rationale for violating the layering principle and using information from the layer below
[141.00s -> 148.00s]  is that it allows the UDP layer to detect datagrams that were delivered to the wrong destination.
[148.00s -> 154.00s]  In summary, the UDP header is small, because the service it offers the application is very simple.
[154.00s -> 159.00s]  It provides a simple message protocol for sending data from an application on one host
[159.00s -> 164.00s]  that may or may not be delivered to an application on a remote host.
[164.00s -> 168.00s]  Port numbers in UDP work the same way as in TCP.
[168.00s -> 176.00s]  If process 1 on host A wants to send data to process 1 on host B that uses port 177,
[176.00s -> 182.00s]  the data is placed into a new UDP datagram with destination port 177.
[182.00s -> 188.00s]  Host A adds its own source port number so any replies can be sent to process 1 on host A.
[189.00s -> 194.00s]  The datagram is encapsulated in IP datagram and sent to host B.
[194.00s -> 199.00s]  Host B removes the UDP datagram and directs the data to process 1.
[199.00s -> 204.00s]  It's useful to think of UDP as merely a demultiplexing mechanism,
[204.00s -> 210.00s]  to divide up the stream of UDP datagrams arriving at host B and send them to the correct process.
[210.00s -> 215.00s]  In fact, some people call UDP the user demultiplexing protocol for this reason.
[215.00s -> 218.00s]  It's essentially all UDP does.
[218.00s -> 225.00s]  To sum up UDP's service model, we say that it has the following three properties shown here in the table.
[225.00s -> 228.00s]  First, it provides a connectionless datagram service.
[228.00s -> 231.00s]  No connection is established because none is needed.
[231.00s -> 235.00s]  All of the information is self-contained in the datagram.
[235.00s -> 240.00s]  It means packets may show up in any order, so if the application cares about in-order delivery,
[240.00s -> 244.00s]  it will need to re-sequence the data itself.
[244.00s -> 247.00s]  UDP is an unreliable delivery service.
[247.00s -> 251.00s]  It doesn't send any acknowledgements to let us know data reached the other end.
[251.00s -> 254.00s]  It has no mechanism to detect missing datagrams.
[254.00s -> 259.00s]  If an entire datagram is dropped along the way, UDP will not inform the application,
[259.00s -> 262.00s]  and it will not ask the source to resend the datagram.
[262.00s -> 266.00s]  However, the application might choose to ask for the data again by itself,
[266.00s -> 270.00s]  essentially building a retransmission mechanism on top of UDP.
[270.00s -> 274.00s]  Early versions of NFS, the network file system, did exactly this.
[274.00s -> 279.00s]  They decided they didn't want to use the sliding window used by TCP,
[279.00s -> 283.00s]  so they created their own inside the application.
[283.00s -> 288.00s]  UDP should sound very much like the service provided by the IP layer.
[288.00s -> 293.00s]  That's because UDP is offering little more than a simple wrapper on top of the IP layer,
[293.00s -> 299.00s]  with a means to direct the arriving data to the correct application at the other end.
[300.00s -> 303.00s]  Why do we have UDP?
[303.00s -> 307.00s]  UDP is used by applications that don't need reliable delivery,
[307.00s -> 311.00s]  such as simple request-response applications.
[311.00s -> 316.00s]  DNS, the domain name system used by the Internet to turn a hostname into an IP address,
[316.00s -> 321.00s]  uses UDP because the request is fully contained in one UDP datagram.
[321.00s -> 324.00s]  You'll learn how DNS works later,
[324.00s -> 329.00s]  but for now you just need to know that if we send a DNS request containing a hostname,
[329.00s -> 336.00s]  the DNS server will respond with an IP address we can use to send IP datagrams to the host.
[336.00s -> 340.00s]  If the request is successful, then using UDP is lightweight and fast.
[340.00s -> 344.00s]  There's no need to set up a connection before making the query.
[344.00s -> 348.00s]  If the request is unsuccessful, it simply times out and is resend.
[348.00s -> 352.00s]  This makes DNS simple and fast most of the time.
[352.00s -> 358.00s]  The DHCP, or Dynamic Host Configuration Protocol, uses UDP for the same reasons.
[358.00s -> 365.00s]  The Network Time Protocol, or NTP, also uses UDP because it, too, is a request-response protocol.
[366.00s -> 371.00s]  Some other applications use UDP because they have their own special needs
[371.00s -> 374.00s]  for retransmission, congestion control, and in-sequence delivery.
[374.00s -> 379.00s]  For example, a few real-time streaming audio and video services use UDP.
[379.00s -> 382.00s]  This is much less common than it used to be,
[382.00s -> 388.00s]  because most video and audio streams of HTTP today use TCP instead of UDP.
[388.00s -> 391.00s]  That's because they're built on top of HTTP.
[393.00s -> 400.00s]  In summary, we say that UDP provides a simpler datagram delivery service between application processes.
