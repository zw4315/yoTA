# Detected language: en (p=1.00)

[0.00s -> 5.84s]  Public-key cryptography is a critical part of most secure systems today.
[5.84s -> 9.84s]  It's different than symmetric cryptography in that there's what's called a public
[9.84s -> 12.22s]  key, a key that doesn't have to be secret.
[12.22s -> 18.00s]  You can distribute this public key freely and still communicate securely.
[18.00s -> 19.74s]  How does that work?
[19.74s -> 25.60s]  Like symmetric cryptography, public-key ciphers have three algorithms, one to generate keys,
[25.60s -> 28.36s]  one to decrypt, and one to encrypt.
[28.36s -> 31.64s]  They differ from symmetric cryptography in two ways.
[31.64s -> 39.28s]  First, the generate algorithm generates two keys, a public key k and a private key k-inverse.
[39.28s -> 43.64s]  To encrypt, you pass the public key and a plaintext to obtain a ciphertext.
[43.64s -> 49.92s]  To decrypt, you pass the private key and the ciphertext to obtain the plaintext.
[49.92s -> 54.76s]  Therefore, if you generate the keys, you can give out the public key freely, hence
[54.76s -> 59.20s]  its name, and know that only someone with the private key can decrypt something sent
[59.20s -> 62.32s]  with the public key.
[62.32s -> 65.96s]  Because the public key is reused many times, though, this means the encryption process
[65.96s -> 67.64s]  has to include randomization.
[67.64s -> 71.96s]  Otherwise, two parties that send the same message will produce the same ciphertext.
[71.96s -> 76.16s]  If you're dealing with small messages, an adversary could just exhaustively try all
[76.16s -> 77.16s]  of the messages.
[77.16s -> 82.60s]  So, for example, you can prepend some random data to the plaintext to generate the ciphertext.
[83.44s -> 85.44s]  This is kind of magic.
[85.44s -> 89.48s]  You can generate two keys, one public, one private.
[89.48s -> 94.76s]  People with the public key can send data only someone with the private key can decrypt.
[94.76s -> 98.64s]  If each side had the other's public key, then we wouldn't need symmetric cryptography
[98.64s -> 99.64s]  at all.
[99.64s -> 104.44s]  So it turns out that's not quite the case, and I'll explain why in a little bit.
[104.44s -> 108.44s]  Public cryptography is much, much more computationally expensive than symmetric cryptography,
[108.44s -> 110.36s]  so we can't just use it all the time.
[113.60s -> 120.20s]  You can use public-key cryptography for integrity as well, using something called a signature.
[120.20s -> 126.56s]  Again, you have three functions, generate, which generates a pair of keys, sign, which
[126.56s -> 131.16s]  takes the private key, and verify, which takes the public key.
[131.16s -> 134.12s]  A signature provides integrity, like a MAC.
[134.12s -> 139.56s]  You can't produce a valid signature for a message M without the private key, but anyone
[139.60s -> 142.12s]  can verify it with the public key.
[142.12s -> 150.12s]  Furthermore, you can't derive the public key from the private one.
[150.12s -> 153.52s]  So there are a lot of public-key algorithms out there.
[153.52s -> 156.44s]  For encryption, we have RSA, Rabin, and El Gamal.
[156.44s -> 160.64s]  For signatures, we have RSA, Rabin, El Gamal, and DSA.
[160.64s -> 164.72s]  But public-key algorithms work differently than symmetric ones.
[164.72s -> 168.32s]  The basic idea behind RSA, for example, is really simple.
[168.32s -> 171.84s]  Modular exponentiation of large integers.
[171.84s -> 176.80s]  However, simple transformations of a message to a number is not necessarily secure.
[176.80s -> 180.12s]  So you have to be careful in how you use them.
[180.12s -> 183.28s]  I gave one example of that earlier, how you have to add randomness.
[183.28s -> 187.60s]  So generally speaking, it's good to use existing, tested implementations of these
[187.60s -> 190.40s]  algorithms rather than try to re-implement them yourself.
[190.40s -> 193.84s]  Or you can re-implement them, but then don't use your implementation in a secure
[193.84s -> 196.08s]  system.
[196.12s -> 200.68s]  For many of these algorithms, we can use the same key for an encryption and for signing.
[200.68s -> 204.48s]  While they use the same key, though, they use very different algorithms.
[204.48s -> 209.84s]  You can't, for example, sign a document by encrypting it with a private key.
[209.84s -> 212.52s]  So I'm not going to go into all of the details, but I just want to give you a sense
[212.52s -> 216.52s]  of how one very famous of these algorithms, RSA, works.
[216.52s -> 220.44s]  RSA is named for its co-creators, Revesque, Shimmer, and Adelman.
[220.44s -> 223.36s]  They won a Turing award, the highest award in computing for it.
[223.36s -> 227.24s]  I'm presenting RSA because conceptually it's very simple.
[227.24s -> 236.08s]  To generate RSA keys, you choose two distinct, very large, prime numbers, p and q.
[236.08s -> 239.76s]  From p and q, you compute their product, n.
[239.76s -> 247.32s]  You then use p and q to derive k and k-inverse, the public and private keys.
[247.32s -> 251.60s]  You advertise n and k as the public key.
[251.60s -> 258.32s]  To encrypt a message, you consider the message m as a large number and raise it to the k power
[258.32s -> 260.60s]  then take it modulo n.
[260.60s -> 264.12s]  You send that ciphertext number.
[264.12s -> 269.88s]  To decrypt, you consider the ciphertext message m as a large number, the ciphertext message
[269.88s -> 275.48s]  c as a large number, and raise it to the k-inverse power, then take it modulo m.
[275.48s -> 281.56s]  It turns out that if you do this, you will recover the original plaintext message.
[281.56s -> 284.60s]  So you derive k and k-inverse from p and q.
[284.60s -> 290.68s]  If an adversary learns p and q, then they can generate the private key and break the system.
[290.68s -> 293.56s]  You can't derive p and q from k.
[293.56s -> 297.56s]  It turns out you also can't derive p and q from n.
[297.56s -> 299.48s]  n is the product of two primes.
[299.48s -> 303.04s]  Factoring n into p and q turns out to be computationally hard.
[303.04s -> 307.04s]  If someone figured out how to do it quickly, then all of RSA crashes down.
[307.04s -> 310.60s]  As you can imagine, a lot of people put a huge amount of effort into understanding
[310.64s -> 315.40s]  exactly how hard it is to factor a product with two prime numbers.
[315.40s -> 317.84s]  For those of you who know a bit about computational complexity, we know that the
[317.84s -> 320.76s]  problem isn't the computational class NP.
[320.76s -> 326.76s]  It's suspected to be outside class p, but it's suspected to not be NP-complete.
[326.76s -> 330.88s]  That means our best guess is that you can't do it in polynomial time, but it's not as
[330.88s -> 335.84s]  hard as the hardest problems in NP, like traveling salesman.
[335.84s -> 338.24s]  Public key cryptography seems pretty amazing.
[338.24s -> 343.36s]  You can generate two keys, distribute one publicly, that have confidentiality, integrity,
[343.36s -> 344.36s]  and authenticity.
[344.36s -> 351.92s]  Why do we use symmetric cryptography at all?
[351.92s -> 354.56s]  There is, of course, a catch.
[354.56s -> 358.12s]  Public key cryptography is much, much slower than symmetric ciphers.
[358.12s -> 360.64s]  We can do symmetric crypto at line rate.
[360.64s -> 364.60s]  Public key systems, though, have execution times in milliseconds.
[364.60s -> 370.32s]  For example, if you run RSA with a 2048-bit key, it takes nearly 6 milliseconds to decrypt
[370.32s -> 371.32s]  a message.
[371.32s -> 375.92s]  And remember, the party who has the private key does the decrypting, so if you distribute
[375.92s -> 379.20s]  your public key widely so lots of other parties can communicate with you, you're
[379.20s -> 384.28s]  the bottleneck on how many messages can be handled.
[384.28s -> 388.20s]  This is why hybrid schemes are very popular today.
[388.20s -> 392.32s]  The idea is that you start with public key cryptography and use it to encrypt a symmetric
[392.32s -> 396.68s]  key, or you use it to exchange some information, a secret session key that you use to generate
[396.68s -> 398.36s]  symmetric keys.
[398.36s -> 404.00s]  You bootstrap the secure session with public key cryptography to exchange a secret, then
[404.00s -> 406.84s]  use that secret for much more efficient symmetric cryptography.
[406.84s -> 413.84s]  If you want to see a detailed example of this, I'll cover it in the TLS video.
[413.84s -> 418.12s]  One big pitfall people run into with public key cryptography is signing an underspecified
[418.12s -> 419.56s]  message.
[419.56s -> 424.92s]  For example, if I sign a message, I should specify who the message is for and give it
[424.92s -> 426.28s]  a lifetime.
[426.28s -> 429.84s]  Otherwise, someone can simply replay the message.
[429.84s -> 433.64s]  Since my public key isn't changed very often, a signed message is valid as long
[433.64s -> 435.84s]  as people are using my public key.
[435.84s -> 439.24s]  By valid, I mean it will properly pass the verify function.
[439.24s -> 442.68s]  So you want to limit its use at the application level.
[442.68s -> 447.28s]  Otherwise, a signed message saying, you can access this file, could be taken by an adversary
[447.28s -> 448.28s]  and used.
[448.28s -> 453.32s]  Instead, you should say something like, Nick can access this file until noon on Halloween.
