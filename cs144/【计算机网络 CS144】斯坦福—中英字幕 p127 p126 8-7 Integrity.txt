# Detected language: en (p=1.00)

[0.00s -> 6.20s]  Encryption provides confidentiality, but we also need integrity.
[6.20s -> 10.24s]  For a system to be secure, we need to know that a message is actually generated by someone
[10.24s -> 13.26s]  else and no one has modified it.
[13.26s -> 16.88s]  For example, suppose we want a secure file system protocol.
[16.88s -> 21.82s]  Without integrity, an adversary could append garbage data to writes or potentially create
[21.82s -> 24.44s]  new write commands with garbage data.
[24.44s -> 27.72s]  The basic point is that secrecy is not enough.
[27.72s -> 30.48s]  Encryption can prevent someone from reading our messages, but it doesn't protect them
[30.48s -> 32.60s]  from tampering.
[32.60s -> 37.80s]  The second property of secure systems, besides confidentiality, is integrity.
[37.80s -> 40.96s]  Integrity algorithms let you know for sure that a message was generated by someone
[40.96s -> 41.96s]  with the key.
[41.96s -> 46.68s]  So assuming the key is secret, you can be assured it came from a specific program,
[46.68s -> 47.96s]  host, etc.
[47.96s -> 49.60s]  This is really useful.
[49.60s -> 53.44s]  For example, with integrity, you can know that a routing vector actually came from the
[53.44s -> 55.20s]  node it supposedly came from.
[55.20s -> 59.12s]  An adversary isn't trying to trick you into routing traffic through them.
[59.12s -> 63.56s]  You can know that the person who's making a bid and an auction actually made that bid.
[63.56s -> 67.38s]  And you can know, if you receive a message to terminate a connection, or a bad message
[67.38s -> 70.68s]  that might cause you to terminate the connection, that the message actually came
[70.68s -> 75.52s]  from the other endpoint and isn't someone trying to shut down the connection on you.
[75.52s -> 79.40s]  Generally speaking, in security, integrity usually comes first.
[79.40s -> 84.12s]  There are lots of cases where you want integrity, but confidentiality isn't that important.
[84.12s -> 91.20s]  But it's very rare that you want confidentiality without integrity.
[91.20s -> 96.76s]  Cryptographic hashes and message authentication codes are two major integrity primitives.
[96.76s -> 100.90s]  Cryptographic hashes let you safely determine that data hasn't been modified.
[100.90s -> 103.08s]  Anyone can generate a cryptographic hash.
[103.08s -> 105.52s]  They require no key.
[105.52s -> 109.38s]  It's a hash function with some special properties.
[109.38s -> 112.68s]  Cryptographic hashes are useful for storing data.
[112.68s -> 117.48s]  You can be sure no one has tampered with the data, and since no key is needed, anyone
[117.48s -> 122.04s]  can check that the data hasn't been tampered with.
[122.04s -> 126.84s]  Message authentication codes, or MACs, are a second way to verify that data hasn't
[126.84s -> 127.84s]  been modified.
[127.84s -> 132.84s]  They have all of the integrity properties that cryptographic hashes do, but they have
[132.84s -> 139.32s]  the additional property that they ensure that the person who generated the MAC has a key.
[139.32s -> 143.92s]  Only someone else with the same key can check that the MAC is correct.
[143.92s -> 146.28s]  Message authentication codes are useful in networks.
[146.28s -> 150.28s]  If you send a message and the MAC appended to it, the receiver, if they have the corresponding
[150.28s -> 155.04s]  key, can check that the message they receive is the message you sent, that you sent
[155.04s -> 158.12s]  it, and since you had to have had the key to generate the MAC.
[158.12s -> 163.96s]  In that way, MACs also provide authentication, hence their name.
[164.96s -> 169.32s]  So let's look at cryptographic hashes first.
[169.32s -> 174.52s]  A cryptographic hash is a hash function with some special properties.
[174.52s -> 180.16s]  Like an ordinary hash function, a cryptographic hash produces a fixed length output from
[180.16s -> 182.20s]  an arbitrary length input.
[182.20s -> 186.36s]  For example, I can compute a 256-bit hash from a gigabyte of data.
[186.36s -> 191.60s]  They're generally very fast to compute, faster than the network.
[191.64s -> 196.08s]  Cryptographic hashes, like normal hash functions, typically work by performing a single scan
[196.08s -> 201.24s]  of the data and performing some mathematical operations based on each byte or word.
[201.24s -> 204.60s]  That way, you don't have to keep the entire data in memory at once, you can just
[204.60s -> 208.08s]  stream through it.
[208.08s -> 212.56s]  Cryptographic hashes provide the property that they are collision resistant.
[212.56s -> 218.76s]  What this means is that if I have some data x and a hash h of x, then it's intractable
[218.80s -> 225.56s]  to generate a message y, such that the hash of y is equal to the hash of x.
[225.56s -> 227.92s]  Of course, there are many such collisions.
[227.92s -> 232.24s]  So let's say I have a 256-bit cryptographic hash.
[232.24s -> 236.88s]  There are 2 to the 256 different values this hash could take.
[236.88s -> 239.20s]  Let's say I'm hashing a gigabyte of data.
[239.20s -> 246.64s]  Well, there are 2 to the 30 bits, so 2 to the 2 to the 30 different blocks of data,
[246.64s -> 252.12s]  but only 2 to the 256 different hashes.
[252.12s -> 257.16s]  So while such collisions exist, they are very difficult to find, such that people spend
[257.16s -> 259.40s]  years trying to do so and don't.
[259.40s -> 265.36s]  You can't just try two of the different data blocks.
[265.36s -> 268.00s]  This is a very, very deep idea.
[268.00s -> 269.88s]  Make sure you understand it.
[269.88s -> 275.56s]  Given a hash value h, it is intractable to generate a piece of data that has that
[275.56s -> 277.88s]  hash value.
[277.88s -> 282.08s]  This might seem very simple, but it is amazingly powerful.
[282.08s -> 286.68s]  Given a hash value h, it is intractable to generate a piece of data that has that
[286.68s -> 289.44s]  hash value.
[289.44s -> 293.28s]  If you need to use a hash function, then use SHA-256 or SHA-512.
[293.28s -> 299.68s]  These are the SHA-secure hash algorithm 2, SHA-2 algorithms, with either 256 or 512-bit
[299.68s -> 300.68s]  hashes.
[300.68s -> 303.88s]  SHA-1 is nearly broken today.
[303.96s -> 308.20s]  There's also SHA-3, which the National Institute of Standards and Technology selected in October
[308.20s -> 313.40s]  2012 to be an alternative hash to SHA-2, which is just as strong, but based on different
[313.40s -> 315.48s]  mathematical principles.
[315.48s -> 322.60s]  That way, if there's something wrong with SHA-2, we can fall back on SHA-3.
[322.60s -> 327.68s]  SHA-2 was designed by the National Security Agency, or NSA, and published in 2001.
[327.68s -> 330.80s]  Given all the recent press on the NSA trying to build backdoors, you might think there's
[330.80s -> 331.80s]  one on SHA-2.
[332.72s -> 334.56s]  Really, chances are there isn't.
[334.56s -> 339.52s]  It's been around for over a decade, and it was vetted in a public process.
[339.52s -> 344.92s]  Anyone who is anyone in cryptography and security has taken a look, and it seems fine.
[344.92s -> 349.04s]  Raking SHA-2 would be the equivalent of developing Einstein's theory of relativity
[349.04s -> 351.04s]  and physics.
[351.04s -> 355.40s]  SHA-3 was designed by a group of security researchers and won a competition sponsored
[355.40s -> 357.84s]  by NIST for the new SHA-3.
[358.84s -> 366.84s]  Cryptographic hashes have this nice property that a small hash uniquely describes a very
[366.84s -> 368.64s]  large piece of data.
[368.64s -> 370.64s]  The basic approach is this.
[370.64s -> 374.84s]  Take your file and compute its hash to store this as H1.
[374.84s -> 377.88s]  Later, compute the hash in the file again.
[377.88s -> 380.30s]  Let's call this hash value H2.
[380.30s -> 384.32s]  If the new value doesn't match the old one, then something has changed in the file.
[384.32s -> 388.68s]  If the two are equal, then you know the file hasn't been tampered with, because nobody
[388.68s -> 395.00s]  could generate a new file or change the existing file, though it has the same hash value.
[395.00s -> 398.32s]  Something you sometimes see when you download software is someone publishes the hash of
[398.32s -> 400.68s]  the software alongside the program.
[400.68s -> 404.20s]  You can then check that what you've downloaded is what they've produced, so nobody's
[404.20s -> 408.84s]  inserted malware into the distribution after it was released.
[408.84s -> 413.12s]  One neat way you can use hashes is something called a Merkle hash tree.
[413.12s -> 417.40s]  By themselves, cryptographic hashes just tell you if the data has been modified.
[417.40s -> 422.38s]  If I have a huge file, I can tell it's been modified, but not where.
[422.38s -> 426.72s]  If you build a Merkle hash tree, you can tell which part of the file has been modified.
[426.72s -> 431.58s]  You hash small blocks of the file, then create a tree of hashes like shown here.
[431.58s -> 434.84s]  If the top level hash differs, then you know the two files differ.
[434.84s -> 438.68s]  You can then walk down the trees and in a logarithmic number of steps, figure out
[438.68s -> 441.96s]  which part of the files differ.
[441.96s -> 445.24s]  So if someone has tampered with their file, you can see if it's because someone truncated
[445.24s -> 452.68s]  it by accident, or if they inserted malicious code.
[452.68s -> 456.78s]  So cryptographic hashes are very useful, and they tell you if nobody has modified
[456.78s -> 460.56s]  the data, but they don't require a secret.
[460.56s -> 463.80s]  Anyone can generate a cryptographic hash.
[463.80s -> 467.56s]  Anyone can check a cryptographic hash.
[467.56s -> 471.28s]  Message authentication codes, though, want to provide authenticity as well.
[471.28s -> 477.84s]  You want to be sure that the program that generated the MAC has a secret.
[477.84s -> 482.40s]  So building message authentication codes is easy once we have cryptographic hashes.
[482.40s -> 485.30s]  All we need to do is incorporate the secret of the hash.
[485.30s -> 490.88s]  We can define a message authentication code, algorithm HMAC, which takes a key K and a
[490.88s -> 495.64s]  message M. All it does is prepend the key to the message and compute a hash over
[495.64s -> 496.64s]  that data.
[496.72s -> 499.68s]  You can then send just the message and the MAC.
[499.68s -> 503.36s]  To check the message authentication code, the receiver prepends the key and computes
[503.36s -> 504.36s]  the MAC.
[504.36s -> 508.24s]  They know only someone with the key could have produced the MAC.
[508.24s -> 509.40s]  So it's simple.
[509.40s -> 512.92s]  We have a cryptographically strong MAC.
[512.92s -> 515.80s]  Wrong.
[515.80s -> 518.92s]  Recall that hash functions work by iterating over the data.
[518.92s -> 522.80s]  For most hash functions, this means you incorporate the new data into the existing
[522.80s -> 524.56s]  hash value.
[524.56s -> 528.92s]  Put another way, the hash value is the intermediate state of the computation.
[528.92s -> 534.44s]  This means that if I see a message M that has a certain MAC, I can append some data
[534.44s -> 539.76s]  to M, making M', and compute the MAC for M'.
[539.76s -> 545.70s]  So as it always seems with security, this simple approach doesn't work and has vulnerabilities.
[545.70s -> 547.96s]  We need to do something smarter.
[548.96s -> 555.64s]  Luckily, that smarter approach is not much more complex.
[555.64s -> 558.92s]  Here's the right way to compute a message authentication code.
[558.92s -> 565.92s]  Take your key K and XOR it with an inner pad, let's say 0x36 repeated 64 times.
[565.92s -> 571.72s]  Take a hash of this inner key K prepended to the message.
[571.72s -> 577.92s]  Then compute an outer key by XORing K with a different outer pad, say 0x5C repeated 64
[577.92s -> 579.68s]  times.
[579.68s -> 585.52s]  Hash this outer key and the result of the inner hash.
[585.52s -> 588.32s]  So why doesn't the previous attack work?
[588.32s -> 595.20s]  Suppose your attacker appends some information to M. They don't know K. The MAC, however,
[595.20s -> 598.86s]  is made up of the hash of M, not M itself.
[598.86s -> 602.56s]  So appending to M will result in a completely different hash value.
[602.56s -> 606.14s]  The intermediate state of the computation leaked in the previous approach is hidden
[606.36s -> 608.38s]  through this inner hash.
[608.38s -> 611.70s]  So this is how MACs are generally computed today.
[611.70s -> 615.46s]  You take a cryptographic hash of a transformation of the key and the message, and a cryptographic
[615.46s -> 623.06s]  hash of a different transformation of the key and that hash.
[623.06s -> 625.86s]  So one final problem.
[625.86s -> 629.18s]  Let's say you have both confidentiality and integrity.
[629.18s -> 633.32s]  Should you encrypt the MAC or MAC the encrypted data?
[633.32s -> 637.08s]  The answer is the latter, MAC the encrypted data.
[637.08s -> 640.28s]  There are some cases where encrypting the MAC is not always secure.
[640.28s -> 642.60s]  So always MAC encrypted data.
