# Detected language: en (p=1.00)

[0.00s -> 7.80s]  Welcome. Welcome back to CS110. How's assignment one going? You guys started it? I know a
[7.80s -> 10.80s]  bunch of people have started. I've seen you in office hours. There will be more
[10.80s -> 17.92s]  office hours if not today and tomorrow definitely on Sunday and then
[17.92s -> 23.16s]  next week as well. We will have a full list available. So I hope it's
[23.16s -> 27.20s]  going alright and I hope it's not bringing back too many memories of like
[27.20s -> 30.40s]  pointer math and things that were kind of tricky to learn but you're getting
[30.40s -> 36.12s]  back up to speed and then you're learning a little more C++ etc. Let's
[36.12s -> 43.32s]  see. Sunday at noon lab signup will open up. There are most of the labs
[43.32s -> 48.52s]  sections whatever you want to call them are on Fridays right now. Like next
[48.52s -> 54.16s]  week many of you will be in your section instead of here. There are
[54.16s -> 59.76s]  a few sections on Thursdays so if you do need a Thursday section sign up try to
[59.76s -> 62.84s]  get on there and sign up as early as possible if you're like oh I can't
[62.84s -> 66.60s]  do Friday although most of you should be able to do Friday for what it's
[66.60s -> 70.80s]  worth but if you can't do that then get on there and do that. If for
[70.80s -> 75.96s]  some reason you can't find a time that fits your schedule let me know and
[75.96s -> 79.18s]  we'll try to figure something out. You do have to go to some section but we
[79.18s -> 84.42s]  will figure it out. So that's gonna open up on Sunday at noon and there's a link
[84.42s -> 89.86s]  on the class website that will go straight to the signup page. I
[89.86s -> 94.78s]  think that's about it for announcements. I think that's about it.
[94.78s -> 100.42s]  Alright let's get going. So today we're actually not gonna see any code today
[100.42s -> 106.18s]  so what we're gonna do though is we are gonna learn about the Unix version
[106.22s -> 110.94s]  6 file system. Now why do I say it like that? We're not just learning about file systems in
[110.94s -> 117.14s]  general we're gonna learn about a very specific one to show you an idea of how a file system is
[117.14s -> 122.14s]  built. It's not necessarily the way you would build one today or the way people have built
[122.14s -> 128.94s]  them for the last 20 years or so. I think the version 6 file system came out in 1978 or
[128.94s -> 134.86s]  something like that when computers were actually somewhat different but it still works and you can
[134.86s -> 141.18s]  still run an emulator and actually use that kind of file system. But it's generally, think of this
[141.18s -> 147.46s]  as a case study in how to build a file system. Okay so again don't think this is the only way
[147.46s -> 151.66s]  to do it. Don't even think this is the best way to do it necessarily but it is a way to do
[151.66s -> 154.90s]  it and it's a pretty good one and there were some very clever people who came up with it.
[154.90s -> 163.46s]  So that's what we're gonna talk about today and in fact the version 6 file system is
[163.50s -> 168.50s]  exactly the file system that you need to program assignment 2 for and I'm gonna go over three
[168.50s -> 173.54s]  examples at the end of class today which should help you think through how you're going to code
[173.54s -> 181.42s]  that up. So stick around to the end and we'll see those examples. Alright okay so if you've
[181.42s -> 189.70s]  done CS 107 or even 106 B you know that memory at least RAM in your computer is we can think of
[189.74s -> 198.54s]  it as one big long array right going from address 0 to address whatever the maximum address or the
[198.54s -> 204.26s]  maximum number of bytes of memory in your computer. One long array you can you could access it with
[204.26s -> 209.86s]  either pointer math or just an array and if the operating system allowed you to do that. In
[209.86s -> 217.22s]  fact if you took CS 107 E you'll realize that oh if I have a bare metal hardware sort of system
[217.22s -> 222.06s]  I can access all sorts of memory which also means that you can dereference null pointers
[222.06s -> 226.58s]  and nothing actually happens until later in your program when something crashes wildly.
[226.58s -> 234.60s]  But anyway there think of it as one big long byte addressable array that's the RAM system
[234.60s -> 241.42s]  and when I say byte addressable what does that mean? It means that you can adjust one byte
[241.42s -> 246.62s]  of memory at a time you can't do one bit at a time right now you can do masking and you
[246.62s -> 251.34s]  can do bit masking and so forth but you're always working on at least one byte at a time
[251.34s -> 254.74s]  meaning that if you want to read something from memory you're going to read eight bits
[254.74s -> 258.42s]  out of it and if you write something memory you're going to write eight bits to it. Okay
[258.42s -> 264.54s]  that's how RAM works. Now the disk drive on your computer and in fact many of you
[264.54s -> 270.62s]  guys don't even have disk drives in your computer you have an SSD which is a stand a solid
[271.26s -> 277.90s]  state drive which I guess is a it's not a disk drive but it is a memory system that allows you
[277.90s -> 281.90s]  to store information that persists when you turn your laptop off or crashes or whatever
[281.90s -> 288.74s]  that's what disks are all about. They are generally relatively slow although SSDs are
[288.74s -> 294.02s]  much faster because flash memory is pretty fast. It used to be that disks in fact some of you
[294.22s -> 299.50s]  possibly still have these kind of disks on your computer used to be a cylinder that was
[299.50s -> 307.10s]  actually spinning around and it has little read heads that read one byte or well they read
[307.10s -> 311.10s]  more than one byte at a time depending on the type of thing they read what we call a block at
[311.10s -> 317.10s]  a time and they would forward that to the operating system and you the operating system can
[317.10s -> 325.38s]  say save data as well. So a disk has these things called blocks on them okay or sectors
[325.38s -> 329.06s]  you can kind of use those interchangeably I'll talk about the difference in a minute
[329.06s -> 337.58s]  but we can assume that there's some fixed amount of bytes per sector. A lot of times
[337.58s -> 344.74s]  it's 512 on some disks it's as much as 4096 maybe but it's a relatively small amount but
[344.90s -> 350.14s]  that is the smallest chunk of data you can read or write from a drive okay if you want to read
[350.14s -> 354.78s]  one byte from a drive you can't you have to read all 512 and if you want to write one byte
[354.78s -> 359.58s]  you can't you have to write all 512 now if you write one byte that you sound like you
[359.58s -> 363.78s]  have to keep track of up the other 512 the operating system does or the hard drive
[363.78s -> 370.66s]  itself does or what have you but that's the way it works okay the size of the sector
[370.66s -> 377.90s]  just happens to do with the disk itself or the like the type of disk it is and so forth okay
[377.90s -> 382.82s]  so and you it's a trade-off how big your sector is it's just a trade-off on how fast
[382.82s -> 387.54s]  it is and a couple of other different things this is what it might look like and this should
[387.54s -> 394.50s]  look very similar to the memory system right you've got sector 0 sector 1 sector 2 etc sector
[394.50s -> 401.06s]  0 would be bytes 0 through 511 and it's probably a little small to read but anyway that's the like
[401.06s -> 406.66s]  this is 512 bytes and then 512 bytes and you just access it that way okay so that's how the
[406.66s -> 417.30s]  hard drive or the solid-state drive would work the API that the hard drive makes available to
[417.30s -> 422.58s]  the operating system is actually very simple it's read and write basically you can read a sector
[422.58s -> 426.18s]  and you can write a sector and that's about it you give a sector number and you read it you
[426.18s -> 429.90s]  have a second number you write it it's a little more nuanced than that but for the most part you
[429.90s -> 434.38s]  can think of it that way and again you have to write a whole sector or read a whole sector at
[434.38s -> 440.70s]  once okay that's the part that below that level you don't need to worry about okay we're
[440.70s -> 447.02s]  going to talk about kind of a much higher level of basically how do you take this thing
[447.02s -> 455.34s]  here and this memory kind of model and map files to it and map information to it that persists
[455.34s -> 463.34s]  okay all right like I said and I've already done this once or twice you may hear me say block
[463.34s -> 468.66s]  and sector kind of interchangeably it turns out that the sectors are defined on the disk
[468.66s -> 475.74s]  themselves sector 0 sector 1 etc you can have another abstraction where it might be that multiple
[476.14s -> 483.30s]  sectors are considered a block so you might have two sectors per block for our purposes and to make
[483.30s -> 488.38s]  things a little simpler except in the case where we sometimes need to think of sector versus block
[488.38s -> 492.66s]  you don't you don't really normally need to do that we are going to just consider them being
[492.66s -> 497.74s]  the same so if I say block think sector think the chunk of memory on the drive that you
[497.74s -> 504.02s]  can read and then you can write to that's that's what we're going to continue going forth
[504.30s -> 514.58s]  with this lecture okay all right so there is a diagram here again it might be a little hard
[514.58s -> 517.50s]  to see from all the way in the back so pull it up on your slides we can't see it from all the
[517.50s -> 522.62s]  way in the back but there's a there's a diagram here that we're going to talk about now as I
[522.62s -> 528.70s]  said this is one way to do a file system it happens to be the way some people decided to do
[528.70s -> 537.42s]  it for Linux or Unix version 6 back in the late 70s and what it does is it basically allows the
[537.42s -> 543.58s]  files to be written on here so that you can quickly find them depending on your definition
[543.58s -> 552.54s]  of quick and that you can read the data from the drive in a way that is more or less efficient
[552.54s -> 563.10s]  okay and we'll see what we what we mean about that as we go along okay the first block the
[563.10s -> 570.18s]  first sector or block here is special okay it's block zero it's called the boot block and we
[570.18s -> 573.94s]  are not going to worry about that for the class but the boot block is basically what happens
[573.94s -> 578.30s]  when you turn your computer on well the first thing it needs to do is it needs to start the
[578.30s -> 582.62s]  computer up and it can do that in a kind of a couple different ways the first thing computer
[582.62s -> 588.62s]  does is it actually reads from its own BIOS which is ROM memory inside the computer itself and
[588.62s -> 593.58s]  if you don't have a hard drive attached to your computer at all it will usually read something
[593.58s -> 597.42s]  from that BIOS look for a hard drive and then not find it and say something like can't find a
[597.42s -> 602.86s]  hard drive or can't find any any boot drive or something like that that's what block sector
[602.86s -> 608.46s]  one is going to be on your system and that's almost universal like hard drives kind of do
[608.46s -> 616.18s]  that and they know to do that the second block is called the super block and the super block
[616.18s -> 622.90s]  contains information about the file system itself as far as interacting with the operating
[622.90s -> 627.74s]  system okay and again these are things that are generally like put there by either when you
[627.74s -> 633.62s]  format your drive or put there when the drive is created to begin with we will not need to worry
[633.62s -> 641.58s]  about those two sectors at all okay the follow-on sectors are where things start to get
[641.58s -> 648.70s]  interesting okay the rest of the disk is made up of two different parts there is a meta
[648.70s -> 656.82s]  data part and then there is and then there is a like actual data part of the drive okay this
[656.90s -> 662.10s]  diagram it makes it look like that if you broke this up it like there's a whole bunch of meta
[662.10s -> 666.50s]  data here this whole part it's not really that much it's in fact less than 10% but we needed
[666.50s -> 670.70s]  to make this at least big enough so that you could so that you could see it to the extent
[670.70s -> 679.34s]  that you do now with meta data and data sharing this one long abstract kind of array sort of
[679.34s -> 684.38s]  thing you might be starting to sweat a little because it sounds a little bit like a heap
[684.38s -> 690.22s]  allocator all right and you might be going oh no now I've got I've got to deal with this like
[690.22s -> 695.82s]  metadata sharing the same space with the data and every time I put you some metadata I take
[695.82s -> 700.78s]  away from the actual disk space for the data itself and so forth and that's true although I
[700.78s -> 706.30s]  think this is set up a little less like integrated so that we don't have to worry
[706.30s -> 711.66s]  about it too too much okay the details of how the file system work itself are going to be enough
[711.66s -> 718.14s]  to to keep you busy so you don't have to worry too much about it being too much like the the
[718.14s -> 722.46s]  heap allocator but that's basically the same idea you've got all this memory you need to store both
[722.46s -> 727.66s]  the data itself that you're trying to store and metadata about the stuff you're going to store
[727.66s -> 731.22s]  so you can find it so you can access it so you can get information about it whether it's
[731.22s -> 736.78s]  a root directory or a file or how big it is and so forth okay what the what the permissions
[736.78s -> 742.38s]  are and all that that's set in the operating system in the thing itself okay so that's the
[742.38s -> 748.82s]  the basic idea of a file system of this file system okay you've got a couple blocks that we
[748.82s -> 753.14s]  don't worry about we've got a whole bunch of metadata in here and then we've got all the
[753.14s -> 760.18s]  rest of it being data and this is 90% of the drive and depending on the file system that
[760.18s -> 766.34s]  percentage can go up or down I don't know if you can ever if you ever really run out of
[766.34s -> 770.94s]  that metadata space how the file system actually deals with it it might just say look you're out
[770.94s -> 775.94s]  of space or it might be able to take more data out of the rest of the hardware I'm not
[775.94s -> 784.86s]  100% sure how that works and it's really not that pertinent okay all right so we have
[784.86s -> 793.06s]  file payloads that's the actual data much like the payload that you've dealt with in 107
[793.06s -> 801.18s]  if you do the heap allocator assignment and they're stored in 512 byte chunks well it sounds
[801.18s -> 806.18s]  like a good that sounds like a block size or a sector size and in fact it is okay so they
[806.18s -> 814.18s]  the file payloads are stored 512 bytes at a time unlike the heap allocator when you assign
[814.18s -> 822.42s]  a file like when you have a file it can use multiple blocks in different places on the drive
[822.46s -> 828.18s]  it does not have to be contiguous okay which is good because it might it means that you can set
[828.18s -> 832.74s]  up your file and then add to it and then you don't go moving all this data around okay there's
[832.74s -> 838.34s]  no real like necessary although I should say that your hard drive and your drive can what
[838.34s -> 842.02s]  we call fragment which means you've got all these different pieces all over the place and
[842.02s -> 848.30s]  it is not quite as efficient to to grab that data depending on the buffering on your drive
[848.30s -> 853.42s]  and so forth but again that's beyond the scope of what we're talking about now for now all we
[853.42s -> 862.46s]  need to know is 512 byte chunks for your file okay if you have a file that is one byte long
[862.46s -> 870.18s]  that file takes up 512 bytes on the drive too bad okay that's the way code plus the
[870.18s -> 875.10s]  metadata all right why is that the case because 512 is the smallest amount that we can deal with
[875.18s -> 882.94s]  and so therefore we set it up so that our file has at least 512 bytes taken off the drive okay
[882.94s -> 886.90s]  this is why tiny little files can actually end up using a lot more space than you might think
[886.90s -> 892.14s]  because the underlying space has got to be done in 512 byte chunks now that's for this operating
[892.14s -> 898.34s]  system and that's for this file system it may be that more advanced file systems have another
[898.34s -> 902.70s]  way of dealing with this so that you don't have that limitation I'm not exactly sure about
[902.86s -> 909.10s]  the newest ones or whatever but again this is one way of doing it and it's a way that's that seems
[909.10s -> 916.38s]  to work okay 512 bytes is not that much even though you do that most files are not one or
[916.38s -> 920.58s]  two bytes generally but that's that's it even if it was a zero byte file by the way it would
[920.58s -> 928.38s]  have one block associated with it and zero bytes for that okay when it's not 512 if it's more
[928.42s -> 936.06s]  than 512 well it takes more blocks yet in 512 byte chunks okay the last one if the file size
[936.06s -> 942.90s]  is not a multiple of 512 it's just a partial block so if you have a file that's 513 bytes
[942.90s -> 952.70s]  you have two blocks right and 768 more and so forth 512 by 1025 would be one more yeah
[958.70s -> 965.14s]  what's the benefit of storing it as blocks of 512 most last part it's well it's that's a good
[965.14s -> 969.74s]  question is it just to make the calculations better it's the the way they've set up the drives
[969.74s -> 973.42s]  and it's a little historical in that drives were set up that it wants to be able to read
[973.42s -> 977.46s]  that much and write that much that's really what it is why is it 512 it's multiple of two
[977.46s -> 983.62s]  I mean that's the big reason why it's 512 but the the the ability for it to do just
[983.62s -> 988.22s]  those chunks we had to find the quantum if you will somewhere so they said let's make
[989.06s -> 993.74s]  it 512 if we had made it one byte drives would be way too slow if we made it four megabytes well
[993.74s -> 998.10s]  it'd still be too slow because there'd be other issues going on yeah good question any other
[998.10s -> 1002.02s]  questions before we keep going on this what we're gonna do basically I'm gonna go through this
[1002.02s -> 1006.02s]  stuff and then we're gonna do three big examples that well they're not that big but three
[1006.02s -> 1011.38s]  examples of doing this that are that I think you'll you'll see how this works if you are a
[1011.38s -> 1020.18s]  little bit confused by it okay so this diagram down here again it's it's a little bit hard to
[1020.18s -> 1027.30s]  see but let me bump this up here there are actually there are actually there are actually
[1027.30s -> 1037.10s]  two files on here that we'll see a 32 byte file and a 1028 byte file okay and here's how
[1037.10s -> 1043.02s]  this works and it's kind of color-coded for you here okay there's the file that is in green again
[1043.02s -> 1048.98s]  I apologize to people who can't differentiate the colors but the file in green here okay is a file
[1048.98s -> 1057.86s]  that has three blocks associated 1025 1027 1028 and each one of those blocks is 512 bytes and
[1057.86s -> 1065.54s]  the file itself happens to only have one thousand and twenty eight bytes associated with it so it
[1065.54s -> 1071.42s]  uses a full block here and then a full block here and then a tiny little part of the next block
[1071.42s -> 1082.26s]  it's the way that goes okay and the other file was just a 32 byte file which is here which
[1082.26s -> 1087.58s]  is going well it's actually as it turns out so over here but the the information about it
[1087.58s -> 1103.26s]  is here and it uses this block here 32 bytes worth that's that okay question right that's good
[1103.26s -> 1107.50s]  good question would be possible for files to share a block not with this operating system
[1107.50s -> 1112.10s]  okay so if you have ten files and they're all one byte you need ten different 512 byte
[1112.10s -> 1117.38s]  blocks some other file system may have that but this one does not good question other questions
[1117.38s -> 1127.94s]  okay so let's move on um we need to track which blocks are used to store those payloads
[1127.94s -> 1134.50s]  right the whole point of this is if we've got a file spread out among the disc here well we
[1134.50s -> 1139.14s]  better be able to find it right and you might think oh maybe we'll have some sort of linked
[1139.14s -> 1142.74s]  lists where it goes one and then finds the other that's one way to do it it's not the way
[1142.74s -> 1150.46s]  this does it but that is one way to do it the way this does it is it has the blocks that are
[1150.46s -> 1156.38s]  used for the file listed in a particular place on the drive in that metadata area
[1156.38s -> 1165.78s]  okay down here okay and they will it lists them in what we call an eye node okay and an
[1165.78s -> 1171.22s]  eye node is a 32-bit data structure for this operating system it might be different for others
[1171.22s -> 1176.38s]  but for this operating system it's 32 32 bytes I'm sorry if I said bits it's 32 bytes data
[1176.38s -> 1184.06s]  structure and it stores the information about a single file okay you get things like the file
[1184.06s -> 1189.22s]  size you get the permissions you get when it was created or modified right and you get the
[1189.22s -> 1194.06s]  blocks that are all there and the important ones for that we care about are the file type
[1194.06s -> 1199.94s]  that could be either a directory or a file or a link as it turns out and also the file size
[1199.94s -> 1203.86s]  which is going to be critical and in fact the file size is the part that people get most
[1203.86s -> 1208.90s]  confused about when they look at this operating when they look at this file system okay and what
[1208.90s -> 1217.74s]  it is is this block or this eye node okay lists all that information and it has space for
[1217.74s -> 1225.26s]  up to eight different block numbers the block numbers are the ones that show which block tell
[1225.26s -> 1231.18s]  which blocks in order the file is located in okay so if you've ever had your hard drive
[1231.18s -> 1235.86s]  crash by the way and there's various ways of hard drives crashing but sometimes it can crash
[1235.86s -> 1240.78s]  and if it wipes out the metadata here you will almost never be able to get your files
[1240.78s -> 1245.58s]  back because they're spread all around the disk and they're just data and so there's no
[1245.58s -> 1252.82s]  way to reconcile where they are so the various drive manufacturers do fancy things like they
[1252.82s -> 1257.06s]  keep backups of this area somewhere else on the drive and they they do things that try to
[1257.06s -> 1261.50s]  make it so that if your hard drive does crash you can get the data back but in this case if the
[1261.50s -> 1267.74s]  metadata is gone your file is just out there 512 bytes at a time just out there so there's no
[1267.74s -> 1275.82s]  real way to to get that back easily yeah ah that's such a good question what if your
[1275.82s -> 1280.82s]  file is more than eight blocks long we will get there but what but that's a very good follow-on
[1280.82s -> 1284.94s]  question okay but we will get there and they thought of that of course because that's a good
[1284.94s -> 1295.34s]  question because if 512 512 times 8 is like 4096 and even in 1978 files were bigger than
[1295.34s -> 1302.38s]  4 kilobytes so that's a that's a good question right so that's we'll have to deal with that but
[1302.38s -> 1311.78s]  keep that in your mind for another few minutes okay regardless the iNodes themselves well they
[1311.78s -> 1318.78s]  go into blocks okay because they're that's part of the thing and what it is is you can fit 16
[1318.78s -> 1323.34s]  iNodes this diagram is a little bit off this actually only had this this diagram shows that
[1323.34s -> 1329.18s]  there's only four iNodes per block don't worry about the numbers specifically down there
[1329.18s -> 1337.18s]  just know that for this file system you can store 16 32 byte iNodes in one sector or one block okay
[1337.18s -> 1342.38s]  that's gonna be critical when you do your your assignment okay and each one of those refers
[1342.38s -> 1348.62s]  to a particular file or a particular directory on the disk and when I say directory a directory
[1348.62s -> 1353.82s]  is a file it's just a special type of file you'll see what you'll see what that means when
[1353.82s -> 1362.26s]  we do the exam okay all right so let's look a little bit more at what this iNode actually
[1362.26s -> 1371.66s]  does so the iNode 2 here okay which would be down down here in green now I'm gonna I'm
[1371.66s -> 1377.42s]  gonna make this a little bigger so you can see it but the one in green here is iNode number 2
[1377.42s -> 1382.78s]  this is considered iNode number 1 even though it's the 0th one in the block it's considered
[1382.94s -> 1387.10s]  I don't know why they named they numbered them starting at 1 you'll probably have to do a little
[1387.10s -> 1392.06s]  off by one kind of arithmetic when you do your assignment but anyway the point is we're gonna look
[1392.06s -> 1403.10s]  at iNode 2 which happens to be right there it's in block 2 or sector 2 offset 1 I guess
[1403.10s -> 1407.70s]  which is block 2 that makes sense that's where it is for now you don't need to know more
[1407.70s -> 1415.26s]  details than that okay and what it says in it in this case is it says and I guess it's offset
[1415.26s -> 1423.30s]  16 if you talk if you are talking about let's see I know sorry off that's offset 16 for the
[1423.30s -> 1430.02s]  four but don't worry about that for now it's gonna be offset of 32 bytes in that case the
[1430.02s -> 1435.46s]  in this case it's tell us that it's a regular file it says how big it is critical and then
[1435.46s -> 1440.46s]  it says how many blocks it's going to take so if you know the file size then you can start to
[1440.46s -> 1444.66s]  figure out how many blocks it needs to take and that is going to be very important to finding
[1444.66s -> 1454.18s]  out how you can traverse these these iNodes okay the blocks that are listed are 1027,
[1454.18s -> 1462.26s]  1028 and 1025 in that order so if you look at it here the first part of the file is here
[1462.42s -> 1468.10s]  beginning of the file the second part of the next 512 the wrong the next the first 512
[1468.10s -> 1474.70s]  bytes are here the second 5 I've got that wrong again it says 1027 first that's the first one
[1474.70s -> 1480.78s]  thank you and then it says 1028 is the next 512 bytes and here's the final 512 bytes now
[1480.78s -> 1485.14s]  look the operating system is going to try to put these things in order if it's got a whole
[1485.14s -> 1490.18s]  bunch of or the disk is going to depending on which discusses the operating system at least
[1490.18s -> 1494.66s]  initially it's going to try to put it in order why because that just makes the most sense but
[1494.66s -> 1499.90s]  it can't it will find it's got a list of free blocks and it just picks the next one that it
[1499.90s -> 1503.46s]  can do and this is where fragmentation comes into play and you have to be a little bit
[1503.46s -> 1507.86s]  concerned about that sometimes you've been using your disk for a long time sometimes I think your
[1507.86s -> 1513.70s]  computer is slowing down and maybe because your disk needs to be defragmented meaning hey
[1513.70s -> 1518.10s]  take all these these parts of the files that are so far apart and put them closer together
[1518.10s -> 1523.46s]  why would that matter except that they're right next to each other the disks sometimes will read
[1523.46s -> 1529.94s]  more than 512 bytes because it can and it buffers that and so forth so so that's the the big idea
[1529.94s -> 1539.38s]  there all right questions on how that works and we'll get to the question there yeah yeah
[1539.38s -> 1545.62s]  yeah the offset should be each one of these again I Ryan came up with this and he had a
[1545.62s -> 1552.42s]  different reason for doing it this way the these should be eat that you should get 16 I know per
[1552.42s -> 1559.70s]  block okay so they're 32 bytes each 16 so that's that's all when you do your assignment you'll
[1559.70s -> 1564.46s]  you'll get that what I think I'll do is I'll update this diagram and make it so the slides
[1564.46s -> 1571.06s]  are actually correct for what we're talking about here okay all right and by the way because
[1571.06s -> 1579.18s]  it is 1028 as I already mentioned the first two blocks 1027 1028 completely filled this one
[1579.18s -> 1584.78s]  only a little bit partially filled and by the way how could this happen well maybe this file was
[1584.78s -> 1589.62s]  bigger at one point or there was another file here that freed up some space and then this one
[1589.62s -> 1593.90s]  got changed and you're always saving right whenever you say if it's bigger or smaller the
[1593.90s -> 1599.50s]  disk will accommodate that in whatever way it can by deleting the by freeing and I know
[1599.50s -> 1605.78s]  are freeing a block or taking a new block and so it's just going to happen as it goes along okay
[1605.78s -> 1613.66s]  all right so as I said they're not in contiguous or sorted order you really have
[1613.66s -> 1620.22s]  no idea until you actually read off the numbers there about what it is okay I mean this is what
[1620.26s -> 1629.50s]  kind of just said about how it's it could be for one reason or the other you might and we've already
[1629.50s -> 1633.50s]  talked about this too where you might get a file system that does reuse some blocks for
[1633.50s -> 1643.94s]  or kind of double up on blocks this one does not okay all right the files I nodes tell us
[1643.94s -> 1649.62s]  where the to find the payload but as I said it's also stored on the disk itself okay that's
[1649.94s -> 1657.26s]  the part that is the 32 bytes per eye number okay and you have to be able you have to know
[1657.26s -> 1662.94s]  that right because you're going to be reading 512 byte chunks off the disk and so if you
[1662.94s -> 1670.44s]  want to find I node 3 you can do the math the calculation say oh I node 3 must be in the
[1670.44s -> 1676.22s]  first block because there's 16 in there I node 16 is also I guess I know 16 would also be in the
[1676.30s -> 1682.66s]  end of the first block I node 17 is going to be in the first node first part of the next block
[1682.66s -> 1686.30s]  okay so you have to do those calculations and when you get to your assignment next week you
[1686.30s -> 1693.50s]  will start to think about those okay and as I said you can store 16 of these side by side in
[1693.50s -> 1700.74s]  a block all right and last time I think last time I'm going to mention it if you think this
[1700.74s -> 1703.90s]  is the only way to do it it's not if you do have to know how to do this for your
[1703.90s -> 1718.34s]  assignment that's correct yeah good question if you have a block that has partial and the
[1718.34s -> 1722.10s]  question was if you what if you had a block that had partial but was partially filled and
[1722.10s -> 1725.86s]  then you added more data and still didn't fill it it would just fill right up to the
[1725.86s -> 1730.58s]  it's gonna fill it will edit the block it will what it will do is it will read in the block
[1730.90s -> 1736.94s]  do the make the change then write the whole thing back again that's what it'll actually do okay the
[1736.94s -> 1746.60s]  operating system will take care of a lot of that for you good question okay so as humans we like
[1746.60s -> 1752.62s]  to remember we don't like numbers so much okay this is not a comment on like math education
[1752.62s -> 1757.50s]  in the United States or anything this is just saying that we don't like to remember not as
[1757.66s -> 1763.14s]  remembering numbers as we are words because that's you know the way we are words are
[1763.14s -> 1770.86s]  are easy to remember it would not be so good if you had if I said hey I just put a spreadsheet
[1770.86s -> 1775.90s]  in the Dropbox at seven zero eight eight eight one slash done it all right and that's
[1775.90s -> 1779.62s]  how you had to refer to it right you go a little crazy trying to remember those things
[1779.62s -> 1785.82s]  okay this is an emoji I found today it's called like screaming face emoji or something like
[1785.82s -> 1789.82s]  that I also I also found another moment you know there's acting you know there's a thumbs up and
[1789.82s -> 1794.70s]  there's thumbs down and all those there's actually a middle finger emoji I didn't know that until I
[1794.70s -> 1797.82s]  don't think it's listed like you can't like pull it up on your phone and there it is like
[1797.82s -> 1801.78s]  you got to kind of figure know how to do I think but anyway I didn't put that one
[1801.78s -> 1806.54s]  out here but you probably could if you if you got a file name that was like this some
[1806.54s -> 1810.78s]  you could probably want that emoji but anyway we don't like that so what do we do instead
[1811.02s -> 1816.90s]  of course we use names right and we actually have paths and in Linux and Unix the paths
[1816.90s -> 1825.54s]  are an English like name or I should say a you know a string which is separated by slashes and
[1825.54s -> 1828.54s]  you've been doing this right so you've got a path that's slash user slash class
[1828.54s -> 1835.34s]  let's see this 110 slash www slash index dot HTML and that is going to be what we could
[1835.34s -> 1838.90s]  remember I mean I can actually remember that when I can't remember all those different numbers
[1838.94s -> 1843.74s]  okay so we need some sort of translation layer okay we need some sort of virtualization if you
[1843.74s -> 1851.14s]  will between going from the numbers which the computer likes to the words within paths
[1851.14s -> 1857.14s]  which we like okay and so that's handled with these special types of files called
[1857.14s -> 1862.78s]  directories right and that's what we're going to have to do and the directories are just files
[1862.78s -> 1868.66s]  meaning that a directory has an I number associated with it you follow blocks in that
[1868.66s -> 1873.06s]  I number to an actual file that has the flow not there I guess it would be here that has a
[1873.06s -> 1882.34s]  file in it in fact I'll zoom in on that over here it has information in it about the about
[1882.34s -> 1888.10s]  the files that are in that directory okay and it says the name of the file which by the way
[1888.10s -> 1893.62s]  is limited to 14 characters and here's a little tip for your assignment next week it's limited to
[1893.62s -> 1901.06s]  14 characters and there is no trailing zero at the end okay if it doesn't if it uses up
[1901.06s -> 1906.02s]  all 14 characters that makes sense like there's no if it uses all 14 they don't bother with
[1906.02s -> 1910.58s]  the new with the zero because they know you know that it's a maximum 14 so it goes the way
[1910.58s -> 1916.10s]  they described it remember back when these things were created memory was still kind of important
[1916.10s -> 1921.62s]  so we ended up with things like this and things like the y2k problem because some of you
[1921.62s -> 1929.38s]  guys were actually born out anybody born after in 2000 or after yeah youngsters the y2k problem
[1929.38s -> 1933.30s]  for what it's worth is and it I don't know if you've even heard of this but this is a big
[1933.30s -> 1939.54s]  thing back then was in 1997 or so somebody realized that people only use that most programs
[1939.54s -> 1945.50s]  only used two digits for the date and so they would use the last two digits like 1993
[1945.50s -> 1950.90s]  or 1994 whatever they would use 94 well what happens when you get up to 2000 it rolls over
[1950.90s -> 1955.82s]  to zero and then all of a sudden you don't know you think you're in 1900 instead 2000 and then
[1955.82s -> 1960.18s]  people literally thought the world was going to die and I kind of like explode or whatever at
[1960.18s -> 1964.98s]  that point and it didn't of course but most programs those days and in fact many programs
[1964.98s -> 1969.74s]  these days were written in COBOL which is a language from like the 1950s and if you
[1969.74s -> 1976.42s]  were a COBOL program in 1999 you could in 2000 buy a vacation home because lots of people
[1976.42s -> 1982.06s]  are hiring you to go fix the code that's been 30 years old or whatever anyway all right so anyway
[1982.06s -> 1986.30s]  so the as far as often as far as files are go a directory is a file I didn't show you what
[1986.30s -> 1992.26s]  else is in there a directory is a file that has the name and an eye number associated with
[1992.26s -> 1998.06s]  it okay it has the eye number in the directory so if you're looking up a file name you know
[1998.06s -> 2003.46s]  what I number to go to okay by this little by this little file and it is a real file
[2003.50s -> 2009.38s]  the operating system actually keeps the details of that file from you you can't go and say oh
[2009.38s -> 2016.54s]  let me get the actual data out of that file to to say whether to see what the files in there
[2016.54s -> 2024.54s]  are specifically it's all hidden from you you don't get access to that okay all right how do
[2024.54s -> 2031.22s]  we do this well like you actually probably could put a file name inside an inode but the problem
[2031.22s -> 2036.66s]  is file names are kind of long in fact you have the whole path associated with a file name it can
[2036.66s -> 2041.74s]  get very very very very long and we want to keep the eye nodes themselves small we want to
[2041.74s -> 2047.74s]  keep them 32 bytes and in fact if you tried to keep this entire path here in one I know that
[2047.74s -> 2051.82s]  you'd run out of space it's more than 32 bytes immediately so we don't keep the names there
[2051.82s -> 2058.22s]  this is why we keep them in the actual the actual file associated with the directory
[2058.22s -> 2065.62s]  itself okay you also don't want to linear like try to search through the actual like linear
[2065.62s -> 2069.94s]  linearly search through the I know there might be a lot of I know there might be millions of
[2069.94s -> 2074.70s]  them right so you don't want to have to try to do that every time you're looking for a file
[2074.70s -> 2078.54s]  okay that would be that would be kind of slow okay there are better ways to do it question
[2078.54s -> 2085.82s]  do file I numbers always started to okay that's a good question and we'll get there
[2085.90s -> 2092.78s]  in a little bit the file I the the only one the first I node that you care about is the one right
[2092.78s -> 2100.26s]  here that's at sector 2 offset 0 and that happens to be the root I know I number 2 right there so
[2100.26s -> 2105.26s]  I should say yeah it's actually in this file system it's 1 on newer ones it is 2 but it's
[2105.26s -> 2108.86s]  like that's the one that's the directory for root so now we're gonna know where to start
[2108.86s -> 2111.70s]  and we'll see how that manifests itself in a minute question
[2116.46s -> 2123.34s]  good question some of the superblock I believe keeps track of what I know it's had been used
[2123.34s -> 2128.38s]  or not yeah I'm not sure exactly how like the mechanics of that part of it but it does the
[2128.38s -> 2131.98s]  the operating systems keep here in the disc itself is saying hey these ones are failed
[2131.98s -> 2137.70s]  and these ones aren't yeah other questions on this so far okay we're getting there yeah
[2137.70s -> 2150.86s]  good question are the directories that the the direct the file names in here for directory
[2150.86s -> 2155.46s]  are they related to the directories on your computer they are exactly the directories on
[2155.46s -> 2160.54s]  your computer that's what they are in fact so you've got slap you've got a file for the root
[2160.54s -> 2166.26s]  you've got a file for you've got a file for user you've got a file for class you've got a
[2166.26s -> 2171.74s]  file for cs110 etc and literally on the in each one of those has its own I note associated with
[2171.74s -> 2184.58s]  it good question yeah for the I knows themselves is it something that tells you if you in use or
[2184.58s -> 2189.34s]  not in use yes same thing I mean I think it's the operating system or that sorry the disc
[2189.34s -> 2192.82s]  itself has a list of which I know they're not used and just like the blocks that are not used
[2192.82s -> 2201.26s]  yeah good question else all right let's move on a little bit so what do we do for this okay we
[2201.26s -> 2206.42s]  have a directory file type I've already kind of mentioned this a little bit we don't really need
[2206.42s -> 2212.90s]  to change our model to do this because we are going to simply say a directory is a special
[2212.90s -> 2218.20s]  kind of file but it really is just a file so we don't need to make any changes we just lay
[2218.24s -> 2224.76s]  this abstraction onto the system we've already got and we just say great now you're gonna have to
[2224.76s -> 2229.32s]  search through a bunch of files to find your directory but it's gonna be relatively fast
[2229.32s -> 2235.12s]  because you can you only have to search through a limited number to actually find that okay so
[2235.12s -> 2244.08s]  it's not too bad you the file payload the best this is again I think this is actually
[2244.08s -> 2250.28s]  supposed to be hang on that one the file payload a series 16 bytes delivers a foreign table mapping
[2250.28s -> 2255.16s]  names to eye numbers oh yeah sorry that was right this is the what we just talked about down
[2255.16s -> 2263.48s]  here we just talked about down here with the thing each one of these is 16 bytes long okay
[2263.48s -> 2270.32s]  you have 14 bytes for the file name and then 2 bytes for the number the I number that's what
[2270.32s -> 2282.36s]  that's 16 but slightly but slippers are yes that's good that's a very good question the question was
[2282.36s -> 2288.32s]  hey wait a minute what directory is this one started it's wherever the directory that mp3 dot
[2288.32s -> 2295.64s]  mp3 lives that's the file associated with this with this file here yes good good question
[2296.52s -> 2302.76s]  alright so well and when we do the examples it'll start to become a little more a little more clear
[2302.76s -> 2308.08s]  okay again the OS hides this from you it's not like you can go and look at these files yourself
[2308.08s -> 2311.80s]  even though they are just files the operating system won't let you it goes I'm not gonna let
[2311.80s -> 2317.64s]  you look inside that directory file that's for a media use it's the way it goes okay all
[2317.64s -> 2327.32s]  right let's look at block 1024 on here okay that's this one over that's this one we already
[2327.32s -> 2332.92s]  we already did look at this one as it turns out the directory contains two files okay the
[2332.92s -> 2339.28s]  total file size there is actually 32 why because each one of these slivers takes 16
[2339.28s -> 2347.16s]  bytes okay and it the first row of the table is the first file second row is the second file
[2347.16s -> 2351.96s]  and you can look through these and in fact when you do your assignment starting next week on
[2351.96s -> 2356.76s]  this stuff you will have a struct that you will lay over this information so you can walk
[2356.76s -> 2361.40s]  through those files one after the other after the other okay so it's just a bunch of 32
[2361.40s -> 2368.04s]  bytes of data and it's 16 byte chunks for each file okay and again you might ask wait what if
[2368.56s -> 2376.08s]  there were more than 16 times 500 or 512 divided by 16 number of files in the directory yeah it's
[2376.08s -> 2381.08s]  going to need multiple blocks to store that file but it's just like any other file you
[2381.08s -> 2387.08s]  hopefully have some abstraction where you can say give me an entire file or one chunk at a
[2387.08s -> 2392.60s]  time and that's exactly what the program you'll write does and you'll have to abstract that
[2392.60s -> 2399.12s]  away next week okay all right so so what you're going to do is you're going to search through
[2399.12s -> 2404.56s]  these files if you are looking for a directory or a file that is somewhere down the path you
[2404.56s -> 2410.36s]  are going this file will hold instead of saying a dot mp3 you might be looking in the
[2410.36s -> 2414.28s]  slash directory and you might be looking for the user directory well that's going to be user
[2414.28s -> 2417.88s]  and it's going to have an I number and you're going to go to there and keep doing the
[2417.88s -> 2422.32s]  process either recursively or iteratively depending on how you decide to do it
[2423.52s -> 2428.16s]  okay like I said we're going to do examples where you're going to see this in action
[2428.16s -> 2435.32s]  okay all right what does the file look up actually like how does it actually work well
[2435.32s -> 2442.84s]  if you were looking for user slash user slash class class cs110 slash example okay first we
[2442.84s -> 2448.76s]  find the inode for the slash now I've already mentioned that you know where that one is it
[2448.76s -> 2456.36s]  happens to be the first I node or I know number I number one I know number one that you go look
[2456.36s -> 2460.32s]  at so that's where you start so you don't need to go like figure something else out you say okay
[2460.32s -> 2464.68s]  I know where it's listed on the drawer what sector it is on the drive the I number and you
[2464.68s -> 2469.88s]  go there okay so you search that payload in other words you go to the file associated with
[2469.88s -> 2478.00s]  that and you search for the user token and then you find the I number associated with that
[2478.12s -> 2483.36s]  and then you go to the I know table you find that you find out where the file is for that
[2483.36s -> 2490.48s]  you go to that file you read the contents in there you will hopefully find a slash class
[2490.48s -> 2495.80s]  or a class of file and then you go to the class I know and then you find the I number
[2495.80s -> 2499.88s]  with that you go to there you find the file associated with that you go read the file and
[2499.88s -> 2507.16s]  then you find the cs110 file inside that okay and then inside that same thing it's
[2507.16s -> 2511.88s]  the same process again look at the I number go to the block associated with that and then go
[2511.88s -> 2518.20s]  and find the I number associated with the file go to that I number find all the blocks associated
[2518.20s -> 2525.20s]  with that file and read the file that's how the process works okay it's relatively fast okay
[2525.20s -> 2532.12s]  you have to look through at most one two three four different files to get to that and most
[2532.12s -> 2549.76s]  paths aren't that many different that many levels down okay good question the question was hey is
[2549.76s -> 2553.80s]  this like a binary search or something it is not you do have to do a linear search to the files
[2553.80s -> 2559.84s]  now it may be that the files are in alphabetical order but I do not think they are at all like
[2559.84s -> 2564.80s]  you cannot guarantee that anyway what happens is when you create a new file it just gets tagged
[2564.80s -> 2568.36s]  down to the end of the it's just on the end they don't resort it or anything like that so
[2568.36s -> 2573.48s]  good question but you do have to do that but again directories really don't have that many
[2573.48s -> 2579.92s]  files in them and it's pretty quick to search through 32-bit or 16-byte files it's not our
[2579.92s -> 2593.20s]  16-byte in entries in the file relatively fast question a good question are these relative
[2593.20s -> 2600.24s]  offsets or are they they're actually explicit ones they are the I number associated with that
[2600.24s -> 2606.72s]  so it's not an offset or anything it's just go to block to go to I number two starting at
[2606.72s -> 2613.20s]  sector two in the file system so in other words starting here start counting down here
[2613.20s -> 2621.76s]  until you get to that number that's how it works it's not an offset it's not necessarily
[2621.76s -> 2626.00s]  in that sector either it's in the I nodes it's somewhere and it's an I number and so
[2626.00s -> 2631.08s]  it's in the I node somewhere and you just have to figure out you do a little map trust
[2631.08s -> 2634.16s]  me for the next assignment you're gonna do some like arithmetic that's really it yeah
[2636.72s -> 2650.20s]  correct yeah two bytes is what 16,000 16,000 different high notes for this operating system
[2650.20s -> 2654.92s]  that was all I could add whatever you probably couldn't add more than 16,000 files but when the
[2654.92s -> 2659.20s]  hard drive was five megabytes it didn't really matter that much you know question
[2659.20s -> 2670.16s]  a good question what happens if there are two file names had 14 character the first 14 characters
[2670.16s -> 2673.60s]  the same but they're different file names they aren't different filenames there was no way
[2673.60s -> 2678.44s]  to make a file name longer than 14 bytes on this operating in this operating system you
[2678.44s -> 2683.40s]  were limited to that in fact DOS was that way when Microsoft DOS was that way for years
[2683.40s -> 2688.52s]  it was an 8 plus 3 in other words 8 characters then 3 character extension and then they
[2688.52s -> 2694.88s]  had to do some dead jumps in some big hoops to make it so they could put long file names
[2694.88s -> 2699.80s]  into Windows when they did it that way yeah it was a limitation nobody really thought it may
[2699.80s -> 2705.36s]  have mattered that they could do that so yeah limitations back then that were kind of important
[2705.36s -> 2719.32s]  good questions anybody else yeah oh over here sorry mister yeah you are a good question are
[2719.32s -> 2723.80s]  you limited 32 files per directory no you can have as many as you want and it wouldn't be 32
[2723.80s -> 2728.76s]  be yeah I guess it would be well 6 512 virus 16 is that 32 yeah 32 but you just have more
[2728.76s -> 2735.20s]  blocks associated with it just like any other file directory have multiple funds yes
[2735.24s -> 2740.08s]  your directory is a file which can be one block or multiple blocks up to eight and we haven't
[2740.08s -> 2742.56s]  quite gotten to this answer of like whoa what happens when there's more than eight we'll get
[2742.56s -> 2755.40s]  there yeah nope the blocks do not have to be full good question yeah this is a little bit
[2755.40s -> 2759.84s]  that they do flow show up the good question was do hidden files show up and they do I
[2759.84s -> 2764.84s]  didn't represent it here so yeah dot and dot dot do show up if you're if that's your
[2764.84s -> 2772.44s]  question everybody else okay so let's move on we got some big stuff still happening here
[2772.44s -> 2779.88s]  okay this was the question that came up earlier all right the question was I nodes can only store
[2779.88s -> 2784.92s]  eight block numbers okay they're just limited to that all right why because that's the way
[2784.92s -> 2793.08s]  they built it okay so that means ostensibly that you're limited to 8 by 512 or 4096 bytes
[2793.24s -> 2800.72s]  worth of data for a file well even back then as I said that was far smaller than files you might
[2800.72s -> 2808.68s]  want to create okay so what did they do well they had to figure out some other method to do
[2808.68s -> 2818.52s]  that and what they did was they said we had they said let's do what we call indirect addressing
[2818.84s -> 2829.92s]  okay so if you had blocks like 2001 to 2008 right you would be full right because you have
[2829.92s -> 2835.28s]  eight of those times you have 4096 bytes worth and then you the file would be full okay
[2835.28s -> 2841.80s]  once it gets bigger than that a flag is set it says oh now we have what we call a large
[2841.80s -> 2851.64s]  file okay and the large file switches everything so that instead of listing the eight blocks for
[2851.64s -> 2861.56s]  that list the data it lists blocks that themselves list blocks for data okay so what
[2861.56s -> 2868.26s]  that basically means is if you have a block before it had eight numbers in it and each one
[2868.26s -> 2871.00s]  of those you'd go to the first one and that be your data and the second would be your data
[2871.04s -> 2875.92s]  and so forth now it's going to have eight numbers in it back to the seven we'll get to that in a
[2875.92s -> 2882.20s]  few minutes and what it would what it means is each one of those points to a block and inside
[2882.20s -> 2889.08s]  here the block itself is filled with numbers that are other blocks that are your data okay
[2889.08s -> 2894.92s]  it's an indirect inception kind of thing where you've got in there you're indirectly referring
[2894.92s -> 2900.36s]  to your file by saying okay great let's have each one of these numbers go to a block
[2900.72s -> 2906.28s]  and that block has a whole bunch of numbers in them to do that now these are two byte numbers
[2906.28s -> 2914.36s]  blocks are 512 bytes each meaning that you can have 256 different blocks per indirect block
[2914.36s -> 2921.80s]  okay why because you've got one indirect block pointing to here a block I node block
[2921.80s -> 2928.60s]  number pointing to this block inside here you have 256 more numbers each one of those numbers
[2928.60s -> 2936.80s]  points to a block of actual data in that order okay that's called indirect addressing and you
[2936.80s -> 2942.76s]  can do that for every block of the original eight blocks except it's only seven and we'll get
[2942.76s -> 2947.80s]  to why in a minute okay but what does that mean that means if you did store all eight
[2947.80s -> 2955.52s]  blocks as indirect blocks okay well how much data can we store now we could store eight of those
[2955.52s -> 2961.40s]  blocks good block numbers so we have eight of them in the inode each one has 256 other block
[2961.40s -> 2970.16s]  numbers each one of those can store 512 bytes eight times 256 times 512 is one megabyte that's
[2970.16s -> 2976.84s]  how big your file could be with indirect addressing okay what questions do you have
[2976.84s -> 2981.88s]  about that so far that takes a few minutes to process first time I saw it I went oh what's
[2981.88s -> 2992.96s]  going on there yeah ah that is a good question the question was is the number of levels of
[2992.96s -> 2997.80s]  indirection limited for now all we consider if there's one level of indirection we'll
[2997.80s -> 3001.60s]  get to that in a second you're thinking one slide out of two slides ahead but yes
[3001.60s -> 3007.12s]  that for now just think there is no other for this this case one level of indirection
[3007.12s -> 3013.32s]  all we need to worry about we'll get the other in a second somebody else yes what's that you
[3013.32s -> 3024.84s]  change your mind okay anybody else have questions about this yeah good question do did we say do
[3024.84s -> 3029.16s]  do we have all the blocks using indirect addressing or just some of them you automatically
[3029.16s -> 3033.80s]  switch to a full indirection right and it means the operating system and that drive have
[3033.80s -> 3039.04s]  to do the the moving of your files I mean the minute it gets a bet bigger than 4,096 okay
[3039.04s -> 3043.48s]  they kind of whoa wait a minute we got to switch things here and then you end up going
[3043.48s -> 3048.92s]  with that and it and then if you go back to 4,095 it'll switch back again and so forth yeah
[3048.92s -> 3056.72s]  it's it's pretty dumb in that sense but it does that other questions about that okay
[3057.04s -> 3067.00s]  so you might be saying to yourself great in 1977 or 1978 a million byte file was pretty big and
[3067.00s -> 3073.52s]  they just left it at that well even in 1978 a million byte file one megabyte although it was
[3073.52s -> 3079.08s]  a big proportion of the available hard drives in general was not big enough to store all the
[3079.08s -> 3084.60s]  data that you might want to okay so they said well now what do we do right and you kind of
[3084.60s -> 3095.70s]  almost hit on what we do but what we do is we say all righty then if you have a indirect
[3095.70s -> 3101.48s]  addressing why not go to doubly indirect addressing okay and it's not as bad as you
[3101.48s -> 3105.52s]  think okay you might think well now we just go and once it gets bigger and we get we just
[3105.52s -> 3111.16s]  do everything over again like we did before it's not quite that bad okay that would probably
[3111.32s -> 3116.04s]  lead to when you hit that threshold you'd all of a sudden have to change things a lot and you
[3116.04s -> 3120.00s]  don't and it would be more movement than they wanted to do what they did was they said okay
[3120.00s -> 3128.48s]  if you use more than seven of your indirect blocks the eighth indirect block is a doubly
[3128.48s -> 3135.48s]  indirect block and what that means is and this is really inception right you have the the
[3135.48s -> 3140.24s]  seven block numbers that are going to indirect blocks each one of those goes to one that has
[3140.24s -> 3148.96s]  256 entries in it the final block number the eighth block number points to a block okay which
[3148.96s -> 3156.52s]  is filled with block numbers 256 of them each one of which goes to a block which has 256
[3156.52s -> 3164.52s]  numbers in it which each one points to a data file or data part of part of your data okay
[3164.52s -> 3171.92s]  it's an indirect scheme because you can do that right and they just they explicitly say just that
[3171.92s -> 3178.56s]  eighth block and only that eighth block if you need to use it should be interpreted as a doubly
[3178.56s -> 3183.36s]  indirect block okay so there's a couple that I'll have a summary summary down here goes to
[3183.36s -> 3187.16s]  the details here and again you'll have to figure these details out for assignment next week
[3187.16s -> 3191.52s]  and it sounds like oh this is crazy but not as bad as you think once you understand what's
[3191.52s -> 3207.80s]  happening yeah is the eighth let me explain the eighth block again okay here let me do it let
[3207.80s -> 3216.68s]  me do it this way okay you have a you have the I node here okay and the I node has seven
[3216.68s -> 3225.08s]  numbers in it okay we'll call them zero one two three four five and six and those are all
[3225.08s -> 3233.20s]  singly indirect okay they each point to one they each point to a block which has 256 data
[3233.20s -> 3238.88s]  block pointers basic or beta block I nodes okay and each one of those goes to a data
[3238.88s -> 3247.12s]  block okay that last one here okay the eighth one is a special one and it is in hot it's a
[3247.12s -> 3252.04s]  regular number just like the others that points to a block and when you go to that block you
[3252.04s -> 3259.56s]  will find 256 numbers each one of those numbers points to a block which has 256 numbers in it
[3259.56s -> 3266.12s]  which each point to data does that make sense as far as that answer your question as far as
[3266.12s -> 3270.80s]  what's happening there there's no other like there's no other abnormalities to it and it's
[3270.80s -> 3277.20s]  always the seven the eighth one and it's always the one that is used if it's necessary that's
[3277.20s -> 3286.88s]  something the back there no yes they are all two byte numbers yeah and that's in there just
[3286.88s -> 3300.68s]  two byte I know numbers that's all they are okay all right question indirect if you want to use
[3300.68s -> 3308.76s]  yes yes if your file is small enough so that it only fills in the first seven indirect block
[3308.76s -> 3312.00s]  numbers that's all you would do the minute you go over to that eighth one now it's a
[3312.00s -> 3316.40s]  doubly indirect and you have to do it that way but but it's but it's not there's no there's no
[3316.40s -> 3321.68s]  decision-making at that point the only real decision is have I gotten have I gotten bigger
[3321.68s -> 3326.72s]  than 4096 and then it goes to the indirect method and in the indirect method there's a one
[3326.72s -> 3333.28s]  of those blocks that's doubly if it's needed it's always the last one that's that okay all
[3333.28s -> 3348.16s]  right so let's are the indirect blocks still considered files the indirect blocks are no
[3348.16s -> 3352.12s]  they're just blocks in that case they're not files themselves they don't have associated
[3352.12s -> 3358.40s]  I numbers with them no they well they they have block number did not have I numbers with
[3358.84s -> 3367.08s]  good question okay let's summarize and by the way here's the final calculation by the way okay
[3367.08s -> 3378.24s]  you can have up to seven plus 256 indirect blocks why because you have seven from the seven
[3378.24s -> 3384.44s]  that you've got that are indirect right plus you have 256 more indirect blocks because of
[3384.44s -> 3392.44s]  the block that is now a doubly indirect block for a total of 263 indirect blocks each one of
[3392.44s -> 3401.32s]  which points to has 256 blocks associated with it okay and each one of those 256 blocks
[3401.32s -> 3409.12s]  let's say each one is 512 bytes meaning that you can have a total of now 34 megabytes for a
[3409.12s -> 3419.76s]  file in the UNIX version 6 file system okay 34 megabytes today is zero right so you know an
[3419.76s -> 3424.24s]  mp3 is bigger than 30 34 megabytes or what have you know most things are bigger than 34
[3424.24s -> 3429.68s]  megabytes these days but back then that was a big deal I'm gonna date myself but my first
[3429.68s -> 3434.60s]  computer didn't even have a hard drive for its worth but the when I did get a hard drive for
[3434.60s -> 3440.28s]  it was 20 megabytes and I went I will never fill that up and and it took like and it took hours to
[3440.28s -> 3445.72s]  like back it up and so forth the floppy disks and whatever but it but back then 34 megabytes was
[3445.72s -> 3449.72s]  still was pretty big back then right for the number of things that you wanted to do and if
[3449.72s -> 3454.20s]  you did need bigger files well you do just like we do today you would have to break them
[3454.20s -> 3458.64s]  into different files and somehow keep that separate from the file system and go look I just know
[3458.64s -> 3462.20s]  that my I'm gonna do this myself for files that are bigger than that you would chunk
[3462.28s -> 3469.52s]  them up yourselves but anyway point is now we've got an ACK up to 34 megabytes okay alright so to
[3469.52s -> 3479.68s]  summarize okay if a file is less than 4096 bytes okay we take those that I number and you
[3479.68s -> 3484.64s]  go to the I node associate with that I number and it's got eight block numbers in there and
[3484.64s -> 3489.16s]  it also says the file size by the way so you know how to interpret this but you go and you
[3489.16s -> 3495.92s]  find the the eight the eight block numbers are all used as a direct addressed block so
[3495.92s -> 3502.00s]  all eight of those have 512 byte bytes associated with the block that you go there you find the
[3502.00s -> 3507.04s]  data in that order and doesn't have to use all eight you can use one or two update the
[3507.04s -> 3514.52s]  instant you go above 4096 you are now a large file and for large files the first seven block
[3514.52s -> 3520.84s]  numbers are indirectly addressed meaning that each one has 256 it's each one goes to a block
[3520.84s -> 3527.44s]  which has 256 numbers in it each one of those goes to data and you do it in order if you need
[3527.44s -> 3534.04s]  to use the eighth block that eighth block is now doubly indirectly addressed meaning that it
[3534.04s -> 3540.48s]  refers to a block which has 256 block numbers which are which each refer to a block which
[3540.48s -> 3547.00s]  has 256 block number each one refers to yeah if you had 256 which refers to 512 different
[3547.00s -> 3559.80s]  ones okay that's how it works question the two byte number is a block number not an I number
[3559.80s -> 3566.16s]  correct that's a good question all right and again this goes to the question of are they
[3566.16s -> 3570.24s]  files or not they're not once they're blocks that are associated with this scheme they are
[3570.48s -> 3583.36s]  no longer considered files okay so let's yeah question sorry yeah good question where do you
[3583.36s -> 3588.56s]  store those flags that show indirect addressing the I know number itself remember it has six it
[3588.56s -> 3592.72s]  has eight numbers associated with the bytes it's 32 bytes long there's 16 bytes worth that
[3592.72s -> 3598.16s]  are just there for data metadata and it has the file type it has the size it has the flags
[3598.24s -> 3602.64s]  that are set whether it's large or not good question and you will see one when you do this
[3602.64s -> 3606.28s]  out when you do the assignment associated with this we've showed you structs that you
[3606.28s -> 3613.96s]  can use that can map right over that data anybody else okay let's do a couple of examples
[3613.96s -> 3620.80s]  all right we'll do three examples here we are going to try to locate a file called local
[3620.80s -> 3627.44s]  slash slash local slash files slash fairy tale dot txt and then we want to read that file okay
[3627.44s -> 3631.04s]  that's the first thing we're going to do then we're going to look at reading a file called slash
[3631.04s -> 3637.84s]  mead file or med file which is a medium-sized large file okay it's bigger than 4096 but not
[3637.84s -> 3648.24s]  as big as 917,504 which would be using all seven of those indirect blocks okay and then
[3648.24s -> 3653.44s]  we will go and read a file called big slash big file which is a large file which is bigger
[3653.44s -> 3663.56s]  than 917,504 bytes but smaller than 34 megabytes and by the way at that limit right there you do
[3663.56s -> 3667.04s]  have other overhead because now you've got at least two more blocks that have to be used
[3667.04s -> 3671.88s]  for your metadata and whatever but it's not not the not the biggest deal in the world when
[3671.88s -> 3677.16s]  your files are that big anyway it's a tiny tiny amount of extra data that you're using okay
[3677.16s -> 3684.08s]  all right so hopefully I came up with this diagram that actually will make sense okay
[3684.08s -> 3691.92s]  hopefully it's big enough too so we are going to look for slash local slash file slash fairy
[3691.92s -> 3702.56s]  tale dot txt here's the steps on how you do that okay you first look for the slash directory
[3702.56s -> 3710.12s]  okay we know where that lives there's no calculations necessary it lives at I number one okay and I
[3710.12s -> 3717.16s]  number one happens to be I did not put sector zero and sector one here this is sector two
[3717.16s -> 3726.80s]  sector three sector four I node one lives at sector two offset zero that is where the file
[3726.80s -> 3732.36s]  that is where the I know it lives that tells you where to go look for your root directory
[3732.80s -> 3738.68s]  okay no no calculations necessary in that sense or no thinking no like decision-making there you
[3738.68s -> 3742.72s]  go there you look it up and that's that okay so what does this say well what I've got on here
[3742.72s -> 3748.96s]  is these are the block numbers in this column here okay these are the file size I just threw
[3748.96s -> 3752.48s]  that in just so we can kind of check and see the size passes and then these are the I
[3752.48s -> 3757.88s]  numbers associated with the I know those are in order of course right you get one two three
[3757.88s -> 3764.12s]  four all the way up to however many you have remember that you only get sixteen of them
[3764.12s -> 3768.84s]  per block okay this is the arithmetic part you have to deal with now we're doing it kind
[3768.84s -> 3774.08s]  of abstractly you want to figure out the arithmetic a little bit later all right so
[3774.08s -> 3779.00s]  anyway you go to I node one that's the root you say okay what block numbers are associated
[3779.00s -> 3784.56s]  with that file twenty five okay and it's only 80 bytes long so I know I'm only gonna have
[3784.56s -> 3790.16s]  to do one block number and it's singly address or it's directly addressed not indirectly addressed
[3790.16s -> 3795.96s]  so you go to block 25 which happens to be down here and you look through the and you know that
[3795.96s -> 3798.96s]  it's a directory because it's definitely a directory because that's the whole point
[3798.96s -> 3803.44s]  and of the root and you look through and it's got some files in it now and this time so I
[3803.44s -> 3807.04s]  did put the dot and dot dot in there okay and you look through and you read that file
[3807.04s -> 3811.72s]  you go is that I'm looking for local by the way that's first thing I'm looking for is that
[3811.72s -> 3820.36s]  local no is that local no is that local yep well that means that it says oh locals I number is 16
[3820.36s -> 3829.76s]  so what do you do you go up to block I node number 16 and that must be local okay and so
[3829.76s -> 3833.16s]  you do there and you go okay what what do I need to do well it's a thousand and one
[3833.16s -> 3839.64s]  bytes long and I look at block 27 first and then I'll read 54 if I need to and you go to
[3839.64s -> 3844.88s]  block 27 which is down here and you say okay let me read through this now I'm looking for
[3844.88s -> 3851.32s]  files okay because that's the next part of our path and so in five not files not files up
[3851.32s -> 3856.32s]  there's files at I number 31 you see how this is like recursive or iterative or whatever
[3856.32s -> 3862.00s]  just keep doing that all the way through the thing sorry sorry keeps words iterative yes
[3862.00s -> 3866.32s]  um whichever one you want right but I would do it iteratively it's just easier that way
[3866.32s -> 3872.88s]  I think but anyway so you go down here and you say okay great files is at 31 okay so you go to 31
[3872.88s -> 3879.32s]  which is here and you go oh great that means I go to block 32 which is over here and now I'm
[3879.32s -> 3885.48s]  looking for fairytale dot txt and I go down here and I say okay well 30 so I go to 32 and
[3885.48s -> 3891.60s]  I look at that's not fairytale there it is block 47 and now we found our file right and
[3891.60s -> 3894.96s]  now we know it's a file we can check and see if it's a file or a director if we want to but
[3894.96s -> 3900.68s]  now we've gone there we go to 47 I number 47 which happens to be over here and you go great
[3900.68s -> 3907.80s]  it is a 1057 byte long file and so you go okay great let me start reading it I'll go to block
[3907.80s -> 3914.40s]  80 and because it's a 1057 we know that it's less than our large file differentiator right
[3914.40s -> 3919.76s]  so it's just going to be direct blocks that's nice so you go to block 80 and you go to 80
[3919.76s -> 3923.08s]  and that's going to say once upon a time there was a vast forest because it's our fairytale
[3923.28s -> 3929.04s]  and then you read the next one and this may not be in order in fact it isn't in this case you go
[3929.04s -> 3934.80s]  to 89 and says dah dah dah and the prince of soldiers start to google all right and then you
[3934.80s -> 3938.84s]  go back and that's the next one then you finally go to 87 and you get to 87 and they
[3938.84s -> 3946.76s]  lived happily ever after now until you get to 87 how much data are you going to read from each
[3946.76s -> 3950.20s]  one of these that's actually kind of a trick question how much data are you going to always
[3950.36s -> 3960.20s]  read from a sector 512 bytes how much is relevant for 80 and 89 all 512 how much is relevant for 87
[3960.20s -> 3966.96s]  well you have to do the calculation right you have to do a little either modding and dividing
[3966.96s -> 3973.56s]  and you know that arithmetic stuff right because you need to know you will read 512 bytes in fact
[3973.56s -> 3977.88s]  the disk is not going to try to figure the disk doesn't say hey you want to read 7 bytes
[3978.44s -> 3983.84s]  no it says here's 512 bytes you do that what you want it might be garbage some of its garbage and
[3983.84s -> 3989.88s]  some of it is the end of your file you do the math to figure that out okay so that's how that
[3989.88s -> 3994.72s]  works all right and then we found it and then we're done so that's that questions on that
[3994.72s -> 4004.60s]  straightforward enough I hope I mean given that this is new and able to do it you could
[4004.60s -> 4011.20s]  look through that and do it that way okay all right so then let's look at the next one here
[4011.20s -> 4018.68s]  now we want to read a file called slash need file or med file right it's a medium-sized file
[4018.68s -> 4022.60s]  well how do you do first we have to find it by the way right if you're going to do that
[4022.60s -> 4026.92s]  we I could have said oh look we know it's at this I node number well let's just actually find
[4026.92s -> 4032.24s]  it what do we do we go to the root directory we know where that lives and we go there and
[4032.44s -> 4036.44s]  it's the same one as before because I just kind of copied and pasted this over there and changed
[4036.44s -> 4041.04s]  a couple things anyway you go to block 25 you go to 25 you start reading through the files it's
[4041.04s -> 4045.16s]  not that one it's not that one it's not that one though there it is it's the file we're
[4045.16s -> 4049.36s]  looking for it is a file you can go go to the file and find out that it's actually a file
[4049.36s -> 4057.44s]  so you go to I number 16 which is here and once you're here you say okay how big is
[4057.44s -> 4062.88s]  this file 800,000 bytes well that's bigger than 4096 so I'm going to start using my
[4062.88s -> 4069.96s]  indirect addressing okay so you go great there's one two three four five six different
[4069.96s -> 4074.20s]  I know associated with this I hope I counted that right anyway and what you do is you go to
[4074.20s -> 4080.76s]  the first one you say okay let's go to block 26 well down at block 26 I know that these are
[4080.76s -> 4085.72s]  not this is not a file these are more block numbers two bytes each I go to the first one
[4085.80s -> 4090.92s]  and I go okay 80 well that's where my file starts okay so I go to file starts as it was
[4090.92s -> 4094.32s]  the best of times it was the worst of times right there and that's the first one well then
[4094.32s -> 4098.36s]  I go to the next one and that goes to 87 and 87 is over here it was the spring
[4098.36s -> 4103.52s]  of hope was winter despair etc etc okay and you do the same thing all the way through this
[4103.52s -> 4110.88s]  list right and that's going to be 256 different blocks right of 512 bytes and then you go
[4110.88s -> 4115.16s]  to the next one right and you do the same exact thing and you go to 30 and you go okay
[4115.20s -> 4121.40s]  great I'm now going to go to block 89 and I go to 89 and the accident happened in getting
[4121.40s -> 4128.68s]  out of the cart and that is the 257th data block okay because it's indirectly addressed
[4128.68s -> 4135.76s]  all right and you keep doing that all the way through in that particular order going to
[4135.76s -> 4140.40s]  going back here every time you get through the 256 going back down there doing 256 of those
[4140.40s -> 4147.40s]  etc until you get to the last one which is the last one of block 59 and you need to count right
[4147.40s -> 4152.48s]  because it might not be all 256 used right it might just be you know however many you need
[4152.48s -> 4158.56s]  you need to kind of recognize that for the last one there's going to be some off by whatever
[4158.56s -> 4165.00s]  errors depending on whether it's 50 to 512 block bytes or not good everybody with us on that
[4165.00s -> 4173.00s]  one okay hopefully that's not too bad the last one let's take a look the last one is now we're
[4173.00s -> 4178.28s]  going to try to read slash large file we first have to find it and then read it okay same thing
[4178.28s -> 4183.00s]  you first go to the root you find it you have to go to block 25 you go to block 25
[4183.00s -> 4189.36s]  which is a file you read the file you know that these are each 16 bytes each you go down you
[4189.36s -> 4195.28s]  look you're not large for there's the large file it happens to be at I number 16 you go up
[4195.28s -> 4201.48s]  to I number 16 and you go holy smokes this is an 18 megabyte long file and you go great now
[4201.48s -> 4206.96s]  it's not you have to know that but it's not quite quite as critical to know that until you
[4206.96s -> 4213.24s]  get to that last block there or that last block number right remember all of the first seven
[4213.24s -> 4219.08s]  ones are exactly indirect like we just did in the previous one okay so what do you do
[4219.32s -> 4225.72s]  you go to 26 and you go down to 26 and you read off 80 and you go to 80 and this was the beginning
[4225.72s -> 4231.12s]  of the file and then you go to 41 which I don't have on here and that's the next one in 82 etc
[4231.12s -> 4234.96s]  okay and then you're done with this one and then you do the same thing for 35 and 32 and
[4234.96s -> 4244.04s]  50 and 58 and 59 and then you finally get to block 30 in block 30 you go to block 30 you
[4244.16s -> 4253.84s]  oh I got to go to 87 but I know that it's doubly indirect so you go to 87 and 87 has more numbers
[4253.84s -> 4260.96s]  in it and the first number you go to the file there and that happens to be this 1793rd data
[4260.96s -> 4266.84s]  block because you're counting all this up right and then you do for you go through each one of
[4266.84s -> 4275.32s]  these then you go back to block 30 again you read 114 and 114 has 256 different numbers right and
[4275.32s -> 4283.80s]  those go to and and those each have 256 different numbers etc etc yeah should I what
[4283.80s -> 4293.96s]  so 87 should have let's see 87 did I do it wrong I might have done it wrong let's see
[4294.00s -> 4301.32s]  so 87 was from here 87 should be no 87 goes to 89 and that's a block number that's another
[4301.32s -> 4312.60s]  number which goes to let's see which goes to the actual data make sense you go to 30 that
[4312.60s -> 4318.20s]  has a block number right if it was indirect that would point to data but now it points to
[4318.20s -> 4327.84s]  a block which has a block pointing to data it has 256 of them here right yes the two and that's
[4327.84s -> 4331.72s]  an all I mean it could have 256 there it may not but it could have up to him just there yeah
[4331.72s -> 4344.24s]  doesn't it have to if there's not necessarily oh sorry yes you're right it because of this yes
[4344.72s -> 4349.40s]  you could have that you could have this be the last one which goes to them then it's only correct
[4349.40s -> 4369.56s]  because of the way I've done right here all right so questions yes block 30 yeah you know I
[4369.56s -> 4372.92s]  don't know if I did the math right but yeah it would have however many are necessary to get up
[4372.92s -> 4379.04s]  to the maximum file size in there yes it does not have to have 256 here right the mat that would be
[4379.04s -> 4387.16s]  if you had almost 34 megabytes worth yes correct other questions on this the kind of like yeah
[4387.16s -> 4390.88s]  hopefully this makes sense I mean the first time you see it you go oh man it's so complicated
[4390.88s -> 4395.12s]  it is pretty complicated for what it's worth but it's not unknown learnable I mean you can
[4395.12s -> 4399.00s]  certainly learn it and you just have to know how to do it and my final comment which was
[4399.04s -> 4404.52s]  exactly my first comment was don't worry about that this is the only way to do it there are many
[4404.52s -> 4412.16s]  hundreds of probably thousands of different file systems another question yes say again
[4412.16s -> 4418.56s]  one two three one two three four five six I should have done another one sorry thank you
[4418.56s -> 4425.84s]  that should be an aid thank you keeping me honest I'll fix that anyone else all right we'll
[4425.84s -> 4428.88s]  see you on Monday don't forget to sign up for labs on Sunday
