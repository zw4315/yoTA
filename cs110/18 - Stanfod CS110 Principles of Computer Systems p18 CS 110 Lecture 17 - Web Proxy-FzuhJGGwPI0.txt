# Detected language: en (p=1.00)

[0.00s -> 2.48s]  Welcome to Wednesday.
[2.48s -> 4.48s]  Hope the assignment's going well.
[4.48s -> 7.12s]  I will go back to my office right after class today.
[7.12s -> 9.12s]  I guess you get the benefit of coming to class
[9.12s -> 9.84s]  and overhearing this.
[9.84s -> 10.72s]  I'll go back to my office today
[10.72s -> 12.52s]  and then stay there for about 45 minutes
[12.52s -> 16.00s]  to an hour for anybody who has questions on homework.
[16.00s -> 18.20s]  I also have office hours tomorrow morning
[18.20s -> 21.24s]  from 10 until noon.
[21.24s -> 24.00s]  So feel free to stop by Gates 201
[24.00s -> 28.24s]  if you want to go to my office hours.
[28.24s -> 30.40s]  And then, of course, there's regular office hours
[30.40s -> 34.16s]  with the TAs this evening and tomorrow as well.
[34.16s -> 36.92s]  The assignment is due tomorrow.
[36.92s -> 38.36s]  Hopefully it's going all right.
[38.36s -> 40.34s]  Remember, this is a real file system
[40.34s -> 42.56s]  you guys are actually looking at.
[42.56s -> 45.00s]  So all the little nuanced parts to it,
[45.00s -> 46.20s]  well, that's real life.
[46.20s -> 48.20s]  That happens in real programs.
[48.20s -> 52.10s]  So you're getting a little bit of a taste of that.
[52.10s -> 54.26s]  Let's see, I put a joke up here.
[55.20s -> 57.80s]  The barman asks what the first one wants
[58.32s -> 60.20s]  to race conditions to walk into a bar.
[60.20s -> 62.74s]  So I know it's hilarious, isn't it?
[64.92s -> 69.64s]  So the joke is, you always have to explain your jokes
[69.64s -> 72.06s]  if they're not that hilarious, right?
[72.06s -> 73.80s]  So the joke is that this is a race condition.
[73.80s -> 75.24s]  We haven't really talked too much
[75.24s -> 77.72s]  about race conditions yet,
[77.72s -> 80.28s]  but we will start to see many, many race conditions.
[80.28s -> 82.06s]  We've seen a few here and there.
[82.06s -> 84.08s]  A race condition is simply
[84.08s -> 87.28s]  when two things are happening simultaneously
[87.64s -> 89.48s]  and you don't know and you can't predict
[89.48s -> 92.12s]  which one will actually get to where
[92.12s -> 93.64s]  it's trying to go first.
[93.64s -> 97.46s]  That becomes an issue if you're doing things
[97.46s -> 99.72s]  like trying to wait for something to happen
[99.72s -> 101.16s]  or rather not wait for something,
[101.16s -> 103.24s]  if you forget to wait for something to happen
[103.24s -> 106.56s]  and it may be out of order from what you expected.
[106.56s -> 108.12s]  So you have to think about that.
[108.12s -> 112.26s]  It makes programming concurrently tricky
[112.26s -> 113.72s]  because you have to think about that.
[113.72s -> 115.40s]  So today we're gonna do a few examples
[115.40s -> 117.32s]  where we're gonna see race conditions
[117.32s -> 119.84s]  and we're gonna see how one way of handling them.
[120.76s -> 125.76s]  Okay, so this is what I introduced on Monday.
[125.76s -> 128.16s]  We're talking about signals now, okay?
[128.16s -> 133.16s]  And signals are a way to send a message,
[133.40s -> 134.24s]  or not even a message,
[134.24s -> 137.68s]  basically a way to say to another process,
[137.68s -> 139.10s]  something has happened.
[139.10s -> 142.18s]  You don't even get to say like any message itself.
[142.18s -> 144.16s]  The best you can do is you can actually pass
[144.16s -> 145.72s]  a signal number,
[145.72s -> 148.42s]  which is the actual signal that gets sent,
[148.42s -> 149.84s]  but you don't get any other information.
[149.84s -> 152.14s]  If you want to pass other information
[152.14s -> 152.98s]  to the other signal,
[152.98s -> 154.44s]  you have to do it in such a way
[154.44s -> 157.88s]  that both processes have access to it,
[157.88s -> 160.00s]  which generally would mean shared memory
[160.00s -> 163.36s]  or a file or something like that.
[163.36s -> 165.74s]  And that becomes a little bit trickier to do too.
[165.74s -> 168.52s]  So it's not like you have this situation
[168.52s -> 170.12s]  where you're just signaling another process
[170.12s -> 172.30s]  and then being able to tell it lots of stuff.
[172.30s -> 174.34s]  It's gotta be a logic sort of thing.
[174.34s -> 176.26s]  Like when this signal happens,
[176.26s -> 179.14s]  you're going to do this because the signal happened.
[179.14s -> 180.94s]  That's what we're gonna do.
[180.94s -> 185.06s]  We're gonna see examples as we go through this, okay?
[185.06s -> 190.06s]  A signal handler is a function that you write
[191.06s -> 192.86s]  that goes into a process.
[192.86s -> 195.06s]  And when that signal arrives at the process,
[195.06s -> 197.58s]  the signal handler gets called, okay?
[197.58s -> 199.86s]  And the ones that we're gonna focus on
[199.86s -> 203.66s]  are when a child has some change of state,
[203.66s -> 206.94s]  when it ends, when it stops, when it's continued.
[206.94s -> 207.76s]  And we haven't even talked about
[207.76s -> 209.54s]  how you continue a child that's stopped,
[209.54s -> 210.68s]  but we'll get there.
[210.68s -> 212.96s]  And that's a function that you write
[212.96s -> 216.82s]  and it gets called when that happens, okay?
[216.82s -> 220.86s]  All right, there are lots of different types of signals.
[220.86s -> 223.18s]  As we said, there's signals that happen
[223.18s -> 225.26s]  because something bad goes wrong,
[225.26s -> 227.30s]  like you tried to divide by zero,
[227.30s -> 229.02s]  that sends a signal.
[229.06s -> 231.02s]  Or if you try to, if you do control C,
[231.02s -> 232.44s]  well, your program gets a signal
[232.44s -> 234.42s]  that it actually can't block.
[234.42s -> 237.30s]  It actually is going to kill your program, generally.
[237.30s -> 239.38s]  There's some limited ways around that,
[239.38s -> 241.58s]  but that's generally what's gonna happen.
[241.58s -> 243.98s]  And there are other types of signals
[243.98s -> 246.74s]  that you can send that are user signals.
[246.74s -> 247.78s]  There's a couple of separate ones
[247.78s -> 249.50s]  that are specifically for you
[249.50s -> 251.14s]  to use for whatever purpose you want.
[251.14s -> 254.10s]  That's another type of signal, okay?
[255.18s -> 256.28s]  All right, so as I said,
[256.32s -> 258.96s]  SIGCHLD is the one we're gonna care the most about,
[258.96s -> 260.52s]  at least for this class.
[260.52s -> 264.48s]  And it happens whenever a child process
[264.48s -> 267.32s]  of a particular parent changes state.
[267.32s -> 269.04s]  And so we're going to be able to capture that.
[269.04s -> 271.52s]  That is generally when we're going to want
[271.52s -> 275.44s]  to do our wait PID for the child
[275.44s -> 277.46s]  to actually find out what happened to the child.
[277.46s -> 278.56s]  What did it just do?
[278.56s -> 279.40s]  Did it end?
[279.40s -> 281.42s]  Did it die abnormally?
[281.42s -> 282.36s]  What happened to it?
[282.36s -> 284.52s]  So we're gonna generally see wait PIDs
[284.52s -> 288.96s]  inside of the SIGCHLD handler, okay?
[288.96s -> 291.94s]  The first one that we talked about
[291.94s -> 294.68s]  is this program that I'm gonna just retype
[294.68s -> 296.28s]  so that you kind of get the feeling
[296.28s -> 298.92s]  or you actually kind of see what it is
[298.92s -> 302.36s]  kind of in more, a little bit slower
[302.36s -> 303.80s]  so that you can kind of process what's going on.
[303.80s -> 305.92s]  I know a lot of times I've run through code really fast
[305.92s -> 307.46s]  and you go, ah, I've never seen that before.
[307.46s -> 308.40s]  How can I even process it?
[308.40s -> 310.44s]  So I'll try to like slow down a little bit
[310.44s -> 312.00s]  in that sense more often
[312.00s -> 313.50s]  and actually type things out,
[313.50s -> 314.94s]  explain as I'm typing,
[314.94s -> 319.46s]  give you a second to process it, and so forth, okay?
[320.74s -> 322.30s]  So let's start out.
[322.30s -> 324.02s]  We will write a main function.
[324.02s -> 326.32s]  This is the example that you talked about on Monday
[326.32s -> 330.22s]  where you have this model of a dad
[330.22s -> 333.86s]  taking his five children to Disneyland
[333.86s -> 335.94s]  and he lets them all go off and play.
[335.94s -> 337.70s]  They each play for a certain amount of time
[337.70s -> 338.76s]  and then they come back.
[338.76s -> 341.42s]  In the meantime, dad sleeps, okay?
[341.46s -> 343.50s]  And I actually said something on Monday
[343.50s -> 346.02s]  that I was very confused about and I figured out why.
[346.02s -> 348.00s]  It was because I hadn't typed the program in.
[348.00s -> 351.70s]  When I get there, I'll show you what I'm talking about.
[351.70s -> 353.46s]  But in this case, what we're gonna do
[353.46s -> 354.58s]  is we're gonna start out.
[354.58s -> 358.24s]  So let me put it a little higher on the screen here.
[358.24s -> 359.08s]  There we go.
[359.08s -> 361.90s]  What we're gonna do is we're going to start out here
[361.90s -> 363.74s]  and we're just gonna say printf,
[363.74s -> 368.74s]  let my five children play while I take a nap.
[371.82s -> 373.22s]  Look, if I was a dad going to Disneyland,
[373.22s -> 374.18s]  I'd be on all the rides too,
[374.18s -> 375.58s]  so I don't know what he's doing with taking the nap.
[375.58s -> 379.54s]  But anyway, that's what this dad is doing, okay?
[379.54s -> 382.84s]  And then we're gonna set up the signal handler
[382.84s -> 387.84s]  by saying signal, sig, C-H-L-D.
[387.84s -> 390.02s]  By the way, the reason they left out all those,
[390.02s -> 392.90s]  like they left out letters and things
[392.90s -> 394.94s]  is because it used to be that you had to have
[394.94s -> 399.10s]  a certain file length or a certain name length limitation.
[399.10s -> 401.62s]  And so a lot of these names are really short
[401.62s -> 403.26s]  and kinda leaving out letters
[403.26s -> 406.58s]  just because that's historical in this case.
[406.58s -> 409.14s]  So we are gonna tell it what function
[409.14s -> 412.50s]  we need to set as the signal handler.
[412.50s -> 415.46s]  In this case, it's gonna be reap child, okay?
[415.46s -> 417.10s]  And then we're going to start up
[417.10s -> 418.94s]  all these children processes, okay?
[418.94s -> 423.34s]  So we're just gonna go for size T, I equals zero,
[423.34s -> 425.56s]  I, or actually we'll start with one.
[425.56s -> 427.48s]  So we just get one, two, three, four, five.
[427.52s -> 431.84s]  I is less than or equal to five, I plus plus.
[431.84s -> 433.96s]  And then we're just gonna fork.
[433.96s -> 434.96s]  So we're gonna have this kind of,
[434.96s -> 437.74s]  we're not gonna actually capture the PID from the child.
[437.74s -> 438.84s]  But in this case, we're just gonna say,
[438.84s -> 442.52s]  if fork equals zero, that means we are the child
[442.52s -> 444.00s]  if we're in this block.
[444.00s -> 449.00s]  We're going to sleep for three times the,
[449.56s -> 451.48s]  I guess I said kid before, didn't I?
[452.32s -> 454.02s]  Do it kid like this.
[455.02s -> 459.86s]  Okay, there we go.
[459.86s -> 462.94s]  Sleep for three times, whatever the kid index is,
[462.94s -> 466.30s]  index starting at one, right?
[466.30s -> 469.50s]  Sleep in this case is gonna emulate playing,
[470.70s -> 473.10s]  playing or whatever, playing at Disneyland, okay?
[473.10s -> 476.34s]  And then after the child wakes up from the sleep
[476.34s -> 479.86s]  or finishes playing, we're just gonna say print F.
[479.86s -> 483.38s]  We're gonna say child and then because we use size T,
[483.42s -> 485.90s]  we have to use like ZU or something like that,
[485.90s -> 490.90s]  is tired, returns to dad, not data, to dad.
[492.02s -> 493.10s]  There we go.
[493.10s -> 495.58s]  I guess it makes sense in computer science.
[495.58s -> 497.42s]  Okay, so there we go.
[497.42s -> 500.30s]  And I might need a quote on there.
[500.30s -> 504.62s]  All right, and then we're going to just return zero
[504.62s -> 506.66s]  from the child, okay?
[506.66s -> 508.14s]  So that's what's gonna happen in the child.
[508.14s -> 509.90s]  We're gonna do that five times.
[509.90s -> 511.58s]  Boom, and they're gonna sleep for three seconds,
[511.58s -> 512.92s]  six seconds, nine seconds, et cetera.
[513.56s -> 514.40s]  Yeah.
[514.40s -> 516.48s]  Do you have to do the after variable there at the end
[516.48s -> 517.68s]  with the print F or?
[517.68s -> 519.88s]  Probably, thank you very much.
[519.88s -> 521.72s]  How about kid?
[521.72s -> 522.54s]  Thank you very much.
[522.54s -> 523.96s]  That would be a bad mistake.
[523.96s -> 525.80s]  Probably would have gotten a warning, I hope.
[525.80s -> 527.00s]  We'll see, good catch.
[527.00s -> 530.00s]  All right, so anyway, that's gonna be the five children
[530.00s -> 532.96s]  starting up and just sleeping for a while, okay?
[532.96s -> 535.56s]  And then we're gonna have the parent,
[535.56s -> 537.68s]  in this case, like the dad, okay?
[537.68s -> 542.68s]  While numb children done playing,
[543.60s -> 548.48s]  is less than K numb children.
[548.48s -> 551.88s]  Oops, hang on.
[551.88s -> 554.48s]  Oh no, I knew I'd do something like this.
[554.48s -> 557.06s]  I tried to do a special command
[557.06s -> 558.66s]  and of course it's not working.
[560.16s -> 562.76s]  Nope, ah, oh no.
[564.08s -> 566.20s]  Hang on, match one of 76.
[566.20s -> 568.12s]  How about we, no.
[569.16s -> 571.38s]  One, oh, oh no, what have I done?
[573.08s -> 574.28s]  Let's try it again.
[577.56s -> 580.12s]  I wonder if any of that got saved.
[580.12s -> 581.48s]  Let's see, we'll find out.
[581.48s -> 582.60s]  I don't think I saved it anyway.
[582.60s -> 587.60s]  Spring, and let's see, it's live, lecture, crossing.
[589.20s -> 591.52s]  Let's see, it did get a swap file.
[591.52s -> 593.12s]  Let's see if we can recover it.
[593.12s -> 596.72s]  Five children dot C, and
[600.12s -> 602.20s]  looks like it doesn't wanna play.
[602.60s -> 603.50s]  There it goes, okay.
[603.50s -> 604.34s]  What does it say?
[604.34s -> 606.92s]  It says file swap owned by that,
[606.92s -> 608.76s]  another program to edit in the file.
[610.44s -> 614.06s]  I want to recover it, enter.
[615.10s -> 616.72s]  Okay, some of it got saved anyway.
[616.72s -> 617.98s]  It looks like most of it did.
[617.98s -> 619.82s]  Okay, well anyway, all right, let's try this again.
[619.82s -> 621.72s]  I won't try to be fancy on this.
[621.72s -> 623.76s]  So in this, so we got the,
[623.76s -> 627.00s]  everything in there for the parent, or for the child.
[627.00s -> 629.54s]  And then the parent's going to do while numb,
[630.54s -> 633.06s]  children, what was the name of the variable there?
[633.06s -> 636.42s]  It was numb children done playing.
[636.42s -> 641.42s]  Numb children done playing
[641.92s -> 646.92s]  is less than K numb children.
[650.72s -> 652.82s]  All right, so what are we going to do?
[652.82s -> 657.82s]  We are going to print F at least one child
[658.30s -> 663.30s]  is still laying, so dad nods off.
[666.32s -> 670.06s]  Okay, and then the other day we use,
[670.06s -> 672.74s]  but in fact, earlier in this program, we used sleep.
[672.74s -> 675.04s]  I don't know if you remember that when I said that,
[675.04s -> 677.86s]  hey, it looks like the dad is waking up
[677.86s -> 679.74s]  or is not waking up when it should be.
[679.74s -> 681.66s]  And I thought that was because sleep should,
[681.66s -> 684.78s]  sleep normally stops sleeping at the point
[684.78s -> 686.84s]  where a signal is handled, actually,
[687.00s -> 687.96s]  or I guess it's not handled.
[687.96s -> 690.00s]  But anyway, it does, if a signal happens,
[690.00s -> 692.00s]  sleep will generally return.
[692.00s -> 694.08s]  What we want to do is we want to actually
[694.08s -> 697.96s]  have the dad not wake up.
[697.96s -> 698.82s]  So we're going to say snooze,
[698.82s -> 700.18s]  which is a little function we wrote
[700.18s -> 701.60s]  that just basically does this and says,
[701.60s -> 703.52s]  don't wake up if you get a signal.
[703.52s -> 704.36s]  Okay, so that's what we want to do.
[704.36s -> 706.20s]  We want it to snooze for five seconds
[706.20s -> 711.16s]  and then print F dad wakes up like that.
[711.16s -> 714.12s]  And there we go.
[714.12s -> 716.40s]  And then when you get all the children back,
[716.92s -> 720.12s]  we're just going to say print F all children
[720.12s -> 725.12s]  accounted for good job dad.
[726.64s -> 728.18s]  Pumping like that.
[728.18s -> 729.84s]  And then we're going to return zero.
[729.84s -> 731.40s]  Okay, so that's our function.
[731.40s -> 732.60s]  Let's run it.
[732.60s -> 735.26s]  Okay, make five children.
[735.26s -> 737.68s]  Okay, and when we run this, right,
[737.68s -> 740.36s]  what it does is it does all those that forking
[740.36s -> 742.24s]  and then dad nods off, child one returns
[742.24s -> 743.80s]  after three seconds, dad wakes up,
[743.80s -> 746.88s]  child's two, and then goes back to sleep.
[746.88s -> 749.28s]  Child two and three wake up while dad's sleeping
[749.28s -> 750.72s]  in that next five seconds.
[750.72s -> 752.44s]  And then dad goes back to sleep again.
[752.44s -> 755.64s]  And then child four and five also wake up,
[755.64s -> 757.08s]  a return rather.
[757.08s -> 758.44s]  And then that's it.
[758.44s -> 761.04s]  So what did I forget to do?
[763.12s -> 764.08s]  Forgot to write the function
[764.08s -> 766.44s]  that actually does anything, right?
[766.44s -> 768.40s]  So let's see, now this one I want to delete it.
[768.40s -> 769.60s]  There we go, okay.
[769.60s -> 774.60s]  So, in this case, let's see.
[775.68s -> 778.04s]  Actually, hang on one sec, John.
[778.04s -> 780.52s]  PS, no, it doesn't say it's in there.
[780.52s -> 784.56s]  Anyway, okay, so we have to actually write reap child.
[784.56s -> 786.96s]  Well, this is going to be a really simple
[786.96s -> 788.64s]  reap child in this case.
[788.64s -> 789.92s]  Okay, all it's going to do,
[789.92s -> 791.36s]  it's going to clean up after the children.
[791.36s -> 794.48s]  So it's going to do wait PID, all right?
[794.48s -> 798.24s]  And then negative one says wait for any child.
[798.48s -> 800.24s]  No, because we don't care about capturing
[800.24s -> 802.00s]  the return values at this point.
[802.00s -> 803.08s]  You would if you were doing this
[803.08s -> 805.52s]  for a little more robust program.
[805.52s -> 807.80s]  And then zero, which we'll get to changing
[807.80s -> 809.68s]  that today actually, just basically says
[809.68s -> 812.84s]  just block until that child returned.
[812.84s -> 815.04s]  But it's going to have just ended
[815.04s -> 817.64s]  because that's why the signal handler got called.
[817.64s -> 819.48s]  Okay, and then at this point,
[819.48s -> 824.36s]  we need to update the num, what was it again?
[824.40s -> 828.60s]  Num children done playing.
[829.44s -> 831.20s]  Okay, and then that should do that.
[831.20s -> 834.12s]  Now, this signal handler is in the parent
[834.12s -> 837.60s]  and it's getting called when the child ends.
[837.60s -> 838.68s]  Okay, that's how this is getting called.
[838.68s -> 839.52s]  Question.
[843.60s -> 846.48s]  If you didn't write the wait PID there,
[846.48s -> 847.30s]  that's a good question.
[847.30s -> 849.24s]  All that would really happen is it would be
[849.24s -> 850.92s]  as if you were leaking the memory.
[850.92s -> 852.20s]  I mean, you wouldn't clean up after the child.
[852.20s -> 854.84s]  Nothing else would actually happen in that case.
[854.84s -> 856.36s]  It would still actually work.
[856.36s -> 857.94s]  We can test it if you want, but that's it.
[857.94s -> 858.78s]  Any other questions on that?
[858.78s -> 860.44s]  Let's see if this one works now.
[861.64s -> 863.72s]  I just made it, five children, there we go.
[863.72s -> 866.36s]  Okay, so same thing again, waiting for three seconds
[866.36s -> 869.20s]  and then returns to dad, dad wakes up,
[869.20s -> 870.92s]  two more children are going to end
[870.92s -> 872.78s]  in the next five seconds.
[872.78s -> 877.72s]  And then finally the last two children end
[877.72s -> 880.68s]  and then dad wakes up and then we can say
[880.68s -> 882.12s]  that all children are accounted for.
[882.96s -> 884.40s]  Okay, so that's what's happening.
[884.40s -> 887.68s]  The main parent or the parent function is in that while loop
[887.68s -> 889.56s]  but just sleeping for five seconds
[889.56s -> 892.02s]  and the signal handler is happening
[892.02s -> 895.32s]  and when the dad gets done sleeping,
[895.32s -> 898.12s]  it goes, hey, all my children back, we're leaving.
[898.12s -> 898.96s]  Question.
[904.24s -> 906.20s]  Yes, that's exactly what we did when I didn't write that.
[906.20s -> 907.64s]  The question was, wait, if you didn't write
[907.64s -> 910.88s]  the reap child function, what would happen?
[910.88s -> 911.74s]  The dad would keep waking up
[912.32s -> 914.34s]  and then that global variable wouldn't be updated
[914.34s -> 916.58s]  so it would just stay at zero as it turns out.
[918.10s -> 918.92s]  Yeah.
[918.92s -> 920.76s]  When you call signal reap child,
[920.76s -> 924.30s]  are you giving it a function pointer to reap child?
[924.30s -> 925.56s]  Yeah, very good question.
[925.56s -> 930.08s]  When you call the signal function,
[930.08s -> 933.54s]  you're passing in a function pointer to reap child.
[934.74s -> 938.02s]  Why don't we give it to arguments?
[938.02s -> 940.02s]  Good question, well, you generally don't need
[940.02s -> 941.60s]  to give it arguments, it's a good question
[942.42s -> 945.96s]  but when you say signal, all it needs to know is reap child.
[945.96s -> 949.04s]  There's only one argument that reap child must take
[949.04s -> 951.64s]  and it'd have to be an integer for the signal number.
[951.64s -> 953.24s]  Which is it, yeah, good question.
[953.24s -> 954.06s]  Yeah, Ernie.
[954.06s -> 956.48s]  How does cleaning up after the children
[956.48s -> 959.76s]  like make the dad stop the number?
[959.76s -> 961.68s]  Cleaning up after the children does not do that
[961.68s -> 962.96s]  and a good question, like you're saying,
[962.96s -> 964.80s]  why does cleaning up after the children make it happen?
[964.80s -> 967.16s]  It's this that makes the dad,
[967.16s -> 968.92s]  because it's a global variable
[968.92s -> 972.24s]  that is being updated by the signal handler.
[972.24s -> 973.36s]  Now, if you're thinking, wait a minute,
[973.36s -> 976.18s]  I thought children and parents have different memories
[976.18s -> 977.92s]  and so if I update the global variable here,
[977.92s -> 979.26s]  it's not gonna update the parent.
[979.26s -> 984.26s]  Remember, this function is not happening in the child,
[984.54s -> 986.36s]  this function is happening in the parent
[986.36s -> 988.24s]  when the child ends.
[988.24s -> 990.48s]  So it in fact is the same global variable.
[992.38s -> 996.00s]  All right, so that's what happens here.
[996.00s -> 998.10s]  What if we, I guess I'll just change it here.
[998.14s -> 1000.50s]  What if we change something and say,
[1000.50s -> 1002.72s]  let's let all the children
[1005.22s -> 1008.74s]  sleep for the same amount of time?
[1009.86s -> 1011.38s]  So in other words, they're all gonna go out and play
[1011.38s -> 1012.30s]  and they're all gonna come back
[1012.30s -> 1013.30s]  with the exact same amount of time.
[1013.30s -> 1016.58s]  Let's find out what happens if we do this.
[1020.54s -> 1022.10s]  Five children, okay.
[1022.10s -> 1025.18s]  So now, same thing's gonna happen,
[1025.18s -> 1026.36s]  they all come back at the same time,
[1026.36s -> 1028.06s]  maybe in some other different order
[1028.90s -> 1033.74s]  and then five seconds later, dad wakes up again
[1033.74s -> 1037.46s]  and we got all the children back,
[1037.46s -> 1040.46s]  but somehow numChildrenDone
[1040.46s -> 1043.08s]  must not have been updated correctly.
[1043.08s -> 1045.18s]  Okay, let's actually see what happens.
[1045.18s -> 1047.62s]  Let's look at this again like this.
[1047.62s -> 1048.46s]  Let's do this.
[1048.46s -> 1051.62s]  In the handler, let's just do this,
[1051.62s -> 1056.62s]  printf numChildrenDonePlaying, like that.
[1058.06s -> 1063.06s]  And let's see, that should do it.
[1064.46s -> 1068.22s]  And it is going to be num, I'm gonna try this again.
[1068.22s -> 1069.46s]  Oh, that time it worked.
[1069.46s -> 1071.08s]  Okay, all right.
[1071.08s -> 1073.42s]  And then that should do it.
[1074.66s -> 1079.04s]  Okay, so new, five children, there we go.
[1079.04s -> 1082.32s]  All right, and so let's see what happens.
[1082.32s -> 1085.28s]  Oh, well, it looks like four of them
[1085.28s -> 1088.52s]  seem to have come back all at once
[1088.52s -> 1091.32s]  and called that signal handler once.
[1092.50s -> 1095.32s]  It turns out that if children end
[1095.32s -> 1098.28s]  at roughly the same time, this is by the way,
[1098.28s -> 1100.06s]  this is a kernel race condition
[1100.06s -> 1101.86s]  and this is how the kernel handles it.
[1101.86s -> 1104.80s]  If a bunch of children end at the same time,
[1104.80s -> 1107.82s]  the kernel will just say, fine,
[1107.82s -> 1110.04s]  I am going to call one instance
[1110.04s -> 1112.56s]  of the child handler function.
[1112.56s -> 1114.72s]  You get to deal with whether or not
[1115.48s -> 1117.76s]  what the ramifications of that is.
[1117.76s -> 1119.18s]  Okay, so it's kind of a race condition
[1119.18s -> 1120.84s]  in the sense that, in this case,
[1120.84s -> 1123.58s]  four of them were handled by only one
[1123.58s -> 1126.98s]  child handler process happening at the same time.
[1126.98s -> 1128.96s]  The nice thing about it is that
[1128.96s -> 1132.64s]  if you are already in the signal handler
[1132.64s -> 1134.52s]  and another child ends,
[1134.52s -> 1137.52s]  it will call the signal handler again.
[1137.52s -> 1140.16s]  So it's not that you lose any children,
[1140.16s -> 1141.76s]  it's just that you have to deal with
[1141.80s -> 1145.56s]  all the ones that have ended already immediately.
[1145.56s -> 1148.36s]  Okay, and you have to do that inside the child handler.
[1148.36s -> 1149.44s]  We'll see how that goes.
[1149.44s -> 1150.28s]  Yeah, question.
[1150.28s -> 1152.24s]  Just to make sure I get what you just said.
[1152.24s -> 1155.64s]  It's not that children are interrupting each other
[1155.64s -> 1157.12s]  before it's incremented,
[1157.12s -> 1159.36s]  it's that they're coming in at the same time
[1159.36s -> 1162.60s]  and the kernel says, run it once, increment it once.
[1162.60s -> 1164.08s]  Exactly, so the question,
[1164.08s -> 1165.58s]  the comment, it's a perfect comment.
[1165.58s -> 1168.64s]  The comment was, it's not that the children
[1168.64s -> 1171.20s]  are ending and not being processed
[1171.80s -> 1173.52s]  like the signal handler is not getting called for them.
[1173.52s -> 1175.48s]  It's that they're all coming in at the same time.
[1175.48s -> 1177.84s]  The function is only getting called once
[1177.84s -> 1181.80s]  and therefore when they've already ended
[1181.80s -> 1184.04s]  and that function only ends up incrementing
[1184.04s -> 1186.48s]  num children done once.
[1186.48s -> 1190.36s]  What we can do is we can modify our program
[1190.36s -> 1192.36s]  to actually say, oh, all right,
[1192.36s -> 1196.20s]  well, maybe if all those children are,
[1196.20s -> 1198.04s]  if all those children have ended
[1198.04s -> 1201.16s]  when the signal handler happens, let's do this.
[1202.00s -> 1205.84s]  While true, inside our signal handler,
[1205.84s -> 1207.52s]  I'm gonna get rid of this for now
[1207.52s -> 1210.32s]  just so we don't, because we don't need that right now.
[1210.32s -> 1215.32s]  Okay, when the, while true,
[1216.04s -> 1217.86s]  what we're gonna do is we're gonna wait
[1217.86s -> 1220.64s]  for all of the children.
[1220.64s -> 1223.78s]  Okay, and if the return value for wait PID,
[1223.78s -> 1227.98s]  which normally is the child that was just waited for,
[1227.98s -> 1232.98s]  if it returns negative, or if it returns negative one,
[1233.34s -> 1235.06s]  there were, I guess, a negative number,
[1235.06s -> 1237.62s]  it means that there are no more children waiting
[1237.62s -> 1238.82s]  in that one like thing.
[1238.82s -> 1240.38s]  Now, if another one happens to end,
[1240.38s -> 1242.78s]  it will call the signal handler again.
[1242.78s -> 1244.98s]  Okay, so it's not like you have to kind of keep waiting
[1244.98s -> 1245.82s]  and maybe it's happened.
[1245.82s -> 1247.84s]  There's no more race conditions in that case.
[1247.84s -> 1249.58s]  Okay, so what you need to do in this case
[1249.58s -> 1250.42s]  is you need to say,
[1250.42s -> 1252.66s]  oh, all right, we better capture the PID for this.
[1252.66s -> 1255.78s]  Right, and if PID is less than zero,
[1255.78s -> 1257.30s]  we're just gonna return.
[1257.62s -> 1259.18s]  So we're basically gonna break out of the while loop
[1259.18s -> 1262.26s]  after we've now handled all of the potential children
[1262.26s -> 1264.10s]  that may have ended in that case.
[1265.38s -> 1266.86s]  Okay, question, yeah.
[1266.86s -> 1271.86s]  So why is the PID less than one for the last child?
[1272.90s -> 1274.54s]  It's not less than one for the last child.
[1274.54s -> 1276.14s]  It's that we're recalling,
[1276.14s -> 1278.18s]  we're gonna call wait PID again.
[1278.18s -> 1280.72s]  There are no more children to end.
[1280.72s -> 1282.86s]  Therefore, wait PID says there's no more children
[1282.86s -> 1286.00s]  that have ended now.
[1286.00s -> 1290.28s]  Therefore, we are going to return.
[1291.84s -> 1293.42s]  Why would that help?
[1294.42s -> 1295.84s]  Why would that help?
[1295.84s -> 1297.16s]  I'm not allowed to say anything.
[1297.16s -> 1299.20s]  Well, for every child that's ended
[1299.20s -> 1300.68s]  in this little loop here, right,
[1300.68s -> 1303.36s]  it's going to stay in that loop
[1303.36s -> 1308.00s]  until it says no more children have left.
[1308.00s -> 1309.84s]  That's what's happening here.
[1309.84s -> 1311.16s]  You're not get that?
[1311.16s -> 1313.20s]  Will they finish at the same time still?
[1313.20s -> 1314.44s]  If they finish at the same time, that's okay,
[1314.44s -> 1315.40s]  but then we've got a while loop
[1315.64s -> 1316.48s]  that's gonna get the first one,
[1316.48s -> 1317.32s]  then the second one, then the third one,
[1317.32s -> 1318.92s]  then the fourth one, and it's gonna keep going
[1318.92s -> 1321.04s]  in the while loop and just keep asking them.
[1321.04s -> 1323.24s]  And one of them will end up being the one
[1323.24s -> 1325.12s]  that the wait PID captures.
[1325.12s -> 1327.08s]  We don't know which one, but one of them will.
[1327.08s -> 1328.24s]  Then we'll go through the while loop again,
[1328.24s -> 1329.72s]  and it will return a PID.
[1329.72s -> 1331.26s]  So we'll go, oh, we're not gonna break.
[1331.26s -> 1332.40s]  We're then gonna go do it again
[1332.40s -> 1333.60s]  and do it again and do it again
[1333.60s -> 1336.12s]  until all the children are captured.
[1338.64s -> 1339.94s]  Still don't get it.
[1339.94s -> 1340.78s]  You have a question about it?
[1340.78s -> 1343.12s]  Go ahead, think of a question, yeah.
[1343.12s -> 1345.88s]  So wait PID is getting called once,
[1345.88s -> 1347.32s]  but then doesn't necessarily,
[1347.32s -> 1350.40s]  so wait PID is getting called multiple times
[1350.40s -> 1353.76s]  until all the children have been taken care of.
[1353.76s -> 1355.56s]  Yes, wait PID is getting called,
[1355.56s -> 1357.04s]  well, wait PID is getting called once
[1357.04s -> 1359.04s]  when any child ends,
[1359.04s -> 1360.56s]  and then we're going into this while loop
[1360.56s -> 1362.40s]  saying, oh, let's keep waiting for children
[1362.40s -> 1364.56s]  until there are no more left.
[1364.56s -> 1366.60s]  Okay, and then we're gonna end.
[1366.60s -> 1368.88s]  Question in the back, yeah.
[1368.88s -> 1373.10s]  Does wait PID stop after all the children are done,
[1373.98s -> 1374.82s]  or all the children that were called
[1374.82s -> 1376.02s]  as part of this one return?
[1376.02s -> 1377.38s]  That is a good question.
[1377.38s -> 1379.66s]  In this case, the way we're running it right now,
[1379.66s -> 1382.58s]  it blocks while there are still children not done.
[1382.58s -> 1385.18s]  So it will wait, yeah, it'll actually wait
[1385.18s -> 1386.18s]  for all of them to be done.
[1386.18s -> 1387.10s]  Now, they're all gonna come back
[1387.10s -> 1389.62s]  in roughly the same amount of time in this case,
[1389.62s -> 1390.62s]  but that's a good point,
[1390.62s -> 1392.26s]  and we'll see how to handle that in a second
[1392.26s -> 1393.26s]  if you wanna deal with it differently.
[1393.26s -> 1394.34s]  Hosman, do you have a question?
[1394.34s -> 1395.72s]  Yeah, okay.
[1395.72s -> 1397.78s]  All right, okay.
[1397.78s -> 1399.70s]  If you're still, well, let's see what happens
[1399.70s -> 1401.22s]  when we run this.
[1401.22s -> 1406.22s]  And, okay, five children.
[1406.62s -> 1409.78s]  Okay, now it's going to go into that while loop.
[1409.78s -> 1410.82s]  They're gonna return to dad.
[1410.82s -> 1412.82s]  All five of them end up getting captured
[1412.82s -> 1415.98s]  in that while loop, and then dad wakes up,
[1415.98s -> 1418.70s]  and it did increment all, got five of,
[1418.70s -> 1422.48s]  or it incremented num children done each time.
[1422.48s -> 1423.32s]  Yeah.
[1423.32s -> 1425.46s]  So how many times is the signal handler?
[1425.46s -> 1426.52s]  Yeah, very good question.
[1426.52s -> 1428.78s]  In this case, the signal handler,
[1428.78s -> 1430.70s]  it turns out that the signal handler
[1431.14s -> 1434.14s]  is called once, as it turns out.
[1434.14s -> 1437.50s]  It may get called again, although it doesn't matter.
[1437.50s -> 1438.46s]  It doesn't actually matter
[1438.46s -> 1440.22s]  because we're calling wait PID.
[1440.22s -> 1443.22s]  Remember what wait PID does,
[1443.22s -> 1444.86s]  and this is a very good point.
[1444.86s -> 1449.86s]  In this form, when we say wait PID like this,
[1450.66s -> 1452.62s]  when we say wait PID like that,
[1452.62s -> 1457.62s]  what it says is, okay, wait for any child to finish
[1457.66s -> 1460.24s]  if there are outstanding children to finish.
[1460.68s -> 1461.96s]  Like if there's any children out there,
[1461.96s -> 1465.36s]  wait for any one of them to finish, okay?
[1465.36s -> 1470.28s]  And it will actually block until a child finishes.
[1470.28s -> 1471.96s]  If there are no more children,
[1471.96s -> 1473.80s]  because they're all already finished,
[1473.80s -> 1475.80s]  it will return negative one immediately,
[1475.80s -> 1478.28s]  and that's when we'll break out of that loop.
[1481.94s -> 1483.28s]  So to be clear here,
[1483.28s -> 1485.96s]  if you switch back to the sleep statement there,
[1485.96s -> 1488.44s]  the sleep three times kid,
[1488.44s -> 1492.08s]  would we never get the written statement about the dad?
[1492.08s -> 1493.32s]  Yeah, let's do that.
[1493.32s -> 1495.20s]  So Khalid says, whoa, wait a minute.
[1495.20s -> 1499.76s]  What if we made the following change and just said,
[1499.76s -> 1501.28s]  oh, let's see if our new method,
[1501.28s -> 1502.70s]  which we proved works for the other,
[1502.70s -> 1504.72s]  the one where they're all ending at the same time.
[1504.72s -> 1507.02s]  What if we did this now, what's gonna happen?
[1507.02s -> 1510.04s]  And his comment was, oh,
[1510.04s -> 1512.08s]  is it gonna mean that we're never going to,
[1512.08s -> 1512.92s]  like it's, we're not gonna see
[1512.92s -> 1516.20s]  all that dad wakes up business until way at the end?
[1516.20s -> 1517.04s]  Let's find out.
[1519.28s -> 1524.28s]  All right, now child's playing.
[1524.36s -> 1526.72s]  Remember now they're doing three seconds each, right?
[1526.72s -> 1528.82s]  Okay, child one returned after three seconds,
[1528.82s -> 1531.08s]  child two returned after three seconds.
[1531.08s -> 1532.90s]  Dad still hasn't woken up yet.
[1532.90s -> 1535.34s]  Child three return, child four return,
[1535.34s -> 1536.98s]  dad still hasn't woken up.
[1536.98s -> 1539.26s]  In fact, dad's trying to wake up, but guess what?
[1539.26s -> 1540.52s]  The signal handler is the part
[1540.52s -> 1541.76s]  of the program that's running.
[1541.76s -> 1544.68s]  It will not also, it's only one process now.
[1544.68s -> 1546.74s]  Even though there's two functions that could happen,
[1546.82s -> 1549.78s]  the signal handler is the one that's in this while loop,
[1549.78s -> 1552.64s]  and the dad never has a chance to actually wake up
[1552.64s -> 1555.08s]  and see if the children have ended yet.
[1555.08s -> 1559.36s]  So yes, we broke this one by doing that fancy while loop.
[1559.36s -> 1561.02s]  We gotta do something else, yeah.
[1561.02s -> 1563.86s]  So when it's running, when the signal handler is running,
[1563.86s -> 1566.18s]  it's running for the first child that returns.
[1566.18s -> 1569.86s]  It's like running on the call of the first child.
[1569.86s -> 1570.70s]  Yeah, the question is,
[1570.70s -> 1573.06s]  is the signal handler running on the call
[1573.06s -> 1574.58s]  of when the first child ends?
[1574.58s -> 1577.94s]  It could be the first, or in this case it is the first,
[1577.94s -> 1579.90s]  because they are ending at different times.
[1579.90s -> 1582.70s]  It could be many ending at the same time, calling at once.
[1582.70s -> 1583.92s]  But in this case, yes.
[1583.92s -> 1587.66s]  The signal handler starts when the first child finishes,
[1587.66s -> 1590.66s]  and then it never leaves the signal handler
[1590.66s -> 1592.54s]  until all of them finish.
[1592.54s -> 1594.42s]  This is actually not good programming.
[1594.42s -> 1597.90s]  You want your signal handler to be fast.
[1597.90s -> 1600.90s]  If you did 107e, you know that's true about interrupts.
[1600.90s -> 1602.50s]  This is basically the same sort of thing.
[1602.50s -> 1604.78s]  You want your signal handler to be in and out
[1604.78s -> 1606.18s]  as fast as you can.
[1606.18s -> 1608.82s]  So you don't want to wait for all those other children.
[1608.82s -> 1610.34s]  Remember, the dad had a job to do.
[1610.34s -> 1612.54s]  The dad was supposed to wake up and say,
[1612.54s -> 1614.18s]  oh, I'm gonna see if all my children are back,
[1614.18s -> 1617.66s]  but he couldn't until all the children got back, right?
[1617.66s -> 1619.22s]  So that's the big problem, though.
[1619.22s -> 1620.06s]  Yeah.
[1620.06s -> 1621.54s]  Has the first child actually ended
[1621.54s -> 1623.18s]  when the signal handler is called,
[1623.18s -> 1624.78s]  or is it just right before it ends?
[1624.78s -> 1627.02s]  Because otherwise, wouldn't the wait PID
[1627.02s -> 1629.46s]  not be able to capture the first child?
[1629.46s -> 1631.38s]  No, no, good question.
[1632.34s -> 1636.62s]  Is the wait PID called before or after the child ends?
[1636.62s -> 1639.58s]  It is called because the child has ended.
[1640.50s -> 1641.34s]  Okay?
[1641.34s -> 1643.14s]  So in other words, reap child gets called
[1643.14s -> 1645.18s]  when the child has ended,
[1645.18s -> 1646.74s]  and it has not been cleaned up yet.
[1646.74s -> 1647.58s]  There's no wait PID.
[1647.58s -> 1649.62s]  So the operating system is basically saying,
[1649.62s -> 1651.06s]  oh, this child has ended.
[1651.06s -> 1653.62s]  Well, I'm gonna wait around until somebody cleans it up,
[1653.62s -> 1654.82s]  until the parent cleans it up.
[1654.82s -> 1658.74s]  And so it's in the process of being finished,
[1658.74s -> 1660.62s]  but the child hasn't been cleaned up yet.
[1660.70s -> 1663.66s]  That's why it gets the PID returned at that point.
[1663.66s -> 1664.50s]  Yeah, question.
[1664.50s -> 1667.34s]  So the wait PID doesn't have any kids on the point,
[1667.34s -> 1668.98s]  does it have five?
[1668.98s -> 1671.78s]  If we print it out here,
[1671.78s -> 1674.06s]  yeah, let's see what happens when we do that.
[1675.86s -> 1676.82s]  All right, what it's gonna do,
[1676.82s -> 1679.14s]  it's going to, when each child gets back,
[1679.14s -> 1681.38s]  it's going to just do that, right?
[1681.38s -> 1684.70s]  Because by the way, it's still inside the loop, right?
[1684.70s -> 1686.14s]  It's still inside that while loop,
[1686.14s -> 1687.50s]  not leaving that while loop.
[1687.50s -> 1689.22s]  I'll show it to you again.
[1689.22s -> 1691.78s]  And then we'll see, we'll let it finish here.
[1691.78s -> 1694.06s]  And then we'll see, there we go.
[1694.06s -> 1697.10s]  Okay, so it's still in this while loop.
[1697.10s -> 1700.54s]  Remember, forever, true, while true.
[1700.54s -> 1704.94s]  It's in that while loop until wait PID returns
[1704.94s -> 1708.10s]  a negative number saying there are no more children left.
[1708.10s -> 1710.78s]  And in this case, that's really not what we'd like to do.
[1710.78s -> 1712.10s]  It's not the best coding style
[1712.10s -> 1715.46s]  because we're staying in that signal handler
[1715.46s -> 1716.58s]  until they all finish.
[1716.58s -> 1718.38s]  What if one was supposed to go on for days?
[1718.42s -> 1719.62s]  Well, the rest of the program
[1719.62s -> 1720.70s]  wouldn't be able to do anything.
[1720.70s -> 1722.86s]  So you shouldn't stay in the signal handler that long.
[1722.86s -> 1723.70s]  Yeah.
[1723.70s -> 1725.70s]  So when the other children
[1725.70s -> 1727.98s]  that are waiting for it to return,
[1727.98s -> 1730.30s]  when they do return, does it call ReapChild again
[1730.30s -> 1731.94s]  because of the signal again?
[1731.94s -> 1733.30s]  Yeah, this is a good question.
[1733.30s -> 1737.30s]  When, I believe it does, as it turns out,
[1737.30s -> 1738.46s]  call ReapChild again.
[1738.46s -> 1739.82s]  Yeah, I mean, let's do that.
[1739.82s -> 1741.46s]  Let's find out.
[1741.46s -> 1742.50s]  Let's see if we can test this.
[1742.50s -> 1744.22s]  I'm not 100% sure this is gonna do anything,
[1744.22s -> 1745.54s]  but let's test this.
[1746.50s -> 1751.42s]  ReapChild just called, okay?
[1751.42s -> 1752.50s]  I think the question was,
[1752.50s -> 1755.38s]  what happens if they've been cleaned up in here,
[1755.38s -> 1757.86s]  does another signal get generated?
[1757.86s -> 1758.78s]  I believe it will.
[1758.78s -> 1759.98s]  I'm not 100% sure.
[1759.98s -> 1763.14s]  Once it's cleaned up, it might be removed from the,
[1763.14s -> 1764.04s]  it probably is.
[1764.04s -> 1765.34s]  It's probably once it's cleaned up,
[1765.34s -> 1767.38s]  it goes, oh, I don't need to send another signal
[1767.38s -> 1768.34s]  because it's been cleaned up.
[1768.34s -> 1769.62s]  I'm guessing that's the case,
[1769.62s -> 1771.50s]  but let's just find out.
[1771.50s -> 1773.22s]  Okay, let's see how many times it's,
[1773.22s -> 1775.78s]  what we actually need to do here is,
[1776.82s -> 1780.82s]  we also need to, let's say all children are accounted for.
[1780.82s -> 1782.70s]  Let's just see if there's any other issues
[1782.70s -> 1784.66s]  maybe down here later.
[1784.66s -> 1785.94s]  So let's do another,
[1785.94s -> 1789.26s]  let's do another smooze for like three more seconds
[1789.26s -> 1790.62s]  or something like that.
[1790.62s -> 1794.86s]  Okay, make five children, five children.
[1794.86s -> 1799.56s]  Okay, so, boom, ReapChild just got called.
[1799.56s -> 1800.90s]  Now it's gonna be in ReapChild,
[1800.90s -> 1803.50s]  not calling it again until all five get done.
[1803.50s -> 1805.02s]  We know because it's in that while loop
[1805.02s -> 1807.74s]  and it's just gonna sit there and do that, okay?
[1807.74s -> 1808.90s]  And it can't, and it doesn't,
[1808.90s -> 1810.90s]  you can't call the same signal from inside.
[1810.90s -> 1811.72s]  There it goes again.
[1811.72s -> 1812.86s]  It did get called again.
[1812.86s -> 1815.64s]  So yeah, it looks like it got called for it once more
[1815.64s -> 1817.92s]  because all those children that triggered it.
[1817.92s -> 1818.76s]  So I was wrong.
[1818.76s -> 1820.58s]  It does get called at least one more time.
[1820.58s -> 1821.72s]  Now, it didn't matter
[1821.72s -> 1823.54s]  because that one would go into that while loop
[1823.54s -> 1824.38s]  and it would immediately say,
[1824.38s -> 1825.86s]  there's no more children, goodbye.
[1825.86s -> 1826.70s]  And that's it.
[1826.70s -> 1828.54s]  So there's some logic there you have to handle.
[1828.54s -> 1829.62s]  Yeah.
[1829.74s -> 1832.30s]  The SIG parameter, did ReapChild not have any information
[1832.30s -> 1834.74s]  about how many children were called together?
[1834.74s -> 1835.56s]  Good question.
[1835.56s -> 1836.94s]  The SIG, the signal parameter,
[1836.94s -> 1837.98s]  I'm gonna get rid of some of these things
[1837.98s -> 1840.56s]  because we're gonna change it again in a second.
[1840.56s -> 1845.56s]  The signal here, over here, that parameter,
[1845.78s -> 1849.12s]  all it says in this case is that it's a SIG child.
[1849.12s -> 1850.10s]  That's the only thing it gives you.
[1850.10s -> 1851.50s]  It doesn't give you any other information.
[1851.50s -> 1852.42s]  Just says, which signal?
[1852.42s -> 1854.02s]  You could ask which signal got called.
[1854.02s -> 1854.74s]  I mean, you basically look at it and go,
[1854.74s -> 1855.90s]  oh, is it the SIG child?
[1855.90s -> 1856.72s]  Yes.
[1856.72s -> 1857.56s]  That's it.
[1857.56s -> 1859.40s]  Maybe we want this to be an encompassing function
[1860.12s -> 1860.94s]  that could capture many signals
[1860.94s -> 1862.16s]  and maybe you want to know which signal
[1862.16s -> 1863.62s]  actually triggered it.
[1863.62s -> 1864.72s]  So that's how you do that.
[1864.72s -> 1865.56s]  Yeah, Erin.
[1865.56s -> 1868.20s]  So in this case, aren't all of the child processes
[1868.20s -> 1871.52s]  not created yet with the ReapChild called at the start?
[1871.52s -> 1873.28s]  So do we just like pause it?
[1873.28s -> 1874.12s]  Ah, be careful.
[1874.12s -> 1876.16s]  Do you mean ReapChild's called right here?
[1877.16s -> 1878.44s]  It is not called there.
[1878.44s -> 1880.88s]  This is just simply calling signal
[1880.88s -> 1882.92s]  with a function pointer to ReapChild
[1882.92s -> 1885.16s]  saying that when a child ends,
[1885.16s -> 1887.60s]  that's when ReapChild gets called.
[1887.80s -> 1888.64s]  When the first one ends,
[1888.64s -> 1892.04s]  the rest of them still haven't been created yet?
[1892.04s -> 1892.88s]  That's a good question.
[1892.88s -> 1895.28s]  It may be the case that the rest of them
[1895.28s -> 1896.44s]  haven't been created yet.
[1896.44s -> 1897.40s]  By the time, you're right.
[1897.40s -> 1899.28s]  In this for loop here,
[1899.28s -> 1901.76s]  if we had made it sleep zero or no sleep at all,
[1901.76s -> 1904.20s]  then it might have jumped into the loop
[1904.20s -> 1905.04s]  and then it would have done it.
[1905.04s -> 1906.28s]  But it still would have worked okay
[1906.28s -> 1908.56s]  because let's say it didn't have any children
[1908.56s -> 1909.40s]  at that point.
[1909.40s -> 1910.22s]  It would have exited the ReapChild,
[1910.22s -> 1912.24s]  but then the next child would have gotten created
[1912.24s -> 1913.68s]  and it would have gone back and called.
[1913.68s -> 1915.26s]  So, I mean, it's not like anything would have broken
[1915.26s -> 1916.72s]  in that case, but you're right.
[1916.76s -> 1919.20s]  It could have been that we ended up in ReapChild
[1919.20s -> 1920.92s]  before any of the other children were created,
[1920.92s -> 1922.20s]  but it's still gonna get called later
[1922.20s -> 1925.38s]  when they do get created and then eventually finish.
[1927.52s -> 1929.40s]  Good, lots of good questions here.
[1929.40s -> 1930.52s]  I'm glad I'm going over this again,
[1930.52s -> 1932.28s]  or at least this part of here.
[1932.28s -> 1937.28s]  Okay, so what do we want to do in this case?
[1937.80s -> 1939.52s]  So now we've got this problem here.
[1939.52s -> 1942.34s]  Remember, we've changed the behavior
[1942.34s -> 1945.08s]  by adding this while loop up here.
[1945.36s -> 1948.74s]  We've said, wait, block until all the children are done.
[1948.74s -> 1950.76s]  And if we've got five children outstanding,
[1950.76s -> 1952.00s]  then it's gonna sit there and block
[1952.00s -> 1953.12s]  until all the children are done.
[1953.12s -> 1953.96s]  And that's not what we want.
[1953.96s -> 1955.42s]  We want the signal handler to be in
[1955.42s -> 1956.96s]  and out really quickly.
[1956.96s -> 1958.90s]  That's the basic idea.
[1958.90s -> 1963.00s]  So it turns out that we will finally get a chance
[1963.00s -> 1966.96s]  to use this final parameter for weight PID.
[1966.96s -> 1969.04s]  Okay, this parameter, there's a bunch of flags
[1969.04s -> 1971.94s]  you can put in there, you just or them together.
[1972.18s -> 1975.08s]  One of the flags that we care about,
[1975.08s -> 1976.72s]  and in fact, specifically for this,
[1976.72s -> 1980.60s]  is called WNoHang.
[1980.60s -> 1984.92s]  And WNoHang is a flag that says,
[1984.92s -> 1987.64s]  wait for any child, except if there are none
[1987.64s -> 1990.02s]  that are finished, just return immediately
[1990.02s -> 1992.50s]  with a return value of zero.
[1992.50s -> 1996.50s]  So that means, a return value of zero means
[1996.50s -> 2000.86s]  that there are children remaining that have not ended yet,
[2001.96s -> 2004.46s]  but I'm gonna return now because I don't wanna block on this.
[2004.46s -> 2006.26s]  I don't wanna stick around waiting
[2006.26s -> 2008.22s]  for those in this while loop.
[2008.22s -> 2009.84s]  So the only other thing we have to change here
[2009.84s -> 2011.82s]  is we have to say, oh, fine,
[2011.82s -> 2014.50s]  if PID is less than or equal to zero,
[2014.50s -> 2017.78s]  because if the zero case, there are still children,
[2018.70s -> 2021.18s]  but they're still going, so I'm not gonna stick in
[2021.18s -> 2022.70s]  or stick around and try to wait for them.
[2022.70s -> 2025.54s]  I'm gonna come back later when they finish
[2025.54s -> 2028.14s]  and call this function.
[2028.14s -> 2029.64s]  That's what's going on here.
[2029.68s -> 2031.92s]  Let's try this and see if it works.
[2031.92s -> 2033.84s]  Five children.
[2033.84s -> 2034.82s]  Okay, five children.
[2034.82s -> 2036.40s]  So remember, now we've got this idea
[2036.40s -> 2037.88s]  where we want the dad to wake back up
[2037.88s -> 2039.32s]  after the first two children.
[2039.32s -> 2041.64s]  Oh, we've got the reaped children.
[2041.64s -> 2043.10s]  I'll take that out so you can see
[2043.10s -> 2044.10s]  what's going on in a second here.
[2044.10s -> 2046.80s]  But you can see that dad's waking up now,
[2046.80s -> 2048.20s]  which is exactly what we wanted.
[2048.20s -> 2050.62s]  It was exactly what we had in the very first one,
[2050.62s -> 2053.08s]  but now we're doing it in a way that we can capture
[2053.08s -> 2056.46s]  in case some children end at exactly the same time,
[2056.46s -> 2057.86s]  or roughly the same time.
[2058.02s -> 2062.62s]  Let me just run it again without this line in there anymore
[2062.62s -> 2066.86s]  and we'll just see it work in general.
[2069.14s -> 2071.78s]  What questions do you have about this?
[2071.78s -> 2073.62s]  The purpose of w no hang.
[2073.62s -> 2075.44s]  We will use that very often.
[2077.26s -> 2080.28s]  And we'll use that specifically because
[2080.28s -> 2082.68s]  we wanna keep our program going.
[2082.68s -> 2083.60s]  We don't wanna sit there and go,
[2083.60s -> 2084.66s]  oh, let's wait for the child,
[2084.66s -> 2085.76s]  oh, let's wait around for the child.
[2085.76s -> 2087.10s]  Let's do something else.
[2087.18s -> 2091.30s]  Let the signal handler get called when the child ends
[2091.30s -> 2093.08s]  and deal with it at that point.
[2093.08s -> 2093.92s]  Question.
[2093.92s -> 2096.34s]  Basically the flag just says,
[2096.34s -> 2098.70s]  don't like stop the program anymore,
[2098.70s -> 2102.22s]  just deal with any children that have already ended.
[2102.22s -> 2103.78s]  Whereas if we didn't have the flag,
[2103.78s -> 2105.94s]  we would just wait around.
[2105.94s -> 2107.98s]  Yeah, so the question is this flag,
[2107.98s -> 2111.50s]  or the comment is this flag w no hang,
[2111.50s -> 2114.66s]  it says to the wait PID function,
[2115.62s -> 2117.62s]  if there is a child that's ended,
[2117.62s -> 2119.78s]  return that PID and clean it up.
[2119.78s -> 2121.34s]  If any of the children have ended,
[2121.34s -> 2122.18s]  pick one of them,
[2122.18s -> 2123.92s]  clean it up and give me that PID back
[2123.92s -> 2126.42s]  so I can do whatever else I want with it.
[2126.42s -> 2129.52s]  If there are no children that have ended,
[2129.52s -> 2132.06s]  but there are still children out there,
[2132.06s -> 2132.98s]  don't wait for one,
[2132.98s -> 2134.54s]  like we've always done in the past.
[2134.54s -> 2135.94s]  Just return zero and say,
[2135.94s -> 2137.02s]  look, they're still there,
[2137.02s -> 2137.86s]  but I'm not gonna wait.
[2137.86s -> 2139.26s]  You asked me not to wait for them.
[2139.26s -> 2140.72s]  That's what it's doing.
[2140.72s -> 2141.56s]  Question.
[2141.56s -> 2143.86s]  Can you call this 10 minutes after the process dies?
[2143.86s -> 2145.78s]  Is there a queue somewhere in the process
[2145.78s -> 2148.02s]  that needs to be cleaned up?
[2150.02s -> 2151.38s]  Well, so the question is,
[2151.38s -> 2153.10s]  is there a queue or a process that needs to be cleaned up?
[2153.10s -> 2153.92s]  Yes.
[2153.92s -> 2155.74s]  I mean, it's operating system specific,
[2155.74s -> 2157.34s]  and I don't know exactly how Linux does it,
[2157.34s -> 2160.10s]  but the operating system is part of this whole game.
[2160.10s -> 2161.30s]  When the child ends,
[2161.30s -> 2162.38s]  the operating system says,
[2162.38s -> 2166.26s]  oh, okay, I owe the parent a signal,
[2166.26s -> 2168.42s]  and it sends the signal whenever that child ends.
[2168.42s -> 2170.36s]  Now, if the parent has already ended,
[2170.36s -> 2171.98s]  well then, you know, you don't want that.
[2171.98s -> 2173.02s]  But in this case,
[2173.34s -> 2174.78s]  we've made it so the parent will not end
[2174.78s -> 2176.16s]  until all the children end.
[2176.16s -> 2177.54s]  But yeah, that's kind of what's happening.
[2177.54s -> 2178.46s]  The operating system's saying,
[2178.46s -> 2181.50s]  ah, I'm gonna build up a little queue of ended children,
[2181.50s -> 2184.84s]  and then I'll just call wait PID when I need to.
[2184.84s -> 2185.94s]  Lots of other questions.
[2185.94s -> 2186.78s]  Yeah.
[2186.78s -> 2189.38s]  So is ReapChild still called two seconds only,
[2189.38s -> 2191.70s]  or is it five times?
[2191.70s -> 2192.54s]  Good question.
[2192.54s -> 2193.62s]  We don't know how many times
[2193.62s -> 2195.80s]  ReapChild is called in general.
[2195.80s -> 2196.92s]  In this case,
[2196.92s -> 2199.26s]  because they're staggered three seconds, three seconds,
[2199.26s -> 2201.46s]  three seconds, three seconds, it's called five times,
[2201.46s -> 2203.82s]  because there aren't two that end at the same time.
[2203.82s -> 2207.18s]  Any time two or more will end at the same time,
[2207.18s -> 2208.66s]  it could only get called once,
[2208.66s -> 2210.70s]  and that's why you have to handle them all inside that,
[2210.70s -> 2213.10s]  because you may not get another call later.
[2213.10s -> 2215.26s]  And it's just a race condition
[2215.26s -> 2217.10s]  that's kind of built into the operating system,
[2217.10s -> 2218.70s]  and this is the way they've said,
[2218.70s -> 2221.94s]  look, you have to plan for if ReapChild gets called,
[2221.94s -> 2224.24s]  maybe more than one child has ended,
[2224.24s -> 2225.08s]  you better deal with that,
[2225.08s -> 2227.54s]  because we're not gonna call it again in that case.
[2227.54s -> 2228.38s]  Yeah.
[2228.86s -> 2230.82s]  So if we do go back to when multiple,
[2230.82s -> 2233.14s]  say like two can finish at the same time.
[2233.14s -> 2234.98s]  Well, two can finish at the same time, yeah.
[2234.98s -> 2238.90s]  Then this could only get called once or those two,
[2238.90s -> 2241.90s]  and you'd get two PIDs,
[2241.90s -> 2243.82s]  like you'd go through the while loop twice,
[2243.82s -> 2245.34s]  and then be done.
[2245.34s -> 2246.82s]  Correct, you would go through the,
[2246.82s -> 2249.38s]  so yes, if two ended at the same time,
[2249.38s -> 2251.74s]  you would end up getting called once, probably,
[2251.74s -> 2254.78s]  and then this while loop here
[2254.78s -> 2257.02s]  would go through both of them,
[2257.02s -> 2259.00s]  and clean both of them up,
[2259.00s -> 2262.98s]  and then find out that none of the others have finished,
[2262.98s -> 2265.66s]  return zero, and then you return from the function.
[2265.66s -> 2266.50s]  Yep.
[2266.50s -> 2268.42s]  What is null in this case?
[2268.42s -> 2270.90s]  Null in this case, remember this was the status,
[2270.90s -> 2272.66s]  so we could have done,
[2272.66s -> 2275.14s]  in fact, you normally should do something like this,
[2275.14s -> 2280.14s]  status, and then you paste in status like that,
[2281.14s -> 2283.12s]  and it gives you more information.
[2283.12s -> 2285.10s]  What was the return value of the child?
[2285.10s -> 2286.66s]  Did it end abnormally?
[2287.62s -> 2288.86s]  There's lots of information,
[2288.86s -> 2290.50s]  some more information you can get from that.
[2290.50s -> 2292.66s]  What status did it, how did it end?
[2292.66s -> 2294.62s]  Did it, was it stopped, or rather,
[2294.62s -> 2296.70s]  did it end, or was it stopped, or was it continued?
[2296.70s -> 2298.90s]  That gives you more information about that.
[2298.90s -> 2299.94s]  Good questions.
[2299.94s -> 2300.78s]  Yeah.
[2300.78s -> 2302.30s]  Could you run this without the,
[2302.30s -> 2305.82s]  so instead of just passing three?
[2305.82s -> 2308.22s]  Could I run it without which?
[2308.22s -> 2311.30s]  Now you have to see three times kids.
[2311.30s -> 2312.80s]  Oh, yeah, you want me to run it without the,
[2312.80s -> 2314.20s]  so they all end at the same time.
[2314.20s -> 2315.04s]  Sure.
[2316.04s -> 2319.30s]  Let's see, so if they all end at the same time,
[2320.80s -> 2323.68s]  you do that, and,
[2326.52s -> 2327.68s]  let's see, okay, so remember,
[2327.68s -> 2328.96s]  they're all gonna go boom and end
[2328.96s -> 2330.88s]  after three seconds or whatever, right?
[2330.88s -> 2334.32s]  Boom, they all ended, dad finally wakes up and says,
[2334.32s -> 2335.74s]  oh, they've all ended, we're done,
[2335.74s -> 2337.96s]  and they got handled inside that.
[2337.96s -> 2338.80s]  Good question.
[2340.04s -> 2340.88s]  Right.
[2341.92s -> 2343.92s]  That was a lot of, that's a lot of stuff
[2343.96s -> 2345.36s]  packed into one program,
[2345.36s -> 2347.16s]  a lot of different things going on,
[2347.16s -> 2349.12s]  but what we've learned now is,
[2349.12s -> 2352.18s]  well, these signal handlers have some nuance to them,
[2352.18s -> 2356.36s]  they have some, they have this ability to get called,
[2356.36s -> 2358.98s]  but sometimes it's a little bit odd
[2358.98s -> 2361.66s]  because two things could kind of call it at the same time
[2361.66s -> 2363.08s]  so that's nuanced.
[2363.08s -> 2366.52s]  We've got wait PID, which will wait for any children,
[2366.52s -> 2368.64s]  and you can use negative one for the first parameter
[2368.64s -> 2370.40s]  to wait for any of the children,
[2370.40s -> 2372.44s]  and now we've said, yeah, but what if we,
[2372.44s -> 2374.76s]  we don't want you to block and wait for that child,
[2374.76s -> 2376.16s]  we want you to just return immediately,
[2376.16s -> 2378.68s]  and we capture the information about that, saying,
[2378.68s -> 2381.22s]  oh, there's no, if it's zero,
[2381.22s -> 2383.24s]  there are children still remaining
[2383.24s -> 2385.32s]  that have not been captured yet, okay?
[2385.32s -> 2388.60s]  Now, we didn't care if it was children still remaining
[2388.60s -> 2390.72s]  or all the children are done
[2390.72s -> 2393.24s]  because we just know that we're counting correctly,
[2393.24s -> 2395.08s]  so ReapChild will get called again
[2395.08s -> 2396.40s]  if we haven't counted
[2396.40s -> 2398.00s]  or if all the children are still remaining
[2398.00s -> 2400.68s]  just because the parent program
[2400.68s -> 2402.56s]  or the parent part of the process
[2402.56s -> 2406.54s]  is kind of doing its own thing, okay?
[2407.60s -> 2410.28s]  All right, I know there's a lot going on there,
[2410.28s -> 2413.20s]  but do ask more questions,
[2413.20s -> 2415.14s]  and feel free to go run the code yourself
[2415.14s -> 2416.72s]  if you want to, you can download it.
[2416.72s -> 2418.30s]  I didn't put it in the slideshow today,
[2418.30s -> 2419.92s]  I'm not sure if that screwed up my tablet or not,
[2419.92s -> 2423.20s]  but the other day, I'll try that again in the future.
[2423.20s -> 2425.20s]  So anyway, we went through all these different cases,
[2425.20s -> 2428.12s]  so I don't think we need to redo these
[2428.12s -> 2430.20s]  because we did them kind of as we go along,
[2430.60s -> 2432.04s]  but feel free to read the slides about that.
[2432.04s -> 2435.48s]  It's just basically going through exactly what we did live,
[2435.48s -> 2438.64s]  and you saw that we had some various cases
[2438.64s -> 2441.68s]  where we needed to do more logic
[2441.68s -> 2445.04s]  and different type of logic, okay?
[2445.04s -> 2449.84s]  All right, so let's see, that I think is that for,
[2449.84s -> 2454.84s]  there are other flags besides w nohang.
[2456.46s -> 2460.12s]  There's also w untraced.
[2461.00s -> 2463.28s]  Which is a weird name, but basically what it means is
[2463.28s -> 2466.96s]  block until a child process has either ended
[2466.96s -> 2470.64s]  or been stopped, and stopped is paused, not ended,
[2470.64s -> 2473.04s]  and we'll see lots of cases where they get paused.
[2473.04s -> 2476.08s]  If you use w untraced with w nohang,
[2476.08s -> 2478.32s]  it removes that blocking part.
[2478.32s -> 2480.76s]  It doesn't actually block in that case.
[2480.76s -> 2483.44s]  W nohang always says, well, I'm not gonna block,
[2483.44s -> 2486.80s]  but the other ones, w untraced is if it stops,
[2486.94s -> 2490.80s]  and then you also have w continued for the situation
[2490.80s -> 2493.40s]  where the child process has been stopped
[2493.40s -> 2496.28s]  and then gets started back up again.
[2496.28s -> 2498.24s]  Your parent will also get a notice about that,
[2498.24s -> 2500.76s]  get a signal about that, okay?
[2500.76s -> 2503.54s]  So often we will see three of them together,
[2503.54s -> 2507.72s]  w untraced or w continued or w nohang,
[2507.72s -> 2511.12s]  and that just says, look, I want you to wait
[2511.12s -> 2513.70s]  and return information about a child process
[2513.70s -> 2515.68s]  that has changed any kind of its state,
[2515.68s -> 2520.56s]  not just ended, not just stopped, not just continued,
[2520.56s -> 2523.52s]  and by the way, don't actually block
[2523.52s -> 2525.88s]  when you're doing that, okay?
[2527.00s -> 2531.08s]  All right, so that's the basic idea
[2531.08s -> 2533.88s]  of signal handlers so far.
[2533.88s -> 2536.16s]  We have some more nuance in race conditions
[2536.16s -> 2539.56s]  that we have to deal with going forward, okay?
[2539.56s -> 2544.56s]  So we have to talk about some more synchronization issue.
[2546.40s -> 2547.24s]  Okay?
[2548.40s -> 2552.64s]  When you talk about signal handlers, okay,
[2552.64s -> 2557.12s]  remember that the signal handler gets called
[2557.12s -> 2561.48s]  when the whatever thing happens, happens, okay?
[2561.48s -> 2563.32s]  So the question came up earlier and said,
[2563.32s -> 2567.56s]  and somebody said, what if the child process ends
[2567.56s -> 2570.64s]  before the parent actually gets to something or whatever?
[2570.64s -> 2572.60s]  That could happen, all right?
[2572.60s -> 2575.36s]  And because of the way you write your code,
[2575.92s -> 2577.40s]  that might actually happen,
[2577.40s -> 2580.36s]  and it might not be what you want,
[2580.36s -> 2582.48s]  or at least what happens might not be what you want.
[2582.48s -> 2585.24s]  So we have to actually deal with this.
[2585.24s -> 2586.08s]  Here's what we're gonna do.
[2586.08s -> 2587.72s]  I'm gonna write another program,
[2587.72s -> 2592.00s]  and it's going to be basically a job list
[2592.00s -> 2592.84s]  toward a program.
[2592.84s -> 2595.46s]  In other words, we're gonna start up a bunch of programs
[2595.46s -> 2598.38s]  using fork exec CVP, like we've done before.
[2598.38s -> 2599.22s]  We're gonna start them up,
[2599.22s -> 2601.72s]  and we're gonna add them to a job list.
[2601.72s -> 2604.52s]  Now, in fact, you're gonna do this for assignment four,
[2604.56s -> 2607.64s]  coming up, not this week, but next week.
[2607.64s -> 2610.80s]  You're gonna do this coming up for that assignment,
[2610.80s -> 2612.12s]  and you're gonna have to do this
[2612.12s -> 2613.60s]  because your shell does that.
[2613.60s -> 2615.52s]  Whenever you type a command, guess what?
[2615.52s -> 2618.08s]  The shell takes that command and puts it into some list
[2618.08s -> 2619.22s]  that it's keeping track of
[2619.22s -> 2621.12s]  to know which programs are running.
[2621.12s -> 2622.16s]  That's what it's doing.
[2622.16s -> 2622.98s]  So that's what we're gonna do.
[2622.98s -> 2624.28s]  We're gonna run these programs,
[2624.28s -> 2625.84s]  three of them, as it turns out,
[2625.84s -> 2628.76s]  and then we're going to, every second, by the way,
[2628.76s -> 2629.92s]  we're gonna do it one second after the other
[2629.92s -> 2631.16s]  after the other,
[2631.20s -> 2635.84s]  and then we're gonna have a signal handler
[2635.84s -> 2640.84s]  that gets called when the child's state changes.
[2641.02s -> 2641.96s]  Remember, it always gets called
[2641.96s -> 2643.34s]  when the child's state changes,
[2643.34s -> 2646.72s]  and we are going to add it to this job list
[2646.72s -> 2649.28s]  through the signal handler.
[2651.16s -> 2655.28s]  And then the parent is also going to maintain,
[2655.28s -> 2658.76s]  well, the parent is maintaining this job list
[2658.76s -> 2660.62s]  is really what it is.
[2660.78s -> 2662.30s]  In fact, we're not really maintaining it at all.
[2662.30s -> 2663.42s]  We're just printing it out.
[2663.42s -> 2665.20s]  Let me show you the program,
[2665.20s -> 2668.04s]  and then we will see it in action.
[2669.08s -> 2672.70s]  This is gonna be called job list synchronization.c,
[2672.70s -> 2674.02s]  and it's gonna be the following.
[2674.02s -> 2677.14s]  Again, we'll write the main part first
[2677.14s -> 2681.10s]  just to kind of show you what it's actually doing here.
[2682.58s -> 2685.76s]  I'm gonna call, by the way, the date function.
[2685.76s -> 2687.86s]  You haven't seen the date function before.
[2687.86s -> 2691.54s]  It just does the date, just prints out the date.
[2691.54s -> 2693.18s]  I'm gonna call the date function,
[2693.18s -> 2697.06s]  and it's going to run that
[2697.06s -> 2699.14s]  and then print it out to the screen.
[2699.14s -> 2702.58s]  That's all the date function is actually going to do.
[2702.58s -> 2703.68s]  What we're gonna do is
[2703.68s -> 2705.36s]  we're going to set up a signal handler,
[2705.36s -> 2707.90s]  signal sig child,
[2707.90s -> 2711.28s]  and it's going to be, in this case, reap processes.
[2712.78s -> 2715.58s]  That's setting up the signal handler.
[2717.98s -> 2720.28s]  Then we are going to do what we call,
[2720.28s -> 2724.14s]  we are going to just,
[2724.14s -> 2725.98s]  actually, we're gonna do this in a minute.
[2725.98s -> 2730.82s]  Right now, we're just going to start the actual for loop
[2730.82s -> 2732.78s]  to start the processes.
[2732.78s -> 2735.54s]  For size T, I equals zero,
[2735.54s -> 2738.92s]  I is less than three in this case, I plus plus.
[2738.92s -> 2743.42s]  Okay, PID T, PID equals fork.
[2743.42s -> 2746.16s]  Okay, if, I don't know why this is not,
[2747.16s -> 2749.24s]  okay, there we go, anyway.
[2749.24s -> 2751.68s]  All right, fork, did I have,
[2751.68s -> 2752.72s]  I might have had a mistake in there,
[2752.72s -> 2756.72s]  so anyway, if the PID is zero,
[2756.72s -> 2759.04s]  means we're in the child.
[2759.04s -> 2761.98s]  Okay, what are we gonna do in there, in this case?
[2761.98s -> 2766.98s]  We are actually going to just call EXCVP, okay,
[2767.12s -> 2771.68s]  and it's K arguments, zero, and K arguments.
[2771.68s -> 2775.44s]  Remember, this is how exact VP works, okay?
[2775.48s -> 2777.12s]  And that's that, okay?
[2777.12s -> 2779.04s]  Remember, that will not return if it works,
[2779.04s -> 2780.36s]  and we're gonna assume the date function
[2780.36s -> 2781.82s]  is gonna work in this case.
[2781.82s -> 2784.76s]  We're not doing any error checking in that case, okay?
[2784.76s -> 2789.76s]  And then we're going to sleep for one second, okay?
[2789.92s -> 2792.96s]  Which basically forces the CPU,
[2792.96s -> 2796.04s]  or forces the parent off the CPU.
[2796.04s -> 2797.32s]  What do I mean by that?
[2797.32s -> 2799.00s]  I mean that it's gonna tell the parent,
[2799.00s -> 2800.78s]  go to sleep, and then the child
[2800.78s -> 2802.84s]  is actually gonna get to do its thing.
[2802.84s -> 2804.12s]  If you have multiple processors,
[2804.12s -> 2805.56s]  this will probably happen anyway,
[2805.56s -> 2807.36s]  but in this case, we're just forcing it
[2807.36s -> 2809.00s]  to make the parent wait for a second.
[2809.00s -> 2809.82s]  Why?
[2809.82s -> 2810.66s]  Well, who knows?
[2810.66s -> 2813.72s]  Maybe this is a system where you're typing commands in
[2813.72s -> 2816.20s]  and it's waiting for a command to give it, whatever.
[2816.20s -> 2818.36s]  For now, we're just forcing it off the CPU,
[2818.36s -> 2822.60s]  and then we're going to print job percent D
[2822.60s -> 2825.88s]  added to the job list,
[2825.88s -> 2829.96s]  and we're going to print the actual PID of the child,
[2829.96s -> 2833.52s]  okay, and then we're going to return zero,
[2833.88s -> 2834.70s]  and that's that.
[2834.70s -> 2836.16s]  Okay, so everybody gets what's going on here.
[2836.16s -> 2839.38s]  We're gonna start a process, three processes,
[2839.38s -> 2840.64s]  the date command.
[2840.64s -> 2842.52s]  It's going to, we're gonna print out,
[2842.52s -> 2846.52s]  hey, I've started these processes after one second, okay?
[2846.52s -> 2848.12s]  That's what's happening there.
[2848.12s -> 2852.08s]  In reap child, or reap processes in this case, okay,
[2852.08s -> 2853.52s]  what we're gonna do is we're still gonna do this
[2853.52s -> 2855.88s]  while true, because we don't know,
[2855.88s -> 2857.72s]  we're almost always gonna do this from now on,
[2857.72s -> 2860.08s]  because we don't know how many children have ended
[2860.08s -> 2862.88s]  or have changed state, okay?
[2862.88s -> 2867.52s]  And we're gonna say PID equals wait PID,
[2867.52s -> 2870.58s]  negative one, null, and W, no hang,
[2870.58s -> 2871.72s]  because we don't wanna wait,
[2871.72s -> 2874.62s]  we don't wanna block on these, okay?
[2874.62s -> 2878.64s]  And then we're gonna say if PID is less or equal to zero,
[2878.64s -> 2879.50s]  we're simply gonna break,
[2879.50s -> 2881.92s]  same exact things we did before, okay?
[2881.92s -> 2883.32s]  And then now we're going to,
[2883.32s -> 2884.68s]  if we were keeping track of this,
[2884.68s -> 2886.28s]  which you'll do for assignment four,
[2886.28s -> 2888.72s]  we're gonna print job percent,
[2888.72s -> 2889.84s]  we're just gonna print it in this case,
[2889.88s -> 2894.12s]  job percent D removed from the job list, okay?
[2894.12s -> 2897.52s]  So in this case, what it's going to do
[2898.84s -> 2902.28s]  is when the job ends, remember, no hang,
[2902.28s -> 2903.12s]  actually in this case,
[2903.12s -> 2906.56s]  it's just when the job actually finishes, okay?
[2906.56s -> 2909.40s]  It will say it's removed from the job list.
[2909.40s -> 2910.58s]  When the child ends,
[2910.58s -> 2912.32s]  well, why are we keeping in the job list?
[2912.32s -> 2914.56s]  Let's remove it from the job list, okay?
[2914.56s -> 2917.34s]  So again, the parent is creating all these processes
[2917.34s -> 2919.76s]  and putting it into the job list.
[2920.64s -> 2921.46s]  We're just printing it out,
[2921.46s -> 2922.30s]  but it's like putting it into a job list.
[2922.30s -> 2924.80s]  When the signal handler gets called
[2924.80s -> 2926.52s]  for the child process, it says,
[2926.52s -> 2931.52s]  oh, the job is now removed from the job list, okay?
[2931.88s -> 2934.10s]  Let's run this and see what happens.
[2938.20s -> 2940.68s]  Job list synchronization, all right.
[2940.68s -> 2945.68s]  It says job 23735, which is the PID of the child,
[2945.70s -> 2947.64s]  removed from the job list.
[2947.68s -> 2951.24s]  And then it says job 23735 added to the job list.
[2951.24s -> 2953.24s]  And then it says the date, great,
[2953.24s -> 2954.74s]  or actually it said the date first, in fact,
[2954.74s -> 2957.78s]  because it said the date and then ended.
[2957.78s -> 2959.16s]  And then it did the same thing,
[2959.16s -> 2961.16s]  and then it says the next job was removed
[2961.16s -> 2963.88s]  and then added and then removed and then added.
[2963.88s -> 2966.72s]  Now, you're probably saying to yourself,
[2966.72s -> 2968.12s]  well, that's kind of dumb.
[2968.12s -> 2971.98s]  The job lists here, they're being removed
[2971.98s -> 2974.48s]  before they're being added, right?
[2974.48s -> 2975.48s]  And you've got to say to yourself,
[2975.48s -> 2978.74s]  well, why is that happening, right?
[2978.74s -> 2980.44s]  Well, what did we do to make it happen?
[2980.44s -> 2981.90s]  That's the bigger question.
[2981.90s -> 2983.36s]  Yeah, comment or question?
[2983.36s -> 2985.96s]  I was wondering, is that because we forced the parent
[2985.96s -> 2986.96s]  on the CPU?
[2986.96s -> 2990.08s]  Yeah, we did this little sleep for one second, right?
[2990.08s -> 2993.04s]  Well, by the time it gets to that sleep,
[2993.04s -> 2995.86s]  the child is already on its way,
[2995.86s -> 2997.86s]  and the date does not take more than one second
[2997.86s -> 3001.36s]  to happen, it happens like instantly, right?
[3001.36s -> 3004.40s]  When the date function is done, command is done,
[3005.22s -> 3006.06s]  it calls the signal handler.
[3006.06s -> 3009.68s]  All of that happens before one second is done.
[3009.68s -> 3011.06s]  Now, you'll notice when I run it,
[3011.06s -> 3013.00s]  that one second actually doesn't happen
[3013.00s -> 3013.84s]  by the time it says.
[3013.84s -> 3016.88s]  It's because sleep does not wait that one second.
[3016.88s -> 3021.00s]  If I change the snooze, it would actually wait one second.
[3021.00s -> 3022.94s]  But in this case, it just wakes up immediately
[3022.94s -> 3023.78s]  in that case.
[3023.78s -> 3024.60s]  Husband?
[3024.60s -> 3025.44s]  Did you remove the sleep?
[3025.44s -> 3028.20s]  Didn't it also sometimes run through the issue
[3028.20s -> 3031.80s]  because if that didn't do automatically return
[3031.80s -> 3033.94s]  to the child, then you would?
[3034.38s -> 3035.74s]  Yeah, very good question, very good comment.
[3035.74s -> 3036.94s]  The question and comment was,
[3036.94s -> 3038.78s]  wait, wait, wait, if we removed sleep one,
[3038.78s -> 3041.50s]  wouldn't it still have this potential problem?
[3041.50s -> 3043.34s]  Because you don't know if the date command
[3043.34s -> 3045.54s]  is gonna run faster than this command
[3045.54s -> 3047.12s]  is gonna get to, absolutely.
[3047.12s -> 3048.30s]  Like, you don't know that.
[3048.30s -> 3050.90s]  We're purposely putting in this sleep in here
[3050.90s -> 3053.10s]  to say, hey, this is something that could happen
[3053.10s -> 3054.62s]  even though we're forcing it to,
[3054.62s -> 3055.62s]  so we know what's gonna happen
[3055.62s -> 3056.78s]  because we're forcing it to.
[3056.78s -> 3058.74s]  But yeah, these are race conditions,
[3058.74s -> 3060.04s]  you can't predict them.
[3060.04s -> 3061.30s]  Very good point.
[3063.06s -> 3063.90s]  Yeah?
[3063.90s -> 3066.66s]  If you had the print, like, that the parent
[3066.66s -> 3069.14s]  would have the list before you checked
[3069.14s -> 3071.98s]  if it was the child, what would happen?
[3071.98s -> 3075.10s]  If you had this right here before you checked
[3075.10s -> 3077.90s]  if it was the child, it would all,
[3077.90s -> 3079.58s]  well, remember, at that gate,
[3079.58s -> 3081.38s]  it would get parent printed twice in that case
[3081.38s -> 3084.58s]  because the child and the parent would do it.
[3084.58s -> 3087.74s]  So that's not really what we wanted to do in this case.
[3087.74s -> 3088.86s]  But you see the issue here.
[3088.86s -> 3090.06s]  We've got this race condition,
[3090.06s -> 3091.90s]  and really what we wanna do
[3091.94s -> 3095.06s]  is we want the child not to send that signal
[3095.06s -> 3098.78s]  until after this command.
[3098.78s -> 3100.38s]  That's what we want.
[3100.38s -> 3102.62s]  Okay, we want the child to,
[3102.62s -> 3103.66s]  maybe it ends.
[3103.66s -> 3105.54s]  We don't care if the child ends.
[3105.54s -> 3107.54s]  We just don't want that signal to be sent
[3107.54s -> 3109.56s]  until after, or until we're ready
[3109.56s -> 3111.30s]  for that signal to be sent.
[3111.30s -> 3112.42s]  Okay, and in this case,
[3112.42s -> 3115.22s]  it's gonna be after we've added the job to the list.
[3115.22s -> 3116.54s]  Because that would be kind of hard.
[3116.54s -> 3117.74s]  This is especially true
[3117.74s -> 3120.02s]  if you literally were keeping some list
[3120.02s -> 3121.34s]  that you needed to,
[3122.26s -> 3123.46s]  if it was a queue or something,
[3123.46s -> 3126.26s]  or some set or something of the list,
[3126.26s -> 3128.46s]  and you tried to remove it before you added it,
[3128.46s -> 3130.18s]  well, you're gonna crash.
[3130.18s -> 3131.00s]  Or there's some other,
[3131.00s -> 3132.18s]  like, oh, I can't remove that job
[3132.18s -> 3133.02s]  even though it ended.
[3133.02s -> 3133.86s]  That's weird.
[3133.86s -> 3137.02s]  So you need to somehow be able to say,
[3137.02s -> 3141.70s]  don't call that signal until after this printf,
[3141.70s -> 3142.88s]  in this case.
[3142.88s -> 3144.86s]  All right, so how are we going to do that?
[3144.86s -> 3147.62s]  Okay, there's the thing we just did.
[3147.62s -> 3148.82s]  What we need to do,
[3148.82s -> 3150.34s]  okay, well, we actually kind of went through
[3150.74s -> 3151.82s]  all this detail here.
[3151.82s -> 3153.52s]  What we need to do is we need to use
[3153.52s -> 3156.62s]  a different type of system call here.
[3157.70s -> 3162.70s]  We need to have this idea of a signal set.
[3163.94s -> 3166.42s]  And this signal set is going to be
[3168.14s -> 3170.80s]  a data structure that says,
[3170.80s -> 3175.80s]  when you call this function called sigproc mask,
[3176.24s -> 3181.24s]  it says, don't let a particular signal get called
[3181.40s -> 3183.16s]  until we unblock it.
[3184.08s -> 3186.58s]  Okay, so we're going to block some signal.
[3186.58s -> 3188.66s]  In fact, sometimes you can block as many signals
[3188.66s -> 3190.40s]  as you want, but we're gonna, in particular,
[3190.40s -> 3193.52s]  block the sigchild until we're ready
[3193.52s -> 3196.92s]  for that sigchild to be okay to be fired.
[3197.84s -> 3199.10s]  That's all we're doing.
[3199.10s -> 3202.36s]  Okay, there's three different types,
[3202.36s -> 3204.52s]  like functions we have to deal with in this case.
[3204.52s -> 3208.36s]  The one is called sig empty set.
[3208.36s -> 3209.92s]  Let me make this a little bigger.
[3209.92s -> 3211.32s]  One is called sig empty set.
[3211.32s -> 3216.32s]  And sig empty set basically takes this sig set T type
[3216.60s -> 3218.80s]  that we have and it kind of initializes it
[3218.80s -> 3221.80s]  and says there are no signals in that set.
[3221.80s -> 3223.24s]  Okay, it's just an initialization.
[3223.24s -> 3225.74s]  And by the way, this signal set's basically an integer.
[3225.74s -> 3226.96s]  It's got a bunch of bits,
[3226.96s -> 3228.80s]  that's obviously it's got a bunch of bits in it.
[3228.80s -> 3231.36s]  The bits are set depending on the signal.
[3231.36s -> 3232.52s]  And it's a 32-bit integer.
[3232.56s -> 3235.24s]  It turns out there's less than 32 signals.
[3235.24s -> 3237.20s]  So we can get away with that.
[3237.20s -> 3242.08s]  Then if you want to add a particular signal to a set,
[3242.08s -> 3245.80s]  you say, okay, I'm going to pass in the set
[3245.80s -> 3247.68s]  that I'm going to add and then I'm gonna tell it
[3247.68s -> 3252.16s]  which signal I want to actually add to that set.
[3252.16s -> 3253.12s]  Okay, you can also remove them.
[3253.12s -> 3254.36s]  The three that we're gonna care about right now
[3254.36s -> 3255.52s]  are these three.
[3255.52s -> 3260.52s]  And then if you want to, say, go block this signal,
[3260.92s -> 3265.92s]  you call SIG PROC MASK with a value called SIG BLOCK.
[3270.16s -> 3274.20s]  And then you pass in the SIG set that you care about.
[3274.20s -> 3278.32s]  You can also get back the signal
[3278.32s -> 3281.02s]  that have already been set.
[3281.02s -> 3282.54s]  Like it's kind of one of those weird things
[3282.54s -> 3284.24s]  where they're like, well, we're not gonna tell you.
[3284.24s -> 3288.44s]  Remember like from day one where we talked about UMASK
[3288.44s -> 3289.72s]  and there was that weird thing where the only way
[3289.76s -> 3291.58s]  to check UMASK was to actually change it
[3291.58s -> 3292.96s]  and you get back what you checked?
[3292.96s -> 3295.08s]  It's the same sort of thing here.
[3295.08s -> 3297.36s]  Why they did this is just historical, I'm guessing.
[3297.36s -> 3299.76s]  But anyway, most of the time we're not gonna care
[3299.76s -> 3301.04s]  about the existing set.
[3301.04s -> 3303.00s]  We're just gonna say, look, here's our new set.
[3303.00s -> 3304.64s]  I don't care what signals are already done.
[3304.64s -> 3305.62s]  Let's just go with it.
[3305.62s -> 3307.60s]  If you're writing a more robust program,
[3307.60s -> 3309.56s]  you might care about that.
[3309.56s -> 3310.44s]  Okay, all right.
[3310.44s -> 3314.12s]  So let's see how this actually works in practice.
[3314.12s -> 3318.44s]  So let's go modify our,
[3318.44s -> 3323.44s]  let's go modify our main function here.
[3323.96s -> 3325.44s]  We're not gonna have to do anything, by the way,
[3325.44s -> 3326.52s]  to the reprocesses.
[3326.52s -> 3329.22s]  We're just gonna have to change main here
[3329.22s -> 3331.30s]  to have this signal set that we're gonna block
[3331.30s -> 3333.00s]  and you'll see how that happens.
[3333.00s -> 3334.84s]  Okay, all right.
[3334.84s -> 3337.00s]  So what we're gonna do is we're going to the same thing.
[3337.00s -> 3338.48s]  We're gonna set up this signal
[3338.48s -> 3340.68s]  and then we are going to say, okay, fine.
[3340.68s -> 3343.32s]  I'm going to get a SIG set underscore T
[3343.32s -> 3344.96s]  and I'm just gonna call it my set.
[3344.96s -> 3349.16s]  I'm going to initialize it by calling SIG empty set,
[3350.42s -> 3355.42s]  SIG empty set, and then we pass in a pointer to the set
[3355.92s -> 3360.32s]  and then we say, let's add the SIG child to that.
[3360.32s -> 3365.32s]  SIG add set, SIG, or sorry, set and SIG CHLD.
[3371.52s -> 3372.54s]  Okay, all right.
[3372.54s -> 3376.06s]  So at this point, now we've got our set
[3376.06s -> 3377.50s]  that we're going to be able to say,
[3377.50s -> 3379.18s]  hey, wait for this signal,
[3379.18s -> 3381.86s]  like block this signal until we're ready for it.
[3381.86s -> 3384.18s]  Okay, we don't need to quite block it yet, right?
[3384.18s -> 3388.82s]  We wanna block it before we actually have the chance
[3388.82s -> 3392.78s]  to call it, like before we actually do fork
[3392.78s -> 3395.10s]  because at that point we needed to be,
[3395.10s -> 3397.90s]  we needed to be blocked, okay?
[3397.90s -> 3402.10s]  So at this point, we're gonna say SIG proc mask, okay?
[3402.10s -> 3407.10s]  SIG block, and then we are going to pass in our set
[3407.22s -> 3410.98s]  and we're not gonna care about the other set.
[3410.98s -> 3413.06s]  So at this point, right before fork,
[3413.06s -> 3415.00s]  we have blocked the signals.
[3415.00s -> 3418.58s]  It turns out, and this is a good thing as it turns out,
[3418.58s -> 3421.90s]  blocked signals are passed along to your children.
[3421.90s -> 3423.90s]  Whatever signals are blocked in the parent
[3423.90s -> 3426.48s]  are also blocked in the children.
[3426.48s -> 3428.38s]  And the reason for that is so that we can do this.
[3428.38s -> 3429.42s]  I mean, that's really the basic,
[3429.42s -> 3431.78s]  the main reason that we did this
[3432.30s -> 3433.12s]  is so that we can do that.
[3433.12s -> 3435.82s]  So by the time you get to this child part,
[3436.94s -> 3439.18s]  by the time we actually run the date command,
[3439.18s -> 3440.90s]  we are not allowed, in fact,
[3440.90s -> 3445.90s]  the program is not allowed to call the SIG child signal.
[3446.30s -> 3450.18s]  Now, it doesn't mean that it gets ignored forever.
[3450.18s -> 3451.82s]  If once we unblock the signals,
[3451.82s -> 3454.46s]  that queue of signals that need to be sent will go,
[3454.46s -> 3455.70s]  oh, okay, the operating system will go,
[3455.70s -> 3457.94s]  oh, great, I've got this child that's ended,
[3457.94s -> 3458.76s]  I'd better call it.
[3458.76s -> 3461.76s]  But it's only after we unblock it, okay?
[3462.76s -> 3466.06s]  All right, so what do we have to do at this point?
[3466.06s -> 3471.06s]  We now need to, in the child,
[3471.24s -> 3473.64s]  this is gonna seem a little strange,
[3473.64s -> 3477.84s]  but in the child, we're gonna do SIG PROC MASK, okay?
[3477.84s -> 3480.78s]  Actually, I kind of lied to you a little bit earlier.
[3481.76s -> 3485.82s]  The reason the signals get blocked in the children
[3485.82s -> 3487.26s]  is not because of this, actually,
[3487.26s -> 3489.60s]  it's because you may want the children
[3489.60s -> 3493.32s]  to also be able to block on their signal,
[3493.32s -> 3495.26s]  and it might be because you're running
[3495.26s -> 3496.60s]  the same sort of program.
[3496.60s -> 3498.36s]  We will see why that's actually not important,
[3498.36s -> 3500.66s]  because of what I'm exactly gonna do right now.
[3500.66s -> 3503.72s]  We're going to unblock
[3505.52s -> 3507.42s]  for the child only,
[3509.32s -> 3510.52s]  right there.
[3510.52s -> 3513.00s]  So in other words, what if date
[3514.04s -> 3516.24s]  called a child process?
[3516.24s -> 3519.28s]  If we didn't unblock at that point,
[3519.82s -> 3521.00s]  the date function would start out
[3521.00s -> 3523.42s]  with its child process blocked,
[3523.42s -> 3524.64s]  and date doesn't do that,
[3524.64s -> 3526.24s]  so it doesn't actually matter that much,
[3526.24s -> 3528.44s]  but if date had its own child,
[3528.44s -> 3531.92s]  because the signal sets are passed along
[3531.92s -> 3534.62s]  to their children, date would also have that issue,
[3534.62s -> 3537.40s]  and it might not be able to handle that, okay?
[3537.40s -> 3539.92s]  So who knows, it might be an issue.
[3539.92s -> 3541.16s]  But for now, what we're doing is we're saying,
[3541.16s -> 3543.08s]  in the child, go ahead and unblock,
[3543.08s -> 3544.30s]  because it doesn't matter.
[3544.30s -> 3545.96s]  The child, we don't care if the child
[3545.96s -> 3548.00s]  gets a child handler called.
[3548.00s -> 3551.20s]  We care about the parent's child handler getting called,
[3551.20s -> 3554.64s]  and we don't want it to unblock until
[3554.64s -> 3556.66s]  right here, after the printf.
[3557.88s -> 3559.64s]  Okay, so after the printf,
[3559.64s -> 3562.76s]  sig proc mask,
[3562.76s -> 3565.80s]  sig unblock
[3565.80s -> 3568.48s]  in the parent set,
[3568.48s -> 3570.64s]  we don't care about what the previous one was,
[3570.64s -> 3572.28s]  no, like that.
[3572.28s -> 3574.60s]  After this, now,
[3574.64s -> 3578.72s]  when the child, or the parent's signal handler
[3578.72s -> 3580.76s]  can get called when the child ends,
[3580.76s -> 3582.34s]  it probably already will have ended,
[3582.34s -> 3584.54s]  because we just waited for a whole second,
[3584.54s -> 3587.00s]  and in this case, it's a really fast function.
[3588.08s -> 3588.92s]  Question?
[3588.92s -> 3590.60s]  Can you explain again why
[3590.60s -> 3594.76s]  on the unblock inside the child doesn't unblock?
[3596.44s -> 3597.88s]  Yes, very good question.
[3597.88s -> 3601.28s]  The question is, go back a second and explain why
[3601.28s -> 3603.48s]  unblocking the child,
[3603.48s -> 3605.48s]  unblocking the signal in the child
[3605.48s -> 3607.56s]  doesn't have anything to do with the parent.
[3607.56s -> 3608.96s]  Okay.
[3608.96s -> 3612.28s]  The parent, forget about the child for a second.
[3612.28s -> 3614.54s]  The parent has a main function,
[3614.54s -> 3617.72s]  and it has a signal handler for the sig child.
[3618.80s -> 3621.24s]  The parent's sig child handler
[3621.24s -> 3624.48s]  gets called when the child ends,
[3624.48s -> 3627.00s]  unless we have told the parent,
[3627.00s -> 3630.16s]  we're not gonna let you accept that signal.
[3630.96s -> 3631.80s]  Really what it is,
[3631.80s -> 3634.14s]  or you can't send that signal to the parent.
[3635.68s -> 3637.76s]  So it doesn't matter if the child's signal
[3637.76s -> 3639.24s]  is blocked or not.
[3639.24s -> 3642.32s]  That's dealing with its own children if it had some.
[3642.32s -> 3643.16s]  So it doesn't matter.
[3643.16s -> 3647.52s]  So when you say sig proc mask sig unblock inside the child,
[3647.52s -> 3649.76s]  it's just saying, I'm making sure the child
[3649.76s -> 3652.56s]  doesn't have any signals of its own blocked right now.
[3653.76s -> 3655.28s]  And then, and that might,
[3655.28s -> 3658.84s]  because that might be important to the child, right?
[3658.84s -> 3660.36s]  In the parent though,
[3660.36s -> 3663.92s]  even here we are still blocking that signal for the parent
[3663.92s -> 3666.48s]  because the last thing the parent saw
[3666.48s -> 3670.76s]  was this block right here before it forked.
[3670.76s -> 3674.84s]  So the parent's child handler is not going to get called
[3674.84s -> 3678.08s]  until line 45 down here,
[3678.08s -> 3680.76s]  when we call unblock,
[3680.76s -> 3685.20s]  we'd say sig proc mask unblock, sig unblock on that set.
[3685.24s -> 3689.36s]  At that point, now the parent's signal handler can get called
[3689.36s -> 3692.08s]  and it will get called because the operating system goes,
[3692.08s -> 3693.42s]  oh, now you're accepting signals?
[3693.42s -> 3694.52s]  I've got one for you.
[3694.52s -> 3696.12s]  And it calls it then.
[3696.12s -> 3698.76s]  Hopefully this will actually
[3701.76s -> 3704.74s]  see how this work, jobless synchronization.
[3704.74s -> 3706.94s]  And hopefully there we go.
[3706.94s -> 3710.12s]  Now we actually are waiting for one second
[3710.12s -> 3711.96s]  and now the jobs are added
[3711.96s -> 3715.08s]  and then removed in the proper order.
[3716.04s -> 3717.96s]  We didn't allow them to be removed
[3717.96s -> 3719.48s]  until they've been added.
[3719.48s -> 3723.28s]  And in this case that just took us a little time to add it.
[3723.28s -> 3724.76s]  And that's the way it goes.
[3726.76s -> 3727.60s]  Question.
[3727.60s -> 3729.20s]  Well, but the date still gets printed
[3729.20s -> 3730.30s]  before you add the job.
[3730.30s -> 3732.40s]  Yeah, the date gets printed before we add the job.
[3732.40s -> 3733.88s]  We don't really care about that
[3733.88s -> 3735.32s]  because we've said to the,
[3735.32s -> 3736.54s]  that's a good point though.
[3736.54s -> 3739.08s]  We said, hey, go run, right?
[3739.08s -> 3740.96s]  We're trying to do our own like adding in,
[3740.96s -> 3742.20s]  we're trying to do our own bookkeeping,
[3742.20s -> 3744.00s]  but yeah, you're off and running, right?
[3744.04s -> 3745.26s]  Now, if you want to do that,
[3745.26s -> 3746.80s]  yeah, you wouldn't.
[3746.80s -> 3747.88s]  If you needed to do that,
[3747.88s -> 3750.90s]  we would have done something like this.
[3750.90s -> 3753.12s]  If you said, wait, I don't even want date to run
[3753.12s -> 3756.64s]  before we did the exec CVP, right?
[3756.64s -> 3759.28s]  Like we would have to, before we even forked,
[3759.28s -> 3762.20s]  we would have to then figure out like how to do that.
[3762.20s -> 3763.48s]  Now, this might actually,
[3763.48s -> 3765.96s]  this also might be like an issue you can't,
[3765.96s -> 3768.00s]  in this case, we would have to do something else
[3768.00s -> 3771.80s]  to try to figure out like how to wait to print
[3771.80s -> 3774.00s]  until the parent has done it.
[3774.00s -> 3775.24s]  But once you've got a child and a parent,
[3775.24s -> 3777.12s]  they're kind of independent anyway.
[3777.12s -> 3779.00s]  So you're not really gonna wanna,
[3779.00s -> 3780.24s]  you're not gonna be able to wait
[3780.24s -> 3781.40s]  for the parent on the child.
[3781.40s -> 3782.60s]  The child is not really gonna be able
[3782.60s -> 3784.82s]  to wait for the parent itself.
[3784.82s -> 3786.64s]  So you've gotta be able to figure some other logic
[3786.64s -> 3787.84s]  out to do that.
[3787.84s -> 3788.98s]  Yeah.
[3788.98s -> 3790.40s]  Yeah.
[3790.48s -> 3791.32s]  Sorry.
[3802.86s -> 3804.04s]  Very good question.
[3804.04s -> 3805.08s]  The question was, wait,
[3805.08s -> 3808.80s]  is reprocesses also passed down to the child?
[3808.80s -> 3812.00s]  It certainly is because it's part of the program, right?
[3812.00s -> 3814.96s]  So the child has access to all its own functions.
[3814.96s -> 3817.92s]  Now, the child's reprocess won't get called
[3817.92s -> 3822.64s]  when the child ends because it's not,
[3822.64s -> 3825.00s]  it doesn't have a child that's ended.
[3825.00s -> 3826.04s]  That was a good inception, Mike.
[3826.04s -> 3826.88s]  You mentioned earlier how the date
[3826.88s -> 3828.16s]  might have a child process.
[3828.16s -> 3829.92s]  Yeah, yeah, right.
[3829.92s -> 3831.84s]  The date might have a child process,
[3831.84s -> 3834.04s]  in which case, then it would get called.
[3834.04s -> 3837.04s]  And in that case, we would have more job reforms
[3837.04s -> 3841.68s]  than job added because we never did a job added.
[3841.68s -> 3842.50s]  Yeah, yeah.
[3842.50s -> 3843.64s]  So the question was, wait, wait, wait, wait.
[3843.64s -> 3845.30s]  If the date did have a child,
[3845.30s -> 3847.80s]  then this signal might get called.
[3848.64s -> 3852.36s]  Now, likely, the child would set up its own,
[3852.36s -> 3854.08s]  well, actually, that's a good point.
[3854.08s -> 3855.84s]  In this case, this one would have, sure,
[3855.84s -> 3857.16s]  it might have gotten called
[3857.16s -> 3859.60s]  if the child process had a child process.
[3859.60s -> 3862.44s]  Yeah, if the child process had a child process.
[3862.44s -> 3864.60s]  Yeah, the child's one would get called.
[3864.60s -> 3866.44s]  It wouldn't get added to the parent's job list.
[3866.44s -> 3869.04s]  It would get added to the child's job list,
[3869.04s -> 3871.00s]  or I guess it would get removed
[3871.00s -> 3871.92s]  from the child's job list.
[3871.92s -> 3873.20s]  So you would have to put more logic in there
[3873.20s -> 3874.64s]  if you cared about that.
[3874.64s -> 3876.02s]  Yeah, yeah, good point.
[3876.02s -> 3876.86s]  Yeah.
[3876.86s -> 3879.70s]  What you could also do is you can basically say,
[3879.70s -> 3881.98s]  you can set up the signal,
[3881.98s -> 3885.32s]  you can say signal with a null value.
[3885.32s -> 3888.12s]  Well, basically, it's saying don't handle it anymore.
[3888.12s -> 3890.28s]  You could do that in the child if you cared about that.
[3890.28s -> 3892.26s]  We happen to not care about that for this part.
[3892.26s -> 3893.44s]  Good, very good, good point.
[3893.44s -> 3894.70s]  There are lots of things to think about
[3894.70s -> 3896.54s]  with these things when you're building these real programs.
[3896.54s -> 3897.38s]  Yeah.
[3898.48s -> 3901.50s]  So a sigblock, does that not allow the program
[3901.50s -> 3903.62s]  to receive signals or send signals?
[3903.62s -> 3905.26s]  It does not allow, good question.
[3905.28s -> 3907.82s]  The question was, does sigblock not allow the program
[3907.82s -> 3909.06s]  to receive signals or send it?
[3909.06s -> 3913.46s]  It doesn't allow the parent, in this case,
[3913.46s -> 3915.78s]  to receive that signal.
[3915.78s -> 3917.94s]  Its signal handler will not get called.
[3917.94s -> 3919.74s]  It may be queued up to get called later,
[3919.74s -> 3921.38s]  but it will not get called.
[3921.38s -> 3922.22s]  Good question.
[3923.06s -> 3923.88s]  Yeah.
[3923.88s -> 3924.72s]  I was gonna ask, is there a limit
[3924.72s -> 3928.90s]  to how many signals the operating system
[3928.90s -> 3930.86s]  will block and store?
[3930.86s -> 3931.70s]  Oh, good question.
[3931.70s -> 3935.18s]  If there's some list or some queue limit
[3935.18s -> 3937.76s]  on the number of signals, I don't know of any.
[3937.76s -> 3939.80s]  It's probably big enough that it's not gonna matter.
[3939.80s -> 3941.44s]  Like, it's probably thousands,
[3941.44s -> 3942.82s]  and you probably likely won't be able
[3942.82s -> 3946.54s]  to even create thousands of children anyway or whatever.
[3946.54s -> 3948.38s]  So it's probably some limit
[3948.38s -> 3949.62s]  that we aren't gonna worry about.
[3949.62s -> 3950.74s]  Yeah, good question.
[3951.62s -> 3956.62s]  If we commented this out,
[3958.10s -> 3959.46s]  it's gonna run exactly the same
[3959.46s -> 3961.66s]  because the child isn't gonna get any children,
[3962.64s -> 3963.86s]  and it's not gonna matter anyway.
[3963.86s -> 3967.62s]  Although, if we ran another program that had children,
[3967.62s -> 3968.94s]  yeah, it probably would print
[3968.94s -> 3970.34s]  that some job has been added,
[3970.34s -> 3971.38s]  and I'd be like, well, that's weird.
[3971.38s -> 3972.86s]  Why would that happen, right?
[3972.86s -> 3975.88s]  But no, in this case, not gonna matter.
[3978.10s -> 3979.82s]  Did I delete the wrong one?
[3979.82s -> 3980.98s]  Oh no, thank you for.
[3983.46s -> 3985.86s]  Oh, you wanna do this one.
[3985.86s -> 3988.86s]  That one would just make you behave as it did before.
[3988.86s -> 3990.10s]  That one, thank you.
[3992.38s -> 3994.78s]  All right, jobless synchronization.
[3994.78s -> 3996.58s]  Yeah, same sort of thing.
[3996.58s -> 3999.22s]  No children for the children are getting,
[3999.22s -> 4000.06s]  calling that function.
[4000.06s -> 4000.90s]  Yeah?
[4000.90s -> 4002.72s]  If you had one that did.
[4004.46s -> 4007.06s]  Right, if date had its own child process,
[4007.06s -> 4008.06s]  yeah, we probably would have gotten
[4008.06s -> 4009.42s]  a weird printf in there that said
[4009.42s -> 4011.74s]  some other process had been added to the jobless.
[4011.74s -> 4014.22s]  So again, when you're trying to do these things,
[4014.22s -> 4015.58s]  you have to kind of keep track
[4015.58s -> 4017.30s]  of some of the details of these
[4017.30s -> 4020.14s]  because it's tricky.
[4020.78s -> 4021.66s]  Good question.
[4021.66s -> 4022.50s]  Yeah?
[4022.50s -> 4024.78s]  Is there a way to remove the connection
[4024.78s -> 4028.90s]  between the function pointer and the signal?
[4028.90s -> 4029.92s]  Yeah, good question.
[4029.92s -> 4033.50s]  If you want to say, stop calling
[4033.50s -> 4035.82s]  my function or signal handler,
[4035.82s -> 4037.88s]  I forget exactly what it is,
[4037.88s -> 4040.10s]  but it's another, you basically do signal
[4040.10s -> 4041.30s]  and then instead of SIGCHILD,
[4041.30s -> 4043.74s]  it's like no signal, it's not that,
[4043.74s -> 4045.14s]  but it's something like that.
[4045.14s -> 4046.42s]  I don't remember exactly what it is,
[4046.42s -> 4048.06s]  but that's what it is.
[4048.06s -> 4050.54s]  In fact, we can look it up.
[4050.54s -> 4055.12s]  If we do man signal, let's see.
[4055.12s -> 4055.96s]  Here we go.
[4057.34s -> 4058.82s]  Let's see, SIG, here we go.
[4058.82s -> 4063.08s]  SIGIGN means the signal's gonna get ignored.
[4063.08s -> 4067.92s]  Or SIGDFL means that the default action will happen.
[4067.92s -> 4070.20s]  So you just pass that into signal
[4070.20s -> 4072.48s]  and it goes, oh, all right, no more SIGCHILD.
[4072.48s -> 4075.14s]  It's gonna be called in my process.
[4075.14s -> 4075.98s]  Good question.
[4077.10s -> 4077.94s]  All right.
[4078.90s -> 4080.26s]  Kind of nice when you have the manual right there,
[4080.26s -> 4081.12s]  your fingertips.
[4082.46s -> 4083.30s]  Okay, all right.
[4083.30s -> 4086.36s]  So those are the signals there.
[4086.36s -> 4091.36s]  We have gone through the different types of signals.
[4091.78s -> 4093.62s]  We can actually write a little function
[4093.62s -> 4094.68s]  to kind of capture this
[4094.68s -> 4097.52s]  instead of writing each little part out individually.
[4097.52s -> 4100.34s]  In this case, we could write impose SIGCHILD block,
[4100.34s -> 4102.32s]  which does sets up a set
[4102.32s -> 4105.02s]  and then calls SIGPROCMAS to block,
[4105.02s -> 4107.18s]  and then we could do the exact lift one,
[4107.18s -> 4109.82s]  which does the same sort of thing except unblocks it.
[4109.82s -> 4111.96s]  You could also have one that toggles it if you want to,
[4111.96s -> 4113.16s]  and you'll see those functions.
[4113.16s -> 4115.92s]  We've written some of those functions for you there.
[4116.94s -> 4118.92s]  Okay, all right.
[4119.82s -> 4122.54s]  We already did this, the improved job list.
[4122.54s -> 4126.14s]  And what else can we say for it?
[4127.02s -> 4128.82s]  Yeah, as I said, fork processes
[4128.82s -> 4131.02s]  inherit the block signal sets.
[4131.02s -> 4133.36s]  So it should lift that signal
[4133.36s -> 4135.46s]  just in case the child cares about it.
[4135.50s -> 4137.34s]  And as people have already mentioned,
[4137.34s -> 4142.06s]  it probably should also get rid of that signal handler too
[4142.06s -> 4144.06s]  so it doesn't get called when the child ends
[4144.06s -> 4145.70s]  because that's not part of our program.
[4145.70s -> 4147.26s]  So again, things you have to think about
[4147.26s -> 4148.94s]  when you're building these for real.
[4148.94s -> 4150.42s]  You have to do lots and lots of testing
[4150.42s -> 4151.70s]  on this sort of stuff.
[4151.70s -> 4153.22s]  Okay, two more quick signals
[4153.22s -> 4157.02s]  or two more quick system calls here.
[4157.02s -> 4160.38s]  Processes can send messages to other processes
[4160.38s -> 4162.32s]  without something happening.
[4162.32s -> 4165.34s]  You are allowed to send a signal to another process.
[4166.18s -> 4170.18s]  You do it using a slightly ill-defined command called kill.
[4170.18s -> 4172.62s]  Now kill was named because the only signal
[4172.62s -> 4175.58s]  that they originally sent was one to terminate a process.
[4175.58s -> 4177.22s]  Basically said kill this process
[4177.22s -> 4179.74s]  and it means not make it stop running.
[4179.74s -> 4180.58s]  Right, so that was the original.
[4180.58s -> 4181.42s]  And then they said, well,
[4181.42s -> 4182.74s]  what if we want to send other signals?
[4182.74s -> 4183.78s]  Let's just keep kill.
[4183.78s -> 4185.28s]  Why didn't you call it send signal or something?
[4185.28s -> 4186.12s]  I don't know.
[4186.12s -> 4188.22s]  But they kept it as called kill.
[4188.22s -> 4189.58s]  Okay, so it doesn't actually kill.
[4189.58s -> 4191.14s]  If you send a SIG kill,
[4191.14s -> 4194.22s]  yes, it will terminate the process.
[4194.26s -> 4199.26s]  But otherwise, you are allowed to give an AP ID,
[4199.26s -> 4201.58s]  send a particular signal.
[4201.58s -> 4204.58s]  Okay, so if you want to send the SIG child signal
[4204.58s -> 4207.14s]  to a particular process, you can send it.
[4207.14s -> 4208.86s]  You can also send,
[4208.86s -> 4211.34s]  I think there's two other ones called like,
[4211.34s -> 4215.60s]  it's SIG, I think it's SIG USR one,
[4215.60s -> 4218.42s]  which is like a generic one that you're allowed to send.
[4218.42s -> 4220.04s]  Just because hey, maybe you want to send one
[4220.04s -> 4221.74s]  that's not a special one that says kill
[4221.74s -> 4225.82s]  or that says stop or says continue or whatever.
[4225.82s -> 4229.54s]  We will see lots of use of these as we go.
[4229.54s -> 4233.74s]  You can also send a signal to yourself,
[4233.74s -> 4238.54s]  which is you do by the raise system call,
[4238.54s -> 4241.34s]  which basically just takes the signal number you're trying
[4241.34s -> 4242.70s]  and it sends it to your own process.
[4242.70s -> 4246.48s]  It is exactly like saying kill with get PID
[4246.48s -> 4248.66s]  for your own PID signal number.
[4248.66s -> 4251.36s]  You could use either and they're interchangeable.
[4251.36s -> 4256.36s]  Okay, you can also get the value of,
[4259.16s -> 4263.44s]  you can change PID to not be the actual PID.
[4263.44s -> 4268.14s]  You can make it affect other processes
[4268.14s -> 4272.64s]  that are tangentially related to a particular process.
[4272.64s -> 4274.96s]  And you handle that with a thing called groups,
[4274.96s -> 4277.00s]  which I'm not going to go into right now.
[4277.00s -> 4282.00s]  But if you send a negative number less than one to kill,
[4284.00s -> 4286.38s]  it actually goes and finds the group
[4286.38s -> 4287.76s]  that's associated with that process.
[4287.76s -> 4288.88s]  What you can do with processes,
[4288.88s -> 4292.02s]  you can set them up such they're in same groups.
[4292.02s -> 4294.52s]  So if you want to send a signal to one process,
[4294.52s -> 4296.40s]  it can then, or it can,
[4296.40s -> 4298.92s]  if you want to send one kill signal,
[4298.92s -> 4301.44s]  it can go to a whole bunch of different processes.
[4301.44s -> 4302.96s]  So it's nice to have these groups.
[4302.96s -> 4305.86s]  We'll get into groups when you get to assignment four.
[4306.84s -> 4308.62s]  And then you can also be zero or negative one.
[4308.62s -> 4311.40s]  We're not going to worry about that for right now.
[4311.40s -> 4313.70s]  Okay, that was a lot of stuff.
[4316.70s -> 4319.50s]  You have assignment two due tomorrow,
[4319.50s -> 4323.42s]  assignment three will come out tomorrow morning.
[4323.42s -> 4325.14s]  I'll do it, release it first thing in the morning
[4325.14s -> 4328.04s]  for anybody who wants to get going on it.
[4328.04s -> 4331.48s]  And I will explain a little bit
[4331.48s -> 4334.62s]  about assignment three on Monday.
[4334.70s -> 4336.88s]  So if you want to get started on it,
[4336.88s -> 4338.54s]  well, maybe I'll do a little video.
[4338.54s -> 4341.26s]  I don't know when I'm going to do a little video.
[4341.26s -> 4342.62s]  But anyway, I will do some explaining
[4342.62s -> 4346.22s]  about assignment three on Monday.
[4346.22s -> 4348.84s]  All right, last minute questions on this stuff or otherwise?
[4348.84s -> 4349.68s]  Yeah.
[4351.20s -> 4353.00s]  Assignment three is actually going to be due
[4353.00s -> 4354.72s]  a week from Sunday.
[4354.72s -> 4357.02s]  So it's a little longer amount of time.
[4357.02s -> 4358.42s]  And then the next one is going to be out that day.
[4358.42s -> 4359.80s]  And then the midterm happens.
[4359.80s -> 4362.38s]  So you've got an extra time for the next one as well.
[4362.98s -> 4365.82s]  It's a little stretched out because midterms and so forth.
[4365.82s -> 4367.18s]  All right, see you guys Monday.
[4367.18s -> 4368.10s]  We're in lab.
[4368.10s -> 4369.38s]  Oh, that reminds me.
[4369.38s -> 4370.22s]  I totally forgot.
[4370.22s -> 4371.18s]  Sorry, one last thing.
[4373.06s -> 4375.14s]  So there are a lot of people who wanted to do
[4375.14s -> 4379.82s]  the Thursday, I forget which one, 3 p.m. lab.
[4379.82s -> 4381.98s]  We are adding another Thursday lab.
[4381.98s -> 4385.24s]  So we're changing one of the Thursday morning labs,
[4385.24s -> 4386.98s]  which not many people are in.
[4386.98s -> 4390.62s]  We're adding a Thursday afternoon lab.
[4390.62s -> 4393.14s]  We're going to combine the two Thursday morning ones.
[4393.14s -> 4394.52s]  And it's only like four or five extra people.
[4394.52s -> 4395.46s]  So it's not a big deal.
[4395.46s -> 4396.58s]  I will put that up later today.
[4396.58s -> 4399.14s]  So if you want to add the Thursday section,
[4399.14s -> 4400.46s]  if you don't like the section you're in,
[4400.46s -> 4402.78s]  an afternoon one, you'll be able to do that.
[4402.78s -> 4404.38s]  All right, see you guys later.
