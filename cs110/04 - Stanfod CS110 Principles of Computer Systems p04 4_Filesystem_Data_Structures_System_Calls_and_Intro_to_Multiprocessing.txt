# Detected language: en (p=1.00)

[0.00s -> 8.92s]  Welcome. Welcome to week two CS 110. I hope everybody had a nice weekend. I
[8.92s -> 15.16s]  apologize for the lab sign-up fiasco. It was only half an hour but there were
[15.16s -> 18.32s]  some people who are definitely concerned about getting signed up. It
[18.32s -> 22.04s]  looks like most people have signed up. I can tell already that the Thursday
[22.04s -> 30.86s]  times were pretty important. It looks like most people wanted to do the
[30.86s -> 35.80s]  Thursday times but and in fact there's still some spots in the earlier time.
[35.80s -> 39.08s]  There's plenty of Friday times and you guys are signed up for the class
[39.08s -> 44.92s]  during this term so it should be all right hopefully. If for some reason you
[44.92s -> 51.72s]  are not able to get your lab time in or whatever let me know. We'll try to
[51.76s -> 56.44s]  figure something else out but for the most part it looks like a lot of people got
[56.44s -> 60.04s]  what they wanted and some people might be didn't so just let me know if there's
[60.04s -> 71.56s]  a big issue. Okay so we are on to just re-plugging my tablet in here
[71.56s -> 81.56s]  because it seems to be giving me fits. Maybe we don't do the tablet today.
[81.56s -> 85.56s]  Hold on one second. Try one other thing.
[91.56s -> 93.56s]  It doesn't work. It doesn't work.
[93.56s -> 101.56s]  There we go. We'll see if that works.
[101.56s -> 109.80s]  Okay. There we go. All right so today we are going to continue with file systems.
[109.80s -> 112.92s]  We're going to talk specifically about some data structures that the
[112.92s -> 119.52s]  operating system has set up for the for keeping track of files and for
[119.52s -> 124.24s]  keeping track of your processes as well as it turns out and then and remember
[124.24s -> 127.88s]  this is the way Unix does it or this is the way Linux does it it's not the
[127.88s -> 131.84s]  way everything does it but it happens to be there Linux does it and it happens
[131.84s -> 135.96s]  to be a pretty good system for keeping track of your files for for
[135.96s -> 138.64s]  what it's worth. So we're gonna do that then we're gonna talk about system
[138.64s -> 143.48s]  calls. We have seen some system calls already and we've used some but we're
[143.48s -> 146.40s]  gonna talk about the details of wait what does it mean to have a system call
[146.40s -> 150.72s]  versus a regular function. All right and then finally we should have time to
[150.72s -> 155.12s]  start getting into the first kind of whoa this is a different way of
[155.12s -> 160.92s]  programming which is multi-processing. Okay so I hope you enjoy that part
[160.92s -> 164.32s]  because it's actually kind of neat once you start going whoa that's really I
[164.32s -> 167.68s]  didn't really know you could do that for the program so that's what I
[167.68s -> 171.72s]  think makes makes this stuff fun. All right the assignment going all right?
[171.72s -> 176.52s]  I'm at one going okay it's due Wednesday no there are no extensions
[176.52s -> 181.04s]  allowed on no like late days for the first assignment and then the second
[181.04s -> 184.80s]  assignment will be out on Wednesday as well. All right come to office hours
[184.80s -> 192.96s]  if you're still having trouble. Okay so Linux when you run a program your
[192.96s -> 197.44s]  program ends up in what's called a process or it has a process that is
[197.44s -> 202.52s]  basically saying it's given a number and it says this program is running and
[202.52s -> 205.72s]  that's the process that it's running under okay we'll get to the details
[205.72s -> 210.12s]  about how that can change a little a little later but Linux maintains data
[210.12s -> 213.44s]  structures to keep track of these processes of course it does right the
[213.44s -> 218.04s]  operating system needs to know about your your programs that are running and
[218.04s -> 221.64s]  so there's some data structure that it keeps track so it keeps track of all
[221.64s -> 225.00s]  the different parts of all the different things that are associated with your
[225.00s -> 230.32s]  program okay they're called process control blocks okay they're called
[230.32s -> 234.92s]  process control blocks and they have lots of information in them okay and
[234.92s -> 238.00s]  they are stored in this thing called the process table which is organized by
[238.00s -> 243.04s]  the operating system okay process control box store lots of things one
[243.04s -> 246.72s]  thing that they score is store is called the descriptor table and the
[246.72s -> 252.76s]  descriptor table is a data structure that holds information about the files
[252.76s -> 257.28s]  you've opened or the files that have been opened for you or the file like
[257.28s -> 260.28s]  things that have been opened for you or that you have opened like for
[260.28s -> 265.28s]  instance networking is modeled using a file the terminal is actually modeled
[265.28s -> 268.84s]  using the file you can print to the terminal just like or you can read and
[268.84s -> 272.08s]  write from the terminal just like you read and write from a file that's one
[272.08s -> 275.00s]  of the beauties beautiful things about Unix is they treat everything like a
[275.00s -> 278.56s]  file if you can as it turns out but anyway they keep this thing called the
[278.56s -> 284.08s]  descriptor table and each process maintains its own set of descriptors
[284.08s -> 289.84s]  okay which is the things that it has open at the time and we all they always
[289.84s -> 295.72s]  get zero one and two for free those are standard out standard or standard
[295.72s -> 299.56s]  in standard out and standard error they kind of get those for free okay
[299.56s -> 303.96s]  most often they are what we call bound to the terminal in other words you
[303.96s -> 308.00s]  type something and it goes to standard in you print out something from your
[308.44s -> 311.72s]  goes to either standard out or the standard error and those are the normal
[311.72s -> 315.28s]  things now we will spend lots of time in this course talking about hey what
[315.28s -> 319.00s]  happens if we remap standard into something else to reading in from a
[319.00s -> 323.24s]  file or standard in Stan or the output of another program we'll talk
[323.24s -> 328.96s]  lots about that as as the course goes goes along okay the descriptors as
[328.96s -> 335.28s]  we've seen you use read write close etc open to actually interact with the
[335.28s -> 340.28s]  files descriptors and then the process control block keeps track of all the
[340.28s -> 346.68s]  different all the details of that okay if you do an open on a file you
[346.68s -> 349.88s]  generally get a very small integer as the file descriptor because zero one
[349.88s -> 353.16s]  and two are taken and then it just kind of goes up from there and it's
[353.16s -> 359.32s]  your own file descriptors are fairly small numbers generally okay all right
[359.32s -> 363.72s]  now this this diagram kind of goes down many levels here not many a few
[363.72s -> 367.28s]  levels and we kind of have to understand each little level as we go
[367.28s -> 372.28s]  if the file descriptor if a descriptor is in use in other words it's an open
[372.28s -> 378.48s]  file okay it maintains a link to this thing called the open file table
[378.48s -> 382.32s]  entry okay so if you have a file it's open you've got this thing
[382.32s -> 387.64s]  called an open file table entry which has some details about the file okay it
[387.64s -> 394.28s]  has things like it takes it takes into account whether or not it's a read only
[394.28s -> 398.72s]  file or read write file or write only file or so forth it takes it has and
[398.72s -> 402.64s]  that's the mode part of it it also has this thing called the cursor which
[402.64s -> 405.72s]  just like the cursor on your screen tells you like where in the file
[405.72s -> 410.56s]  you're reading from okay so it turns out that you can do that it also
[410.56s -> 415.32s]  turns out that multiple programs can open the same file and be reading from
[415.32s -> 420.12s]  different parts of it at the same time okay so lots of lots of files could be
[420.12s -> 425.88s]  opened by various different programs and in fact they end up having this
[425.88s -> 429.00s]  cursor saying hey this program is at this point in the file and this
[429.00s -> 431.88s]  program is at this point that's the cursor okay it's also got this thing
[431.88s -> 437.20s]  called the ref count now the ref count discusses Howard basically keeps
[437.20s -> 444.12s]  track of how many descriptors across all processes actually refer to that
[444.16s -> 450.12s]  session okay and that's important because if you close the file it may be some
[450.12s -> 452.88s]  other file needs to leave it open or something so it's not going to close
[452.88s -> 455.56s]  it and just does this reference count of that we will talk about what
[455.56s -> 460.16s]  this other one this V node is in a second but if you were to do
[460.16s -> 465.88s]  something like say open some filing as read only well this is what you
[465.88s -> 470.76s]  might end up with you might end up with mode being read because you've
[470.76s -> 473.72s]  opened as read only cursor being at zero because it was just opened and the
[474.20s -> 477.24s]  beginning ref count is one maybe you're the only one in the system that has
[477.24s -> 481.80s]  that file open it's pretty likely and the V node will get to in a second okay
[481.80s -> 485.72s]  so that's how that that's how that works all right and in fact this is
[485.72s -> 491.32s]  for process 1001 which you can't see because that's way too small but
[491.32s -> 495.68s]  process ID 1001 later today we'll talk about process IDs actually are all
[495.68s -> 506.12s]  about okay all right so what else do we have well multiple and all the
[506.12s -> 511.20s]  different processes on your computer are take each have their own process
[511.20s -> 515.84s]  control blocks and their own descriptor tables but they all point to a common
[515.84s -> 519.60s]  open file table it's actually a little hard to read to I think but
[519.60s -> 524.84s]  that's the open file table and this is where you have all of the details
[525.28s -> 529.56s]  that we talked about in the previous page but it may be more than one file
[529.56s -> 535.72s]  might or more than one process may point to it okay now it turns out if you
[535.72s -> 539.80s]  have a cursor like if two files are pointing to if two files are at
[539.80s -> 543.64s]  different places in the in the actual file then you need to have two
[543.64s -> 546.08s]  different things you're pointing at okay but that's the basic deal
[546.08s -> 552.16s]  there's one open file table for all of the file resources and this is so
[552.16s -> 556.28s]  you can share them I mean if 25 programs are opening a file you want to
[556.28s -> 563.24s]  be able to share them question though yes the yellow and the green and the
[563.24s -> 567.04s]  blue are the process control blocks for a process so your programs running it
[567.04s -> 570.40s]  might be the yellow one my programs running it might be the green one and
[570.40s -> 573.28s]  remember we can all log on a myth at the same time so we could be running
[573.28s -> 576.76s]  different programs at the same time we each get our own process control
[576.76s -> 580.00s]  blocks for the opera the operating system does it now this is hidden
[580.20s -> 583.28s]  by the way it's not like you can go and dig into your process control block the
[583.28s -> 586.76s]  operating system keeps track of that good question any other questions at
[586.76s -> 596.68s]  this point yeah so a good question how do you keep track of which file has
[596.68s -> 601.52s]  reached which cursor these will actually point to different ones that
[601.52s -> 604.68s]  if they're at different places in the file so then you've got I think you've
[604.68s -> 607.48s]  got another one that's open that has a different cursor associated with it
[608.00s -> 611.60s]  that's because you might be reading in different places so you're going to have
[611.60s -> 616.36s]  two copies of that in that case okay and we'll talk about the V note does
[616.36s -> 620.12s]  in a second too because that's another one all right so we want to be
[620.12s -> 624.40s]  able to keep true keep track of all these files that are shared okay in the
[624.40s -> 630.40s]  case of zero one and two up here okay this this is a zero and a zero and a
[630.40s -> 635.52s]  zero that's standard in and they all happen to point down to this first one
[635.52s -> 640.24s]  right here we look down here and then this one's all the way over here and
[640.24s -> 643.48s]  they all point to that one why because they're all reading from the same
[643.48s -> 648.36s]  standard in depending on which program happens to have control of the terminal
[648.36s -> 652.56s]  at that point or the whatever the the keyboards going okay you can't type in a
[652.56s -> 655.52s]  keyboard and have it go to two different programs as it turns out okay
[655.52s -> 657.72s]  it's only going to go to one program basically I mean there's a
[657.72s -> 661.20s]  little new more nuanced than that but it's that's basically the idea you
[661.20s -> 664.76s]  also they also by the way all their standard outs go down to this one
[664.96s -> 669.68s]  okay and this one actually is interesting if you if you happen to be
[669.68s -> 675.68s]  running one program and and this is a standard app for like your programs
[675.68s -> 680.16s]  that you want if they offer like one kind of session if they all are
[680.16s -> 683.96s]  printing things out they all go to the terminal so you can run for
[683.96s -> 689.20s]  instance make which you do for your assignments right and make calls g++
[689.20s -> 692.76s]  will make may have some output messages they go to the terminal and so
[692.76s -> 697.12s]  does g++ because they share the same file descriptor in that case
[697.12s -> 702.24s]  okay the same they share the same entry in the open file table in other
[702.24s -> 706.64s]  words and that's just so that you can can all they can all go to the
[706.64s -> 711.52s]  terminal as it turns out okay so that's the basics of that well guess
[711.52s -> 717.20s]  what we can talk about these things called a vnode so the vnode is just a
[717.20s -> 723.40s]  structure that holds the information about the file kind of like a cache and
[723.40s -> 727.68s]  when we say cache we mean a place in memory that is storing something
[727.68s -> 731.84s]  instead of going back to the original location right it's stored in RAM
[731.84s -> 736.88s]  memory and it's very fast and that's what's happening with the vnode here
[736.88s -> 742.92s]  okay the vnode is basically saying it's basically storing the details about
[742.92s -> 747.40s]  what kind of file it is a regular file as a directory etc it also stores the
[747.40s -> 751.64s]  reference count how many things have this file open and then it stores a
[751.64s -> 754.80s]  bunch of other details needed to actually access the file so a bunch of
[754.80s -> 760.12s]  pointers and then it stores a copy of the inode which we talked about last
[760.12s -> 764.80s]  week which is the information about a particular file so if a file is open
[764.80s -> 767.84s]  you don't need to go back and if you want to read from it or to go
[767.84s -> 771.64s]  back and go and try to find it again in the file system you've got the
[771.68s -> 775.56s]  information about the inode right there okay so that's the details and this gets
[775.56s -> 781.60s]  updated as the file gets written to and so forth but and then that gets
[781.60s -> 786.32s]  pulled in so those are the levels of the data structures that the operating
[786.32s -> 790.84s]  system and your program keep track of in order to in order to keep track of
[790.84s -> 798.40s]  what files we have open yes why does it store the ref count two places
[798.40s -> 802.36s]  that's probably a good question it may be depending on who's reading it when or
[802.36s -> 805.32s]  which part of the program which part of the opposite reading it when it'll go to
[805.32s -> 809.76s]  either the it'll go to either V node or the open file table entry I'm not
[809.76s -> 812.32s]  sure why it does both but if they should be I think they should be locked
[812.32s -> 821.92s]  step yeah if you have different if you have different if you have you
[821.92s -> 824.48s]  mean like this one might this one might also point that would be a bad
[824.48s -> 827.04s]  example of one but that might also point there yeah so the ref count down
[827.16s -> 832.04s]  here is how many of the open file table entries point to that V node like you
[832.04s -> 836.40s]  could have the same file open in two different ways okay because of you've
[836.40s -> 845.68s]  opened and that's I think that's the answer there question it is a copy
[845.68s -> 849.24s]  from the disk yeah this let me show you the next one right here not the
[849.24s -> 852.32s]  next one I'll get it I'll get to it what it basically does that just reads
[852.32s -> 854.84s]  it from the disk and then stores it in memory so you don't go look it up
[854.84s -> 859.68s]  again on the disk just faster that way faster you can do that the better if
[859.68s -> 871.88s]  you're dealing with things like memory that's a good question the
[871.88s -> 875.64s]  question is is the open file table sorted in any way no it's not sorted in
[875.64s -> 879.40s]  any particular way you basically keep links to it it's not like you're
[879.40s -> 882.40s]  searching through the whole thing to find things generally you have a like
[882.40s -> 887.32s]  if your process opens a file it this green process might open this file well
[887.32s -> 889.76s]  it's got a link right there and it knows how to search that very quickly
[889.76s -> 892.80s]  and then it'll find here and then this might point to a V node and that'll
[892.80s -> 895.84s]  be so it's it's not so slow process it's not and these things
[895.84s -> 899.98s]  aren't giant either there might be thousands of files open but honestly
[899.98s -> 905.16s]  thousands is small and computer speak so it's not a huge huge amount other
[905.16s -> 924.88s]  questions right so this is a good question I have to remember the answer
[924.88s -> 928.68s]  the question was hey if I'm started if I read from some file with this one
[928.68s -> 932.24s]  another file is also pointing to it at the same time which cursor is getting
[932.24s -> 935.92s]  updated I believe it may actually create a whole new entry in that case if
[935.92s -> 940.00s]  it needs to have different cursors in different places like if one if if it's
[940.00s -> 943.56s]  if it's reading through it needs to know where it's reading from and so I
[943.56s -> 945.48s]  think there's another one that created I'll look that up I'm not a
[945.48s -> 950.20s]  hundred percent sure and where that one differentiates yeah anybody else
[950.20s -> 956.44s]  okay let's move on to another one here okay um there well I've already
[956.44s -> 960.88s]  kind of talked about this there's one system-wide V node table
[960.92s -> 964.64s]  basically because everybody has to share these things because you don't want
[964.64s -> 968.12s]  to have them all independent if you can help them up that okay it's kind of
[968.12s -> 971.88s]  like an alias it says hey look somebody's opened this file why keep
[971.88s -> 975.40s]  multiple copies of it for each person that's or each file that's opened it
[975.40s -> 978.96s]  let's just keep it all in one place and then there's some coordination that
[978.96s -> 985.84s]  has to go to deal with the cursors and so forth all right and like I
[985.84s -> 990.40s]  said the well first of all none of this is really available to you just as the
[990.40s -> 993.60s]  user the kernel keeps track of this you don't really want that by the way I mean
[993.60s -> 998.04s]  you don't want you as the user to be able to walk through the open file
[998.04s -> 1001.88s]  table and see other people's files and what other programs have files open or
[1001.88s -> 1005.56s]  be able to change any details about that so you want that to be somewhat
[1005.56s -> 1011.82s]  secure and then this little I node is and this is basically separate from the
[1011.82s -> 1016.40s]  file system by the way the file system is kind of on the disk and you
[1016.40s -> 1022.32s]  keep a copy in memory of for instance this little yellow I node slice in memory
[1022.32s -> 1027.32s]  okay and I'm not I'm not 100% sure when that actually gets updated so but it
[1027.32s -> 1030.32s]  like if it gets modified that probably propagates through at some
[1030.32s -> 1033.76s]  point but it may not be immediate depending on the file system you're
[1033.76s -> 1038.44s]  using okay so those are the big things now if you read the not the big
[1038.44s -> 1042.24s]  textbook with a smaller textbook the one that's online this is all laid out
[1042.24s -> 1046.70s]  and that pretty explicitly as well so if you need more details about it go with
[1046.70s -> 1052.60s]  that all right that's file systems like more details about that let's move
[1052.60s -> 1059.00s]  on to system calls this is where some interesting things happen system calls
[1059.00s -> 1063.42s]  are as I've said I've said this a number of times system calls are the way
[1063.42s -> 1069.56s]  your program interacts with your hardware and the network and things
[1069.56s -> 1075.00s]  that are probably not so great to have your program directly access it why
[1075.00s -> 1078.92s]  because you guys are mean and would write malicious programs right like
[1078.92s -> 1082.80s]  that's the basic idea this didn't always start this way Unix when it
[1082.80s -> 1087.64s]  first started out you it was a very open sort of system and everybody it
[1087.64s -> 1090.20s]  was in a research environment and nobody was going to go muck around in
[1090.20s -> 1093.48s]  somebody else's files but when they when it started getting more and more
[1093.48s -> 1096.84s]  and more users they realized hey we better figure out how to make this so
[1096.84s -> 1103.60s]  that there's good security and a system call is the way that works okay so we've
[1103.60s -> 1106.80s]  seen some system calls already we've seen open and read and write and close
[1106.80s -> 1111.04s]  and stat L staff there's all system calls okay we'll see lots and lots of
[1111.04s -> 1114.80s]  more system calls because remember this class is all about interacting with the
[1114.80s -> 1121.00s]  operating system and the functions are different okay we write functions or
[1121.00s -> 1124.92s]  you wrote some functions for 107 or 107e that would have gone into let's
[1124.92s -> 1131.52s]  say lib C or just your user functions or lib standard C++ system calls have to be
[1131.52s -> 1135.36s]  privileged okay they have to access their own data structures that your
[1135.36s -> 1142.96s]  program shouldn't have access to and they should be able to be partitioned
[1142.96s -> 1147.56s]  off from the rest of the user okay and so that's what what you really
[1147.56s -> 1152.04s]  want to be able to able to do okay open needs access to the open file
[1152.04s -> 1156.64s]  descriptor table and well and and you don't want to be able to make the user
[1156.64s -> 1163.16s]  have access to that okay in other words we shouldn't be able to get access
[1163.16s -> 1166.68s]  to privileged information yet we still need to be able to open and close files
[1166.68s -> 1171.68s]  okay so that's the bottom line now so we need to have a different call and
[1171.68s -> 1179.76s]  return model now if you took cs107 or cs107e you'll remember that each
[1179.76s -> 1183.92s]  process or maybe you don't but maybe this was never explicit made explicit
[1183.92s -> 1188.12s]  to you I mean 107e those who took that it was pretty straightforward that the
[1188.12s -> 1191.28s]  one program that was running has access to all of the memory in the
[1191.28s -> 1198.64s]  system for 107 or for 106 B or whatever you run a program it thinks it has
[1198.64s -> 1203.16s]  access to the entire system memory okay your program as far as it's
[1203.16s -> 1207.32s]  concerned can write and read from any part in memory now you can get seg
[1207.32s -> 1210.08s]  faults and things because you're not actually given that from the operating
[1210.08s -> 1212.84s]  system you can't just willy-nilly do it but that's the operating system saying
[1212.84s -> 1219.14s]  look here's your portion but in the bigger picture it's not like if you
[1219.14s -> 1223.60s]  were able to access a different portion of memory some other program would be
[1223.60s -> 1228.04s]  also accessing it your program thinks it has all of memory this is going to
[1228.04s -> 1234.04s]  become very important in a few minutes but the 64-bit address space first of
[1234.04s -> 1240.10s]  all it's gigantic okay to the 64 is a very very very big number and as in the
[1240.10s -> 1243.92s]  way the operating system and the hardware works it like I said makes it
[1243.92s -> 1248.88s]  seem like your program has access to the entire memory system but it really
[1248.88s -> 1253.84s]  doesn't this is a virtualization layer what happens is you've got virtual
[1253.84s -> 1258.72s]  memory which is the addresses that your program thinks it's writing to and then
[1258.72s -> 1261.84s]  that gets translated into what we call physical memory which is the
[1261.84s -> 1265.72s]  operating system in the hardware saying okay this program actually has the
[1265.72s -> 1270.60s]  memory here and this program has memory up here even though they both think
[1270.60s -> 1275.16s]  they're writing to the same place okay so so it turns out that you can you
[1275.16s -> 1278.84s]  can do that I wanted to show you an example of that so I wrote a program I
[1278.84s -> 1281.60s]  was going to run it in two places at the same time and show that it was the
[1281.60s -> 1286.08s]  same memories place but it turns out that they that the operating system
[1286.08s -> 1290.96s]  plays some games with that so it doesn't ever put the same one even nearby it
[1290.96s -> 1294.80s]  probably would if you if you if you tried to get a huge amount of memory but
[1294.80s -> 1298.96s]  but for you know for the purposes of this I couldn't quite demonstrate it
[1298.96s -> 1302.20s]  because the it was also a security measure too by the way I don't know if
[1302.20s -> 1308.36s]  you remember from cs107 if you took that when you run a program the stack
[1308.36s -> 1311.96s]  ends up at a slightly different place and there's these canaries in there
[1311.96s -> 1315.52s]  that say whether or not the stack gets overwritten by a malicious user or
[1315.52s -> 1318.36s]  something those are all security issues I think it's the same same sort
[1318.36s -> 1325.52s]  of thing but anyway no process uses all 2 to the 64 bytes okay most programs
[1325.52s -> 1330.60s]  use a very very small amount okay all right that's kind of the setup here
[1330.60s -> 1334.92s]  there are lots of different segments in the memory system you talked about
[1334.92s -> 1340.40s]  some of these in 106 or 107 or 107e you've got the stack the stack is
[1340.40s -> 1344.36s]  where your user program keeps all of its local variables keeps its arrays and
[1344.36s -> 1348.24s]  keeps its kind of local data for functions the stack also is where
[1348.24s -> 1352.12s]  function calls get pushed on to all the data for function calls get pushed on
[1352.12s -> 1356.36s]  to and you've got the function calls the function calls in order on the stack
[1356.36s -> 1360.64s]  okay you've also got the heap you guys wrote a heap allocator and heap
[1360.64s -> 1365.24s]  allocators get memory in bigger chunks generally and that's a different
[1365.24s -> 1370.40s]  portion of memory there's also the code section or also called the text
[1370.40s -> 1376.12s]  section that's where your code is held okay there's a data section which is
[1376.12s -> 1381.24s]  which has part of the data for like global variables things like that okay
[1381.24s -> 1386.96s]  and the this this whole thing is managed basically by the operating
[1386.96s -> 1390.28s]  system for your process okay the operating system says here's some
[1390.28s -> 1393.96s]  memory for your process here's your stack here's your heap here's the data
[1393.96s -> 1398.92s]  here's the code go and it's it could look very similar program to program
[1398.92s -> 1404.28s]  but again it's kind of abstracted a little bit away okay all right there's
[1404.28s -> 1407.80s]  other segments that you may not have talked about okay there's the shared
[1407.80s -> 1412.12s]  107e definitely talks about this there's the shared library portion and
[1412.12s -> 1418.64s]  the BSS portion and the read-only data segment those are all segments
[1418.64s -> 1421.28s]  they have their specialized uses read-only data as you can imagine is
[1421.28s -> 1423.88s]  read-only data you're only allowed to read to it you're not allowed to write
[1423.88s -> 1430.56s]  to it they've got the shared libraries if you have a function like printf right
[1430.56s -> 1435.60s]  if you have printf well there might be many many many programs all using
[1435.60s -> 1439.36s]  printf at the same time to print out to individual terminals well why
[1439.36s -> 1444.16s]  duplicate that code for every user just put it in one code location and
[1444.16s -> 1448.20s]  have that user or have the user jump to that code location and run the
[1448.20s -> 1452.00s]  shared code that's a good way to save some memory okay and that's the way
[1452.00s -> 1460.88s]  shared shared libraries work okay all right so how do programs do function
[1460.88s -> 1466.04s]  calls you should maybe remember this from 107 you have a stack pointer
[1466.04s -> 1472.88s]  right and you have all these other registers in here as well okay to call
[1472.88s -> 1477.40s]  a function what do you do well you put a bunch of data inside the registers
[1477.40s -> 1483.20s]  RDI, RSI, RDX hopefully this is something that's coming back to you from 107
[1483.20s -> 1487.80s]  right RCX etc if you run out of registers in other words the one two
[1487.80s -> 1490.84s]  three four five six you start putting them on the stack and there's a
[1490.84s -> 1495.04s]  very well-defined way of doing that okay and again this is some people
[1495.04s -> 1498.78s]  decided hey this is the way it's gonna be so this is the way we're gonna do
[1498.78s -> 1502.20s]  it it's not like this is some come down from high sort of you have to do it
[1502.20s -> 1505.84s]  it's somebody decided this and said that's what we're gonna do the first the
[1505.84s -> 1510.24s]  first parameter is always going to go into RDI the second parameter is always
[1510.24s -> 1518.60s]  going to RSI etc okay and then you do this call queue or call assembly
[1518.60s -> 1523.84s]  instruction and that jumps to the program code for your for your other
[1523.84s -> 1527.76s]  function in your own user space and then it does the call and then you do
[1527.76s -> 1533.08s]  a return and it comes back that should be relatively familiar okay from doing
[1533.08s -> 1537.20s]  107 or 107e although in 107e didn't have these register names they were
[1537.20s -> 1542.68s]  nice like r0 r1 r2 here there there are all these these historical names from
[1542.68s -> 1551.60s]  x86 days the original x86 days okay so that's how function calls work well
[1551.60s -> 1557.92s]  what's the the big deal with that well this does not encapsulate the
[1557.92s -> 1561.88s]  memory that we use in other words it doesn't hide that memory from anything
[1561.88s -> 1568.68s]  else okay if you have your let's say you have your main stack frame here okay
[1568.68s -> 1572.16s]  and then you call a function just a regular function called load files well
[1572.16s -> 1577.58s]  that's going to go on the stack okay and then you do your if stream or
[1577.58s -> 1580.40s]  whatever that might go on the stack and then that's going to call other
[1580.40s -> 1586.04s]  like read and write function system calls but in this case remember from 107
[1586.04s -> 1589.00s]  where you did all that like sneaky stuff with I don't know if you still
[1589.00s -> 1592.84s]  do this with like ATM machines and trying to hack in and whatever because
[1592.84s -> 1597.56s]  you can go and you can you can go and modify your own stack and whatever you
[1597.56s -> 1602.92s]  can do that but that's not very secure okay in other words it's privacy
[1602.92s -> 1607.08s]  is not the prime concern here basically they're saying look if you own
[1607.08s -> 1610.88s]  the stack for your program sure you want to muck around in your own stack
[1610.88s -> 1614.76s]  go right ahead who cares you might crash your program or you might modify
[1614.76s -> 1617.76s]  something for your own program that doesn't matter right that doesn't
[1617.76s -> 1621.56s]  matter it all the things change everything changes when you all of a
[1621.56s -> 1626.72s]  sudden have to go to when you have to go to the system and get information
[1626.72s -> 1632.84s]  from the system okay so now we get to system calls well system calls okay
[1632.84s -> 1636.96s]  like open they as we said I said a hundred times already they shouldn't be
[1636.96s -> 1641.84s]  exposed and they are need to be stored in a region of memory that your
[1641.84s -> 1646.44s]  program does not have access to okay it can't be a shared library it can't be
[1646.48s -> 1651.36s]  something that your program could actually code that you write modify
[1651.36s -> 1657.20s]  just shouldn't be allowed okay so what do we do well we break up the memory
[1657.20s -> 1663.04s]  diagram into a space that has the kernel stack in it okay you are not
[1663.04s -> 1665.80s]  allowed to write to there and if you tried to the operating system would
[1665.80s -> 1669.40s]  stop you anyway okay but the kernel stack resides in memory but your
[1669.40s -> 1673.18s]  programs do not have access to that okay you basically have to tell the
[1673.18s -> 1677.58s]  operating system hey I'm about to do something or I want you to do
[1677.58s -> 1682.06s]  something for me that involves something I shouldn't have a direct access to
[1682.06s -> 1685.66s]  okay so it needs to be in a region of memory that the user can't touch
[1685.66s -> 1690.46s]  and it needs to be executed in a privileged what we call super user
[1690.46s -> 1695.38s]  mode okay so that that mode can have access to that this is not your
[1695.38s -> 1700.46s]  code anymore okay it's the code that's owned by the kernel okay the kernel
[1700.46s -> 1704.62s]  owns the that code and you have to say to the kernel hey go do this for me
[1704.62s -> 1710.02s]  okay it's called kernel space and it's got the stack segment and it's got its
[1710.02s -> 1717.18s]  own instructions as well okay we can't use call queue anymore to do this okay
[1717.18s -> 1721.98s]  because the minute we use call queue that stays within our own address space
[1721.98s -> 1725.78s]  we could we could do that so we need a different way of doing it what is
[1725.78s -> 1731.46s]  that different way well that different way is to do a thing called a syscall
[1731.46s -> 1734.46s]  and it's an actual instruction I'm going to show it to you in a second
[1734.46s -> 1740.54s]  okay and what it is is you place an opcode in other words an operation you
[1740.54s -> 1744.54s]  want to do all the operations that are the system codes have and have a
[1744.54s -> 1748.74s]  number associated with them if you want to read you've got one for the
[1748.74s -> 1752.02s]  operation code if you want to write it's to open happens to be three we'll see
[1752.02s -> 1756.14s]  that one in a minute open is three etc okay they all have their own opcodes
[1756.14s -> 1762.02s]  that are based in the kernel defines them okay and then you place arguments
[1762.02s -> 1766.14s]  same as before you place them in a bunch of registers now it happens for
[1766.14s -> 1771.54s]  some reason it goes RSI RDI RSI RDX R10 instead of RCX I don't know why
[1771.54s -> 1776.06s]  that's changed but some other reason for that not important for this class
[1776.06s -> 1780.70s]  at all but that's that's the way that goes and then what you do what
[1780.78s -> 1785.70s]  you do is you perform what's called an interrupt 107E folks you'll know what
[1785.70s -> 1790.46s]  interrupts are but an interrupt is basically saying hey operating system
[1790.46s -> 1795.98s]  stop my program and handle this and the operating system goes okay your
[1795.98s -> 1798.86s]  program is not going to be stopped and then I'm going to go do I'm going
[1798.86s -> 1801.62s]  to look at the registers and do whatever you want and then I'm going to start
[1801.62s -> 1804.70s]  your program up again that's basically what an interrupt is doing it's
[1804.70s -> 1809.02s]  interrupting your program until whatever you're asking get to get done gets
[1809.06s -> 1813.14s]  done okay we're going to see that a lot in this course of your program
[1813.14s -> 1816.26s]  waiting around for something else to get done being in some sort of
[1816.26s -> 1822.10s]  interrupted state or sleep state or something like that okay so you put
[1822.10s -> 1826.14s]  all these things in the in the registers you do this syscall it
[1826.14s -> 1829.94s]  handles it and then it returns back to you with the result as you might
[1829.94s -> 1836.46s]  expect in our ax except for a couple things there's a question oh such a
[1836.50s -> 1839.54s]  good question the question was yeah this question was what happens if you have
[1839.54s -> 1843.82s]  more than six arguments you don't there are no system calls that are that
[1843.82s -> 1848.14s]  have more than six arguments in them that's by the rules because of that
[1848.14s -> 1851.98s]  exact reason you don't have access to put them on the stack so they they
[1851.98s -> 1855.46s]  get put in the just in the registers you have and no system calls need more
[1855.46s -> 1858.62s]  there are there are ways of getting around that by the way you can but but
[1858.62s -> 1863.06s]  in general there are no system calls that have more than six other
[1863.06s -> 1873.06s]  questions yeah yeah let me talk about the interrupt handler good question the
[1873.06s -> 1875.62s]  question was just like what's what's this deal the interrupt handler it's
[1875.62s -> 1882.10s]  another function that's actually in the kernel space that runs and that
[1882.10s -> 1885.66s]  function goes okay now I'm in kernel space on the I'm the kernel I get to do
[1885.66s -> 1890.14s]  and I get to access all things you can't affect that function at all but
[1890.14s -> 1895.58s]  you can call it and that's been calling it through this syscall method that we
[1895.58s -> 1899.22s]  have here that's how you do it so what's the bottom line on that this is
[1899.22s -> 1903.22s]  how you tell the operating system please do something for me because I'm
[1903.22s -> 1906.38s]  not allowed you're not allowing me to do this system calls are wait the
[1906.38s -> 1910.34s]  way you do that and then there's some some details about what happens if you
[1910.34s -> 1915.02s]  return to the regular function there was an error if you if you have a return
[1915.38s -> 1923.30s]  value that is negative what it does is it sets the error number or error no
[1923.30s -> 1928.78s]  which is that global variable to the positive value of that negative value
[1928.78s -> 1934.02s]  why that's just the way they've done it and then you update our ax to
[1934.02s -> 1937.42s]  actually contain negative one so if you do a system call and you get back
[1937.42s -> 1945.38s]  negative one you know that you've that you've got an issue and and then you go
[1945.38s -> 1957.06s]  and check the error number okay yeah error number is per process yes it's
[1957.06s -> 1964.50s]  part of the C library yes yes so when you call the when you when you do the
[1964.50s -> 1967.86s]  interrupt the colonel knows that your process is the one that it arrived it
[1967.86s -> 1974.50s]  yeah and it knows where to find those details good question anybody else all
[1974.50s -> 1978.22s]  right so that's how system calls work I'm not gonna ask you too many more
[1978.22s -> 1981.30s]  deep too many details about this I'm not gonna certainly not gonna like make
[1981.30s -> 1985.22s]  you do any assembly coding or anything like that for this but I do want to
[1985.22s -> 1989.82s]  just show you what happens when when you do this remember the copy function
[1989.82s -> 1993.94s]  that we had the copy function opened up two files opened up a file to read
[1993.98s -> 1997.54s]  from opened up about the right right to and then copied all the data out of
[1997.54s -> 2004.66s]  one into the other let's look at that in GDB and let's actually let's see
[2004.66s -> 2012.14s]  let's stop it on line 19 we'll break on line 19 and we'll run the
[2012.14s -> 2017.30s]  program okay well whoops I got to run it with let's say copy dot C to copy
[2017.30s -> 2022.90s]  copy dot C okay all right so now we've stopped on line 19 and we're about to
[2022.90s -> 2026.62s]  step into the system call if I do ask to actually step into the system call
[2026.62s -> 2031.90s]  you'll see that it goes into syscall template we haven't quite called the
[2031.90s -> 2036.22s]  actual system call yet because we have to do the setup in other words we
[2036.22s -> 2039.98s]  have to set the we have to set the parameters and we have to actually do
[2039.98s -> 2047.18s]  that syscall but we can do disassemble here and we'll notice that you have
[2047.18s -> 2051.58s]  things like the a couple things going on here that this is not really that
[2051.58s -> 2056.74s]  important but it's gonna move some of some detail like move zero to remember I
[2056.74s -> 2060.02s]  said open was zero to for the operation code well there it goes right
[2060.02s -> 2066.38s]  there okay and and I think I said RDI is the where the actual name of the
[2066.38s -> 2071.94s]  pro the first argument remember open here's what open looks like it is let's
[2071.94s -> 2080.10s]  see hang on let's just list 19 again oops list there it is so that's the
[2080.10s -> 2085.74s]  open call is RV one which I typed as copy dot C okay is there all right so
[2085.74s -> 2090.66s]  let's actually do this let's do this for I don't know if this will actually
[2090.66s -> 2095.42s]  list all the different instructions as I'm going through it let's step into the
[2095.42s -> 2098.34s]  instructions one at a time okay it's going to do a couple things that
[2098.34s -> 2102.20s]  aren't that important but then it's going to move 0 to which is the op
[2102.20s -> 2107.40s]  code into eight are EAX or our X and then it's going to do the syscall okay
[2107.40s -> 2112.52s]  and it's gonna do the syscall so if we look our a X is going to be two well
[2112.52s -> 2119.52s]  that's the opcode for open if we print out RDI let's cast it to a char star RDI
[2119.52s -> 2124.40s]  it should be there we go copy dot C okay so it's done the setup and it's
[2124.40s -> 2129.48s]  about to call the function for us okay and do the system call now you
[2129.48s -> 2133.94s]  might ask you oh great can I step into the system call kind of
[2133.94s -> 2138.18s]  impossible to step into a system call because the operating system is running
[2138.18s -> 2142.54s]  your program which is running GDB or I guess is running GDB which is running
[2142.54s -> 2146.30s]  your program and stepping into the operating system would mean trying to
[2146.30s -> 2149.74s]  like stop the operating system and it just wouldn't work as it turns out it
[2149.74s -> 2154.06s]  would be impossible to do that if you want to debug a kernel you actually
[2154.06s -> 2157.78s]  generally have to do it from another computer that's talking to the other
[2157.78s -> 2162.30s]  computer basically through like a connection of some sort it's tricky to
[2162.30s -> 2166.98s]  debug a kernel because it's got to be running and you can't really debug it
[2166.98s -> 2170.10s]  that easily or put it in some other virtual machine or something like that
[2170.10s -> 2175.22s]  so anyway if we let's just actually do as I and see what happens it
[2175.22s -> 2179.50s]  actually jumps it actually let's see I believe it jumped back oh yeah jump
[2179.50s -> 2184.42s]  back to our thing if we finish let's do P does an RA X yeah we had a
[2184.42s -> 2188.34s]  positive return value which is going to mean those it was success in that
[2188.38s -> 2196.18s]  case okay so that's how that's how system calls work it's kind of like
[2196.18s -> 2200.38s]  calling a function it's just you don't say call you say syscall which stops
[2200.38s -> 2206.02s]  your process and turns over to the kernel okay what questions you have
[2206.02s -> 2213.02s]  about that system calls okay relatively straightforward I mean that shouldn't
[2213.02s -> 2216.18s]  look too new to you just know that most of the functions we're going to
[2216.18s -> 2221.02s]  use our system calls because of the type of class that this is okay here's the
[2221.02s -> 2224.42s]  summary summary is we use system calls because we don't want the user to
[2224.42s -> 2229.42s]  have access to sensitive parts great we can't do that using our regular
[2229.42s -> 2234.62s]  function call why because we own that memory we're allowed to touch all that
[2234.62s -> 2238.90s]  memory and so if our for our code is accessing things that it shouldn't be
[2238.90s -> 2244.70s]  that would be bad because we could be malicious okay and then the way this
[2244.70s -> 2248.62s]  happens is through an interrupt called syscall and that stops your program
[2248.62s -> 2252.68s]  translate transfers over to the operating system and does that and then
[2252.68s -> 2257.38s]  once the kernels running it's in control does the opening closing
[2257.38s -> 2261.82s]  reading from a disk whatever and then afterwards it returns back to your
[2261.82s -> 2267.42s]  program okay all right what questions you have about those right now system
[2267.42s -> 2272.66s]  calls anything else okay again this is this is in the this is talked about
[2272.66s -> 2276.66s]  in the in the book and in fact I think it's talked about in the Brian know
[2276.66s -> 2286.80s]  how our handbook as well okay let us move on to a fun topic called multi
[2286.80s -> 2295.30s]  processing okay so far we have been talking about programs that ever since
[2295.30s -> 2301.34s]  106 a 106 B 107 generally your programs are running a single process
[2301.34s -> 2306.18s]  okay a process that is going along and it might be doing lots of things but
[2306.18s -> 2311.02s]  it's one process at a time okay it used to be that one process was all
[2311.02s -> 2314.34s]  computers could actually run anybody know what computer that one is on the
[2314.34s -> 2321.34s]  board says it on there you can kind of ABC it's an IBM personal computer
[2321.54s -> 2330.54s]  from 1981 this is actually the computer I took to college it did not have a hard
[2330.54s -> 2337.78s]  drive in it like I said and I said the other day it had a maximum of 640
[2337.78s -> 2345.62s]  kilobytes of memory which was not that much it ran at 4.0 4.77 megahertz
[2345.62s -> 2349.70s]  your computers these days run at gigahertz so it was relatively slow but
[2349.70s -> 2353.94s]  it actually had one process available at a time you could run one thing on at a
[2353.94s -> 2358.98s]  time and that was all you got now along the way somebody some clever people did
[2358.98s -> 2362.94s]  write a program or some various programs that allowed you to kind of do
[2362.94s -> 2367.12s]  multi processing but it was very rudimentary and it crashed a lot and it
[2367.12s -> 2371.58s]  was didn't it didn't work particularly well and your computer was slow
[2371.58s -> 2374.82s]  enough that doing multiple things at once didn't really make sense anyway
[2374.82s -> 2380.06s]  okay well these days we have really fast computers okay we have computers
[2380.06s -> 2384.98s]  that are gigahertz and that are running really at very high frequencies okay and
[2384.98s -> 2389.66s]  so we want to be able to run multiple programs at a time at the same
[2389.66s -> 2397.34s]  time okay this is called multi processing all right and you will tell
[2397.34s -> 2401.76s]  your computer to do things concurrently in other words you're gonna write a
[2401.76s -> 2406.44s]  program and it's going to be doing two different things potentially exactly the
[2406.44s -> 2410.60s]  same time and that's kind of interesting okay I think that's that's
[2410.60s -> 2416.28s]  very interesting what we can do to show you a little bit about the
[2416.28s -> 2423.76s]  process on your computer in fact I will pull this up here see processing okay
[2423.76s -> 2429.68s]  we are going to open I think we're going to open up get PID X dot C so
[2429.68s -> 2434.48s]  when your program is running as I said before we've kind of talked about this
[2434.48s -> 2439.00s]  couple times it has a process ID associated with it it is a process and
[2439.00s -> 2445.04s]  it has a process identifier associated with it okay and we can
[2445.04s -> 2451.64s]  actually get the identifier if you want by doing the following PIDT PID
[2451.64s -> 2459.08s]  equals get PID okay PID underscore T is just an integer okay you're all why
[2459.12s -> 2461.92s]  don't we just call it integers well they wanted to make it its own type it's just
[2461.92s -> 2468.76s]  typed F to an integer okay you can do that and then you can say print F my
[2468.76s -> 2477.76s]  process ID percent D it's just an integer PID and return zero and that
[2477.76s -> 2482.76s]  should do it whoops except for I need a semicolon after that there we go
[2482.76s -> 2492.32s]  okay make get whoops make get PID X okay get PID X process ID was fifteen
[2492.32s -> 2497.48s]  thousand seven hundred eighty seven great process ID fifteen seven eight
[2497.48s -> 2502.20s]  eight process ID fifteen seven eight nine now if I wait a little bit right
[2502.20s -> 2506.80s]  if we wait a little bit it's probably not gonna be ninety but it is in that
[2506.80s -> 2512.24s]  case okay so sometimes there are lots of other processes being started and
[2512.24s -> 2518.28s]  stopped on like myth 55 right now that will probably start going up in in order
[2518.28s -> 2521.24s]  and see if it goes up there we go we got a few more that kind of started up
[2521.24s -> 2526.44s]  in there right but but that's what that's what I'm so you're just given a
[2526.44s -> 2531.00s]  number when your program is running and that's your process ID okay all
[2531.00s -> 2536.24s]  right the process ID allows the operating system to keep track of you
[2536.24s -> 2540.16s]  so that no you can use your process control blocks and it can do all that
[2540.64s -> 2547.20s]  it can use your process ID number to say you get to run for a chunk of time and then some
[2547.20s -> 2552.32s]  other program gets to run for a chunk of time and this is why I can move my
[2552.32s -> 2557.24s]  this is why I can have the program my program running and I can also do
[2557.24s -> 2560.92s]  things like right on the board while the program is the other program is
[2560.92s -> 2564.84s]  running in the background the operating system is fast enough that it allows
[2565.04s -> 2572.52s]  your computer to seem like multiple programs are running at once most of the time there
[2572.52s -> 2577.76s]  there's only one thing running at a time except for the fact that your computers
[2577.76s -> 2581.76s]  these days all have multiple processors in them and in fact the myth machines all have
[2581.76s -> 2586.80s]  four or eight different cores in them which are individual processors which means they
[2586.80s -> 2592.48s]  actually do run more than one program at a time okay you can actually see this if you go to
[2592.48s -> 2599.16s]  I don't think they have this I think I installed this but we can we can do it but if you type H top
[2599.16s -> 2605.64s]  okay what H top does is it gives you a list of all the different programs that are running
[2605.64s -> 2609.20s]  on the system from all the other users too and you think wait a minute I can know what
[2609.20s -> 2613.88s]  other users are running you can as it turns out that's not hidden from from you and it
[2613.88s -> 2618.72s]  also in fact this myth machine has eight different processors here and you can see them all
[2618.84s -> 2624.48s]  running nobody's really doing anything right now like this myth happens to be very not busy right
[2624.48s -> 2628.08s]  later in the quarter we'll be in class and we'll look at this and it'll be like going crazy
[2628.08s -> 2632.40s]  because some 107 assignments going you know they're doing some crazy things or whatever okay but
[2632.40s -> 2635.96s]  that's what's going on here you can actually look at this and it tells you what percentage
[2635.96s -> 2641.04s]  of each processor is being used most of the time it's pretty idle but right now not much
[2641.08s -> 2649.60s]  is really going on okay so that's that's what processes are okay and like I said your computers
[2649.60s -> 2656.12s]  these days have multiple processors which means they can run multiple programs at the same time
[2656.12s -> 2662.48s]  literally it's not just time shifting or time splitting between the each process it's literally
[2662.48s -> 2670.12s]  two are running at the same time okay we'll see how this becomes important very soon okay so
[2670.12s -> 2677.16s]  we have a new system call okay the new system call is called fork and it's obviously it's
[2677.16s -> 2682.88s]  I mean kind of like a fork you eat from but it really is like a fork in the road okay this
[2682.88s -> 2689.76s]  when we say fork what fork does is it says the fork is a system call that allows you to
[2689.76s -> 2696.08s]  create a new process from your program so that now your program is going to literally go down
[2696.08s -> 2702.80s]  two different code paths at the exact same time okay that's what fork does did you have a question
[2702.80s -> 2708.32s]  okay so this is what fork actually does okay we're gonna see why that we might want to do that
[2708.32s -> 2712.00s]  you might be able to start thinking about why you might want to do that but it's but for
[2712.00s -> 2717.08s]  for the types of programs we're running in this class multiple processes become very important
[2717.08s -> 2721.52s]  here's what fork does and this is a little subtle and people always tend to forget this
[2721.52s -> 2728.48s]  so I'm gonna explicitly say what it does fork creates one more new process okay you've already
[2728.48s -> 2733.60s]  got a process fork creates one more process that's a lot of people for some reason last
[2733.60s -> 2738.64s]  quarter thought that it created two it does not for creates one and now there are two if
[2738.64s -> 2744.56s]  each one of those forked right now there would be four right because each one of those creates
[2744.56s -> 2749.52s]  one more and then there's a total of four etc all right but your process if you fork it creates
[2749.52s -> 2755.80s]  one more process and that is called the child process because the parent is the one creating
[2755.80s -> 2763.32s]  it okay and the fork call by the way the child and parent and this is the most interesting part
[2763.32s -> 2770.88s]  about it they both start executing on the next line after fork it's not like you fork and the
[2770.88s -> 2775.20s]  one the the child goes off somewhere else it does this in the probe probe the parent goes off
[2775.20s -> 2780.24s]  no no they both go to the next instruction and now you've got two programs two processes
[2780.24s -> 2786.08s]  running the next line in your code which is kind of interesting you'll see how it works in
[2786.08s -> 2796.00s]  it in a minute okay fork returns a PID T or an integer but it's only kind of a PID okay
[2796.00s -> 2803.64s]  here's how it goes the parent when there when you call fork the parent's return value is the
[2803.64s -> 2811.32s]  PID of the newly created child okay so you create a child it's a new process it gets a process ID
[2811.32s -> 2817.48s]  the parent gets that written in return okay so the parent actually can keep track of all its
[2817.48s -> 2821.76s]  children that it creates you can fork multiple times by the way so you can fork and you get
[2821.76s -> 2830.92s]  back the the ID of your child that you just forked the child gets back zero right the
[2830.92s -> 2839.24s]  child gets back zero if the child got back its own PID it wouldn't make much sense because then
[2839.24s -> 2843.44s]  it wouldn't like you wouldn't be able to differentiate between the child and the parent
[2843.44s -> 2848.48s]  if the parent got back the child's PID and the child got back the parent's PID how do we
[2848.48s -> 2855.24s]  know who's who we still can't make that decision right so the way it works the parent gets back
[2855.24s -> 2863.00s]  the child PID and the child gets back zero which means you're the child PID okay you are the child
[2863.00s -> 2869.40s]  now look if the child wants to get its own PID great it can it can call get PID but the return
[2869.40s -> 2875.68s]  from fork is zero if it's the child process that makes sense this confused people for like
[2875.68s -> 2879.80s]  for a while in other other times I've taught this and I'm not not exactly sure why so I'm
[2880.80s -> 2890.72s]  oh good question if you're in the child process you can do get PP ID to get your
[2890.72s -> 2894.98s]  parents process if you want yeah and this is a good this is good if you want to be let's say
[2894.98s -> 2899.20s]  sending signals back and forth between the parent and the child we'll talk about that later in the
[2899.20s -> 2903.40s]  course okay but yes you can if you want to you don't get it for this by default in fact it's
[2903.40s -> 2908.88s]  most often that the child could care less what its parents PID is as it turns out but you
[2908.88s -> 2916.16s]  can get it if you want to okay now here's the other interesting part about this all of the
[2916.16s -> 2921.88s]  memory between the parent and the child is identical I can't draw the straight line at the
[2921.88s -> 2931.16s]  bottom of this tablet all the memory is identical but it is not shared okay so I
[2931.32s -> 2939.80s]  create an integer int a and then I fork right on the next line the parent has an integer int a
[2939.80s -> 2947.24s]  the child has an integer int a the parent let's say the pointer to the parents version of a is
[2947.24s -> 2957.24s]  0x1234 the child's version is 0x1234 the pointer to that if the child changes a the parents
[2957.24s -> 2974.04s]  does not change how does that work any ideas yeah exactly the answer was it doesn't it's not
[2974.04s -> 2980.08s]  really the same exact memory they are now they are now separate memory but they think they're
[2980.08s -> 2986.52s]  the same part of memory now what it does is you think wait a minute if I have a huge amount
[2986.52s -> 2992.16s]  of code and I fork isn't this gonna be really slow because it's got it somehow has to copy all
[2992.16s -> 2998.36s]  the data from like the parent to the child it does this thing called copy on right in other
[2998.36s -> 3004.68s]  words the operating system is clever enough not to make any copies until either the parent
[3004.68s -> 3013.04s]  or the child changes a value so it's kind of shared in the sense that the operating system
[3013.04s -> 3019.32s]  is keeping track of it all but the instant you change a value in one in the child or the parent
[3019.32s -> 3025.56s]  it is not reflected in the opposite the child be your parent if you're the child it's not
[3025.56s -> 3029.36s]  reflected you make it the operating system makes a copy of it says okay great now you
[3029.36s -> 3035.20s]  have your value and you have your value okay it's a very interesting interesting concept as it
[3035.20s -> 3038.92s]  turns out it so they did this for lots of reasons they did it so that they can make it so
[3038.92s -> 3044.12s]  that programs can go to the next line and not worry about any of the data and they also did
[3044.12s -> 3049.48s]  it in the way they did so that it's fast so that's kind of me okay what questions you
[3049.48s -> 3057.56s]  have in that how fork works yeah good question so we're gonna see actually we're not quite
[3057.56s -> 3062.36s]  gonna see exactly that but the question was what happens when the parent process is terminated
[3062.36s -> 3067.64s]  the child process keeps going yeah process the child process keeps going now it turns out
[3067.88s -> 3072.76s]  that you might end up going back to the terminal because your parent is what's running in the
[3072.76s -> 3076.92s]  terminal and the child process might end at some time later after you type some other command or
[3076.92s -> 3080.80s]  whatever so it's a little bit but of course we have a way of dealing with that which we'll
[3080.80s -> 3084.68s]  talk about like how to make sure that your parent doesn't end before your child does and
[3084.68s -> 3089.28s]  so forth but that's it the other interesting thing about it although not particularly
[3089.28s -> 3094.88s]  relevant is that if the child or if the parent ends the child's parents now becomes root
[3094.92s -> 3099.08s]  actually which is like the main underlying process doesn't have a parent anymore parent
[3099.08s -> 3117.04s]  who died unfortunately sad but that's that's the way that goes good question yeah oh sure
[3117.04s -> 3121.04s]  yeah this is the question is look if you wanted to pass along the PID to this child
[3121.24s -> 3125.84s]  you could call get PID before you fork save it into value and then it's available later sure
[3125.84s -> 3130.68s]  or the child can just call get PPID which is get parent PID so either one but yeah there's
[3130.68s -> 3135.92s]  there's ways of doing that there is there are ways of sharing data by the way but we're
[3135.92s -> 3140.00s]  not going to cover that really in here you'll see one example in a lab about sharing data but
[3140.00s -> 3144.52s]  most of it is not most of it doesn't need to be shared as it turns out I asked that we
[3144.52s -> 3150.04s]  asked a pretty good in my humble opinion question on the final last quarter where a lot of
[3150.04s -> 3153.64s]  people thought oh no we have to share memory but you actually didn't have to as turned out
[3153.64s -> 3158.88s]  but so you won't really review responsible for doing much of that okay all right the
[3158.88s -> 3163.72s]  reason the parent the child get these two different return values is simply to differentiate
[3163.72s -> 3170.52s]  them okay the first thing you will often do in a program is if PID equals equals zero do
[3170.52s -> 3176.04s]  this because I'm the child all else do this and that just says okay now I've got two
[3176.04s -> 3180.44s]  different process going in different directions so that's generally what you do sometimes we want
[3180.44s -> 3184.32s]  them both to do exactly the same thing for various reasons but most of the time we do
[3184.32s -> 3188.04s]  want to make a decision and say look if I'm the child I'm going to go down this path if I'm
[3188.04s -> 3191.68s]  the parent I'm going to be done this path they start at the exact same point though
[3191.68s -> 3198.36s]  okay so that's the difference there all right so let's look at a program okay we're
[3198.56s -> 3207.88s]  going to write another program called basic fork oops oh no I've done it again hang on
[3207.88s -> 3217.36s]  there we go cursor there we go okay basic fork dot no not not the binary how about
[3217.36s -> 3225.04s]  dot C there we go okay so what we're going to do in here okay is we are going to actually
[3225.36s -> 3234.72s]  just print out greetings from a process and then the per parent of that process okay so that's what
[3234.72s -> 3240.04s]  it's gonna look like there okay and then we're going to call fork okay and we do a little bit
[3240.04s -> 3245.20s]  of error checking if the PID is negative one it means the fork failed why would a fork fail
[3245.20s -> 3249.48s]  maybe the operating system ran out of memory or some other thing happened you will almost never
[3249.48s -> 3255.56s]  see that actually that's not true you will see that if you try to do thousands of processes
[3255.56s -> 3260.20s]  your program is limited at least on our system to about a thousand maybe a thousand twenty four
[3260.20s -> 3265.28s]  different processes so if you tried to do forking such that it just kept creating many many more
[3265.28s -> 3269.08s]  processes you'd get limited at about a thousand twenty four there's a thing called a fork bomb
[3269.08s -> 3274.16s]  which would which is where you just basically try to just do as many of you do kind of
[3274.16s -> 3278.60s]  recursively call fork or you call it in a loop or just everybody forks and it just uses
[3278.60s -> 3282.56s]  up all your processes this is why they had to limit it because you could take down a system
[3282.56s -> 3288.84s]  by doing the fork bomb which is very easy to do as it turns out but anyway you were gonna check
[3288.84s -> 3295.36s]  it there and then we're going to print out bye-bye from process your the process that we
[3295.36s -> 3301.28s]  are going to get from calling get PID and then we're going to also print out the parent
[3301.28s -> 3308.16s]  process everybody see how though it's gonna happen remember by the time the program gets to this
[3308.16s -> 3315.20s]  line here there are now two processes going the original parent and the child and that's the
[3315.20s -> 3319.80s]  difference okay now we haven't done any checking to see who's the parent in the child we don't
[3319.80s -> 3325.68s]  really care for this for this one right now okay make basic fork I think it's already done
[3325.68s -> 3335.24s]  yeah okay basic fork and there we go all right greetings from process 26385 with parent 2892
[3335.24s -> 3341.72s]  that's the shell as it turns out okay and then it says bye-bye from process 26385 with parent
[3341.72s -> 3348.52s]  2892 because it ended and then it says bye-bye from process 26386 which has parent a parent of
[3348.96s -> 3358.36s]  26385 and that is the parent that created it okay so we can run this a number of times again you
[3358.36s -> 3363.80s]  probably will not see this with this tiny little program but it turns out that the ordering of
[3363.80s -> 3371.56s]  those two final lines completely arbitrary okay why because who knows who gets to go next the
[3371.56s -> 3377.56s]  parent of the child it is completely arbitrary and non-deterministic this is the problem this
[3377.60s -> 3381.90s]  is one of the harder parts about this class is that you're not dealing with non-determinism okay
[3381.90s -> 3387.24s]  debugging some of these things is very tricky if you don't if you don't have a real clear idea
[3387.24s -> 3391.64s]  of what you're expecting because you can run a program two or three times in a row and it
[3391.64s -> 3396.68s]  can come out absolutely different each time but still be perfectly correct okay so that's a
[3396.68s -> 3406.28s]  little bit a little bit tricky to deal with sometimes question oh good question that was
[3406.28s -> 3409.72s]  a very good question why didn't the print f statements like bang into each other and print
[3409.72s -> 3416.00s]  out like that so print f actually has some buffering in it and the way the print f function
[3416.00s -> 3422.36s]  actually works it's going to generally keep like one call at a time is going to get through
[3422.36s -> 3426.08s]  and it will print all the way to a new line now if you were printing multiple things at once
[3426.08s -> 3429.48s]  and some other programs printing multiple things at once they might get interlaced but one line
[3429.48s -> 3432.72s]  at a time not going to get interlaced good question though yeah you will see some
[3432.72s -> 3438.56s]  interlacing but not not one line at a time generally yeah when we get to C++ using C out
[3438.56s -> 3443.00s]  Jerry Kane actually created a library that makes it so it doesn't do that in C out either which is
[3443.00s -> 3461.60s]  nice yeah yeah this is yeah so this is a good question the question was wait wait a minute
[3461.60s -> 3466.28s]  when the parent process that when when you do fork like one's going and the other is going maybe
[3466.28s -> 3471.92s]  maybe not at the same time okay two different processes now the operating system treats it just
[3471.92s -> 3477.32s]  like any other two different processes if there's only one processor available the child gets to
[3477.32s -> 3480.64s]  run for a little time the parent gets to run for a little time the child gets run for a
[3480.64s -> 3483.80s]  little time the parent gets run for a little time and it's just shifted back and forth if
[3483.80s -> 3489.08s]  there's two processors it actually could be that both are running on their own processor at
[3489.08s -> 3494.40s]  exactly the same time literally the same time yeah that's the that's the different there so the
[3494.40s -> 3498.40s]  operating system is taking care of that and saying great now I have another process I better time
[3498.40s -> 3503.68s]  slice it so it gets a little bit of time to keep running yeah we're gonna see lots of those
[3503.68s -> 3510.24s]  sorts of examples as we go along okay all right so then I just showed you the output of
[3510.24s -> 3517.00s]  this the as I said the original process has its parent being the shell and then this is
[3517.00s -> 3520.80s]  non-deterministic so we have to be a little careful that when we're writing these programs
[3520.80s -> 3528.20s]  because we can't necessarily predict the order question yeah anybody else I'm sure you have
[3528.20s -> 3533.32s]  lots of questions on this stuff as we go a little bit farther okay fork is called twice
[3533.32s -> 3539.28s]  are called once fork returns twice right it returns to your program twice in two separate
[3539.28s -> 3547.92s]  processes okay as I said all segments of data are faithfully replicated all right the heap is
[3547.92s -> 3553.68s]  replicated pointers are replicated file descriptors are replicated which is interesting it means that
[3553.68s -> 3558.84s]  as it turns out if you have a fork after you've opened a file and they both try to read from
[3558.84s -> 3562.52s]  the file the first one to read gets part of the file the next one's cursor is actually
[3562.52s -> 3567.00s]  moved over and gets more of the other the rest of it so it's actually duplicated at that
[3567.00s -> 3575.72s]  level as it turns out okay the we will talk about how to deal with open file descriptors
[3575.72s -> 3588.76s]  as we go along as well okay what else any other question on that all right now like I mentioned
[3588.76s -> 3593.28s]  debugging this is a bit tricky you might want to say you might be saying yourself hey how do
[3593.36s -> 3602.08s]  I actually go and debug this stuff well it's a little tricky you can do it in GDB I've given
[3602.08s -> 3609.24s]  you the commands here you can go look at the actual you can go look at the actual code to
[3609.24s -> 3614.68s]  do to kind of a GDB trace if you want to I'm not going to go over that right now but you
[3614.68s -> 3622.68s]  can say for instance set detach on fork to off basically what it normally does is GDB if you
[3622.72s -> 3628.16s]  have a fork it just lets that child go and it continues with the parent and the child
[3628.16s -> 3633.36s]  process is on its own if you set detach on fork off what it does is it actually goes down the
[3633.36s -> 3638.12s]  path of the child GDB keeps track of the child process you can do these things you can do this
[3638.12s -> 3642.92s]  thing called info inferiors which is the two different with all the different processes it
[3642.92s -> 3647.68s]  gives you a list you can switch between them if you want to that's that's down here and you
[3647.68s -> 3652.28s]  can also say oh if I'm going to continue I want to continue one of the processes and then
[3652.40s -> 3656.96s]  start debugging the other one you can do that I would say most people probably don't get to
[3656.96s -> 3660.76s]  this level but if you want to and you're molding and you're debugging you and I really can't figure
[3660.76s -> 3666.16s]  this out this is how you would do it okay it's not not that often that you do that but just
[3666.16s -> 3669.96s]  know that it's there in case you go I have to go debug this and GDB I have no idea how
[3669.96s -> 3677.48s]  that go look at the trace and you'll see how to do it okay all right like I said the
[3677.48s -> 3685.12s]  only real difference is the process ID and the return value from for okay you get a new problem
[3685.12s -> 3689.88s]  you get a different process ID if you're the child from the parent and the return value from
[3689.88s -> 3698.56s]  fork is is different okay parent gets the product of PID child gets zero not it's PID but that's
[3698.56s -> 3703.04s]  how we differentiate it from the parent okay and that's how we make them go in different
[3703.04s -> 3713.28s]  directions if we want to okay let's see another difference oh let's actually this might be a
[3713.28s -> 3720.08s]  duplicate slide hold on no not really it's kind of got the replicating bunch of information but
[3720.08s -> 3726.36s]  there's no like I said there's no default sharing okay you can wait in the parent we're
[3726.36s -> 3731.16s]  gonna get to that in a few minutes where you can say hey I want to wait for my children in
[3731.16s -> 3737.76s]  fact we're gonna talk about that for much like for much of the multi-processing material we're
[3737.76s -> 3741.72s]  gonna talk about hey how does the parent wait for all of its children appropriately and how
[3741.72s -> 3746.52s]  does that work we're gonna get to that you can't wait for your parent as it turns out
[3746.52s -> 3751.72s]  not really allowed the way it goes why I don't know they built it that way you're not really
[3751.72s -> 3757.68s]  allowed to wait for your parent turns out when a child process ends the parent can get notified
[3757.92s -> 3762.04s]  or the parent can wait for that but it doesn't go the other direction I'm not exactly sure why
[3762.04s -> 3768.56s]  but that's the way they that's where they built it okay all right let's look at another
[3768.56s -> 3775.68s]  program okay we're gonna look at a little program of a tree of forks okay a tree of
[3775.68s -> 3784.32s]  forks I think let's see is this the one I want is it hang on one oops there we go
[3784.32s -> 3793.56s]  nope there we go let's let's look at the let's see if we're gonna do which which one
[3793.56s -> 3800.28s]  we're gonna do in a sec we want to look at well just look at it here and then I'll go run
[3800.28s -> 3808.08s]  it as we go here's what this is gonna do okay this is going to basically do a for loop around
[3808.08s -> 3815.76s]  a bunch of fork calls okay so what we're going to do is we are going to basically have a string
[3815.76s -> 3822.74s]  called K trail okay and we are going to find out how long it is we're going to loop through
[3822.74s -> 3828.00s]  all the letters in that string or all the characters in that string we're gonna print
[3828.00s -> 3834.20s]  them out at one letter at a time but in the meantime we're going to fork okay and then
[3834.20s -> 3838.80s]  in this case it's an assert that just says look at the PID is assert the PID is greater
[3838.80s -> 3842.64s]  than or equal to zero which would make it so that if anything failed that it would crash
[3842.64s -> 3848.00s]  the program or stop the program and then it will keep going down okay what do you think's
[3848.00s -> 3858.84s]  gonna happen here if the string is ABCD oops if the string is ABCD what is going to happen
[3858.84s -> 3868.52s]  in here the first thing that's gonna happen is what it's gonna print out okay okay and then
[3868.52s -> 3875.44s]  we're gonna end up with here's the parent we're gonna end up with a child process okay
[3875.44s -> 3881.52s]  and then the for loop is going to come back here remember it's going to the same it's got
[3881.52s -> 3886.68s]  the same value of I it's got the same value for the string and same value all that okay but
[3886.68s -> 3891.36s]  now there are two things going through here I is going to be incremented to one okay and
[3891.36s -> 3896.96s]  then it is going to print what from the child B and then what's gonna get printed from
[3896.96s -> 3902.04s]  the parent B do we know what order that's gonna happen in we have no idea but it doesn't
[3902.04s -> 3906.24s]  matter to both be right but then what's gonna happen with the parent the parent is going to
[3906.24s -> 3913.24s]  create a child and the child is going to create a child and then everybody is gonna go back up
[3913.24s -> 3919.44s]  here and they're all gonna be on C now how many different versions of C are we gonna get
[3919.44s -> 3927.32s]  four one two three four not necessarily in that order and then all four are gonna each create
[3927.32s -> 3932.68s]  another child and another child another child another child they get on and they all create
[3932.68s -> 3940.44s]  a child how many different D's are we gonna have eight different D's let's try it okay let's
[3940.44s -> 3944.88s]  try it I have to figure out which program this is because I think I forgot which one is we
[3944.88s -> 3951.88s]  are gonna look for trail length thing trail I think start at C for puzzle that's the one okay
[3952.88s -> 3960.64s]  let's see for oh no fork might might not be actually written oh it's not gonna hold on
[3960.64s -> 3967.16s]  copy for I have that I have written original let's see to fork puzzle that's see okay yes
[3967.16s -> 3982.00s]  a fork puzzle okay okay ready a b c d a b c b d c d c d oh not the order we necessarily would
[3982.00s -> 3987.72s]  have hoped for right it's not one a two B's three four C's eight D's but there are that
[3987.72s -> 3995.08s]  many right one a I see one a one two let's see two B's one two three four C's and then
[3995.08s -> 4003.24s]  eight B's I assume okay all right let's try running it again oh what happened there why
[4003.24s -> 4017.64s]  do I have my come my line here and a D way over here any ideas what's that yeah the parent
[4017.64s -> 4021.76s]  finished first good answer yeah the parent finished first and one of the children was still
[4021.76s -> 4027.52s]  doing its printing after the parent finished the shell got it back and did that right so we
[4027.52s -> 4031.04s]  can we can do it a few more time there you go I got the same sort of thing again right that
[4031.04s -> 4037.72s]  time it happened you work okay but remember non-deterministic and that's the way it goes so
[4037.72s -> 4043.28s]  let's spend a minute just making sure everybody understands what's happening in this program
[4043.28s -> 4049.76s]  what questions do you have about it you get why there are one a two B's forces etc yeah
[4051.76s -> 4072.48s]  yes so the question was okay I get that it's I get that why they're all the letters there
[4072.48s -> 4078.32s]  why they're all those letters why is it out of order is it because you have these multiple
[4078.32s -> 4085.36s]  processes given time from the operating system it's exactly that and it turns out that the parent
[4085.36s -> 4092.40s]  in there must have gotten the like gotten the signal to keep going through all of its D's before
[4092.40s -> 4096.48s]  one of the children did and in some cases the child and children all in before the parent so
[4096.48s -> 4101.20s]  it's it's completely non-deterministic in that sense you can't control it okay in that sense
[4101.20s -> 4105.88s]  there are ways to control what happens we will get to that many times you don't want to
[4105.88s -> 4110.68s]  necessarily hinder them from going in a particular order but sometimes you need them to go in a
[4110.68s -> 4124.96s]  particular order so we'll talk about that too question yes grandchildren of the children yes
[4136.88s -> 4141.92s]  that's a good question I believe that any time your parent the question was hey what happens
[4141.92s -> 4145.84s]  when the children's children died today their parent now become the grandparent and so forth
[4145.84s -> 4149.08s]  no I don't I think it just becomes all the way to root I think if your parent dies
[4149.08s -> 4155.72s]  you're just kind of become an orphan right so yeah I think that's what that's what
[4155.72s -> 4161.28s]  happens with that root is not the same as shell root is like the kernel basically running
[4161.28s -> 4165.80s]  it's running there might be some other program but yeah it's a it's not the shell it's not the
[4165.80s -> 4169.88s]  shell can end and the other programs will continue as well unless there's some other
[4169.88s -> 4181.40s]  method to kill them yeah yeah so the question was hey explain again what happens with the D
[4181.40s -> 4186.44s]  at the end let's see if we can get it to work no no there we go okay so why did that
[4186.44s -> 4193.72s]  D show up after my terminal line showed up well remember there's the parent process which
[4193.72s -> 4199.56s]  when it ends the terminal says oh you've ended here's a here's a prompt again type something else
[4199.56s -> 4207.72s]  right if the parent process ends before all of its children do then it will do that and the
[4207.72s -> 4212.28s]  child can still be running and print out to there we're gonna see we're gonna see an example
[4212.28s -> 4217.68s]  of that I guess on Wednesday where we're gonna get into some of these crazy ones where you go
[4217.68s -> 4222.64s]  oh wow it really does do that like it just it will print out you can type LS and it will still
[4222.64s -> 4227.48s]  be printing stuff out from your program and whatever right you can you can do that um but
[4227.48s -> 4234.96s]  let me let me show you to try something that's for I in let's see let's do this sequence
[4234.96s -> 4245.88s]  one through 100 do echo I done no echo dollar sign I done there we go okay that's gonna print out
[4245.88s -> 4250.32s]  this is bash it's a different program I'm just gonna print out 100 numbers in a row but if we
[4250.32s -> 4257.40s]  do this and we say sleep for one second in between it's gonna print one two three etc
[4257.40s -> 4262.24s]  right if we do this and we can run this what we call in the background I don't you've
[4262.24s -> 4269.16s]  ever done this before it is now running and I can type LS and my program is running along in
[4269.16s -> 4273.76s]  the background and doing its thing right I mean I can even it's even crazier than that I can do
[4273.76s -> 4281.20s]  like them and then oh boy you know it it'll do this until it gets up to a hundred and it's
[4281.20s -> 4284.76s]  just two processes running at the same time and they're both trying to print out the terminal
[4284.76s -> 4290.24s]  and they don't care that you know one's going and one's not so that's what yeah so there
[4290.24s -> 4294.56s]  you go little does it'll just keep going right until you do that I think I can still end up in
[4294.56s -> 4299.28s]  whatever I notice you've gone right you can actually no you can't you can put it in the
[4299.28s -> 4303.32s]  foreground and then kill it but you will learn all about this when you do the Stanford
[4303.32s -> 4307.60s]  shell assignment which is coming up in a few weeks where you you have to build this and
[4307.60s -> 4310.96s]  it you end up with things like this but yeah but does that answer your question about how
[4310.96s -> 4325.48s]  it's happening yeah yeah the question was what what's the significance of when the parent
[4325.48s -> 4329.52s]  process dies before the child does nothing really I mean there's no real significance
[4329.52s -> 4334.12s]  except for the fact that you can end up back in the shell and you might not want to be like
[4334.12s -> 4338.12s]  we don't like it that it printed out that D after our after our prompt we want it to be
[4338.28s -> 4343.08s]  look finish everything then print out the thing and we'll we'll see examples of that straight
[4343.08s -> 4355.00s]  straight away on Wednesday yeah yes why is there always one child we do have multiple children we
[4355.00s -> 4363.12s]  didn't oh why is it always one they're both there oh that's a good question they're all
[4363.12s -> 4367.48s]  going roughly the same time right it's such a fast program they're roughly going at the
[4367.48s -> 4371.32s]  same time it could very easily come out there's two I mean you just don't know but they're
[4371.32s -> 4375.16s]  they're they're pretty much doing it all at the same time before the pendant the parent
[4375.16s -> 4379.00s]  will will just end almost at the same time and sometimes one will be out but there's no
[4379.00s -> 4393.20s]  significance to just having one yeah good question all right what else good question
[4393.20s -> 4399.44s]  if we look at the program the question was can you choose to just do one fork each time well
[4399.44s -> 4407.00s]  sure how about this what if we wanted to stop the program at the end at the end of what if
[4407.00s -> 4415.24s]  we wanted to stop the program so let's look at fork puzzle dot C okay okay so we have the
[4415.24s -> 4422.48s]  fork there okay let's do let's see what would be interesting here if we did if we said this
[4422.76s -> 4430.72s]  if PID equals zero now we know we're in the child right we could say oh I don't know print F
[4430.72s -> 4440.16s]  by you know whatever and then we could also do exit zero or we can do return zero or whatever
[4440.16s -> 4445.04s]  we want let's do return zero return zero and that will actually say okay I'm done and not go
[4445.04s -> 4453.20s]  through the fork right for puzzle for puzzle right and now it's going to just do the parent
[4453.20s -> 4457.52s]  only all the other children did their like guys but nobody ever got back in the for loop
[4457.52s -> 4463.40s]  so you can just use how you have to forget the logic for that yeah good question anybody else
[4463.40s -> 4479.84s]  ah that's a good question question was if we had one processor and you are forking a process
[4479.84s -> 4484.76s]  are you necessarily going to are you ever going to make the program faster because that probably
[4484.76s -> 4488.26s]  not no I mean if you're trying to do a certain amount of work and you have one processor to do
[4488.26s -> 4492.64s]  it unless there's some other thing going on like for instance you're waiting for network or
[4492.64s -> 4496.40s]  you're waiting for a file to be read or something like that that can take some time other than
[4496.40s -> 4501.60s]  that no you're not going to save time this is not necessarily a time-saving sort of thing it's
[4501.60s -> 4507.16s]  kind of a logic thing where we want something to happen look the shell is doing exactly this
[4507.16s -> 4511.76s]  it's forking a process and running whatever you tell it to run and so so we will use that
[4511.76s -> 4517.04s]  map more than just this kind of funny like oh do lots of things for multiple processes yeah
[4517.04s -> 4521.92s]  good question all right I think we will see you guys on Wednesday
