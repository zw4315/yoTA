# Detected language: en (p=1.00)

[0.00s -> 1.48s]  Hello, hello.
[1.48s -> 3.24s]  Welcome.
[3.24s -> 9.20s]  Welcome back to day two, CS110.
[9.20s -> 11.36s]  So we have a lot to cover.
[11.36s -> 13.28s]  We have a lot to cover every day.
[13.28s -> 15.40s]  That's one of the things about this class is that
[15.40s -> 18.16s]  there's lots and lots of material.
[18.16s -> 19.44s]  So a couple things.
[19.44s -> 22.84s]  I put out the first assignment, which we're going
[22.84s -> 24.04s]  to talk about today.
[24.04s -> 27.18s]  So hopefully we'll get started on that if you
[27.18s -> 28.88s]  haven't already.
[28.92s -> 32.36s]  Please re-download the assignment if you downloaded it
[32.36s -> 34.44s]  last night or early this morning.
[34.44s -> 36.88s]  I made a couple not critical changes.
[36.88s -> 40.92s]  But for instance, I found out that for whatever reason, the
[40.92s -> 47.16s]  PDF, if you open the PDF and try to copy some of the
[47.16s -> 51.40s]  commands from the PDF and then try to run it, it will
[51.40s -> 53.44s]  look like your program's not working, but it's because
[53.44s -> 56.60s]  there's some hidden character in the pasted thing.
[56.60s -> 58.12s]  So that confused me for a while.
[58.16s -> 60.16s]  I think my program's working, but it didn't look like it.
[60.16s -> 62.16s]  And so re-download that.
[62.16s -> 63.44s]  I think I fixed that.
[63.44s -> 66.24s]  That would be a really annoying bug to know that your
[66.24s -> 68.60s]  program's working fine and then it's just because you
[68.60s -> 71.28s]  copied a code and it had hidden characters in it.
[71.28s -> 75.20s]  So please re-download that.
[75.20s -> 77.12s]  Let's see, Piazza is up and going.
[77.12s -> 79.32s]  There's been a few questions on Piazza.
[79.32s -> 82.78s]  Piazza's probably your first line of defense as far as
[82.78s -> 86.40s]  trying to get information about the
[86.44s -> 88.24s]  assignments and so forth.
[88.24s -> 89.56s]  I look at Piazza all the time.
[89.56s -> 91.16s]  The TAs look at Piazza all the time.
[91.16s -> 94.92s]  And so it's a good place to kind of get started
[94.92s -> 95.76s]  if you have a question.
[95.76s -> 98.52s]  Obviously coming to office hours is a great place too,
[98.52s -> 100.72s]  but lots of questions get answered on Piazza
[100.72s -> 104.28s]  before they get answered in office hours or whatever.
[104.28s -> 106.12s]  And you might as well check there.
[106.12s -> 106.96s]  All right.
[107.92s -> 112.28s]  So on Monday, we started out with Umask.
[112.28s -> 116.84s]  And the questions afterwards kind of indicated
[116.84s -> 118.48s]  that I confused a bunch of you.
[118.48s -> 120.36s]  So I apologize about that.
[120.36s -> 122.12s]  I just wanted to redo,
[122.12s -> 127.40s]  just talk about Umask a little bit more,
[127.40s -> 129.12s]  just to kind of give you the overview of it.
[129.12s -> 131.12s]  By the way, this is not the most important part
[131.12s -> 131.96s]  of the class.
[131.96s -> 133.60s]  So I wanted to start with it the other day.
[133.60s -> 134.88s]  I did not mean to confuse anybody,
[134.88s -> 136.80s]  but I just wanted to talk about permissions
[136.80s -> 137.80s]  a little bit more,
[137.80s -> 140.76s]  specifically as it relates to Umask
[140.76s -> 142.60s]  so that I kind of unconfuse you
[142.60s -> 146.36s]  or get your questions answered right now.
[146.36s -> 151.36s]  Okay, the Umask is all about allowing the user
[151.56s -> 156.56s]  to control what the default permissions are for files, okay?
[157.32s -> 161.48s]  So it's not so much about the program
[161.48s -> 163.60s]  trying to set various permissions.
[163.60s -> 164.92s]  It's about the user saying,
[164.92s -> 169.52s]  hey, look, when a program creates a file for me,
[169.52s -> 172.28s]  I don't want it to give read access
[172.28s -> 173.84s]  to anybody in the world, right?
[173.84s -> 177.28s]  That's up to the user to be able to control that.
[177.28s -> 180.00s]  So if you go to your terminal,
[180.00s -> 181.80s]  in fact, I'll just do that right now,
[181.80s -> 185.92s]  and you type Umask, if you, hang on.
[187.20s -> 190.56s]  I don't know why my, oh, hold on a sec.
[190.56s -> 193.04s]  No, hang on, let me try this again.
[193.04s -> 195.64s]  Oh, uh-oh, that's not good.
[195.64s -> 197.88s]  Hold on a sec, there we go, okay.
[197.88s -> 198.84s]  There we go, okay.
[199.00s -> 203.44s]  If you type Umask, then it will tell you
[203.44s -> 206.76s]  your default user permissions, right?
[206.76s -> 210.00s]  And in fact, remember, 077,
[210.00s -> 211.80s]  we'll go over the details of this in a minute,
[211.80s -> 215.84s]  means that the zero, the second zero after the zero,
[215.84s -> 217.92s]  meaning it's an octal number,
[217.92s -> 222.36s]  the actual this zero here means that the user
[222.36s -> 224.64s]  can write whatever permissions it wants, okay?
[224.64s -> 226.28s]  So it'll be read, write, execute,
[226.28s -> 228.16s]  whatever permissions the program tries to write,
[228.48s -> 229.32s]  it will be able to write it.
[229.32s -> 232.08s]  The seven in the seven means that the group
[232.08s -> 236.60s]  and any other people, not the owner,
[236.60s -> 239.44s]  cannot write directly to the,
[239.44s -> 243.20s]  or cannot actually have those permissions set, okay?
[243.20s -> 245.04s]  So let me give you an example, all right?
[245.04s -> 248.88s]  If we actually, if I do the following,
[248.88s -> 253.04s]  where I type touch,
[253.04s -> 255.54s]  let's say test1.txt,
[255.54s -> 260.06s]  and then do ls-l test1.txt.
[260.06s -> 263.86s]  Okay, notice that it gave read write permissions.
[263.86s -> 265.46s]  When you do touch, it doesn't do
[265.46s -> 267.06s]  the execute permissions anyway.
[267.06s -> 270.86s]  The touch file, the touch will attempt to do the user,
[270.86s -> 273.94s]  to do the read write for anybody it's allowed to.
[273.94s -> 277.50s]  The Umask, because 077 says you can't do that, okay?
[277.50s -> 282.50s]  But if I changed Umask to zero, okay,
[282.66s -> 286.10s]  well, that would now, now if I just actually check it,
[286.10s -> 288.54s]  right, it's zero, which means that if I tried
[288.54s -> 291.46s]  to set a particular permission for the owner,
[291.46s -> 294.18s]  the, or sorry, the, yeah, the owner,
[294.18s -> 297.72s]  anybody else, and the group, it will now allow me to.
[297.72s -> 301.02s]  So if I do touch test2.txt,
[301.02s -> 303.78s]  let's see if this is different, oops,
[303.78s -> 306.64s]  test2.txt, guess what?
[306.64s -> 308.86s]  It set all the permissions that way, okay?
[308.86s -> 311.02s]  So it's all about the user, you,
[311.06s -> 312.98s]  having control over what gets set,
[312.98s -> 316.46s]  regardless of what the program tries to set, okay?
[316.46s -> 318.70s]  So in other words, the touch program said,
[318.70s -> 321.66s]  set the read write permissions for the owner,
[321.66s -> 323.18s]  the group, and everybody else,
[323.18s -> 327.98s]  and the original Umask blocked out the setting
[327.98s -> 331.78s]  of the permissions for the group and anybody else, okay?
[331.78s -> 333.62s]  Does that make sense about what's going on now?
[333.62s -> 336.30s]  It's basically, the Umask is saying,
[336.30s -> 338.02s]  you as the user get to control this.
[338.02s -> 340.18s]  If another program tries to set the permissions,
[340.22s -> 341.66s]  it won't let it, or it will let it,
[341.66s -> 344.38s]  depending on what your situation is.
[344.38s -> 345.22s]  Yes, question?
[345.22s -> 346.46s]  What is touch?
[346.46s -> 349.40s]  Touch actually creates, like, an empty file.
[349.40s -> 350.90s]  Yeah, that's all, yeah?
[350.90s -> 352.86s]  We only need, like, three octal numbers
[352.86s -> 354.30s]  that you code, like what we want,
[354.30s -> 355.94s]  and what we don't want in our permissions,
[355.94s -> 358.10s]  so what's the first number that's in there?
[358.10s -> 359.54s]  The first one here?
[359.54s -> 360.82s]  In Umask, we did it.
[360.82s -> 363.54s]  Oh, the first one in Umask is the,
[363.54s -> 366.26s]  it's the fact that it is an octal number.
[367.18s -> 368.58s]  Yeah, I believe that's what it is anyway,
[368.94s -> 370.42s]  you put a zero before three digits,
[370.42s -> 373.58s]  and it means it's an octal number in Unix talk.
[373.58s -> 374.74s]  It's really normally what it is.
[374.74s -> 375.58s]  What other question on that?
[375.58s -> 376.40s]  Yeah?
[376.40s -> 378.66s]  So when you have, when you have, like,
[378.66s -> 382.82s]  you just did Umask, and then it was zero, seven, seven.
[382.82s -> 386.06s]  Isn't, isn't it, the way Umask, seven, eight,
[386.06s -> 387.58s]  all three bits are on?
[387.58s -> 389.14s]  Right, so this is a good question.
[389.14s -> 390.38s]  So the question was, wait a minute, wait a minute,
[390.38s -> 393.42s]  I thought all three ones were the bits were on.
[393.42s -> 394.70s]  I'm gonna go over that in a second.
[394.70s -> 396.26s]  Umask is the reverse.
[396.26s -> 397.18s]  Why?
[397.18s -> 398.18s]  I couldn't find out.
[398.70s -> 399.54s]  I'm like, I did all sorts of searching,
[399.54s -> 400.74s]  and I'm like, why would this be the case?
[400.74s -> 401.98s]  Not exactly sure.
[401.98s -> 404.36s]  The way you use it, I'll show you in a second.
[404.36s -> 405.20s]  Very good question.
[405.20s -> 406.02s]  Yeah?
[406.02s -> 407.86s]  So if all of them are on, why aren't they
[407.86s -> 409.98s]  the size of the hex model?
[409.98s -> 413.22s]  These files were created for various other reasons.
[413.22s -> 416.46s]  Like, other programs created these ones, yeah.
[416.46s -> 419.54s]  So, and it's, it's the default for touch,
[419.54s -> 423.18s]  for instance, doesn't ever try to set the executable.
[423.18s -> 424.02s]  So that's that.
[424.02s -> 425.26s]  Okay, let's go over some more details
[425.26s -> 426.90s]  about any other big ones on this one.
[426.90s -> 428.82s]  Again, this is not the most important part of this class,
[428.82s -> 430.50s]  so I don't want to spend an hour
[430.50s -> 431.86s]  kind of going over the nuances of it.
[431.86s -> 434.94s]  Except to say that there are,
[434.94s -> 437.14s]  remember there are three parts to the permissions.
[437.14s -> 439.22s]  There's the owner in red,
[439.22s -> 442.06s]  and sorry for colorblind people, I apologize.
[442.06s -> 446.58s]  There's owner in red, and then I put green for the,
[446.58s -> 450.38s]  for the group, and then blue for the other.
[450.38s -> 452.58s]  Anybody else who's not in your group and not you.
[452.58s -> 453.70s]  And that's what it is.
[453.70s -> 457.62s]  And by the, permissions are just bits, right?
[457.62s -> 459.38s]  So if you have a permissions,
[459.38s -> 463.90s]  if you want permissions rw dash, rw dash, rw dash,
[463.90s -> 467.18s]  that would be one, one, zero, one, one, zero, one, one, zero.
[467.18s -> 471.34s]  Or, well, one, one, zero happens to be octal six,
[471.34s -> 473.58s]  and then octal six, and octal six.
[473.58s -> 477.98s]  Okay, so zero, six, six, six would be the permissions
[477.98s -> 481.50s]  for rw dash, rw dash, rw dash.
[482.18s -> 485.50s]  Now, the mask does the reverse,
[485.50s -> 487.78s]  like it's the reverse, and again,
[487.78s -> 489.66s]  I'm not exactly sure why.
[489.66s -> 490.50s]  I'm also not sure, whoops,
[490.50s -> 493.46s]  I'm also not sure why this little black line,
[493.46s -> 496.26s]  hang on, let me see if I can't get rid of that for a sec.
[497.46s -> 499.30s]  That is kind of weird.
[499.30s -> 502.26s]  Maybe that, hang on, let me try this.
[502.26s -> 505.26s]  Nope, well, okay, it's just gonna stay there for a while.
[507.30s -> 508.66s]  Hang on, yeah, I'm not sure why.
[508.70s -> 513.70s]  Well, anyway, so the U-mask is actually applied as follows.
[515.22s -> 519.78s]  Okay, so if the U-mask is zero, zero, seven,
[519.78s -> 522.94s]  or zero, seven, seven, in other words, octal zero, seven,
[522.94s -> 525.26s]  seven, that would be this U-mask,
[525.26s -> 527.74s]  and it basically says you're not allowed
[527.74s -> 532.74s]  to create permissions for any of the group or the other.
[534.14s -> 535.30s]  That's the bottom line for it.
[535.30s -> 537.90s]  And what it does, and it kind of stinks that this is,
[537.98s -> 539.34s]  I've got this weird black box in here,
[539.34s -> 543.06s]  but it basically does whatever you're attempting to set,
[544.18s -> 547.94s]  bitwise ANDs it with the inverse of the U-mask,
[547.94s -> 549.26s]  and that's how it actually gets
[549.26s -> 551.46s]  the actual permissions that are set.
[551.46s -> 552.54s]  Okay, so that's how it goes,
[552.54s -> 554.16s]  and I did a little example here
[554.16s -> 556.62s]  of if you're trying to set this,
[556.62s -> 559.54s]  RW dash, RW dash, RW dash,
[559.54s -> 564.54s]  and you have a U-mask that's zero and all ones,
[565.06s -> 567.54s]  then it does the inverse of it,
[568.06s -> 568.88s]  ANDs it against that,
[568.88s -> 571.78s]  and you get the permissions out like this.
[571.78s -> 573.40s]  That's all there is to it.
[573.40s -> 575.70s]  What other questions do you have on this stuff?
[576.82s -> 577.66s]  Yep?
[577.66s -> 578.48s]  What does a group mean?
[578.48s -> 579.32s]  So I think you said before
[579.32s -> 581.34s]  that maybe you can be part of multiple groups.
[581.34s -> 583.70s]  So what does a group permission actually mean?
[583.70s -> 587.24s]  Yeah, so let's do, let me show you.
[587.24s -> 588.08s]  That's a good question
[588.08s -> 589.86s]  about what is an actual group here.
[589.86s -> 593.34s]  And again, I wish I could get rid of this little thing.
[593.34s -> 595.90s]  I don't really know why it's even there, but.
[596.46s -> 600.70s]  Oh, ah-ha, I moved it, I moved it, woo-hoo.
[600.70s -> 602.38s]  Okay, it's gone, woo-hoo.
[602.38s -> 604.58s]  All right, what can I say?
[604.58s -> 607.00s]  All right, I don't know why it's there, but.
[607.00s -> 612.00s]  So if you do the following and say groups,
[612.62s -> 614.46s]  these are all the group,
[614.46s -> 617.88s]  I guess the, hang on, I think it's just group.
[617.88s -> 618.88s]  Group, is it?
[618.88s -> 620.42s]  Nope, I thought it was groups.
[620.42s -> 622.66s]  Anyway, you can find out what groups you're in,
[622.66s -> 627.64s]  and if you look at particular files,
[627.64s -> 632.06s]  the second one over here is the actual group
[632.06s -> 635.18s]  that your, that file happens to belong to.
[635.18s -> 637.08s]  So all it is, each file has a user
[637.08s -> 638.86s]  and then has a group that many users
[638.86s -> 640.90s]  may be able to use for it.
[640.90s -> 643.10s]  I'm not sure what the operator one in particular is,
[643.10s -> 644.50s]  but that's the way it is.
[644.50s -> 645.94s]  What other question on this?
[646.94s -> 647.78s]  Anyone else?
[649.06s -> 650.30s]  See more hands, okay.
[650.30s -> 653.06s]  So U-mask is not that important,
[653.06s -> 655.66s]  it's just kind of a nuanced thing I wanted to show you.
[655.66s -> 656.50s]  All right.
[658.80s -> 662.90s]  Okay, so, if you, here's another,
[662.90s -> 664.70s]  just another example, I guess, about this.
[664.70s -> 666.50s]  Basically, if you have the file
[666.50s -> 668.54s]  that we created the other day, right,
[668.54s -> 670.14s]  where it just basically tries
[670.14s -> 674.30s]  to set a certain permissions, in this case, 0644,
[674.30s -> 678.42s]  and your U-mask is, like, if it's zero,
[678.46s -> 681.86s]  it will enable you to set all those permissions correctly.
[681.86s -> 684.34s]  If you change your U-mask, you can,
[684.34s -> 687.46s]  the same program inherits that U-mask
[687.46s -> 690.86s]  and then applies it and will only allow you
[690.86s -> 691.88s]  to set the permissions here.
[691.88s -> 695.56s]  Now, a particular program can modify the U-mask.
[695.56s -> 698.86s]  So if the program modifies the U-mask,
[698.86s -> 700.26s]  then it will be able to write to it,
[700.26s -> 701.46s]  but it's all about defaults,
[701.46s -> 703.62s]  and as long as you know what the program's attempting
[703.62s -> 706.68s]  to do, you as the user can control it.
[706.68s -> 708.18s]  That's the bottom line there.
[709.42s -> 711.62s]  All right, Unix file systems are interesting.
[712.54s -> 715.10s]  Okay, assignment one.
[715.10s -> 717.94s]  How many people have actually looked at it already?
[717.94s -> 720.14s]  Half of you, okay, if that.
[720.14s -> 723.06s]  The first assignment is, well, first of all,
[723.06s -> 725.10s]  we haven't covered enough stuff for you to get,
[725.10s -> 729.22s]  to do new CS110 stuff for the first assignment,
[729.22s -> 731.86s]  but what we wanted to do is give you a refresher
[731.86s -> 736.62s]  on CS106B and CS107, and a little bit more,
[736.70s -> 738.86s]  hey, you gotta go learn some C++ things
[738.86s -> 740.50s]  that you didn't learn in 106B.
[740.50s -> 742.54s]  Okay, so that's what this assignment is all about.
[742.54s -> 746.50s]  All right, the assignment is meant to get you up to speed
[746.50s -> 749.86s]  on all of this coding that you need
[749.86s -> 751.22s]  to be able to do for this class.
[751.22s -> 753.78s]  Okay, so some of you have already emailed me and go,
[753.78s -> 755.74s]  oh my gosh, I haven't taken 107 in like two
[755.74s -> 757.74s]  and a half years and whatever, what am I gonna do?
[757.74s -> 760.02s]  Well, this assignment is gonna get you back up to speed.
[760.02s -> 764.26s]  All right, the assignment itself, okay,
[764.26s -> 766.40s]  is kind of a fun assignment.
[767.04s -> 769.84s]  It's basically called the six degrees of Kevin Bacon,
[769.84s -> 771.08s]  and why is it Kevin Bacon?
[771.08s -> 774.20s]  Well, Kevin Bacon happens to have been in a ton of movies,
[774.20s -> 778.84s]  and so if you try to link Kevin Bacon to another actor,
[778.84s -> 781.80s]  it's very hard to find more than one or two movies
[781.80s -> 783.56s]  where Kevin Bacon was in this movie
[783.56s -> 785.08s]  with a bunch of actors,
[785.08s -> 786.68s]  they were in a bunch of different movies,
[786.68s -> 789.04s]  and then some other actor happened to be in one movie
[789.04s -> 790.56s]  with one of those actors,
[790.56s -> 792.06s]  and you can link them together
[792.06s -> 794.20s]  like with one movie difference, okay?
[794.20s -> 796.96s]  And so that's how the program actually works.
[796.96s -> 800.84s]  You can, you run it by saying dot slash search,
[800.84s -> 803.84s]  which is one of the files you will be working on,
[803.84s -> 805.30s]  and then you type two names in,
[805.30s -> 807.76s]  in this case it's Meryl Streep and Jack Nicholson,
[807.76s -> 810.40s]  and by the way, many actors,
[810.40s -> 813.74s]  because you can have many people with the same name,
[813.74s -> 818.36s]  are in the IMDb, Internet Movie Database system
[818.36s -> 821.16s]  with a little Roman numeral next to their name
[821.16s -> 823.12s]  in parentheses, that just means
[823.16s -> 826.04s]  that there's two or three or more Jack Nickelsons,
[826.04s -> 827.20s]  and you have to type that in.
[827.20s -> 828.60s]  So you have to be a little bit careful.
[828.60s -> 830.32s]  Madonna, for instance, is another one.
[830.32s -> 833.12s]  If you're testing your code for this,
[833.12s -> 834.60s]  before you test a particular name
[834.60s -> 835.48s]  that you haven't tested yet,
[835.48s -> 836.88s]  go in IMDb and look them up,
[836.88s -> 841.08s]  and if they have a little parentheses like that
[841.08s -> 842.88s]  next to their name, you have to type that one in,
[842.88s -> 844.30s]  or the Roman numeral,
[844.30s -> 847.38s]  otherwise it will say Madonna's not in the search,
[847.38s -> 850.32s]  in the files, and you'll think your program's broken
[850.32s -> 852.46s]  when really it's just you didn't type it in wrong.
[853.06s -> 855.02s]  Okay, so that's how it works.
[855.02s -> 858.10s]  You can type dot slash search Meryl Streep and Jack Nicholson,
[858.10s -> 860.06s]  and it works fine.
[860.06s -> 863.84s]  Let's actually do this.
[865.82s -> 867.06s]  Oh no, here we go again.
[867.06s -> 868.86s]  Hang on, there we go, all right.
[870.86s -> 872.02s]  Come on, there we go.
[873.36s -> 876.86s]  All right, let's see, we will do assignments,
[876.86s -> 881.86s]  assignment one, and you can test this out yourself
[882.06s -> 884.14s]  by doing samples, not sound tools,
[884.14s -> 888.98s]  samples slash search, and it's got the search solution,
[888.98s -> 891.98s]  and if you type Meryl Streep,
[891.98s -> 894.70s]  and you type Streep, Streep?
[894.70s -> 896.16s]  There might be a Meryl Streep, I don't know.
[896.16s -> 901.16s]  And then you type Jack Nicholson, parentheses one, right?
[902.46s -> 903.82s]  It should say that Meryl Streep
[903.82s -> 906.42s]  was in close up with Jack Nicholson, okay?
[906.42s -> 907.40s]  Let's try some others.
[907.40s -> 909.18s]  Try to fool the system.
[909.18s -> 911.34s]  Give me two names of actors we might have heard of,
[911.62s -> 914.64s]  just so, but give me two names.
[916.18s -> 918.94s]  Jerry Cain, Jerry Cain, who taught the class before.
[918.94s -> 922.14s]  I think there might be more than one, actually.
[922.14s -> 925.06s]  And then let's try Meryl Streep, why not?
[925.06s -> 927.58s]  He probably wasn't in a, oh, what did I do?
[927.58s -> 928.42s]  Did I forget?
[929.80s -> 932.18s]  Forgot the quotes here, thank you, there we go.
[932.18s -> 934.82s]  Okay, so Jerry Cain was not the lecturer
[934.82s -> 936.80s]  who was here, was in a movie called No Rules
[936.80s -> 938.46s]  with somebody named Don Fry.
[938.46s -> 941.42s]  Don Fry was in the Ant Bully with Meryl Streep, right?
[941.42s -> 943.02s]  It's gonna be really, it's actually really hard
[943.02s -> 945.82s]  to find more than one or two different movies.
[945.82s -> 948.22s]  Give me some other names of people that we've heard of.
[948.22s -> 949.42s]  Michael Jordan.
[949.42s -> 950.26s]  Sorry?
[950.26s -> 951.10s]  Michael Jordan.
[951.10s -> 951.92s]  Michael Jordan.
[951.92s -> 953.14s]  Michael Jordan was in what?
[953.14s -> 954.78s]  Air Jordan, or Michael Jordan?
[954.78s -> 955.62s]  Space Jam.
[955.62s -> 956.86s]  He was in, that's our Space Jam, yeah.
[956.86s -> 958.70s]  Okay, there's probably more than one,
[958.70s -> 960.18s]  but we'll just try this.
[960.18s -> 963.06s]  Jordan, and then anybody else?
[963.06s -> 963.96s]  Keanu Reeves.
[963.96s -> 964.80s]  Keanu Reeves.
[964.80s -> 965.64s]  Keanu.
[965.64s -> 966.46s]  Keanu.
[966.46s -> 967.30s]  Keanu.
[967.30s -> 969.14s]  Did I spell it right?
[969.14s -> 969.98s]  Think so.
[969.98s -> 971.10s]  Okay, couldn't find Michael Jordan
[971.10s -> 972.38s]  because there's probably more than one,
[972.38s -> 976.50s]  so we will do, let's just see if it's the first one.
[976.50s -> 977.34s]  I don't know.
[977.34s -> 979.50s]  There we go, Michael Jordan was in Blink, who knew?
[979.50s -> 981.62s]  With Rick, I don't know how to pronounce that,
[981.62s -> 983.54s]  and that other person with a chain reaction.
[983.54s -> 984.74s]  So it's hard, right?
[984.74s -> 986.18s]  You can go back a long ways.
[986.18s -> 989.62s]  Let's see if Michael Jordan and,
[990.94s -> 994.06s]  let's see, how about Charlie Chaplin?
[994.90s -> 996.38s]  All right, that was a while ago, right?
[996.38s -> 1001.38s]  And, hmm, I don't know, maybe it,
[1001.86s -> 1003.20s]  I wonder if,
[1006.54s -> 1008.18s]  I haven't tried that one yet.
[1008.18s -> 1009.62s]  That's an interesting, that's interesting.
[1009.62s -> 1010.98s]  We'll let it go for another second or so.
[1010.98s -> 1013.30s]  It might be that, hmm, I'm not sure
[1013.30s -> 1014.14s]  what's going on with that.
[1014.14s -> 1016.06s]  Let me try, let me try it, everyone.
[1017.74s -> 1019.42s]  So I should try these things out before,
[1019.42s -> 1023.74s]  but let's just try Meryl Streep, and,
[1024.74s -> 1026.90s]  yeah, that's interesting.
[1026.90s -> 1028.14s]  I wonder if Charlie Chaplin's not,
[1028.14s -> 1031.08s]  well, it shouldn't, hmm, I don't know.
[1031.08s -> 1032.10s]  That's weird.
[1032.10s -> 1033.34s]  How about Ronald Reagan?
[1036.46s -> 1038.56s]  There we go, oh, I think something,
[1038.56s -> 1041.46s]  I think it's the file system, actually, hang on.
[1042.70s -> 1044.46s]  Let's go try again and see if,
[1045.46s -> 1048.10s]  I don't know, I don't know, I don't know, that's weird.
[1048.10s -> 1050.58s]  Well, anyway, you get kind of the idea.
[1050.58s -> 1052.70s]  You can, even though I'm,
[1052.70s -> 1054.10s]  even though it's a little crazy.
[1054.10s -> 1055.70s]  But you can also do things like,
[1055.70s -> 1058.54s]  you can do IMDb test, which you're gonna do first,
[1058.54s -> 1061.38s]  which would be something like just check and see,
[1061.38s -> 1063.14s]  let's just check.
[1063.14s -> 1064.26s]  Oh, you know what, is it Charles?
[1064.26s -> 1065.50s]  No, I think it's IE.
[1067.28s -> 1069.18s]  Might be Charles, ah, there we go.
[1069.18s -> 1070.18s]  Maybe that was the issue before.
[1070.18s -> 1071.94s]  Okay, hold on, hold on, hold on.
[1073.78s -> 1075.50s]  I don't know why it didn't tell us, Charles.
[1075.50s -> 1077.86s]  There we go, okay, well, okay.
[1077.86s -> 1080.10s]  So here's one problem with the IMDb database.
[1080.46s -> 1083.02s]  Charlie Chaplin wasn't alive in 2006.
[1083.02s -> 1085.50s]  He died in like 1970 or something.
[1085.50s -> 1087.54s]  But he was, whenever somebody's in,
[1087.54s -> 1089.68s]  like clips in a movie, they also put him in here, too.
[1089.68s -> 1091.58s]  So it's a little bit trickier.
[1092.90s -> 1093.74s]  Anyway, that's that.
[1093.74s -> 1098.38s]  But you can do IMDb cert test,
[1098.38s -> 1102.74s]  and if we do Charles Chaplin,
[1104.18s -> 1106.26s]  then it will give you the fact
[1106.26s -> 1109.30s]  that he was in thousands and thousands of movies,
[1109.30s -> 1112.10s]  and it will list a bunch of them, not all of them,
[1112.10s -> 1114.62s]  and you can test your program that way.
[1114.62s -> 1119.62s]  So that's kind of the basic idea about how this works.
[1121.14s -> 1123.14s]  Let's talk about a little bit more details.
[1123.14s -> 1125.06s]  There are two big files,
[1125.06s -> 1128.04s]  big being hundreds of thousands of names,
[1128.04s -> 1129.90s]  that are called, one's called the actor file,
[1129.90s -> 1131.74s]  one is called the movie file,
[1131.74s -> 1135.22s]  and they are set up such that
[1135.22s -> 1137.58s]  you can do binary searching on them.
[1137.58s -> 1141.38s]  The actor file has a whole bunch of offsets
[1141.38s -> 1144.46s]  to where various actors are located in this file,
[1144.46s -> 1146.46s]  and then there they have the name of the actor
[1146.46s -> 1148.46s]  and all the movies that the actor was in,
[1148.46s -> 1150.68s]  and the movie database is kind of the reverse.
[1150.68s -> 1153.62s]  It's got a whole bunch of offsets into this file
[1153.62s -> 1154.62s]  that point to movies,
[1154.62s -> 1157.50s]  and then the movies say what actors they were in.
[1157.50s -> 1158.90s]  These files are big enough
[1158.90s -> 1161.46s]  that you do not want to read them all in at once,
[1161.46s -> 1165.02s]  number one, but we've actually put a lot of that
[1165.02s -> 1165.84s]  under the hood for you.
[1165.84s -> 1166.90s]  You don't need to worry about
[1166.94s -> 1168.22s]  the fact that you're not reading these.
[1168.22s -> 1170.38s]  Just know that you're actually jumping
[1170.38s -> 1173.42s]  to a place in the file and reading a little bit.
[1173.42s -> 1175.06s]  But the important part about these files
[1175.06s -> 1177.66s]  is that you can do a binary search on them.
[1177.66s -> 1179.38s]  They are set up in alphabetical order
[1179.38s -> 1181.22s]  such that you can do a binary search.
[1181.22s -> 1183.78s]  Awesome, binary searches, as you know from CS106B,
[1183.78s -> 1187.54s]  are very fast because they break things into chunks
[1187.54s -> 1190.42s]  and divide and conquer, et cetera.
[1190.42s -> 1193.18s]  So you have to figure out how to
[1193.18s -> 1196.10s]  index correctly into this weird file
[1196.14s -> 1197.42s]  that's got all these offsets in it
[1197.42s -> 1201.14s]  with a whole bunch of different kind of nuances to it,
[1201.14s -> 1204.10s]  and that's the CS107 part.
[1204.10s -> 1206.08s]  That's the part where you're gonna be going,
[1206.08s -> 1210.30s]  oh boy, I gotta remember how to do pointer math
[1210.30s -> 1213.84s]  and pointer arithmetic and indexing into things and so forth
[1213.84s -> 1216.12s]  so an off by one errors and all that kind of stuff.
[1216.12s -> 1218.62s]  So that's the CS107 part.
[1218.62s -> 1221.18s]  There's a C++ part where you're going to use
[1221.18s -> 1224.14s]  the standard template library which is similar
[1224.22s -> 1227.10s]  but different from the Stanford library
[1227.10s -> 1230.68s]  which you used in like 106B or even 106A.
[1230.68s -> 1232.42s]  Specifically, you're gonna have to use this function
[1232.42s -> 1235.38s]  called lower bound which is a standard
[1235.38s -> 1237.44s]  template library function which does
[1237.44s -> 1239.10s]  the binary search for you.
[1239.10s -> 1241.14s]  In fact, there was a question on Piazza already
[1241.14s -> 1243.98s]  that said, hey, can we do recursion to do this searching?
[1243.98s -> 1246.94s]  And I said, whoa, no recursion necessary for searching
[1246.94s -> 1250.42s]  because lower bound doesn't do recursion
[1250.42s -> 1253.82s]  but it does the searching, the binary search for you.
[1255.06s -> 1258.98s]  The idea is you set up the lower bound function
[1258.98s -> 1260.42s]  and it searches through your data
[1260.42s -> 1262.22s]  but you have to set it up correctly.
[1262.22s -> 1265.14s]  But that's the kind of 106B plus sort of stuff
[1265.14s -> 1266.70s]  that you're gonna be working on.
[1268.86s -> 1271.46s]  This lower bound function, it's a little bit interesting.
[1271.46s -> 1273.74s]  It returns what we call an iterator
[1273.74s -> 1275.98s]  and an iterator, for our purposes at least
[1275.98s -> 1277.98s]  for this assignment, is a pointer
[1278.02s -> 1280.82s]  because an iterator allows you to add to it
[1280.82s -> 1284.82s]  and allows you to go to the next one
[1284.82s -> 1287.70s]  in the line of whatever you're iterating through.
[1287.70s -> 1288.58s]  That's what it does.
[1288.58s -> 1290.98s]  You will be able to learn those sorts of things.
[1290.98s -> 1292.18s]  This is what this week is all about.
[1292.18s -> 1293.46s]  Oh, I don't know what an iterator is yet.
[1293.46s -> 1295.06s]  Let me learn what it is.
[1295.06s -> 1296.90s]  Once you have figured all that out,
[1296.90s -> 1300.18s]  well, you're able to search through this database.
[1300.18s -> 1301.96s]  Well, now you actually have to link
[1301.96s -> 1304.36s]  actor one to actor two.
[1304.36s -> 1305.26s]  Well, how are you gonna do that?
[1305.26s -> 1306.64s]  You're gonna do a breadth first search.
[1306.64s -> 1308.60s]  Ah, more 106B stuff.
[1308.60s -> 1309.56s]  Right, you're gonna have to remember
[1309.56s -> 1310.72s]  how to do a breadth first search.
[1310.72s -> 1311.76s]  I'll give you a hint.
[1311.76s -> 1313.42s]  You probably wanna use a queue
[1313.42s -> 1316.20s]  or in our case a list which is a queue
[1316.20s -> 1318.32s]  by another name as such.
[1318.32s -> 1321.68s]  So those are the big things about the assignment, okay?
[1322.92s -> 1324.36s]  Now let's talk a little bit more
[1324.36s -> 1327.40s]  about this lower bound for a couple minutes.
[1327.40s -> 1330.12s]  The assignment itself says I am requiring
[1330.12s -> 1332.28s]  that you use the STL lower bound algorithm.
[1332.28s -> 1334.12s]  Oh great, so you gotta use that
[1334.12s -> 1335.96s]  to perform binary searches
[1336.24s -> 1339.44s]  and that you use C++ lambdas,
[1339.44s -> 1342.20s]  also known as anonymous functions
[1342.20s -> 1344.60s]  with capture clauses to provide
[1344.60s -> 1346.00s]  nameless comparison functions.
[1346.00s -> 1346.92s]  And you're thinking to yourself,
[1346.92s -> 1348.80s]  I have never seen that before, right?
[1348.80s -> 1349.72s]  And we haven't even learned it yet.
[1349.72s -> 1350.88s]  Well, I'm gonna talk to you
[1350.88s -> 1352.32s]  a little bit about that right now.
[1352.32s -> 1357.32s]  A C++ lambda is, it's a new concept probably,
[1358.32s -> 1360.88s]  although if you've done any JavaScript,
[1360.88s -> 1362.20s]  you have certainly used these before,
[1362.20s -> 1363.12s]  although you might not have known
[1363.12s -> 1365.00s]  what they were called.
[1365.00s -> 1367.16s]  And what it is, it's a function
[1367.16s -> 1371.00s]  that is placed in line as a parameter
[1371.00s -> 1373.48s]  to another function, okay?
[1373.48s -> 1376.72s]  Which expects the parameter itself to be a function,
[1376.72s -> 1378.40s]  so it's kind of inception, right?
[1378.40s -> 1383.40s]  You did all this in 107 with function pointers, okay?
[1383.52s -> 1384.56s]  So if you remember 107,
[1384.56s -> 1386.32s]  you talked about function pointers.
[1386.32s -> 1390.08s]  This is a function pointer that's in line
[1390.08s -> 1393.96s]  and not like another function that you're setting up, okay?
[1393.96s -> 1394.80s]  So for instance,
[1394.80s -> 1397.72s]  you remember the qsort function from 107, right?
[1397.72s -> 1402.72s]  The last parameter in here is a, oops, it's not good,
[1403.04s -> 1407.36s]  is a comparison function that you have to define
[1407.36s -> 1409.96s]  and you pass it in to qsort, okay?
[1409.96s -> 1412.72s]  Qsort has no idea how that function works.
[1412.72s -> 1414.40s]  It just knows that I have two pointers
[1414.40s -> 1415.24s]  that I'm gonna pass into this function
[1415.24s -> 1417.64s]  and I'm gonna get back which one's the,
[1417.64s -> 1419.66s]  I'm gonna get back a zero, a negative one, or a one
[1419.66s -> 1421.84s]  to say whether it's small or bigger or the same.
[1421.84s -> 1423.52s]  It's all it knows, right?
[1424.04s -> 1425.92s]  And that's what function pointers are all about.
[1425.92s -> 1428.84s]  You give this other function the function pointer
[1428.84s -> 1431.82s]  that says, hey, I'm gonna do something for you, use it.
[1431.82s -> 1434.56s]  That's all it is, okay?
[1434.56s -> 1437.26s]  That's what that's all about, okay?
[1437.26s -> 1440.20s]  Let's look at a little program about this, okay?
[1440.20s -> 1443.08s]  I just made up some dumb program to do the following,
[1443.08s -> 1443.92s]  okay?
[1443.92s -> 1446.64s]  In this program, okay, I created two,
[1446.64s -> 1447.96s]  well, let's start with this one.
[1447.96s -> 1452.48s]  I created a function called ModifyVec and what it does,
[1452.48s -> 1456.90s]  we're now in C++ land, so it takes in a C++ vector
[1456.90s -> 1458.68s]  by reference, okay?
[1458.68s -> 1463.40s]  It takes in a value and it takes in this
[1463.40s -> 1466.68s]  which is C++ for function pointer.
[1466.68s -> 1467.96s]  You can think of it that way, okay?
[1467.96s -> 1471.00s]  What it is is it says, give me a function
[1471.00s -> 1475.04s]  that returns an integer and takes two integers
[1475.04s -> 1477.16s]  as parameters, okay?
[1477.16s -> 1479.96s]  And what it's gonna do is it's going to basically
[1479.96s -> 1483.84s]  loop through the vector and then pass in
[1483.84s -> 1487.76s]  that vector element, a reference to it as it turns out,
[1487.76s -> 1489.72s]  and the, well, it's actually gonna,
[1489.72s -> 1491.62s]  it gets a reference out.
[1491.62s -> 1493.00s]  It's going to pass in the value,
[1493.00s -> 1497.48s]  it's going to pass in the value in the vector
[1497.48s -> 1500.06s]  and then it's going to apply that operation to it.
[1500.06s -> 1500.90s]  That's all it's doing.
[1500.90s -> 1504.72s]  It's basically updating the vector with new values
[1504.72s -> 1506.60s]  based on some operation, okay?
[1506.60s -> 1508.12s]  Well, what are the two operations I did?
[1508.14s -> 1509.68s]  I happen to make one called add,
[1509.68s -> 1513.96s]  which basically returns X plus Y when you pass it in.
[1513.96s -> 1514.80s]  Pretty simple.
[1514.80s -> 1517.08s]  And then subtract, which does X minus Y.
[1517.08s -> 1519.32s]  That's all it does, okay?
[1519.32s -> 1522.60s]  Well, what are we actually doing in main?
[1523.86s -> 1527.32s]  We are getting some stuff out of the command line
[1527.32s -> 1529.98s]  and then we are creating a vector
[1529.98s -> 1534.00s]  and then calling the operator
[1534.00s -> 1537.32s]  inside this modify vector function, okay?
[1537.32s -> 1540.12s]  I'm saying modify the vector, pass in the vector,
[1540.12s -> 1542.16s]  pass in the value that I'm typing on the command line
[1542.16s -> 1546.64s]  to do the operation with, and then the function itself.
[1546.64s -> 1547.48s]  Okay?
[1547.48s -> 1549.40s]  A key part of this
[1549.40s -> 1554.10s]  is that when you call this modifyVec function,
[1554.10s -> 1557.00s]  even though add is a function itself,
[1557.00s -> 1559.68s]  it is not getting called immediately.
[1560.60s -> 1562.52s]  That's a key, key part of this.
[1562.52s -> 1565.36s]  When you say modifyVec and you pass in parameter one,
[1565.36s -> 1566.92s]  parameter two, parameter three,
[1567.48s -> 1569.56s]  this is a parameter that is not being called
[1569.56s -> 1572.92s]  until modifyVec actually calls it directly.
[1573.84s -> 1576.24s]  Okay, that's how that's working.
[1576.24s -> 1577.96s]  Okay, and you can test it out
[1577.96s -> 1581.64s]  by saying function pointer add 12,
[1581.64s -> 1584.14s]  and what we'll do is we'll take the one, two, three,
[1584.14s -> 1586.36s]  four, five, 10, 100,000,
[1586.36s -> 1589.94s]  and add 12 to each one of those and print them out.
[1589.94s -> 1590.78s]  Okay?
[1590.78s -> 1593.54s]  This should look very familiar from CS107.
[1593.54s -> 1595.68s]  Okay, if it's not, if you're a little rusty on that,
[1595.68s -> 1597.24s]  okay, take a look at the example,
[1597.24s -> 1598.10s]  figure out how it works,
[1598.10s -> 1601.24s]  and ask questions about it if you've got them.
[1601.24s -> 1602.68s]  Okay?
[1602.68s -> 1604.40s]  But the important part is
[1604.40s -> 1607.32s]  here's where you're passing in a function pointer.
[1608.24s -> 1609.08s]  Okay?
[1609.08s -> 1612.52s]  Now, let's rewrite this as,
[1612.52s -> 1615.96s]  or using this weird thing called a lambda function.
[1615.96s -> 1616.80s]  Okay?
[1616.80s -> 1618.18s]  Everything is the same,
[1618.18s -> 1622.24s]  except for this from right here
[1622.24s -> 1624.00s]  to right here,
[1624.00s -> 1625.80s]  and then the same thing on the next line.
[1625.80s -> 1627.56s]  What's happening here is,
[1627.56s -> 1628.92s]  we are saying, okay, great,
[1628.92s -> 1631.00s]  passing the vector, passing that value,
[1631.00s -> 1633.48s]  and then passing this weird thing,
[1633.48s -> 1635.56s]  which actually has code
[1635.56s -> 1639.56s]  inside the function parameter itself.
[1639.56s -> 1640.96s]  Seems kind of weird,
[1640.96s -> 1642.68s]  but it's just inline code
[1642.68s -> 1645.72s]  that's going to return x plus y
[1645.72s -> 1649.84s]  for parameters x and y.
[1649.84s -> 1650.68s]  Okay?
[1650.68s -> 1651.56s]  Exactly the same thing,
[1651.76s -> 1653.36s]  except notice I do not have an add
[1653.36s -> 1655.04s]  and subtract program up here,
[1655.04s -> 1656.16s]  or function up here.
[1656.16s -> 1658.88s]  I have just done the exact same thing in line.
[1658.88s -> 1661.08s]  That's what a lambda allows you to do.
[1661.08s -> 1662.12s]  Okay?
[1662.12s -> 1663.92s]  A lambda does the following,
[1663.92s -> 1666.20s]  it has the following signature.
[1666.20s -> 1667.36s]  It has a curly,
[1667.36s -> 1668.64s]  or a,
[1668.64s -> 1669.82s]  it's a little hard to see here.
[1669.82s -> 1671.64s]  It has two square brackets,
[1671.64s -> 1672.90s]  and something can go in there,
[1672.90s -> 1674.32s]  we'll talk about that in a minute.
[1674.32s -> 1677.68s]  It has a parameter list,
[1677.68s -> 1678.60s]  parameter list,
[1678.72s -> 1680.48s]  and then it has some code
[1680.48s -> 1682.00s]  that's in curly braces.
[1682.00s -> 1682.84s]  Okay?
[1682.84s -> 1685.96s]  That is a function that gets passed into
[1685.96s -> 1688.64s]  the other function as a parameter itself.
[1688.64s -> 1689.48s]  Okay?
[1689.48s -> 1690.48s]  It does not have a name associated with it,
[1690.48s -> 1691.32s]  doesn't need one,
[1691.32s -> 1692.16s]  it's right in line.
[1693.20s -> 1694.04s]  Okay?
[1694.04s -> 1695.50s]  And this is exactly what will happen,
[1695.50s -> 1697.70s]  it's exact same program now.
[1697.70s -> 1698.54s]  Okay?
[1698.54s -> 1699.36s]  All right,
[1699.36s -> 1700.20s]  we'll talk about what this weird thing
[1700.20s -> 1702.68s]  in this square brackets are for a second.
[1702.68s -> 1704.12s]  Ponder that for a second.
[1704.12s -> 1707.58s]  What questions do you have about it so far?
[1707.58s -> 1709.22s]  You may not have enough time to think through yet,
[1709.22s -> 1711.84s]  but questions do you have about it so far?
[1711.84s -> 1712.68s]  Yeah?
[1712.68s -> 1714.18s]  What is the advantage of a lambda
[1714.18s -> 1716.98s]  if you like to write it in line?
[1716.98s -> 1717.98s]  Yeah, good question.
[1717.98s -> 1718.82s]  The question was,
[1718.82s -> 1719.64s]  what's the advantage of this
[1719.64s -> 1720.98s]  is the advantage that you can write it in line.
[1720.98s -> 1721.94s]  That is one advantage.
[1721.94s -> 1723.26s]  Normally these functions are short,
[1723.26s -> 1724.10s]  they're right there,
[1724.10s -> 1725.42s]  you can look at them right there,
[1725.42s -> 1726.30s]  that's great.
[1726.30s -> 1728.30s]  Another advantage which we will come up to
[1728.30s -> 1729.84s]  is the big advantage,
[1729.84s -> 1731.34s]  is the fact that you can do things
[1731.34s -> 1733.12s]  with landers you can't do with function pointers,
[1733.12s -> 1734.38s]  and we'll get to that in a minute.
[1734.38s -> 1735.22s]  But yeah,
[1735.22s -> 1736.04s]  for now I just wanted to introduce it
[1736.04s -> 1736.88s]  in this kind of,
[1737.04s -> 1738.52s]  it's exactly the same as before,
[1738.52s -> 1740.48s]  next we'll go into what is new.
[1740.48s -> 1743.78s]  What other questions do you have about that so far?
[1747.60s -> 1749.08s]  Okay, if you are like,
[1749.08s -> 1750.16s]  oh I haven't seen this before,
[1750.16s -> 1751.40s]  take a look at it again,
[1751.40s -> 1752.28s]  and we'll get there.
[1752.28s -> 1753.10s]  Now,
[1754.60s -> 1757.28s]  it turns out, okay,
[1757.28s -> 1758.76s]  what if, or I should say,
[1758.76s -> 1763.76s]  what if we want to actually utilize variables
[1763.80s -> 1766.84s]  that we don't want to explicitly pass
[1767.68s -> 1768.50s]  into the function?
[1768.50s -> 1770.44s]  And it's not necessarily just a variable,
[1770.44s -> 1773.56s]  we could actually have a function call
[1773.56s -> 1775.36s]  inside our Lambda function
[1775.36s -> 1777.34s]  that might use something local
[1777.34s -> 1779.80s]  to the original calling function.
[1779.80s -> 1782.04s]  Let me show you what I mean, okay?
[1782.04s -> 1783.84s]  This is what we originally had, right?
[1783.84s -> 1787.18s]  We had a function here which took in two things,
[1787.18s -> 1789.02s]  it took in a value,
[1789.02s -> 1789.86s]  and it took in,
[1789.86s -> 1792.18s]  or it took in two values, okay?
[1792.18s -> 1794.56s]  One of those values is coming from this vector,
[1794.56s -> 1796.72s]  the other one we pass into the function.
[1797.56s -> 1798.56s]  That's like the 12 that would add 12
[1798.56s -> 1803.00s]  to each one of the elements in the vector, okay?
[1803.00s -> 1806.20s]  But what if we wanted to change it to say,
[1806.20s -> 1809.56s]  I only want to deal in my function here
[1809.56s -> 1812.92s]  with the actual vector element itself?
[1812.92s -> 1815.90s]  I don't want to pass another element through
[1815.90s -> 1818.48s]  using these function parameters, okay?
[1818.48s -> 1819.72s]  This, as it turns out,
[1819.72s -> 1821.02s]  will be very hard to do,
[1821.02s -> 1822.96s]  in fact, I don't even know if I know how I would do it,
[1822.96s -> 1827.56s]  with a regular old function pointer, okay?
[1827.56s -> 1829.28s]  And I'll show you the example in a second.
[1829.28s -> 1832.36s]  It turns out we want modify vector in this case
[1832.36s -> 1836.20s]  to also handle the value that we are updating by.
[1836.20s -> 1838.40s]  In other words, we want the function
[1838.40s -> 1840.92s]  that calls modify vector to handle that
[1840.92s -> 1844.72s]  before it even gets to our modify vector function.
[1844.72s -> 1847.92s]  We want to pre-line up what we've got there.
[1847.92s -> 1849.56s]  That would be really hard to do
[1849.56s -> 1852.72s]  with a function pointer,
[1852.72s -> 1855.80s]  with a Lambda function, it is actually possible, okay?
[1855.80s -> 1859.08s]  Here's how you might do it, okay?
[1859.08s -> 1860.48s]  Here's what I've done differently now.
[1860.48s -> 1862.00s]  I have changed this up here,
[1862.00s -> 1865.48s]  so basically the function now simply says,
[1865.48s -> 1869.14s]  give me a vector element and I will do my operation
[1869.14s -> 1871.14s]  with some other value on it.
[1871.14s -> 1874.24s]  And our modify vector function is really easy,
[1874.24s -> 1876.76s]  all it needs to know is get an element out of the vector,
[1876.76s -> 1879.60s]  pass it on to this operation function, and it's done.
[1879.60s -> 1881.64s]  And then it'll do the rest of it for us.
[1881.64s -> 1883.40s]  But it still does add that.
[1883.40s -> 1886.80s]  Well, down here, what I've said was, okay,
[1886.80s -> 1889.68s]  and this is now the important part here, okay?
[1889.68s -> 1893.64s]  I have said, all right, pass into modify vector,
[1893.64s -> 1895.64s]  the vector we're trying to change,
[1895.64s -> 1900.64s]  and then the following Lambda function, okay?
[1901.36s -> 1905.62s]  Which is this, it says, only take one parameter, x,
[1905.62s -> 1910.48s]  but use the value of, called val,
[1910.48s -> 1913.88s]  from the scope of this function,
[1913.88s -> 1917.28s]  in the modify vec function, okay?
[1917.28s -> 1918.12s]  How is it gonna do that?
[1918.12s -> 1920.92s]  It's gonna say return x plus that value.
[1920.92s -> 1923.56s]  In other words, I am not sending val
[1923.56s -> 1927.16s]  as a parameter to modify vec anymore, okay?
[1927.16s -> 1928.64s]  So that's what's happening here.
[1928.64s -> 1932.52s]  The way this works is through this idea of captures, okay?
[1932.52s -> 1936.92s]  And a capture says, put something inside
[1936.92s -> 1940.32s]  those square brackets that are local variables
[1941.00s -> 1942.32s]  or variables in scope anyway,
[1942.32s -> 1945.32s]  that you want to pass to the lambda function
[1948.56s -> 1952.10s]  that will get used in some other function, okay?
[1952.10s -> 1954.84s]  In this case, I'm just passing in val,
[1954.84s -> 1957.70s]  and then we're saying int x is the,
[1957.70s -> 1959.60s]  and then we're saying in here,
[1959.60s -> 1964.60s]  return x plus val semicolon and curly brace like that.
[1965.08s -> 1966.64s]  That's what we're doing inside that function,
[1966.64s -> 1967.72s]  and it allows you to do that.
[1967.72s -> 1969.12s]  Now, you might still say,
[1969.16s -> 1971.32s]  well, it doesn't seem like it's that much different.
[1971.32s -> 1973.12s]  It turns out that it's, well,
[1973.12s -> 1974.36s]  it would be almost impossible to do this
[1974.36s -> 1976.00s]  with a regular function pointer, number one.
[1976.00s -> 1979.44s]  And number two, it's even more difficult to do
[1979.44s -> 1981.40s]  if you are in a class function
[1981.40s -> 1984.72s]  trying to call a non-class function, okay?
[1984.72s -> 1986.24s]  It's just really hard to do,
[1986.24s -> 1988.20s]  especially if that non-class function
[1988.20s -> 1991.40s]  expects something already handled for you
[1991.40s -> 1995.36s]  that isn't part of the parameter list already, okay?
[1995.36s -> 1999.04s]  So that's a lot to kind of think about right now.
[1999.80s -> 2000.80s]  By the way, there are lots of ways
[2000.80s -> 2002.00s]  to capture multiple variables.
[2002.00s -> 2003.62s]  You can capture multiple variables
[2003.62s -> 2006.92s]  by putting them in a list like value one,
[2006.92s -> 2009.38s]  value two, et cetera.
[2009.38s -> 2012.88s]  You can also capture them by reference,
[2012.88s -> 2014.88s]  which unfortunately looks just like a pointer,
[2014.88s -> 2017.28s]  but it's not in this case, or an address, rather.
[2017.28s -> 2018.76s]  But if you said a up or sand val,
[2018.76s -> 2021.64s]  it would pass the value by reference,
[2021.64s -> 2024.82s]  so you're actually changing the original one.
[2024.82s -> 2027.68s]  You would do this with big data structures and so forth.
[2027.68s -> 2029.32s]  Now, the reason I'm bringing all this up
[2029.32s -> 2030.52s]  and showing you how to do this
[2030.52s -> 2033.72s]  is that you do have to do it for this assignment
[2033.72s -> 2037.64s]  in a particular place using that lower bound function.
[2037.64s -> 2039.28s]  And go back to the notes here and go,
[2039.28s -> 2041.16s]  oh, how is this stuff actually working?
[2041.16s -> 2043.66s]  Understand these, then you'll be able to figure out
[2043.66s -> 2045.04s]  how to do the one for the assignment.
[2045.04s -> 2045.88s]  Yeah?
[2045.88s -> 2049.42s]  Can you explain again why you can't just pass in,
[2049.42s -> 2051.08s]  or why it's so hard to do
[2051.08s -> 2053.20s]  what you're trying to do here with the function?
[2053.20s -> 2055.04s]  Yeah, so let's think about what we're trying to do.
[2055.04s -> 2056.30s]  If we have a function that says,
[2056.30s -> 2060.08s]  okay, you are gonna give me a function pointer,
[2061.22s -> 2064.22s]  in this case, just a function, kind of lambda function,
[2064.22s -> 2067.60s]  but a function pointer that only has one value,
[2067.60s -> 2072.18s]  but that value is contingent on something else happening
[2072.18s -> 2074.12s]  in the original calling function.
[2074.12s -> 2078.74s]  In other words, this val variable.
[2078.74s -> 2081.94s]  If I can't pass that in to the function up here,
[2081.94s -> 2085.46s]  how would this modifyVec do that
[2085.50s -> 2087.98s]  unless I was able to pass in another variable?
[2089.46s -> 2090.90s]  I obviously could have done it
[2090.90s -> 2092.38s]  with passing that other variable in,
[2092.38s -> 2094.38s]  but they don't do it for things like lower bound.
[2094.38s -> 2097.14s]  They say, here's the function signature.
[2097.14s -> 2099.50s]  You get one variable, or you get one function
[2099.50s -> 2101.26s]  to pass in with one parameter.
[2101.26s -> 2102.50s]  You don't get any other parameters.
[2102.50s -> 2103.50s]  And you go, well, wait a minute.
[2103.50s -> 2104.66s]  I need two parameters for this.
[2104.66s -> 2105.86s]  How am I gonna pass the other one?
[2105.86s -> 2107.14s]  How am I gonna deal with the other one?
[2107.14s -> 2109.34s]  You do it through the lambda function.
[2109.34s -> 2111.74s]  Okay, you say, oh, I'll handle it locally.
[2111.74s -> 2114.18s]  Capture that variable I'm gonna need.
[2114.18s -> 2116.90s]  Tell the function what to do with that variable.
[2116.90s -> 2118.68s]  And then when that whole function gets passed
[2118.68s -> 2120.70s]  into the other function, it all gets handled
[2120.70s -> 2124.12s]  as if it was, it all gets handled as a black box
[2124.12s -> 2126.82s]  to the original function, or the one you're calling.
[2126.82s -> 2129.26s]  So these things are subtle.
[2129.26s -> 2130.74s]  But you'll see later, in fact,
[2130.74s -> 2132.94s]  when you start to write the assignment,
[2132.94s -> 2134.08s]  you'll get to this point and go,
[2134.08s -> 2135.54s]  I guess I could use a regular function point,
[2135.54s -> 2136.90s]  and you'll go, oh, I can't.
[2136.90s -> 2138.30s]  Just won't work that way.
[2138.30s -> 2140.66s]  So that's where it's gonna come into play.
[2140.66s -> 2142.66s]  What other questions do you have on this?
[2144.78s -> 2145.62s]  No?
[2145.62s -> 2147.26s]  Okay, look at this stuff again.
[2147.26s -> 2149.10s]  There are lots of documentation on it.
[2149.10s -> 2151.42s]  And certainly feel free to come to Office Hours
[2151.42s -> 2152.62s]  to look at it as well.
[2154.14s -> 2156.96s]  All right, what other comments do we have on here?
[2156.96s -> 2158.82s]  They are critical for C++ classes.
[2158.82s -> 2162.10s]  As I said, class method variables,
[2162.10s -> 2164.80s]  you actually can't pass them by reference at all
[2164.80s -> 2167.74s]  to other functions no matter how you do it.
[2167.74s -> 2170.26s]  So that's gonna be, you're necessary
[2170.26s -> 2172.74s]  to use the lambda functions.
[2172.74s -> 2177.74s]  You can capture all of the variables in a class
[2178.22s -> 2182.30s]  by using the this pointer to do that.
[2182.30s -> 2184.98s]  You can also, as I said, do them by one after the other.
[2184.98s -> 2187.62s]  There's some nuances about how you actually
[2187.62s -> 2188.82s]  need to set these up.
[2188.82s -> 2190.98s]  But if you wanted to pass in this and val
[2190.98s -> 2193.90s]  and myvec by reference, that's how you would do it.
[2194.94s -> 2196.00s]  You'll see when you get into this.
[2196.00s -> 2197.96s]  And by the end of the class, by the end of the quarter,
[2197.96s -> 2199.32s]  you'll go, oh, I get these things.
[2199.32s -> 2200.50s]  But the first couple times you see it,
[2200.50s -> 2201.98s]  you go, I don't know what's going on.
[2201.98s -> 2204.34s]  Go back to the slides, ask questions on Piazza
[2204.34s -> 2206.98s]  and in office hours, and we will figure it out.
[2208.88s -> 2210.78s]  Anything else on that?
[2210.78s -> 2213.30s]  Okay, all right.
[2213.30s -> 2216.18s]  Let us go back to where we ended up yesterday.
[2216.18s -> 2219.96s]  We're gonna talk about file systems some more, okay?
[2219.96s -> 2222.60s]  Yesterday I ended with this example,
[2222.60s -> 2226.24s]  which basically was re-implementing the cp command
[2226.24s -> 2229.02s]  called copy, and it was a pretty simple,
[2229.02s -> 2233.38s]  all things considered, program that basically says,
[2233.38s -> 2235.02s]  you have file one and file two,
[2235.02s -> 2237.06s]  and you wanna copy the contents of file,
[2237.06s -> 2239.54s]  or you wanna, file two is what you're creating.
[2239.54s -> 2244.34s]  You wanna copy file one into file two as an exact copy.
[2244.34s -> 2246.62s]  Okay, and what we did was we said, okay, fine.
[2246.62s -> 2250.18s]  We are going to set up a file descriptor,
[2250.18s -> 2252.42s]  which is just an integer, and we're gonna use
[2252.42s -> 2254.54s]  the open command to do it,
[2254.54s -> 2255.66s]  and we're gonna say it's read only.
[2255.66s -> 2257.06s]  That's the one we're reading from.
[2257.06s -> 2259.40s]  We're gonna do the exact same thing,
[2259.40s -> 2260.66s]  except we're gonna create a file
[2260.66s -> 2263.98s]  using another file descriptor, using open,
[2263.98s -> 2268.98s]  and using write only, o create, and o excl.
[2269.18s -> 2272.02s]  We'll see another one in a couple slides as well.
[2272.02s -> 2273.82s]  But this says, create the file
[2273.82s -> 2276.56s]  if it doesn't exist already, right?
[2276.56s -> 2278.50s]  Otherwise produce an error.
[2278.50s -> 2281.14s]  And then attempt to do the following permissions,
[2281.14s -> 2282.46s]  and that may or may not work
[2282.46s -> 2284.82s]  with those exact permissions based on the Umask.
[2284.86s -> 2287.18s]  Again, not super important, okay?
[2287.18s -> 2288.24s]  And then what do we do?
[2288.24s -> 2289.78s]  We set up a little buffer,
[2289.78s -> 2291.98s]  and this buffer can be any length we want.
[2291.98s -> 2294.06s]  We just happen to make it 1024
[2294.06s -> 2295.54s]  because we wanna save memory, let's say,
[2295.54s -> 2297.14s]  but you could make it bigger if you wanted to.
[2297.14s -> 2298.78s]  And then we have a while loop,
[2298.78s -> 2300.86s]  and there were some questions about the while loop here.
[2300.86s -> 2304.86s]  This is to read 1024 bytes from the file,
[2304.86s -> 2307.14s]  one after another after another,
[2307.14s -> 2308.54s]  one kilobyte, then another kilobyte,
[2308.54s -> 2309.90s]  then another kilobyte,
[2309.90s -> 2312.64s]  and each time take that kilobyte
[2312.64s -> 2314.30s]  and put it into the output file.
[2314.74s -> 2316.66s]  And that's what the first while loop is doing, okay?
[2316.66s -> 2317.50s]  How does it work?
[2317.50s -> 2319.26s]  Well, it reads data.
[2319.26s -> 2323.68s]  It reads from the input file into the buffer
[2323.68s -> 2326.38s]  and the size of, in this case, 1024.
[2326.38s -> 2328.86s]  You do not need to worry about the fact that there's,
[2328.86s -> 2331.98s]  oh, there might be a null character at the end.
[2331.98s -> 2333.98s]  These are not strings necessarily.
[2333.98s -> 2334.92s]  They're just data.
[2334.92s -> 2339.54s]  So you can read all 1024 bytes worth, okay?
[2339.54s -> 2342.26s]  If you end up getting zero bytes back,
[2342.26s -> 2343.96s]  it means there were no more bytes to read,
[2344.48s -> 2346.48s]  and you can end, okay?
[2346.48s -> 2349.48s]  If you get any number of bytes other than zero,
[2349.48s -> 2351.32s]  well, they came out of the file,
[2351.32s -> 2353.32s]  and you then need to write them to the other file.
[2353.32s -> 2354.16s]  How do you do that?
[2354.16s -> 2355.80s]  Well, you start out and you say,
[2355.80s -> 2358.48s]  okay, I've got the number of bytes written, which is zero.
[2358.48s -> 2359.64s]  I haven't written any yet.
[2359.64s -> 2362.20s]  And then I'm gonna do another while loop,
[2362.20s -> 2365.88s]  which is going to attempt to write all of those bytes.
[2365.88s -> 2367.26s]  That's right here.
[2367.26s -> 2369.00s]  It's going to be right here.
[2369.00s -> 2371.40s]  It's going to try to write all of those bytes
[2371.40s -> 2373.60s]  into the file at once, okay?
[2374.12s -> 2375.72s]  It's going to do it into the output file.
[2375.72s -> 2380.26s]  It's going to index so many bytes into the buffer,
[2380.26s -> 2382.04s]  and the first time through, this is gonna be zero.
[2382.04s -> 2384.88s]  Of course, it's gonna start and try to do all 1024.
[2384.88s -> 2389.48s]  It turns out that write may only write some of those bytes.
[2389.48s -> 2390.32s]  Why?
[2390.32s -> 2391.52s]  Well, that's what the operating system can do.
[2391.52s -> 2394.52s]  The operating system can say, you wanna write 1024?
[2394.52s -> 2396.48s]  I'm gonna only allow you to write eight bytes.
[2396.48s -> 2398.32s]  Sorry, you have to try again later.
[2398.32s -> 2400.02s]  That's what this while loop is all about.
[2400.02s -> 2403.08s]  It's going through until you have successfully
[2403.40s -> 2405.20s]  written all those bytes, okay?
[2405.20s -> 2409.68s]  It's probably not going to fail for 1024 on a local file,
[2409.68s -> 2411.68s]  but if you try to do a million bytes at once,
[2411.68s -> 2413.52s]  it might say, oh, you can have half a million,
[2413.52s -> 2416.08s]  and then next time you have to do another half a million.
[2416.08s -> 2416.92s]  Okay?
[2416.92s -> 2417.74s]  All right.
[2419.00s -> 2421.88s]  And by the way, the read command, as I mentioned yesterday,
[2421.88s -> 2424.68s]  does block until those bytes are read,
[2424.68s -> 2427.12s]  or at least some of those bytes are read.
[2427.12s -> 2428.60s]  If there's any bytes to be read,
[2428.60s -> 2431.32s]  it will wait until some are available.
[2431.32s -> 2433.84s]  What questions do you have on this program so far?
[2435.20s -> 2436.04s]  Anything?
[2438.54s -> 2440.12s]  Nope, okay.
[2440.12s -> 2444.36s]  So, the interesting part about that
[2444.36s -> 2448.36s]  is that this is direct and low level.
[2448.36s -> 2450.28s]  Okay, when I say low level,
[2450.28s -> 2452.00s]  all the other things that you might have used
[2452.00s -> 2455.62s]  to read and write to files uses read and write
[2455.62s -> 2457.36s]  under the hood to do that.
[2457.36s -> 2461.02s]  Okay, so if you're using file pointers,
[2461.66s -> 2464.86s]  which you might use in C or IO streams in C++,
[2464.86s -> 2469.62s]  they are themselves using read and write to do the work.
[2469.62s -> 2471.30s]  Okay, they have some other nice benefits to them.
[2471.30s -> 2472.30s]  They can buffer connections.
[2472.30s -> 2475.70s]  You can go backwards and forwards using a file star
[2475.70s -> 2476.94s]  or an IO stream.
[2476.94s -> 2478.34s]  You can rewind, et cetera.
[2478.34s -> 2479.66s]  You can't do that with read and write.
[2479.66s -> 2483.38s]  You have to manually figure out the details of that
[2483.38s -> 2484.72s]  in a library function.
[2484.72s -> 2486.66s]  So, read and write are going to be fast,
[2486.66s -> 2490.02s]  but they're really not that developed, right?
[2490.02s -> 2492.74s]  You have to go through that while loop to write out.
[2492.74s -> 2495.46s]  Otherwise, you may miss writing some other bytes.
[2495.46s -> 2499.74s]  Okay, those are the big things about read and write.
[2499.74s -> 2501.06s]  Okay, what are their questions?
[2501.06s -> 2501.88s]  Anything?
[2503.62s -> 2506.82s]  All right, so let's move on
[2506.82s -> 2509.58s]  to another program called T.
[2509.58s -> 2514.58s]  Okay, now T is a program that you have built into Linux.
[2515.66s -> 2519.14s]  Okay, and T works like this.
[2519.14s -> 2522.02s]  Okay, T does the following.
[2522.02s -> 2526.38s]  It says, okay, take input from the command line
[2526.38s -> 2528.30s]  or piped in through another file
[2528.30s -> 2531.54s]  and then print it out to the output
[2531.54s -> 2535.82s]  and print it into any one of a number of files.
[2535.82s -> 2539.30s]  Okay, so for instance, I can say cat,
[2539.30s -> 2543.32s]  let's say t.c, which is a file I have,
[2543.32s -> 2546.34s]  cat t.c, no, I don't have t.c, hang on.
[2546.38s -> 2549.50s]  Maybe not, maybe if I went to the right file.
[2549.50s -> 2552.18s]  Let's see, lecture and then file system, there we go.
[2552.18s -> 2555.78s]  If I type cat t.c, it will print it out to the screen.
[2555.78s -> 2560.78s]  If I type cat t.c and then pipe it into the T program,
[2562.54s -> 2565.86s]  okay, what it will do is it will then say,
[2565.86s -> 2567.42s]  okay, fine, I'm gonna print it out to the screen
[2567.42s -> 2572.42s]  and I'm gonna copy it into t2.c and t3.c and t4.c
[2574.10s -> 2575.54s]  and whatever, and it will do that.
[2575.58s -> 2578.38s]  So it should print out to the screen, which it did,
[2578.38s -> 2583.38s]  and then if we look at t2.c, it's also there.
[2584.58s -> 2587.46s]  And it's the same thing for t3.c and t4.c.
[2587.46s -> 2589.58s]  Okay, do you get the idea of what t is doing?
[2589.58s -> 2590.70s]  Yeah.
[2590.70s -> 2591.98s]  Is it creating those new?
[2591.98s -> 2593.02s]  It's creating those.
[2593.02s -> 2594.30s]  If they already exist.
[2594.30s -> 2596.06s]  If they already exist, let's try.
[2596.06s -> 2599.58s]  Let's see if we, let's type a file called,
[2600.78s -> 2605.04s]  I don't know, d.txt and abcd,
[2605.56s -> 2607.36s]  and let's try the exact same thing,
[2607.36s -> 2611.72s]  except now we're gonna cat d, d.txt into this,
[2611.72s -> 2616.72s]  dot txt into t2, t3, and t4, t2.c, yup, it overwrites it.
[2620.02s -> 2621.12s]  Yeah, so it doesn't care.
[2621.12s -> 2623.00s]  In that case, it overwrites it.
[2623.00s -> 2624.88s]  Okay, so do you get what's going on here?
[2624.88s -> 2627.28s]  Take a file that, or standard input and do that.
[2627.28s -> 2630.38s]  By the way, standard input is normally you typing.
[2630.38s -> 2632.42s]  That's what standard input does.
[2632.42s -> 2634.34s]  If we did the same thing and I said,
[2634.50s -> 2637.62s]  instead of cat d.txt, I just said,
[2637.62s -> 2640.46s]  okay, t, t2, t3, t4, right?
[2640.46s -> 2644.90s]  And then I start typing, this is some text, right?
[2644.90s -> 2645.98s]  Well, it doubles it.
[2645.98s -> 2648.62s]  What it did, it took that, this is some text,
[2648.62s -> 2649.78s]  and it printed it out to the screen,
[2649.78s -> 2651.58s]  and it threw them into the files,
[2651.58s -> 2654.78s]  and then this is some more text.
[2654.78s -> 2656.10s]  It does the same thing,
[2656.10s -> 2660.38s]  until I type control d, which says end of file.
[2660.38s -> 2661.98s]  That's, by the way, what that means in there.
[2662.02s -> 2665.58s]  And then if we look at t2.c now,
[2665.58s -> 2667.90s]  it's this is some text, this is some other text.
[2667.90s -> 2670.02s]  Okay, so standard input is you typing,
[2670.02s -> 2673.98s]  or getting information from the output of another file.
[2673.98s -> 2676.06s]  That's what the little pipe symbol does.
[2676.06s -> 2678.18s]  Okay, you will be very familiar with that pipe symbol
[2678.18s -> 2680.62s]  by the end of this class, I guarantee it.
[2680.62s -> 2685.38s]  Okay, all right, let's look at t.c.
[2685.38s -> 2689.86s]  Let's actually look at how we might do this, okay?
[2690.86s -> 2693.06s]  Well, what do we have to do?
[2693.06s -> 2695.14s]  We said, take standard input,
[2695.14s -> 2697.10s]  we have to figure out how to do that.
[2697.10s -> 2698.70s]  We're going to print the standard input
[2698.70s -> 2700.98s]  to standard output, we have to figure out how to do that.
[2700.98s -> 2703.54s]  And then we have to open up as many files
[2703.54s -> 2706.54s]  as we type on the command line,
[2706.54s -> 2708.74s]  and then open them up and print the data
[2708.74s -> 2710.22s]  to those as well.
[2710.22s -> 2712.00s]  We might want a helper function for this,
[2712.00s -> 2713.46s]  just because it seems like there's gonna be
[2713.46s -> 2716.34s]  a lot of things going on here, okay?
[2716.34s -> 2719.06s]  But let's actually start this off and say, okay, fine.
[2719.10s -> 2721.78s]  Int file descriptors.
[2721.78s -> 2723.88s]  If we have a command line,
[2723.88s -> 2727.74s]  you remember that the command line is argv and argc.
[2727.74s -> 2729.66s]  Argc says how many different things
[2729.66s -> 2731.50s]  you've typed on the command line.
[2731.50s -> 2733.74s]  The first one is the program name,
[2733.74s -> 2735.30s]  and the rest are the things you typed
[2735.30s -> 2737.42s]  after the program name, okay?
[2737.42s -> 2742.38s]  We need to create argc number of files.
[2742.38s -> 2743.20s]  Why?
[2743.20s -> 2747.50s]  If I type, if I type, let's see, let's do this.
[2747.50s -> 2752.50s]  If I type t abc.txt def.txt, right?
[2754.80s -> 2756.96s]  We've got a file that's going to the output.
[2756.96s -> 2758.80s]  We've got a file for abc.txt,
[2758.80s -> 2761.54s]  and we've got a file for def.txt.
[2761.54s -> 2763.46s]  Three things on the command line means argc
[2763.46s -> 2764.38s]  is gonna be three.
[2764.38s -> 2766.78s]  That's how many file descriptors we need,
[2766.78s -> 2768.82s]  as it turns out, okay?
[2768.82s -> 2770.20s]  So let's go back up here and do that.
[2770.20s -> 2772.44s]  So we do that, okay?
[2772.44s -> 2776.26s]  Well, then we need to actually
[2778.30s -> 2781.60s]  create those files, except for standard in, right?
[2781.60s -> 2785.78s]  Or rather, standard out in this case, okay?
[2785.78s -> 2787.82s]  Because standard out is going to be created
[2787.82s -> 2788.86s]  for you already.
[2788.86s -> 2790.18s]  Turns out it already exists.
[2790.18s -> 2792.02s]  Here's how that works, okay?
[2792.02s -> 2797.02s]  Fds0 in this case equals stdout, standard out file.
[2798.86s -> 2800.14s]  That's what it's called.
[2800.14s -> 2803.06s]  Standard out and standard in already exist.
[2803.06s -> 2804.82s]  There are two, there's another one too.
[2805.38s -> 2809.62s]  Well, there's standard in .t file.
[2809.62s -> 2813.38s]  There's also standard error .file,
[2813.38s -> 2815.92s]  or standard error underscore file.
[2815.92s -> 2817.96s]  That's because sometimes you want your program
[2817.96s -> 2820.04s]  to print regular output and also output
[2820.04s -> 2823.46s]  that's an error or debugging or whatever,
[2823.46s -> 2824.30s]  just the way it goes.
[2824.30s -> 2825.74s]  There's three different types of files
[2825.74s -> 2829.14s]  that are created for you as we go, okay?
[2829.14s -> 2831.22s]  So that's how that one works, all right?
[2831.22s -> 2834.22s]  And then we have to open all those other files.
[2834.26s -> 2835.58s]  So let's do it this way.
[2835.58s -> 2839.74s]  Size t, i equals one, we've already created fds0.
[2839.74s -> 2844.74s]  i equals one, i is less than argc, i plus plus, okay?
[2845.38s -> 2847.38s]  And what we're gonna do here
[2847.38s -> 2852.38s]  is we are going to say fds i equals open argv of i,
[2856.58s -> 2858.26s]  and then now we're going to do the,
[2858.26s -> 2859.90s]  okay, we're gonna write output to these,
[2859.90s -> 2862.94s]  so write only, okay?
[2862.94s -> 2866.46s]  And we're gonna bitwise or that with o create,
[2866.46s -> 2867.50s]  because we're creating the file.
[2867.50s -> 2869.02s]  And then there's one other that we haven't seen yet
[2869.02s -> 2872.50s]  called o trunk, this is the one that says,
[2872.50s -> 2874.38s]  if the file exists, wipe it out
[2874.38s -> 2876.04s]  before you're putting the other stuff into it.
[2876.04s -> 2877.74s]  That's what your question kind of goes to.
[2877.74s -> 2880.88s]  And then we can say, oh, let's try to do 044,
[2880.88s -> 2884.20s]  but we know that may or may not work, okay?
[2884.20s -> 2885.04s]  That's how we're doing that.
[2885.04s -> 2885.96s]  Now we've opened all those files
[2885.96s -> 2888.70s]  we're about to push out to, okay?
[2888.70s -> 2892.82s]  Well, let's read in the data, char buffer,
[2893.66s -> 2895.46s]  we'll make it 2048 this time, why not?
[2895.46s -> 2899.16s]  Okay, while true, this is gonna look very familiar
[2899.16s -> 2900.90s]  to what we did before, okay?
[2900.90s -> 2905.90s]  While true, s size t, remember that's a signed integer,
[2906.48s -> 2910.58s]  number of bytes read equals read,
[2910.58s -> 2913.02s]  we're gonna read from where?
[2913.02s -> 2915.90s]  Standard in file number, that's what we said.
[2915.90s -> 2917.54s]  We said we read from the input file,
[2917.54s -> 2921.34s]  from the typing or data piped in from another file,
[2921.34s -> 2922.74s]  output piped in.
[2923.70s -> 2928.70s]  Size of buffer, okay, so we do that, okay?
[2929.78s -> 2933.20s]  And then if num read equals zero,
[2933.20s -> 2934.48s]  we mean we're done,
[2934.48s -> 2935.54s]  because we don't have anything else to do.
[2935.54s -> 2937.78s]  And this is where we'll use our little helper function
[2937.78s -> 2941.48s]  here to write output to all those different files.
[2941.48s -> 2946.48s]  So let's see, we'll do another size t i equals zero,
[2946.74s -> 2950.22s]  i is less than arg c, i plus,
[2950.22s -> 2951.82s]  plus we need to do all of them.
[2951.82s -> 2953.22s]  We'll do a function called write all,
[2953.22s -> 2954.78s]  which we'll write in a second.
[2954.78s -> 2956.06s]  And then we are going to do,
[2956.06s -> 2961.06s]  we're gonna write it out to a buffer, i in this case,
[2961.14s -> 2963.42s]  and then, or to a file descriptor,
[2963.42s -> 2967.06s]  and then the amount of bytes read, okay?
[2969.50s -> 2971.34s]  And then that will do that,
[2971.34s -> 2973.82s]  sorry for the size of the screen.
[2973.82s -> 2978.66s]  And then we are going to, let's see,
[2978.66s -> 2980.30s]  that's on one line, so that actually will work.
[2980.30s -> 2981.70s]  And then afterwards,
[2981.70s -> 2983.34s]  we're done writing to all those files.
[2983.34s -> 2984.82s]  We have to close them all.
[2984.82s -> 2989.14s]  Well, we better do another size t i equals zero,
[2989.14s -> 2992.78s]  i is less than arg c, i plus, plus, right?
[2992.78s -> 2997.78s]  And in this case, we're going to close fds i.
[2998.50s -> 3000.30s]  You can close the input if you want to.
[3000.30s -> 3002.06s]  If you're done with it in your program, close it.
[3002.06s -> 3003.84s]  It's still opened in all the other programs
[3003.84s -> 3004.68s]  that might be running.
[3004.68s -> 3007.78s]  So it's not like you're ruining anything for anybody, okay?
[3007.78s -> 3009.86s]  And then now we can return zero,
[3010.30s -> 3011.70s]  which I might already have in there, I do.
[3011.70s -> 3012.90s]  Okay, so that's that.
[3012.90s -> 3014.46s]  Let's see if there's any issue there.
[3014.46s -> 3015.66s]  There will probably be, there will be an issue
[3015.66s -> 3018.30s]  because we haven't created the write all function yet,
[3018.30s -> 3021.50s]  but let's see.
[3021.50s -> 3024.18s]  Comparisons do not have their mathematical meaning.
[3024.18s -> 3027.50s]  Oh no, line 21.
[3027.50s -> 3029.42s]  Did you guys notice that?
[3029.42s -> 3031.42s]  21, there we go.
[3031.42s -> 3032.70s]  Oh, thank you.
[3032.70s -> 3035.82s]  Semicolon, there we go.
[3037.42s -> 3038.94s]  Better?
[3038.98s -> 3040.02s]  Try it again.
[3040.02s -> 3041.02s]  Oh no, what have I done?
[3041.02s -> 3041.86s]  There we go.
[3043.70s -> 3045.26s]  All right, there we go.
[3045.26s -> 3046.70s]  Implicit declaration of,
[3046.70s -> 3050.36s]  and standard out underscore file under layered.
[3051.46s -> 3055.38s]  Let's see, standard, oh, file number is what it is.
[3055.38s -> 3056.22s]  Thank you.
[3056.22s -> 3057.42s]  I was getting it wrong.
[3057.42s -> 3062.42s]  It is standard out file, like this.
[3063.98s -> 3065.54s]  File new, like that.
[3065.54s -> 3067.46s]  And the same thing, there we go, I did the same thing.
[3067.50s -> 3069.26s]  Okay, let's try it again.
[3069.26s -> 3071.54s]  Okay, so what we need to do now
[3071.54s -> 3073.74s]  is just quickly write that other function,
[3073.74s -> 3075.24s]  which is just write all,
[3075.24s -> 3077.50s]  which should look very familiar to the copy function.
[3077.50s -> 3081.94s]  Static void write all.
[3081.94s -> 3084.42s]  What does a static function do?
[3084.42s -> 3085.50s]  You better remember.
[3088.46s -> 3090.88s]  Only visible in the current file.
[3090.88s -> 3094.06s]  You should write your local functions as static
[3094.06s -> 3099.02s]  just because it's nice to not pollute the name spaces
[3099.02s -> 3100.50s]  too much if you can help it.
[3100.50s -> 3105.50s]  Okay, we're going to do a buffer and a length.
[3105.70s -> 3108.14s]  Okay, and in this function,
[3108.14s -> 3110.90s]  we are going to do the same exact thing we did before.
[3110.90s -> 3115.90s]  Size T num written equals zero.
[3116.26s -> 3121.26s]  And then while num written is less than the length
[3121.48s -> 3124.82s]  that was passed in, we are going to do what?
[3124.82s -> 3129.06s]  We're going to do num written plus equals write.
[3129.06s -> 3131.30s]  We're writing the output to each of those files.
[3131.30s -> 3133.26s]  Okay, to the file descriptor we passed in,
[3133.26s -> 3137.58s]  the buffer plus the number of bytes we've already written
[3137.58s -> 3142.58s]  and the length minus number of written bytes.
[3142.94s -> 3144.70s]  And that should do it.
[3144.70s -> 3146.38s]  And that's all our function is.
[3146.38s -> 3148.10s]  Question, yeah.
[3148.58s -> 3151.24s]  What do you, why do you do that?
[3154.02s -> 3155.02s]  Here?
[3155.02s -> 3156.46s]  Yeah, so what does that mean?
[3156.46s -> 3158.02s]  Remember what the T command is doing.
[3158.02s -> 3161.50s]  It's reading from you typing, which is standard input.
[3161.50s -> 3164.30s]  So in this case, we have to open that file for,
[3164.30s -> 3166.18s]  we have to open it to be able to read to,
[3166.18s -> 3167.42s]  or sorry, we have to not open it.
[3167.42s -> 3169.90s]  We have to set it because it's already open for you.
[3169.90s -> 3171.66s]  So we need that file descriptor.
[3171.66s -> 3173.58s]  That's how we do it.
[3173.58s -> 3174.42s]  Good question.
[3175.54s -> 3177.04s]  Other questions on this before I try it?
[3177.04s -> 3177.88s]  Yeah, Chase.
[3177.88s -> 3182.88s]  Is there a set order that you have to put the commands in?
[3183.28s -> 3185.52s]  Could you put o create in the frame?
[3185.52s -> 3188.04s]  Nope, it's an or, so you can do it in any order.
[3188.04s -> 3189.36s]  Totally associated like that.
[3189.36s -> 3190.84s]  Good question.
[3190.84s -> 3191.68s]  Anybody else?
[3192.72s -> 3194.36s]  All right, let's try it.
[3194.36s -> 3198.80s]  Make, oh it's a different file.
[3198.80s -> 3203.68s]  Okay, so T, if I do dot slash T,
[3203.68s -> 3208.52s]  and then I say, f file one dot txt, file two dot txt,
[3208.52s -> 3212.40s]  right, and I start typing, this is me typing,
[3212.40s -> 3215.48s]  more typing, right, and then control D,
[3215.48s -> 3217.94s]  I should be able to look in f one dot txt
[3217.94s -> 3219.64s]  and see that that's where it was.
[3220.64s -> 3221.48s]  Okay.
[3223.08s -> 3227.52s]  So, what questions do you have about that?
[3227.52s -> 3231.64s]  We've now learned about standard file in,
[3231.72s -> 3234.68s]  standard in file number, and standard out file number,
[3234.68s -> 3235.76s]  input and output, there's also
[3235.76s -> 3238.48s]  standard error file number, okay.
[3238.48s -> 3240.32s]  In our little program here,
[3240.32s -> 3242.48s]  we're assuming everything succeeded,
[3242.48s -> 3244.64s]  but the actual code, which you can go look at online,
[3244.64s -> 3246.16s]  has more error checking.
[3246.16s -> 3247.80s]  You should probably do more error checking.
[3247.80s -> 3249.98s]  For our class, we're not quite as worried
[3249.98s -> 3252.68s]  about most error checking, but you'll see
[3252.68s -> 3255.32s]  in various assignments when it's important.
[3255.32s -> 3256.48s]  Okay.
[3256.48s -> 3258.48s]  Other questions on that?
[3258.48s -> 3261.04s]  All right, that is T.
[3262.48s -> 3263.52s]  Okay.
[3263.52s -> 3266.40s]  So, we're gonna continue to dig a little deeper
[3266.40s -> 3269.94s]  into file system sorts of things, okay.
[3269.94s -> 3274.16s]  There are two functions, stat and lstat,
[3274.16s -> 3276.90s]  which are system calls, and again,
[3276.90s -> 3281.28s]  a system call is a function that the kernel runs, okay,
[3281.28s -> 3283.08s]  your code calls it and then the kernel
[3283.08s -> 3285.32s]  takes over and runs it, okay,
[3285.32s -> 3289.78s]  and they populate this other thing called a struct stat,
[3289.78s -> 3291.70s]  unfortunately it's overloaded, okay,
[3291.70s -> 3296.12s]  struct stat is populated, the struct stat you pass in
[3296.12s -> 3299.22s]  is populated by the stat function, okay,
[3299.22s -> 3302.02s]  and stat and lstat are exactly the same,
[3302.02s -> 3304.66s]  except that if there is a link,
[3304.66s -> 3306.74s]  and we'll talk about links a little bit later,
[3306.74s -> 3309.78s]  stat returns the functions about the links itself,
[3309.78s -> 3311.82s]  lstat says, oh, I'm gonna go
[3311.82s -> 3313.98s]  check the details of that link.
[3313.98s -> 3315.98s]  What a link is, is think of an alias.
[3315.98s -> 3319.06s]  It's basically a name that points to some other file.
[3319.90s -> 3323.54s]  Okay, so we'll get to that in the next day or so, okay,
[3323.54s -> 3324.90s]  and you can definitely look these things up.
[3324.90s -> 3327.38s]  By the way, you should get very used to
[3327.38s -> 3330.74s]  typing things like man to stat and so forth,
[3330.74s -> 3333.66s]  to being the part of the manual that you need.
[3333.66s -> 3336.70s]  If you just type man stat, watch what happens.
[3336.70s -> 3340.18s]  I think it's a different, it's the built-in command
[3340.18s -> 3342.22s]  from Unix that gets run, or that you see,
[3342.22s -> 3345.02s]  instead of the library function, okay,
[3345.02s -> 3346.44s]  but you've got all the details here
[3346.44s -> 3349.46s]  for the library, for the function, okay,
[3350.06s -> 3355.06s]  and what they do, okay, is they populate this struct stat,
[3355.94s -> 3358.68s]  and this struct stat has some information in it
[3358.68s -> 3360.50s]  that might be useful to you.
[3360.50s -> 3364.26s]  Okay, we eventually will use the inumber, okay,
[3364.26s -> 3366.80s]  or the inode number, and then,
[3366.80s -> 3369.86s]  but the one we care about is this mode, okay,
[3369.86s -> 3374.26s]  and the mode is a bunch of different bits in one variable
[3374.26s -> 3378.06s]  that allows you to find out information about the file.
[3378.10s -> 3379.94s]  Okay, so you can extract information about the file.
[3379.94s -> 3381.02s]  Is it a directory?
[3381.02s -> 3384.62s]  Is it, I think, I don't know if that tells how big it is.
[3384.62s -> 3385.66s]  I don't think that tells how big it is,
[3385.66s -> 3390.26s]  but it says various information about a particular file.
[3390.26s -> 3395.26s]  Okay, and we want to actually do a little bit of coding
[3395.60s -> 3399.04s]  to show you what this is doing, okay?
[3399.04s -> 3401.42s]  So there's a function called find.
[3401.42s -> 3402.66s]  I used Unix for years and years
[3402.66s -> 3403.48s]  and didn't know about this,
[3403.48s -> 3404.98s]  and once I found out there was a function called find,
[3404.98s -> 3406.44s]  I went, oh boy, there's the,
[3406.48s -> 3408.20s]  I've been using it every day, and I have.
[3408.20s -> 3410.00s]  I use find every single day.
[3410.00s -> 3413.16s]  What find does is it allows you to search through
[3413.16s -> 3415.76s]  a set of directories recursively
[3415.76s -> 3419.00s]  and find a particular file or a pattern for a file.
[3419.00s -> 3420.56s]  So let's see, we happen to,
[3420.56s -> 3423.40s]  I know there's search dot whatever in here,
[3423.40s -> 3426.36s]  so if I go back up to, let's do this,
[3426.36s -> 3429.84s]  find live lecture,
[3429.84s -> 3434.84s]  and then search dot star, I'll put that in parentheses,
[3435.60s -> 3439.96s]  okay, then what it does is it goes and says anything
[3439.96s -> 3442.40s]  that actually, it sort of shows you,
[3442.40s -> 3444.12s]  well, actually in this case it didn't,
[3444.12s -> 3444.96s]  hang on, let me just do this.
[3444.96s -> 3446.96s]  I'll just say search like that,
[3446.96s -> 3450.52s]  and it will tell you where the various things
[3450.52s -> 3453.44s]  are found for that, okay?
[3453.44s -> 3454.60s]  Let's see.
[3454.60s -> 3456.36s]  Oh, you know what, find is a little different.
[3456.36s -> 3458.08s]  It means a thing called a dot name.
[3458.08s -> 3459.12s]  That's what it's looking for.
[3459.12s -> 3460.30s]  Okay, so there we go.
[3460.30s -> 3462.48s]  There's where search itself is.
[3462.48s -> 3466.40s]  If I wanted to find matching all the different ones,
[3466.40s -> 3468.04s]  I would type search star,
[3468.04s -> 3469.32s]  and it would give me all the different things
[3469.32s -> 3472.08s]  that had star or search in them,
[3472.08s -> 3473.60s]  which are all those files.
[3473.60s -> 3474.64s]  Okay, so it allows you to search
[3474.64s -> 3476.96s]  through various directories to find files
[3476.96s -> 3480.04s]  based on a file name or partial matches, okay?
[3480.04s -> 3481.32s]  So what we're gonna do is we're gonna write
[3481.32s -> 3484.88s]  a relatively simple program to actually do this,
[3484.88s -> 3488.64s]  and to do some searching to do exactly that.
[3488.64s -> 3493.16s]  If you do find, slash user, slash include,
[3493.16s -> 3496.92s]  and then look for stdio.h,
[3496.92s -> 3499.86s]  find slash user, slash include,
[3502.20s -> 3504.98s]  stdio, let's see, you gotta do the dash name,
[3504.98s -> 3509.98s]  stdio.h, and then print as it turns out.
[3510.00s -> 3510.82s]  There we go.
[3510.82s -> 3513.00s]  We'll list all the ones that are called stdio.h,
[3513.00s -> 3514.60s]  and there's a whole bunch of them as it turns out.
[3514.60s -> 3517.80s]  And our search function should do the exact same thing.
[3517.80s -> 3518.64s]  Okay?
[3519.92s -> 3522.40s]  We need to be able to read a file in,
[3522.40s -> 3523.56s]  see if it's a directory.
[3523.56s -> 3527.24s]  If it's a directory, traverse into that directory,
[3527.24s -> 3528.92s]  and then continue reading.
[3528.92s -> 3530.64s]  This should look fairly familiar
[3530.64s -> 3534.24s]  from some CS107 things that you did, okay?
[3534.24s -> 3538.92s]  But let's actually go and write the actual command.
[3541.56s -> 3543.60s]  Search.c.
[3543.60s -> 3545.48s]  Okay, I've got all the header stuff in there.
[3545.48s -> 3546.32s]  What are we gonna do?
[3546.36s -> 3548.06s]  We're going to first do the main function,
[3548.06s -> 3550.76s]  and then we're gonna write this list matches function,
[3551.88s -> 3556.88s]  which is going to be a little bit more involved.
[3558.28s -> 3563.28s]  But for right now, let's actually do the search function.
[3564.36s -> 3567.04s]  In fact, yeah, well, we'll do some of it.
[3567.04s -> 3568.76s]  In fact, I'll just show it to you right now,
[3568.76s -> 3569.88s]  and then we can go and run it,
[3569.88s -> 3573.50s]  the actual version in a little bit, okay?
[3573.50s -> 3575.28s]  The main function,
[3575.28s -> 3576.52s]  consider me typing it all out right now.
[3576.52s -> 3580.08s]  The main function looks like this, okay?
[3580.08s -> 3585.08s]  It basically uses the LSTAT system call
[3587.42s -> 3589.84s]  to get information about whether or not
[3589.84s -> 3591.28s]  a file is a directory.
[3591.28s -> 3592.28s]  And how do you do that?
[3592.28s -> 3597.04s]  Well, you say LSTAT and then some name, right?
[3597.04s -> 3599.50s]  And you populate a struct stat,
[3599.50s -> 3601.12s]  it populates a struct stat with that.
[3601.12s -> 3606.12s]  And then you check and see if it is a directory
[3606.36s -> 3610.12s]  by using this macro, sisdir,
[3610.12s -> 3614.08s]  and then you pass in the mode that you get back,
[3614.08s -> 3616.08s]  all there is to it, okay?
[3616.08s -> 3619.84s]  And then you need to actually go ahead
[3619.84s -> 3624.84s]  and check the length of the directory name itself, okay?
[3625.68s -> 3629.96s]  And then you have a pattern that we're gonna type in
[3629.96s -> 3631.84s]  that you actually are gonna pass in
[3631.84s -> 3633.88s]  to the list matches function
[3633.88s -> 3638.40s]  by basically copying the path
[3638.40s -> 3640.68s]  plus the filing, plus the next, plus the next,
[3640.68s -> 3642.22s]  plus the next, okay?
[3642.22s -> 3643.66s]  And that's how it's gonna work
[3643.66s -> 3646.72s]  using the list matches program,
[3646.72s -> 3650.24s]  or list matches function that we're going to write, okay?
[3650.24s -> 3651.08s]  So that's basically what it is.
[3651.08s -> 3652.58s]  You're gonna type in the search
[3652.58s -> 3654.16s]  and then the name of the directory
[3654.16s -> 3655.56s]  you're starting to search at
[3655.56s -> 3660.56s]  and then the pattern that you're trying to search for
[3661.24s -> 3665.76s]  and the list matches will do all that, okay?
[3665.76s -> 3667.26s]  All right, so how's that gonna work?
[3667.26s -> 3672.26s]  Well, as I said, we need Lstat to do this, okay?
[3673.28s -> 3675.04s]  The sisdir is a macro.
[3675.04s -> 3677.04s]  A macro is kind of like a function
[3677.04s -> 3679.24s]  except it gets replaced in the code immediately.
[3679.24s -> 3680.68s]  It doesn't actually call a function.
[3680.68s -> 3682.88s]  It's like inlines a bunch of code.
[3682.88s -> 3684.48s]  It's basically just trying to check some bits
[3684.48s -> 3685.96s]  and if one of those bits is set,
[3685.96s -> 3689.46s]  means it's a directory for this case, okay?
[3689.46s -> 3690.88s]  There's also isreg,
[3690.88s -> 3693.28s]  which is whether or not it's a regular file.
[3693.28s -> 3695.40s]  Islink is whether it's a link to a file.
[3695.40s -> 3697.84s]  That's the alias I mentioned before.
[3697.84s -> 3699.48s]  And most of this is actually gonna happen
[3699.48s -> 3701.52s]  in the list matches function,
[3701.52s -> 3704.76s]  which I'm gonna show you in a second, okay?
[3704.76s -> 3709.76s]  You need to utilize opendir to open a directory
[3709.92s -> 3714.00s]  and you need to utilize dirint, which is,
[3714.64s -> 3717.72s]  you struct dirint and the readdir function,
[3717.72s -> 3719.08s]  which you should have done in 107.
[3719.08s -> 3720.30s]  If you forget that one, well,
[3720.30s -> 3721.48s]  you can go look up how to do it.
[3721.48s -> 3724.44s]  But it basically does the traversing
[3724.44s -> 3725.72s]  of this directory for you.
[3725.72s -> 3726.80s]  It's kind of nice to do that.
[3726.80s -> 3730.04s]  And then you need to know how to close a directory as well.
[3730.04s -> 3730.88s]  Okay?
[3730.88s -> 3734.08s]  All right, so here's the actual implementation
[3734.08s -> 3737.40s]  of the list matches function, okay?
[3737.40s -> 3739.04s]  The list matches function does what?
[3739.04s -> 3741.32s]  It opens the directory up, okay?
[3741.32s -> 3745.00s]  And if the directory, if the path is null,
[3745.00s -> 3747.44s]  meaning if there is nothing there,
[3747.44s -> 3748.80s]  then it just returns, okay?
[3748.80s -> 3750.32s]  Otherwise, it takes the path,
[3750.32s -> 3754.80s]  it copies the actual path onto the,
[3754.80s -> 3759.48s]  or the, it copies a slash onto the path
[3759.48s -> 3762.40s]  and then starts going through all the different directories
[3762.40s -> 3765.68s]  or all the different entries and checking each one
[3765.68s -> 3768.92s]  to see if it matches what we're trying to match.
[3768.92s -> 3769.76s]  Okay?
[3769.80s -> 3772.16s]  I'm gonna have to do this for my pen down here.
[3772.16s -> 3775.72s]  So we are going to read in the directory
[3775.72s -> 3779.48s]  for in this while loop of going through the directory, okay?
[3779.48s -> 3781.68s]  Again, if it's null, we're going to stop
[3781.68s -> 3783.60s]  because we've gone to, you know, we've gone to the end.
[3783.60s -> 3784.44s]  That's how this works.
[3784.44s -> 3786.88s]  It goes until it gives you back a null, okay?
[3786.88s -> 3791.88s]  And then we're going to compare this to dot and dot dot.
[3792.40s -> 3795.62s]  Dot and dot dot are the two files that are mean what?
[3795.62s -> 3798.24s]  What did we say dot and dot dot were?
[3798.24s -> 3800.08s]  Same directory as dot,
[3800.08s -> 3802.80s]  and then previous directory as dot dot.
[3802.80s -> 3804.68s]  So what it's gonna do is it's gonna ignore those.
[3804.68s -> 3806.12s]  It's gonna skip them because why,
[3806.12s -> 3807.68s]  because then it would end up in some loop
[3807.68s -> 3810.52s]  that you don't wanna go down necessarily, okay?
[3810.52s -> 3814.36s]  And then if you happen to have a path which is too long,
[3814.36s -> 3816.60s]  we only allow a certain path with, that's fine.
[3816.60s -> 3817.76s]  Then it just kind of says, I'm done.
[3817.76s -> 3819.52s]  I'm not gonna go any farther than that.
[3819.52s -> 3820.60s]  Too bad for you.
[3820.60s -> 3822.68s]  And then it copies the actual name
[3822.68s -> 3825.80s]  onto the end of the path after that slash.
[3825.80s -> 3830.20s]  And then it does the LSTAT command again,
[3830.20s -> 3831.84s]  checks if it's a regular file.
[3831.84s -> 3833.56s]  If it's a regular file,
[3833.56s -> 3837.10s]  it does a string comparison on that file.
[3837.10s -> 3839.38s]  And then if it comes out with zero,
[3839.38s -> 3840.54s]  meaning they're the same,
[3840.54s -> 3842.60s]  then it will actually print out the path.
[3842.60s -> 3845.16s]  And that's how it actually finds it, okay?
[3845.16s -> 3847.40s]  If it's a directory, what does it have to do?
[3847.40s -> 3850.60s]  It has to recursively call list matches
[3850.60s -> 3852.84s]  because then it needs to traverse through the list.
[3852.84s -> 3854.74s]  So it's a recursive program,
[3854.74s -> 3857.34s]  but really it's not that,
[3857.34s -> 3860.84s]  it's just looking through a set of directories to do that.
[3863.26s -> 3864.10s]  Question.
[3864.10s -> 3865.48s]  What is a regular file?
[3865.48s -> 3867.50s]  Yeah, a regular file is not a link.
[3867.50s -> 3870.06s]  It's basically a file that has data inside it.
[3870.06s -> 3872.46s]  A link is a file that refers to another file.
[3872.46s -> 3875.54s]  So the data inside of it refers to the other file
[3875.54s -> 3878.90s]  and the operating system needs to know
[3878.90s -> 3881.18s]  whether or not it's an alias or a link
[3881.18s -> 3884.54s]  or a regular file so that it can travel down those or not.
[3885.22s -> 3887.42s]  What other questions do you have on this one,
[3887.42s -> 3888.34s]  on this program?
[3889.94s -> 3890.78s]  Yeah?
[3890.78s -> 3895.54s]  Why do we use the else that instead of just the...
[3895.54s -> 3897.42s]  Yeah, what did we say the difference was?
[3897.42s -> 3898.66s]  It was just a matter of length.
[3898.66s -> 3900.66s]  Like, do we expect that link?
[3900.66s -> 3902.02s]  You might have links, yeah.
[3902.02s -> 3902.86s]  You can certainly have links.
[3902.86s -> 3905.48s]  In fact, your assignment has links in it.
[3905.48s -> 3908.30s]  Let me show you a link in your assignment.
[3908.30s -> 3912.38s]  If you go to, let's see.
[3912.38s -> 3916.78s]  Whoops, let's go to assignment, assignment one.
[3918.02s -> 3922.06s]  Let's see, I think, starter maybe?
[3922.06s -> 3922.90s]  There we go, okay.
[3922.90s -> 3927.90s]  If we go into here and if you look at dash L, okay?
[3929.46s -> 3931.82s]  Take a look at samples down here.
[3933.94s -> 3935.42s]  What's going on there?
[3935.42s -> 3938.86s]  It says samples has this little weird arrow
[3938.90s -> 3942.30s]  that points to slash AFS slash IRS class CS110
[3942.30s -> 3943.98s]  samples assignment one.
[3944.94s -> 3947.32s]  And by the way, if we go into samples,
[3947.32s -> 3948.16s]  let's take a look.
[3948.16s -> 3951.30s]  Now we're actually in that file.
[3951.30s -> 3953.82s]  If we look at it, we've got an actor data file
[3953.82s -> 3955.48s]  and a movie data file.
[3955.48s -> 3958.02s]  And those two files are ginormous.
[3958.02s -> 3959.86s]  And what it means is if you put a link
[3959.86s -> 3963.54s]  in your assignment file to this regular file,
[3963.54s -> 3965.12s]  none of you are gonna change these files.
[3965.12s -> 3966.86s]  You're not even allowed to, as it turns out.
[3967.30s -> 3969.54s]  You can't change them because it'll read only for you.
[3969.54s -> 3971.28s]  But it means that everybody in the class
[3971.28s -> 3973.58s]  can get access to this one gigantic file
[3973.58s -> 3975.56s]  through a link so that it doesn't have,
[3975.56s -> 3976.76s]  so that you don't have to make copies
[3976.76s -> 3977.90s]  of them for everybody.
[3977.90s -> 3979.30s]  You would quickly run out of space
[3979.30s -> 3981.40s]  if we tried to make 80 gigabyte file
[3981.40s -> 3984.10s]  or 80 megabyte files for everybody or whatever.
[3984.10s -> 3986.38s]  Yeah, 800 megabyte files, whatever.
[3986.38s -> 3987.58s]  Other questions on that?
[3987.58s -> 3988.42s]  Good question.
[3988.42s -> 3989.26s]  Did that answer it?
[3989.26s -> 3990.86s]  Okay, great.
[3990.86s -> 3991.90s]  All right.
[3991.90s -> 3996.22s]  So that's how the stat and Lstat works.
[3996.26s -> 3998.78s]  Again, the reason we did this example
[3998.78s -> 4000.38s]  was to show you that you can use Lstat
[4000.38s -> 4003.26s]  to get whether something's a file or a directory.
[4003.26s -> 4005.64s]  Okay, you can, or stats do that.
[4005.64s -> 4007.34s]  You can also do that with other,
[4008.26s -> 4010.36s]  there's other things that you might care about,
[4010.36s -> 4012.04s]  like for next assignment, you'll care about
[4012.04s -> 4016.50s]  some other pieces of that structure.
[4018.50s -> 4019.32s]  All right.
[4020.88s -> 4025.88s]  We relied on Opender, which basically says,
[4025.88s -> 4026.88s]  oh, it's a directory.
[4026.88s -> 4028.56s]  We had to do an assertion in there that says,
[4028.56s -> 4030.74s]  don't try to open a directory that's a file.
[4030.74s -> 4031.74s]  You have to figure that out.
[4031.74s -> 4034.24s]  Okay, you have to make sure you do that.
[4034.24s -> 4037.40s]  And then you get all of these different
[4037.40s -> 4040.24s]  directory entries by walking through that
[4041.54s -> 4044.04s]  reader call, okay?
[4044.04s -> 4046.76s]  And again, you probably did this in 107.
[4046.76s -> 4048.24s]  You probably did an assignment about that,
[4048.24s -> 4049.12s]  but it's not too bad.
[4049.12s -> 4051.24s]  It's just recall, call that function
[4051.24s -> 4052.08s]  again and again and again,
[4052.08s -> 4053.12s]  and it gives you the next directory,
[4053.16s -> 4056.36s]  the next file, the next token, or the next directory.
[4056.36s -> 4058.92s]  Okay, let's see, what else?
[4058.92s -> 4059.76s]  Here it is.
[4059.76s -> 4060.60s]  Here's your answer to your question.
[4060.60s -> 4061.42s]  We used lstat instead of stat,
[4061.42s -> 4063.16s]  so we know whether it's really a link,
[4063.16s -> 4064.82s]  and we're gonna ignore links in this case.
[4064.82s -> 4066.64s]  You can have links that are recursive,
[4066.64s -> 4069.16s]  like that refer back to something earlier
[4069.16s -> 4071.48s]  in the file system, and so if you did that,
[4071.48s -> 4072.52s]  you might have a problem,
[4072.52s -> 4073.76s]  because you traversed on a link,
[4073.76s -> 4075.28s]  and then it might come back to where you were,
[4075.28s -> 4076.28s]  and then you didn't end up in this
[4076.28s -> 4079.68s]  recursive loop forever, and that would be probably bad.
[4079.92s -> 4083.88s]  Okay, and I went over the other details about all this.
[4083.88s -> 4088.16s]  You should, as always, remember to close your directories.
[4089.24s -> 4092.16s]  Okay, anything else on those?
[4096.88s -> 4099.84s]  All right, there's another function
[4099.84s -> 4102.58s]  that we'll briefly look at called list,
[4102.58s -> 4104.64s]  which is basically ls, right?
[4104.64s -> 4105.96s]  And ls does what?
[4105.96s -> 4108.80s]  ls actually lists all the stuff in your directory.
[4108.84s -> 4109.68s]  Well, guess what?
[4109.68s -> 4111.20s]  It has to do basically the same sort of thing.
[4111.20s -> 4113.92s]  It needs to read through all of the directory entries
[4113.92s -> 4115.94s]  and get the information out about it.
[4115.94s -> 4118.24s]  It needs to get the permissions, by the way.
[4118.24s -> 4120.00s]  It needs to get whether or not it's a directory,
[4120.00s -> 4125.00s]  and it needs to populate these parts of it right here.
[4125.56s -> 4128.44s]  It also needs to tell how big,
[4128.44s -> 4132.36s]  or how many other, what we call hard links,
[4132.36s -> 4133.52s]  refer to a file.
[4133.52s -> 4135.06s]  That's another topic we'll get to,
[4135.06s -> 4136.64s]  I guess on Friday or next week.
[4136.64s -> 4138.40s]  But basically, you can have one file
[4138.94s -> 4141.68s]  which lots of things point to in two different ways,
[4141.68s -> 4143.92s]  and the list will actually tell you
[4143.92s -> 4146.24s]  how many of those exist.
[4146.24s -> 4147.40s]  Okay, it needs to get the name,
[4147.40s -> 4149.84s]  and it needs to get the date it was created,
[4149.84s -> 4151.42s]  and so forth, okay?
[4151.42s -> 4155.48s]  Those details are a little bit like down in the weeds,
[4155.48s -> 4157.52s]  but you can do that, okay?
[4157.52s -> 4160.74s]  If you wanna look at the entire list.c function,
[4160.74s -> 4161.58s]  you can do that.
[4161.58s -> 4164.28s]  On the key one, I will show you right here.
[4165.28s -> 4166.60s]  This is the permissions one.
[4166.60s -> 4170.12s]  How do you get the permissions for a particular file?
[4170.12s -> 4171.38s]  Okay, well, let's see.
[4172.36s -> 4176.46s]  Okay, what we need to do is we need to,
[4177.44s -> 4179.08s]  there's a lot of code in this one, right?
[4179.08s -> 4181.16s]  We basically need to,
[4181.16s -> 4184.62s]  here's the list permissions right down here, okay?
[4184.62s -> 4186.92s]  It needs to find, and there's details about this
[4186.92s -> 4187.80s]  that you don't really need to know,
[4187.80s -> 4192.80s]  but it basically says set all the permissions to dash, okay?
[4193.80s -> 4198.80s]  And then go ahead and look through each directory, right?
[4198.92s -> 4202.10s]  And check the permissions of each directory,
[4202.10s -> 4204.28s]  and if it's a directory, you put D in it,
[4204.28s -> 4209.28s]  and otherwise, you go through all the permissions
[4209.72s -> 4213.20s]  for each one of the various permissions
[4213.20s -> 4214.36s]  that you might have.
[4214.36s -> 4215.90s]  So you have to go through each one of those,
[4215.90s -> 4218.36s]  go look, can the user, can the owner read,
[4218.36s -> 4220.36s]  can the owner write, can the owner execute?
[4220.36s -> 4221.20s]  Set that up.
[4221.20s -> 4222.68s]  Can the other do the same thing?
[4223.44s -> 4225.04s]  And can the group do the same thing, right?
[4225.04s -> 4227.16s]  Details, you have to kind of go through all these details
[4227.16s -> 4229.56s]  when you're writing this low-level code.
[4229.56s -> 4233.32s]  That's kind of the way it goes in this case, okay?
[4233.32s -> 4235.32s]  And let's see, is there anything else important here?
[4235.32s -> 4238.28s]  Here are some flags that you can use
[4238.28s -> 4242.00s]  for all of the different files, right?
[4242.00s -> 4246.28s]  S-I-R, user, that's a macro that basically says
[4246.28s -> 4250.16s]  check and see if the user can write,
[4250.16s -> 4254.20s]  or the user can read, or the user can write.
[4254.20s -> 4255.96s]  Nine different things to check for,
[4255.96s -> 4260.56s]  because there's three for each owner, group, and user.
[4260.56s -> 4263.64s]  Lot to do if you're trying to do all of this one by one.
[4265.64s -> 4267.52s]  It's kind of amazing what LS can do.
[4267.52s -> 4269.26s]  It has to go through all these details
[4269.26s -> 4273.22s]  if you're doing systems type stuff, okay?
[4273.22s -> 4275.92s]  The list permissions function itself
[4275.92s -> 4279.44s]  prints out those permissions, and this is,
[4279.48s -> 4282.48s]  hang on, I think the next, oh, no, that's,
[4282.48s -> 4284.00s]  yeah, here we go.
[4284.00s -> 4285.68s]  Oh, no, that's it, right, that was all of it right there.
[4285.68s -> 4287.56s]  That's the list permissions, and the stuff up here
[4287.56s -> 4291.24s]  is kind of all of the setup for it, okay?
[4291.24s -> 4293.12s]  Anyway, go look at the code for this
[4293.12s -> 4297.80s]  if you wanna see how all these macros and things work.
[4297.80s -> 4299.58s]  We won't necessarily make you code
[4299.58s -> 4301.28s]  all this kind of low-level thing.
[4301.28s -> 4303.24s]  You should just know how these things work
[4303.24s -> 4304.80s]  so that you understand how permissions work
[4304.80s -> 4305.84s]  and that there are macros
[4305.84s -> 4307.86s]  and there is this struct that you have to use
[4307.86s -> 4310.80s]  and so forth, okay?
[4310.80s -> 4313.80s]  All right, what questions do you have at this point
[4313.80s -> 4315.84s]  about any of that that we've covered?
[4317.22s -> 4320.12s]  The assignment is due next Wednesday.
[4321.28s -> 4323.68s]  It is due absolutely on Wednesday.
[4323.68s -> 4325.82s]  There's no late days for this assignment
[4325.82s -> 4327.36s]  just because we want you to get going
[4327.36s -> 4328.56s]  on the next assignment and we wanna grade
[4328.56s -> 4330.66s]  the first assignment as quickly as we can.
[4331.62s -> 4334.12s]  Office hours, I have office hours tomorrow morning,
[4334.16s -> 4336.28s]  10 to 12, I believe.
[4336.28s -> 4338.72s]  Stop by if you want, and then we will get the,
[4338.72s -> 4340.68s]  I will send a message out to the CAs.
[4340.68s -> 4342.60s]  They're gonna start some office hours
[4342.60s -> 4344.80s]  probably tomorrow or Friday.
[4344.80s -> 4346.64s]  They will go through on Saturday,
[4346.64s -> 4349.08s]  or sorry, Friday and Sunday at least,
[4349.08s -> 4351.00s]  and then next week as well.
[4351.00s -> 4352.92s]  All right, I'll stick around for a few more minutes
[4352.92s -> 4354.52s]  and we'll see you on Friday.
[4354.52s -> 4357.20s]  There is class this Friday, no labs, class Friday.
