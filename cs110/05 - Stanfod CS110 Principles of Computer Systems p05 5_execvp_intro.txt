# Detected language: en (p=1.00)

[0.00s -> 7.08s]  Okay welcome back. There are fewer and fewer of you here than before. I kind of
[7.08s -> 10.76s]  figured that might happen over the course of a quarter. Thank you for
[10.76s -> 17.20s]  joining us today. So today we're going to continue with talking about Fork and
[17.20s -> 22.40s]  we're going to talk about this new thing called Exec CVP which is
[22.40s -> 28.84s]  generally why we use Fork as it turns out. And we'll also talk about the
[28.88s -> 35.24s]  assignment that's going out, that just went out today. Speaking of Fork,
[35.24s -> 44.08s]  so I, let's see how can I do this. I took, so I was finishing some things up
[44.08s -> 50.48s]  today and then I took a little break and I went to reddit.com. Our programming
[50.48s -> 54.96s]  because I look at the programming ones right and let's see the first thing
[54.96s -> 59.16s]  that's there is this thing called a Fork in the Road and I went oh cool we're
[59.16s -> 62.56s]  talking about Fork in class today. Let me click on it and see what it says.
[62.56s -> 67.84s]  They must be talking about some cool things on Fork and then let's
[67.84s -> 72.76s]  see is the actual paper here I believe it is there it is. Okay so I
[72.76s -> 77.04s]  go great this thing called Fork in the Road. It says the received wisdom suggests
[77.04s -> 80.64s]  that Unix's unusual combination of Fork and Exec which is what we're going to
[80.64s -> 84.72s]  talk about today for process creation was an inspired design. In this paper
[85.20s -> 88.84s]  we argue with that Fork was a clever hack for machines and programs of the
[88.84s -> 94.72s]  1970s that has long outlived its usefulness and is now a liability. And I
[94.72s -> 99.88s]  went oh no here we go and it talks about and so I read this paper and it
[99.88s -> 104.68s]  talks about how Fork is actually not the best thing in the world to teach
[104.68s -> 107.32s]  like as the first thing which is exactly what we do in this class is
[107.32s -> 110.88s]  teaches versus says as designers and implementers of operating systems we
[110.88s -> 113.96s]  should acknowledge that Forks continued existence as a first class
[114.44s -> 118.56s]  operating system primitive holds back systems research and deprecate it. As
[118.56s -> 122.92s]  educators, that's me, as educators we should teach Fork as a historical
[122.92s -> 126.36s]  artifact and not the first process creation mechanism students encounter.
[126.36s -> 134.84s]  Sorry sorry so by the way this is written by Microsoft who for what it's
[134.84s -> 137.92s]  worth does not produce a Unix operating system they have their own operating
[137.92s -> 143.16s]  system. But it actually has some interesting interesting things to say
[143.36s -> 147.64s]  about Fork and about how there are some things that we will actually talk
[147.64s -> 153.52s]  about where it does produce not the best like answer to kind of your
[153.52s -> 157.96s]  questions. For instance Fork happens to be what we call not thread safe
[157.96s -> 161.48s]  and we will talk about threading a little later in the course and it
[161.48s -> 165.48s]  means that you can't mix and match forks and threads in certain ways
[165.96s -> 170.76s]  and that's kind of not a great thing. So as an educator I'm presenting
[170.76s -> 176.96s]  this to you as a as a historical what did they say a historical artifact.
[176.96s -> 180.48s]  So take that for what it is. You still have to know it for the midterm
[180.48s -> 186.20s]  exam. So and who knows maybe maybe we will retool the way these things
[186.84s -> 191.96s]  go as we as we do that as I do this a few more times in the court.
[191.96s -> 195.00s]  And anyway I thought that was interesting and a little sad that I thought it
[195.00s -> 199.48s]  was going to be this great article. There you go. All right. So the
[199.52s -> 203.52s]  other day in class somebody asked a great question. I forget who it is.
[203.52s -> 206.64s]  I apologize. Someone asked a question because we were putting up all these
[206.64s -> 212.56s]  diagrams about file systems and the question was hey these various
[212.56s -> 217.08s]  process control blocks that the operating system keeps track of that
[217.08s -> 223.48s]  actually have file descriptor pointers basically in them can point to file
[223.48s -> 228.08s]  descriptors in the open file table and there is one open file table
[228.44s -> 234.56s]  and those descriptors in the open file table lists has some
[234.56s -> 238.68s]  information about the various files that are open including the mode
[238.68s -> 242.52s]  whether it's right reader right read only et cetera right only.
[242.52s -> 246.44s]  It also has the cursor position in there. And the question was wait
[246.44s -> 250.12s]  a minute if there's only one copy and two files are allowed to
[250.12s -> 255.04s]  simultaneously read a particular file and be at different places in
[255.08s -> 259.32s]  the file how does that work if there's only one copy in the open
[259.32s -> 261.60s]  file table and I said well it's probably true there's more than
[261.60s -> 266.08s]  one copy and I wasn't sure so I went looked it up. Indeed the
[266.08s -> 271.92s]  open file table every time you call open creates a new entry
[271.92s -> 274.88s]  in the open file table which has a cursor for it. So if two
[274.88s -> 280.40s]  programs call open on a particular file or two processes even call
[280.40s -> 284.64s]  open on a particular file you do get duplicates here. And I said
[284.68s -> 287.24s]  well there's the reason it's only one is because you don't like all
[287.24s -> 292.24s]  these duplicates. The difference is that there are when we do
[292.24s -> 298.40s]  fork for instance we know that you have a you copy all of the
[298.40s -> 302.96s]  memory and therefore they will indeed point to the same place
[302.96s -> 307.00s]  in the open file table. So it is true that processes can point
[307.00s -> 311.28s]  to the same open file table record which will have one
[311.28s -> 315.92s]  cursor where in the file you are. But if two programs open it
[315.92s -> 319.28s]  up you do get duplicates in there. So that's why you get two
[319.28s -> 321.84s]  different cursors. Does that clear things up a little for the
[321.84s -> 324.84s]  people who are curious about that? Not the biggest deal in
[324.84s -> 329.92s]  the world but that's how this ends up working. And I
[329.92s -> 333.12s]  thought I'd at least give you the information I looked up
[333.12s -> 338.88s]  on that. Okay so hopefully first assignments finishing up due
[338.88s -> 343.44s]  tonight midnight no extensions remember if you do have trouble
[343.44s -> 345.32s]  like finishing up there I believe they're still office
[345.32s -> 348.60s]  hours tonight so you guys should be able to get to there
[348.60s -> 352.84s]  if you need to. The second assignment which is the next
[352.84s -> 356.52s]  assignment in fact the first assignment where we're really
[356.52s -> 359.44s]  testing things that you probably haven't seen before namely the
[359.44s -> 364.00s]  file system stuff and it is on the file system we described
[364.00s -> 370.56s]  in class. Specifically the Unix version 6 file system from
[370.56s -> 374.72s]  the late 1970s. Why do we care about that file system? It
[374.72s -> 377.04s]  happens to be a decent file system. It happens to be
[377.04s -> 380.92s]  relatively straightforward to understand for what it's
[380.92s -> 386.64s]  worth. And it is a good one to practice manipulating data
[386.64s -> 391.16s]  structures needed for file systems. The test data that
[391.20s -> 395.32s]  you're going to read from the actual test disks that we have
[395.32s -> 399.96s]  are literally bit for bit representations of a Unix version
[399.96s -> 404.72s]  6 disk. So somebody had a Unix version 6 system up and
[404.72s -> 407.28s]  running somehow probably in a virtual machine or something and
[407.28s -> 409.20s]  they copied the disks off and then put it in this
[409.20s -> 413.08s]  assignment. And that's where they came from. And so you're
[413.08s -> 417.04s]  going to have to figure out how to read those disks
[417.04s -> 420.32s]  specifically. Okay we've given you some scaffolding for
[420.36s -> 424.20s]  that obviously but you're gonna have to do that. The lectures
[424.20s -> 427.56s]  from lecture 3, very important to understand because I think
[427.56s -> 430.84s]  we went over the specifics there. And then this section
[430.84s -> 434.04s]  2.5 of one of the textbooks that we have, you can
[434.04s -> 436.16s]  have a link straight to it, is where you get even
[436.16s -> 439.80s]  more specific information about the file system. So if you
[439.80s -> 443.04s]  have questions about specifics go there first then ask
[443.04s -> 447.12s]  a question on Piazza, come to office hours, etc. So the
[447.12s -> 451.60s]  assignment is you've got this disk image and you have to
[451.60s -> 455.84s]  be able to read and write files and find files on
[455.84s -> 458.36s]  those, that system. Okay and then you should be able to
[458.36s -> 461.40s]  read the files and read any block in that file and
[461.40s -> 465.44s]  so forth. You'll primarily be writing in four different
[465.44s -> 468.76s]  files, so you have code in four different places. We do, we
[468.76s -> 472.12s]  ask, we suggest that you do them in this order. First
[472.12s -> 476.48s]  you do the functions in inode.c and you can imagine
[476.48s -> 479.32s]  what that is, that's manipulating or like using the
[479.32s -> 482.60s]  information in an inode to get out information about
[482.60s -> 486.88s]  the file blocks. And then file.c, which kind of puts
[486.88s -> 490.04s]  another abstraction layer on it and says, here's a file
[490.04s -> 492.20s]  that you should be searching for. Okay and then
[492.20s -> 496.44s]  directory.c, which is also kind of is for manipulating
[496.44s -> 498.88s]  the actual directories. I guess file.c is for like
[498.88s -> 501.40s]  reading a specific file. Directory is going and
[501.40s -> 503.00s]  searching for the file. Remember you have to search
[503.00s -> 505.08s]  for root and you have to search all the files in
[505.12s -> 507.32s]  there and then one after the other until you find
[507.32s -> 509.68s]  the path you're looking for, the file at the path
[509.68s -> 511.88s]  you're looking for. And then finally path name is
[511.88s -> 514.84s]  actually doing the searching as well. Anyway, we say
[514.84s -> 518.60s]  go through in that order and after, I guess after
[518.60s -> 520.80s]  the first two you'll have some functionality that you
[520.80s -> 524.84s]  can test with either sanity check or by running, running
[524.84s -> 527.32s]  the program. And then as each one, as you finish
[527.32s -> 530.04s]  each one you get a little bit more functionality.
[530.04s -> 533.84s]  Okay, so that's the, the basic idea. This assignment
[533.84s -> 538.36s]  is in C, not C++. So you don't have access to
[538.36s -> 541.72s]  maps or sets or vectors or anything like that.
[541.72s -> 544.52s]  You've got to deal with low level arrays and
[544.52s -> 546.32s]  you have to deal with structs and so forth.
[546.32s -> 549.84s]  So no C++ stuff in this assignment. Not the
[549.84s -> 551.28s]  end of the world, but it just means that if
[551.28s -> 552.60s]  oh, I think I might be able to do that
[552.60s -> 554.72s]  with a map, no you can't. No maps allowed in
[554.72s -> 559.36s]  this assignment. Okay. The basic idea as I said,
[559.36s -> 562.52s]  you'll be able to locate and read files in
[562.56s -> 566.16s]  this file system, right? You'll be using functions
[566.16s -> 569.04s]  that we've written for you and you'll be doing your own.
[569.04s -> 571.04s]  The one that I mentioned here that you'll use a bunch
[571.04s -> 574.64s]  of times is called disk image read sector.
[574.64s -> 576.56s]  And it takes in a few parameters.
[576.56s -> 580.84s]  It takes in a file descriptor basically.
[580.84s -> 583.60s]  It takes in the sector number, or I guess it's a
[583.60s -> 585.60s]  file system is kind of what it is.
[585.60s -> 588.32s]  It takes in a sector number, okay, and then it
[588.32s -> 591.94s]  takes in a buffer and that will read a particular
[592.42s -> 595.14s]  sector off of this disk image and we've written that for you.
[595.14s -> 596.94s]  Okay, you don't need to worry about that part of it.
[596.94s -> 599.94s]  Finding the right block to read is the important part.
[599.94s -> 603.38s]  A couple things to notice or to know about it.
[603.38s -> 606.10s]  The function will always read disk image
[606.10s -> 608.78s]  underscore sector underscore size number of bytes.
[608.78s -> 610.72s]  And you ask yourself, well what if the file is
[610.72s -> 613.34s]  only 12 bytes long? Is it always gonna read this many
[613.34s -> 616.14s]  and this many happens to be 512 as we've discussed?
[616.14s -> 620.74s]  Yes, it reads that many because the non-first 12 bytes
[620.78s -> 624.38s]  are all garbage but the disk has to read 512 at a time.
[624.38s -> 627.38s]  So you're responsible for saying, well, which of those
[627.38s -> 628.78s]  bytes are actually relevant?
[628.78s -> 630.50s]  And there's a little bit of arithmetic
[630.50s -> 631.82s]  involved with that.
[631.82s -> 633.90s]  Okay, so that's, you're gonna have to think about
[633.90s -> 635.76s]  those sorts of things.
[635.76s -> 637.46s]  It's critical that you read through
[637.46s -> 638.56s]  the header files for this.
[638.56s -> 640.92s]  The header files are actually not that big
[640.92s -> 643.42s]  for this assignment, but there's lots of constants
[643.42s -> 644.26s]  in there you're gonna need.
[644.26s -> 646.62s]  For instance, root I number, right?
[646.62s -> 647.70s]  It's a constant in there.
[647.70s -> 650.02s]  Now we talked about that, it happens to be one
[650.06s -> 653.10s]  and that's the I number for the root.
[653.10s -> 655.10s]  But you need to use the root I number.
[655.10s -> 658.42s]  You could use one, but in this case it's defined for you.
[658.42s -> 661.34s]  There's a directory entry struct and so forth
[661.34s -> 663.34s]  which has a file name in it and all that.
[663.34s -> 666.74s]  These are the things you learn from the header files.
[666.74s -> 668.86s]  Okay, so make sure you read through that.
[668.86s -> 671.38s]  And the assignment is up right now, already by the way.
[671.38s -> 673.18s]  You can go take a look at it.
[673.18s -> 675.58s]  It's due next Thursday for what it's worth.
[677.04s -> 678.62s]  One function I did wanna talk about,
[678.62s -> 680.38s]  this seems to be the one that gives people
[680.38s -> 682.34s]  kind of the most trouble.
[682.34s -> 684.32s]  And mainly because they don't really understand
[684.32s -> 687.06s]  what it's asking before they start trying to code it.
[687.06s -> 688.34s]  Not a good thing.
[688.34s -> 689.88s]  You should try to understand what you're trying to code
[689.88s -> 690.98s]  before you do it.
[690.98s -> 692.74s]  But here's what this function is.
[692.74s -> 696.62s]  It's called inode index lookup, okay?
[696.62s -> 701.30s]  And you actually get passed in a Unix file system.
[701.30s -> 706.30s]  We have already created and initialized that for you.
[707.02s -> 708.62s]  You don't need to worry about that.
[708.62s -> 710.54s]  By the time this function gets called,
[710.54s -> 715.40s]  you will actually have an inode pointer itself, okay?
[715.40s -> 717.90s]  Which is populated with the details of the inode.
[717.90s -> 719.02s]  Remember it's got all the blocks
[719.02s -> 720.82s]  that have block numbers in them
[720.82s -> 722.98s]  and it's got the information about how big the file is
[722.98s -> 726.82s]  and if it's a large file and so forth, okay?
[726.82s -> 731.82s]  And then it's also got a block number
[732.10s -> 733.70s]  that you're searching for.
[733.74s -> 738.54s]  This is the block number of the file itself
[738.54s -> 742.46s]  for however many blocks that file takes up.
[742.46s -> 745.78s]  So if it's a 512 byte long file, it takes one block
[745.78s -> 748.82s]  and so there would only be block number zero, right?
[748.82s -> 750.22s]  Block index zero.
[750.22s -> 754.84s]  If it's a two, like a 1024 byte file,
[754.84s -> 756.74s]  it takes up two blocks, okay?
[756.74s -> 758.32s]  The inode does and the inode takes up,
[758.32s -> 760.62s]  it's just regular, what did I say?
[760.62s -> 762.02s]  32 bytes or whatever.
[762.02s -> 764.66s]  But the actual blocks in the file
[764.66s -> 766.28s]  are what this function is going to return,
[766.28s -> 771.28s]  the index into the actual file that you're looking for.
[772.70s -> 773.54s]  Okay?
[773.54s -> 775.02s]  So that's the, yeah?
[775.02s -> 777.02s]  So block number is what?
[779.30s -> 784.30s]  If I say, okay, so I have a file that's 1024 long, right?
[786.20s -> 789.42s]  Okay, the block number is going to be, let's say one,
[789.42s -> 792.54s]  which is the block into that file, okay?
[792.54s -> 796.34s]  And you need to find the index of that block
[796.34s -> 800.54s]  in the file system that you're looking for, okay?
[800.54s -> 803.00s]  In other words, I'll show you,
[803.00s -> 804.74s]  you'll see how it works in a second.
[804.74s -> 805.58s]  It is a bit confusing.
[805.58s -> 806.42s]  Yeah?
[806.42s -> 808.42s]  Are we counting from zero or from one?
[808.42s -> 809.84s]  Are you counting from zero or from one?
[809.84s -> 811.82s]  Good question, you can do either.
[811.82s -> 813.26s]  But you have to make sure you know which one
[813.26s -> 815.72s]  when you're actually coding it up, yeah, okay?
[815.72s -> 816.90s]  In this case, it would probably be zero.
[816.98s -> 820.06s]  But here's the example I just wanted to show you, okay?
[820.06s -> 822.42s]  Here's the example I wanted to show you.
[822.42s -> 826.30s]  Let's say that the inode indicates
[826.30s -> 830.52s]  that the file is 180,000 bytes long, okay?
[830.52s -> 831.46s]  180,000 bytes.
[831.46s -> 835.26s]  And let's say that the block number is 302.
[835.26s -> 836.46s]  Here's what that means.
[836.46s -> 840.62s]  If you go 512 bytes at a time,
[840.62s -> 845.10s]  the 302nd one is the one you want to return.
[845.10s -> 849.74s]  Okay, it's the block that you will then look up
[849.74s -> 853.74s]  in your file system for that one, okay?
[853.74s -> 857.18s]  Remember, a file can have a block here
[857.18s -> 858.54s]  that's the first 512 bytes,
[858.54s -> 860.38s]  and then it went over here, it's the next 512,
[860.38s -> 862.42s]  and the one over here is the next 512 or whatever.
[862.42s -> 865.60s]  We're looking for the 302nd one of those,
[865.60s -> 866.50s]  the block number for that.
[866.50s -> 867.76s]  Does that make sense?
[867.76s -> 869.28s]  What we're trying to look for?
[869.28s -> 870.12s]  Yeah, Hassel?
[870.12s -> 871.74s]  How do you get the other ones?
[871.74s -> 872.58s]  How do you get the other ones?
[872.58s -> 874.78s]  Well, you call it three once for each time.
[875.46s -> 876.30s]  If you want to get,
[876.30s -> 878.50s]  let's say the file had 302 blocks in it,
[878.50s -> 881.14s]  you have to call this function 302 times
[881.14s -> 884.18s]  to get each individual index for each one.
[884.18s -> 885.98s]  You see how that works?
[885.98s -> 887.56s]  That's the only way you can do it.
[887.56s -> 888.90s]  There's no linked list here
[888.90s -> 890.48s]  that goes between them all, right?
[890.48s -> 892.82s]  You've got the seven first,
[892.82s -> 895.22s]  or you've got the eight file number,
[895.22s -> 898.08s]  or the block numbers inside the inode,
[898.08s -> 901.50s]  and then you've also got the indirect ones as well,
[901.50s -> 904.00s]  and the double indirect one as well also.
[904.84s -> 905.88s]  So just to be clear here,
[905.88s -> 910.88s]  this isn't necessarily the 302nd amount of data in the file?
[911.80s -> 913.00s]  No, it exactly is.
[913.00s -> 916.26s]  It's the 302nd amount of 512 blocks data.
[916.26s -> 917.28s]  That's what it is.
[917.28s -> 920.32s]  Okay, so it could theoretically be
[920.32s -> 922.80s]  somewhere before the 301st block?
[922.80s -> 924.84s]  It could be anywhere in the file system
[924.84s -> 925.76s]  outside the inodes,
[925.76s -> 927.88s]  but it's gonna be anywhere in the file system.
[927.88s -> 931.84s]  But if you're walking through the file,
[931.84s -> 934.24s]  you first need to go find the block for the first 512,
[934.24s -> 935.08s]  then you need the next 512,
[935.08s -> 936.16s]  then you need the next 512.
[936.16s -> 939.44s]  We're trying to find the 302nd 512 block, right?
[939.44s -> 940.34s]  And to find that,
[940.34s -> 942.32s]  you have to know a lot about the file system
[942.32s -> 943.76s]  to figure out how to follow
[943.76s -> 946.52s]  all the little ways around to do it.
[946.52s -> 947.36s]  That make sense?
[947.36s -> 949.38s]  Yeah, so that's why this function is confusing,
[949.38s -> 950.32s]  because people don't quite get,
[950.32s -> 952.32s]  but hopefully we're clearing that up now.
[953.88s -> 955.12s]  Okay, all right.
[955.12s -> 958.82s]  Let's just look at how we might actually do that, okay?
[958.82s -> 960.00s]  Let's say, as I said,
[960.24s -> 961.64s]  the 180,000 bytes,
[961.64s -> 964.48s]  we're looking for block number 302, okay?
[964.48s -> 966.68s]  We're looking for the 302nd block
[966.68s -> 969.48s]  of 512 bytes of data, okay?
[969.48s -> 971.90s]  And remember, and this actually isn't gonna matter
[971.90s -> 973.16s]  so much for what we're doing,
[973.16s -> 975.96s]  but blocks are 512 bytes long, okay?
[975.96s -> 978.56s]  And how do you find the sector index?
[978.56s -> 980.02s]  That's the actual,
[980.02s -> 983.08s]  what sector do I need to tell the disk to read
[983.08s -> 986.04s]  to get that 302nd block of information?
[986.04s -> 989.00s]  That's what we have to do with this function.
[989.84s -> 993.08s]  Well, what do you have to do?
[993.08s -> 994.16s]  Well, first things first.
[994.16s -> 996.52s]  Remember how inodes, right?
[996.52s -> 998.88s]  There's those eight different blocks
[998.88s -> 1000.12s]  that have them in there, right?
[1000.12s -> 1003.76s]  One, two, three, four, five, six, seven, eight.
[1003.76s -> 1007.28s]  And each one of those, if it's a small file,
[1007.28s -> 1008.56s]  that's gonna have a block number
[1008.56s -> 1010.08s]  that's gonna be the first 512 bytes,
[1010.08s -> 1011.16s]  that's gonna be the next 512,
[1011.16s -> 1013.16s]  the next 512, the next 512, et cetera,
[1013.16s -> 1015.50s]  all the way up to 4,096,
[1015.50s -> 1017.44s]  because that would be the amount you can keep
[1017.44s -> 1021.16s]  in eight blocks of, hey, here's the different blocks.
[1021.16s -> 1022.28s]  Everybody with me there?
[1022.28s -> 1023.92s]  So the first thing your function better do
[1023.92s -> 1027.02s]  is figure out if it's a large or small file,
[1027.02s -> 1028.14s]  because it's gonna change
[1028.14s -> 1030.68s]  what these numbers actually refer to
[1030.68s -> 1034.02s]  if it means, if it's a large file versus a small file.
[1034.02s -> 1036.52s]  It's a small file, easy, right?
[1036.52s -> 1037.92s]  You know that it's gonna be,
[1037.92s -> 1040.12s]  that block, it couldn't be 302, by the way,
[1040.12s -> 1041.52s]  because 302 would be,
[1041.52s -> 1043.84s]  it could only be between zero and seven,
[1044.76s -> 1046.20s]  or if it was a small file.
[1046.20s -> 1047.20s]  But anyway, all you would do
[1047.84s -> 1049.48s]  is go to that inode, read the number off there,
[1049.48s -> 1053.18s]  and that's the number that you send back to the return.
[1054.68s -> 1056.30s]  In this case, it is a large file,
[1056.30s -> 1061.30s]  so you know you have indirect addressing,
[1061.44s -> 1062.48s]  which changes things.
[1062.48s -> 1064.68s]  Now each one of these block numbers here,
[1064.68s -> 1068.56s]  they refer to a block in the file system,
[1068.56s -> 1070.24s]  a segment in the file system,
[1070.24s -> 1072.76s]  but those, if when you go there,
[1072.76s -> 1074.92s]  they have 256 numbers in them,
[1074.92s -> 1079.00s]  each one of which refer to a block where data is.
[1081.16s -> 1082.70s]  So what does that mean?
[1082.70s -> 1085.90s]  Well, the 302nd block of your data
[1085.90s -> 1089.12s]  is going to fall into the second indirect block,
[1089.12s -> 1091.34s]  not this one, but this one.
[1091.34s -> 1093.66s]  Do you understand why that's the case?
[1095.44s -> 1100.12s]  There's 256 that this one is going to refer to,
[1100.12s -> 1101.88s]  because this points to a block
[1101.88s -> 1104.10s]  which has 256 numbers in it,
[1104.10s -> 1106.86s]  and those are the first 256,
[1106.86s -> 1109.62s]  and then the next block has the next 256,
[1109.62s -> 1113.58s]  and 302 happens to be in that one.
[1113.58s -> 1114.84s]  Ready with me there?
[1114.84s -> 1115.84s]  So you see how you're gonna have to start
[1115.84s -> 1116.68s]  thinking about this?
[1116.68s -> 1118.48s]  Okay, so what does that mean?
[1118.48s -> 1123.48s]  Well, you are going to use disk image read sector
[1124.10s -> 1126.22s]  to read the sector that is in,
[1126.22s -> 1128.18s]  oh, I erased it, one, two, three, four, five,
[1128.18s -> 1130.30s]  six, seven, eight.
[1130.30s -> 1132.46s]  You're gonna go read the number here
[1132.50s -> 1135.18s]  and read the disk image from that number,
[1135.18s -> 1137.40s]  which is somewhere else in the file system.
[1137.40s -> 1139.04s]  That is going to give you a block
[1139.04s -> 1140.54s]  that's gonna get 512 bytes,
[1140.54s -> 1144.54s]  which is going to have individual block numbers in them.
[1144.54s -> 1149.38s]  They are all UINT 16 underscore T.
[1149.38s -> 1153.18s]  They are shorts, unsigned shorts.
[1153.18s -> 1154.70s]  You are going to then find
[1154.70s -> 1159.70s]  the 302nd mod 256th short in that list,
[1160.10s -> 1162.58s]  and you are gonna return the number there,
[1162.58s -> 1164.30s]  which refers to the block,
[1164.30s -> 1166.86s]  the index in the block that you are looking for.
[1168.86s -> 1171.18s]  If the block number that you're looking for
[1171.18s -> 1174.74s]  happened to be in this eighth one here,
[1174.74s -> 1177.78s]  well, you have another level of indirection,
[1177.78s -> 1181.06s]  so your function had better account for that as well.
[1181.06s -> 1182.90s]  Okay, so you see how that works?
[1183.90s -> 1186.50s]  Great, I'm sure you'll have questions about that
[1186.50s -> 1188.58s]  as you start doing the assignments,
[1188.78s -> 1189.78s]  but at least at this point,
[1189.78s -> 1191.14s]  hopefully you're at least going,
[1191.14s -> 1193.66s]  oh, I see what this function's trying to get me to do.
[1193.66s -> 1195.02s]  Now I kinda have to go through
[1195.02s -> 1197.54s]  all the calculations to do it.
[1198.86s -> 1199.70s]  Good?
[1200.82s -> 1202.62s]  What questions do you have on that?
[1206.02s -> 1207.86s]  Okay, good.
[1208.78s -> 1210.22s]  So I'll just delete all the Piazza questions
[1210.22s -> 1211.72s]  that come up about it.
[1211.72s -> 1212.56s]  Just kidding.
[1213.78s -> 1215.78s]  So you also, of course, for this assignment,
[1215.78s -> 1217.94s]  have to search through the directories
[1218.14s -> 1220.10s]  to locate a particular file.
[1220.10s -> 1222.46s]  You don't have to follow symbolic links.
[1222.46s -> 1224.06s]  There's no worries about what's going on
[1224.06s -> 1225.18s]  with a weird symbolic link.
[1225.18s -> 1226.26s]  You don't need to worry about that.
[1226.26s -> 1228.06s]  You can ignore those.
[1228.06s -> 1230.10s]  You do need to consider directories
[1230.10s -> 1232.30s]  that are more than 32 files
[1232.30s -> 1234.14s]  because 32, I mean, they could be
[1234.14s -> 1236.74s]  as many files as we want, basically.
[1236.74s -> 1239.14s]  Do not think that that's a special case.
[1239.14s -> 1240.80s]  Don't say, oh, no, it's more than 32.
[1240.80s -> 1242.58s]  I have to handle it in some special way.
[1242.58s -> 1245.58s]  You have already written, presumably,
[1245.58s -> 1247.30s]  you will have written at that point,
[1247.50s -> 1251.86s]  functions that are able to read an entire file
[1251.86s -> 1253.58s]  one block at a time.
[1253.58s -> 1255.30s]  Okay, that's kind of the function we just talked about,
[1255.30s -> 1257.42s]  like go find the next block in this file.
[1257.42s -> 1259.26s]  You do not need to make this a special case.
[1259.26s -> 1260.58s]  Too many people try that sometime,
[1260.58s -> 1262.08s]  and they go, it's not necessary.
[1262.08s -> 1263.72s]  Just deal with it like any other file,
[1263.72s -> 1264.70s]  and say, I wanna read the next one,
[1264.70s -> 1265.96s]  read the next one, read the next one,
[1265.96s -> 1267.86s]  and you'll be fine.
[1267.86s -> 1270.02s]  Okay, and they all fit in 512 bytes.
[1270.02s -> 1272.12s]  It's not like a file entry in that
[1272.12s -> 1273.90s]  can be across two blocks.
[1273.90s -> 1274.94s]  Just not gonna happen
[1274.94s -> 1277.44s]  because of the way they're written.
[1277.44s -> 1281.50s]  By the way, you will probably need to lay some structs
[1281.50s -> 1284.90s]  over this data that you get back from these things.
[1284.90s -> 1287.02s]  There's gonna be structs of different things
[1287.02s -> 1288.90s]  like directory entries and so forth.
[1288.90s -> 1292.64s]  Take those and kind of apply them in a CS107 sense
[1292.64s -> 1294.88s]  to the data, and you'll be able to read them off
[1294.88s -> 1296.72s]  directly, okay?
[1296.72s -> 1300.28s]  So that's the kinds of things you have to think about.
[1300.28s -> 1303.32s]  All right, don't forget, and this is one thing,
[1303.34s -> 1306.72s]  file names are 14 characters maximum,
[1306.72s -> 1311.14s]  and if they happen to be exactly 14 characters,
[1311.14s -> 1314.98s]  well, there's no trailing zero at the end.
[1314.98s -> 1315.82s]  Why?
[1315.82s -> 1317.52s]  Because they wanted to save one byte
[1317.52s -> 1322.34s]  for all those 14 file, 14 length files.
[1322.34s -> 1323.80s]  They wanted to save one byte and said,
[1323.80s -> 1325.54s]  oh, if it's 14, I don't need to worry about it.
[1325.54s -> 1328.12s]  So what that means is if you're trying to compare
[1328.12s -> 1330.62s]  to file names, like one that you're looking for
[1330.62s -> 1331.98s]  and one that's in your data,
[1332.00s -> 1334.08s]  you'd better not use strcomp,
[1334.08s -> 1337.96s]  because strcomp looks for the end zero on the end.
[1337.96s -> 1339.88s]  You might want to use strncomp
[1339.88s -> 1341.40s]  or do some other method to say,
[1341.40s -> 1344.44s]  hey, is there a zero at the end there or whatever.
[1344.44s -> 1346.72s]  Okay, you probably shouldn't do strlen either,
[1346.72s -> 1348.78s]  because strlen, all those string functions
[1348.78s -> 1351.44s]  presume that it's a properly formatted string
[1351.44s -> 1353.12s]  if you have a 14 character name,
[1353.12s -> 1355.70s]  not properly formatted string,
[1355.70s -> 1357.92s]  but still in the file system, okay?
[1357.92s -> 1361.14s]  Little nuances like that, that happens in programming.
[1361.30s -> 1362.90s]  We try to save some space here and say,
[1362.90s -> 1364.12s]  and you better document it
[1364.12s -> 1365.36s]  if you're gonna build something like that,
[1365.36s -> 1367.36s]  and of course they did.
[1367.36s -> 1369.08s]  Good?
[1369.08s -> 1372.60s]  All right, that is assignment one.
[1372.60s -> 1374.68s]  It's a relatively advanced assignment.
[1374.68s -> 1375.80s]  I mean, it's the first assignment
[1375.80s -> 1377.48s]  where you're doing new stuff
[1377.48s -> 1379.24s]  that you've seen only in this class
[1379.24s -> 1380.94s]  and haven't done before.
[1380.94s -> 1382.68s]  Please start early.
[1382.68s -> 1384.56s]  You hear that in every class.
[1384.56s -> 1386.96s]  Come to Office Hours, ask Piazza questions, obviously.
[1386.96s -> 1389.32s]  The CAs are not gonna look at your code for this.
[1389.34s -> 1392.74s]  So if you have questions about your code,
[1392.74s -> 1395.02s]  formulate it in some sort of conceptual way
[1395.02s -> 1397.28s]  and say, here's what I'm trying to do.
[1397.28s -> 1398.50s]  What am I doing wrong?
[1398.50s -> 1400.60s]  Or what kinds of things do I need to think about
[1400.60s -> 1401.70s]  because I'm trying to do this?
[1401.70s -> 1404.30s]  And draw some diagrams and so forth
[1404.30s -> 1407.14s]  that the CAs can help you with.
[1407.14s -> 1409.62s]  Okay, they will look at error messages
[1409.62s -> 1411.02s]  and they'll try to figure that out.
[1411.02s -> 1412.14s]  But they're not gonna dig into your code
[1412.14s -> 1414.20s]  and try to figure out what you're trying to do.
[1414.20s -> 1416.34s]  They're going to ask you, what are you trying to do?
[1416.34s -> 1419.14s]  Here's the conceptual framework behind it.
[1419.88s -> 1423.54s]  All right, other questions about that, the assignment?
[1424.52s -> 1425.36s]  It's kind of a fun one.
[1425.36s -> 1428.64s]  I mean, it's definitely a pretty meaty assignment
[1429.52s -> 1430.52s]  as far as it goes.
[1433.00s -> 1437.44s]  All right, let us go back to multi-processing.
[1437.44s -> 1440.32s]  Okay, so here's where we left off on Monday.
[1440.32s -> 1443.72s]  On Monday, we said, hey, there's this new function
[1443.72s -> 1446.32s]  called fork, it's actually a system call.
[1446.38s -> 1449.30s]  It's called fork, it takes no parameters,
[1449.30s -> 1452.66s]  and it just returns to you a number, an integer,
[1452.66s -> 1456.82s]  which is either the PID of the child process
[1456.82s -> 1459.34s]  that fork creates, if you are the parent
[1459.34s -> 1463.38s]  that created, that called fork, or it returns zero,
[1463.38s -> 1468.38s]  which is the value saying, basically, you are the child.
[1468.38s -> 1471.86s]  It is not the PID of the child for the child.
[1471.86s -> 1473.54s]  Okay, because you wanna be able to differentiate
[1473.54s -> 1475.02s]  between these two, okay?
[1475.08s -> 1477.28s]  And then, we started looking at some
[1477.28s -> 1479.56s]  of the various programs about this,
[1479.56s -> 1483.66s]  and we looked at this one called fork puzzle, right?
[1483.66s -> 1486.36s]  And we found out that it turns out
[1486.36s -> 1490.16s]  that with fork puzzle, you can end up with data
[1490.16s -> 1493.68s]  and going, or the output, in some order
[1493.68s -> 1494.96s]  that you can't predict, right?
[1494.96s -> 1496.20s]  If I do it again, it'll probably be
[1496.20s -> 1497.52s]  a slightly different order, and in fact,
[1497.52s -> 1501.00s]  this time, it went and we found that the parent
[1501.00s -> 1502.70s]  finished before one of the children,
[1502.76s -> 1506.12s]  and so the command prompt came back,
[1506.12s -> 1507.84s]  and then we got this weird D at the end,
[1507.84s -> 1509.68s]  and it was kind of ugly, and kind of things
[1509.68s -> 1511.68s]  that you don't necessarily want, okay?
[1511.68s -> 1514.20s]  We wanna make this a little bit more predictable
[1514.20s -> 1516.68s]  if we can help it, and specifically,
[1516.68s -> 1520.60s]  we want the parent to be able to wait for the child.
[1520.60s -> 1521.96s]  Okay, we want the parent to be able to say,
[1521.96s -> 1525.84s]  I'm gonna wait for any children I create to finish.
[1525.84s -> 1527.44s]  Okay, so how do we do that?
[1527.44s -> 1532.44s]  Well, we use this system call called wait PID.
[1533.48s -> 1534.92s]  Okay, wait PID.
[1534.92s -> 1537.04s]  Wait PID has a few arguments, of course,
[1537.04s -> 1539.88s]  and it has an argument that's a PID.
[1539.88s -> 1541.52s]  Most of the time, as it turns out,
[1541.52s -> 1543.42s]  we won't actually put a PID in there.
[1543.42s -> 1547.44s]  You'll see why later, but it stands for the wait set,
[1547.44s -> 1550.76s]  which can be one PID, like I am looking
[1550.76s -> 1555.76s]  for a particular child, or it can be another number
[1555.88s -> 1560.88s]  like negative one, which means wait for any child,
[1560.94s -> 1565.26s]  and then whenever any child ends, this will continue.
[1565.26s -> 1570.26s]  Okay, and it does stop the parent until a child ends.
[1570.42s -> 1572.10s]  Okay, the parent just sits there and waits,
[1572.10s -> 1574.58s]  and doesn't do anything, and by the way,
[1574.58s -> 1576.98s]  it doesn't use up lots of processor time either.
[1576.98s -> 1579.34s]  The kernel, the operating system says,
[1579.34s -> 1580.42s]  oh, you're waiting for the child?
[1580.42s -> 1582.26s]  Okay, just go to sleep for a while,
[1582.26s -> 1586.10s]  and it doesn't do any processing, which is a good thing.
[1586.10s -> 1589.48s]  We like that in our programs, okay?
[1589.50s -> 1591.14s]  So, that's that.
[1591.14s -> 1595.46s]  It also takes an address of a,
[1595.46s -> 1596.66s]  get to your segment in one sec.
[1596.66s -> 1599.38s]  It takes an address of a status,
[1599.38s -> 1601.42s]  so you pass in the address of an integer,
[1601.42s -> 1603.30s]  and it will populate that integer
[1603.30s -> 1607.50s]  with the result of the wait PID call,
[1607.50s -> 1609.82s]  which can be an error, or it can encompass
[1609.82s -> 1612.34s]  the return value, and so forth,
[1612.34s -> 1614.66s]  and then finally, we have the options,
[1614.68s -> 1619.68s]  which are basically a bitwise org set of options.
[1621.20s -> 1622.52s]  For now, we're gonna make it zero,
[1622.52s -> 1624.64s]  because we're gonna get to those later, okay?
[1624.64s -> 1626.36s]  There are no options we're gonna worry about right now.
[1626.36s -> 1627.20s]  Question.
[1627.20s -> 1629.00s]  If the child makes a child,
[1629.00s -> 1631.48s]  does the wait PID also wait for that?
[1631.48s -> 1632.30s]  Good question.
[1632.30s -> 1633.42s]  If the child makes a child,
[1633.42s -> 1634.96s]  does the wait PID wait for that?
[1634.96s -> 1636.10s]  No.
[1636.10s -> 1639.80s]  The child can only wait for its own child in that case.
[1639.80s -> 1642.04s]  The parent doesn't necessarily know that its own child,
[1642.04s -> 1645.18s]  that it's grandchildren, or it can wait for those, no.
[1645.18s -> 1646.96s]  It does need to wait for only its children.
[1646.96s -> 1647.80s]  Good question.
[1649.14s -> 1649.98s]  Anything else on that?
[1649.98s -> 1650.80s]  Let's see an example.
[1650.80s -> 1651.64s]  Yeah.
[1651.64s -> 1652.48s]  Okay.
[1652.48s -> 1656.48s]  So if you call wait PID for the parent's child,
[1657.58s -> 1660.98s]  so if you have the parent as the child,
[1660.98s -> 1662.78s]  and then the child as the child,
[1662.78s -> 1666.18s]  and then you call wait PID for that first child,
[1666.18s -> 1669.82s]  it will wait for both of them, right?
[1669.82s -> 1671.70s]  That's a good question.
[1672.20s -> 1673.04s]  Okay, we're getting into the weeds here.
[1673.04s -> 1678.04s]  If the parent has a child, and the child has a child,
[1678.96s -> 1681.36s]  the grandchild does not have any relation
[1681.36s -> 1684.24s]  to the grandparent to the extent that it will wait.
[1684.24s -> 1687.48s]  When the parent's child ends,
[1687.48s -> 1689.32s]  even if the parent's grandchild keeps going,
[1689.32s -> 1690.96s]  the parent will get notified.
[1690.96s -> 1693.80s]  So no, it doesn't sit there and wait
[1693.80s -> 1695.76s]  for any of grandchildren to finish.
[1695.76s -> 1698.96s]  Well, if you use wait PID for both parents.
[1698.96s -> 1700.96s]  If you use wait PID for both,
[1700.98s -> 1705.48s]  then the child can't finish until its child finishes,
[1705.48s -> 1707.02s]  which means the parent will not finish
[1707.02s -> 1707.86s]  until the child finishes.
[1707.86s -> 1708.70s]  Yeah.
[1708.70s -> 1710.06s]  So you can string them along like that,
[1710.06s -> 1711.58s]  but you have to be a little careful with that.
[1711.58s -> 1713.10s]  But don't think that somehow the grandchildren
[1713.10s -> 1715.50s]  all get encompassed into the parent.
[1715.50s -> 1717.06s]  Yeah, good question.
[1717.06s -> 1717.90s]  Okay.
[1717.90s -> 1718.72s]  Yeah.
[1718.72s -> 1719.56s]  Yeah.
[1719.56s -> 1720.40s]  So you're passing in the child
[1720.40s -> 1722.14s]  that you want to finish?
[1722.14s -> 1722.98s]  Yes, good question.
[1722.98s -> 1724.26s]  You're saying you're passing in the child
[1724.26s -> 1725.10s]  that you want to finish.
[1725.10s -> 1727.94s]  In this case, if we pass in a PID,
[1727.94s -> 1729.86s]  not negative one, for instance,
[1729.88s -> 1733.24s]  then it will wait for that child.
[1733.24s -> 1734.06s]  Correct.
[1734.06s -> 1735.64s]  And you can't pass in one for your grandchildren.
[1735.64s -> 1736.72s]  It doesn't know about that.
[1736.72s -> 1738.68s]  You can only pass in ones that you might know,
[1738.68s -> 1742.12s]  that are direct children of yours.
[1742.12s -> 1742.96s]  You'll see.
[1742.96s -> 1745.72s]  Let's do an example and then we'll see.
[1745.72s -> 1746.56s]  Okay.
[1747.64s -> 1751.20s]  By the way, the return value is the PID of the child
[1751.20s -> 1755.86s]  or negative one if there were no children available
[1755.86s -> 1758.30s]  still running, because that could be the case too.
[1758.32s -> 1759.96s]  If no children happen to be still running
[1759.96s -> 1761.72s]  and you say, wait PID for a child,
[1761.72s -> 1763.40s]  it will return negative one and that means,
[1763.40s -> 1764.24s]  oh, there weren't any to wait,
[1764.24s -> 1766.88s]  or that one in particular had already ended.
[1766.88s -> 1767.72s]  Yeah.
[1767.72s -> 1768.96s]  Doesn't that mean, like,
[1768.96s -> 1772.84s]  while you're, before you're done using wait PID
[1772.84s -> 1774.44s]  that one of that child could terminate
[1774.44s -> 1775.74s]  before it actually...
[1775.74s -> 1776.58s]  Good question.
[1776.58s -> 1778.32s]  Does it mean that your child could terminate
[1778.32s -> 1779.32s]  before you can call wait PID?
[1779.32s -> 1780.64s]  Absolutely.
[1780.64s -> 1781.64s]  Yep.
[1781.64s -> 1783.74s]  And that's okay, as it turns out.
[1783.74s -> 1786.44s]  By the way, wait PID also does some cleanup.
[1786.46s -> 1789.06s]  It makes it so the child process does get cleaned up.
[1789.06s -> 1792.74s]  So we actually should do wait PID in general.
[1792.74s -> 1794.14s]  We didn't in the program before
[1794.14s -> 1795.54s]  because we hadn't learned about it yet,
[1795.54s -> 1797.86s]  but you should do it in general.
[1797.86s -> 1799.26s]  Again, we'll see some examples of this.
[1799.26s -> 1800.10s]  Yeah.
[1800.10s -> 1801.78s]  But if you call wait PID on groups
[1801.78s -> 1803.26s]  and ask the child about the terms
[1803.26s -> 1804.94s]  and the difference between the groups,
[1804.94s -> 1807.40s]  is it possible that the group would
[1807.40s -> 1809.38s]  return to the same place?
[1809.38s -> 1812.38s]  Sorry, what's the question again?
[1812.38s -> 1814.10s]  If you call wait PID on groups
[1814.10s -> 1816.18s]  after there's a trend where it can't shift
[1817.00s -> 1819.24s]  if you call wait PID on the root?
[1820.76s -> 1822.32s]  Well, let's just put it this way.
[1822.32s -> 1826.22s]  If you call wait PID on...
[1826.22s -> 1828.36s]  You should call it only on your children
[1828.36s -> 1829.56s]  or use negative one,
[1829.56s -> 1831.00s]  and we'll get to what that is in a bit.
[1831.00s -> 1831.96s]  You should only call it on its children.
[1831.96s -> 1833.46s]  If your children already ended,
[1833.46s -> 1834.96s]  the return value will be negative one,
[1834.96s -> 1835.80s]  which is fine.
[1835.80s -> 1837.20s]  You'll be able to catch that.
[1837.20s -> 1839.44s]  Or it will give you back the PID
[1839.44s -> 1841.96s]  saying, hey, yeah, that child just ended.
[1841.96s -> 1843.48s]  All you really need to know about that.
[1843.48s -> 1845.60s]  And we'll see how it manifests itself in a minute.
[1846.38s -> 1850.62s]  What happens if you add a process's own PID to a wait set?
[1850.62s -> 1852.38s]  If you add your own process to a wait set,
[1852.38s -> 1853.42s]  it is not a child of yours,
[1853.42s -> 1855.78s]  so it'll kind of ignore that, I believe.
[1855.78s -> 1859.30s]  So you're not gonna wait on your own PID.
[1859.30s -> 1860.74s]  So it's like...
[1860.74s -> 1863.06s]  I don't think anything will happen, actually.
[1863.06s -> 1864.10s]  Like I don't think it'll crash
[1864.10s -> 1865.50s]  or wait forever or whatever,
[1865.50s -> 1866.94s]  but no, I don't think, we can try it,
[1866.94s -> 1868.50s]  but I don't think that's what's gonna,
[1868.50s -> 1870.26s]  I don't think anything will happen, as it turns out.
[1870.26s -> 1871.74s]  It'll probably return negative one saying,
[1871.74s -> 1874.42s]  no, that one's not even in your child's set at all.
[1874.44s -> 1875.72s]  Probably what'll happen.
[1875.72s -> 1878.08s]  Okay, let's look at an example, okay?
[1878.08s -> 1879.36s]  What we're gonna do is,
[1879.36s -> 1883.52s]  we are going to do an example called Separate.
[1883.52s -> 1886.00s]  I don't need to do that right now.
[1886.00s -> 1888.88s]  We are gonna do an example called Separate,
[1890.28s -> 1893.92s]  which is going to use some of this information,
[1893.92s -> 1896.08s]  this wait PID, so that we can actually do something
[1896.08s -> 1897.68s]  where we know what's gonna happen
[1897.68s -> 1900.88s]  and the ordering is going to happen in it, okay?
[1900.88s -> 1902.40s]  So here's what we're gonna do.
[1902.40s -> 1907.40s]  We are going to say, print F before.
[1907.58s -> 1910.94s]  So this is the first thing that's gonna happen,
[1911.94s -> 1915.38s]  is going to, it's gonna print before, okay?
[1915.38s -> 1920.38s]  And then we're gonna say PID T, PID equals fork,
[1921.62s -> 1925.50s]  and that's going to do this process separation business,
[1925.50s -> 1929.70s]  okay, and then we're gonna say print F after.
[1929.70s -> 1931.98s]  How many of these should we get?
[1932.56s -> 1933.40s]  Two, right?
[1933.40s -> 1934.24s]  Because now we have one extra process
[1934.24s -> 1935.84s]  and both are gonna do that, okay?
[1935.84s -> 1939.32s]  If PID equals zero, what does that mean?
[1940.60s -> 1942.36s]  Child, we're the child, okay?
[1942.36s -> 1945.64s]  If the PID equals zero, okay?
[1945.64s -> 1946.68s]  You're gonna wanna say something like,
[1946.68s -> 1950.48s]  print F, I am the child, okay?
[1950.48s -> 1955.12s]  And the parent will wait up for me.
[1955.12s -> 1956.36s]  Okay, it's kind of a nice analogy
[1956.36s -> 1959.06s]  in that sense, if you want, okay?
[1959.06s -> 1961.80s]  And then we are going to immediately return,
[1962.58s -> 1965.26s]  if we are the child, and let's just return 110
[1965.26s -> 1966.98s]  for CS110 or whatever, it doesn't matter,
[1966.98s -> 1969.04s]  we're just gonna show that it's not zero,
[1969.04s -> 1970.58s]  just the return value, you can actually get
[1970.58s -> 1974.36s]  the return value from the,
[1974.36s -> 1978.14s]  you can get the return value from the return
[1978.14s -> 1979.82s]  when the child ends, which is kind of nice,
[1979.82s -> 1981.66s]  because maybe you wanna know what happened with your child,
[1981.66s -> 1983.14s]  did it end appropriately or not,
[1983.14s -> 1985.82s]  or maybe you'll pass some information that way,
[1985.82s -> 1987.60s]  if you want to, okay?
[1987.60s -> 1990.18s]  All right, at this point, we can put an else,
[1990.20s -> 1992.72s]  this else is not strictly necessary
[1992.72s -> 1995.00s]  because of the way we've done our program, right?
[1995.00s -> 1997.00s]  It will always, the child will always return
[1997.00s -> 1998.92s]  at this point, okay?
[1998.92s -> 2001.70s]  So the else is not really necessary in that case,
[2001.70s -> 2003.86s]  but anyway, the point is that it's,
[2003.86s -> 2008.56s]  now we're saying we are the parent in here, okay?
[2008.56s -> 2011.96s]  And the parent is going to, we're gonna have a status,
[2011.96s -> 2015.72s]  okay, and the parent is going to do wait PID,
[2015.72s -> 2018.00s]  for now, we're just gonna wait for the actual PID,
[2018.02s -> 2020.78s]  we're gonna pass in a pointer to the status,
[2020.78s -> 2022.82s]  and we're gonna pass in zero for the options,
[2022.82s -> 2027.10s]  we'll get to what the options mean later, okay?
[2027.10s -> 2030.02s]  All right, after this, this will wait
[2030.02s -> 2032.54s]  until the child finishes, okay?
[2032.54s -> 2034.42s]  And then, it will, yeah, question?
[2034.42s -> 2036.82s]  Status doesn't need to be initialized.
[2036.82s -> 2037.96s]  Status doesn't need to be initialized,
[2037.96s -> 2039.66s]  it's going, you're passing a pointer in,
[2039.66s -> 2042.10s]  it's gonna be changed, it's not using,
[2042.10s -> 2044.62s]  the function is not using the value of status,
[2044.62s -> 2047.66s]  it's populating the value of status for you.
[2048.58s -> 2050.34s]  Okay, it's another way to get kind of two return values,
[2050.34s -> 2053.02s]  if you will, the status and the actual PID,
[2053.02s -> 2056.42s]  it's kind of the C way of doing that, right?
[2056.42s -> 2059.26s]  Okay, so, we're going to do that.
[2059.26s -> 2061.86s]  Now, we're gonna check some things about this, okay?
[2061.86s -> 2065.04s]  We're gonna use a macro, which basically is an,
[2065.04s -> 2066.74s]  you can think of it as an inline function,
[2066.74s -> 2067.94s]  we've seen a little bit of those before,
[2067.94s -> 2071.78s]  but it's called W if exited, okay?
[2071.78s -> 2074.28s]  Now, I know that looks like wife exited.
[2074.28s -> 2077.10s]  And I always say that when I think it,
[2077.10s -> 2079.04s]  because I read it and I go, oh, that means, but it's not,
[2079.04s -> 2083.08s]  it means W if exited, and what it does is,
[2083.08s -> 2085.46s]  it checks the status, okay?
[2085.46s -> 2087.34s]  And if the status is,
[2089.08s -> 2093.02s]  if that macro returns true, it means, okay,
[2093.02s -> 2098.02s]  it was fine, it exited with a regular old return value.
[2098.68s -> 2099.56s]  I'll show you what that means
[2099.56s -> 2102.04s]  when it doesn't happen in a few minutes, too, okay?
[2102.04s -> 2103.28s]  And what you can do is you can printf,
[2103.30s -> 2108.30s]  and you can say child exited with status percent D, okay?
[2112.02s -> 2113.54s]  And this is gonna be the actual,
[2113.54s -> 2114.38s]  it probably shouldn't be status,
[2114.38s -> 2116.58s]  it should be something like the return value or whatever.
[2116.58s -> 2118.58s]  And then you get another macro,
[2118.58s -> 2123.58s]  which does exited status, sorry, W exit status,
[2124.72s -> 2126.22s]  and that's gonna give you the status.
[2126.22s -> 2127.80s]  It's just reading off these bits,
[2127.80s -> 2132.80s]  because the actual macro, or the status variable,
[2133.30s -> 2134.78s]  holds a whole bunch of information in it.
[2134.78s -> 2136.46s]  Part of it is the return value,
[2136.46s -> 2138.50s]  part of it is the other information
[2138.50s -> 2140.90s]  about how it exited and so forth, okay?
[2140.90s -> 2142.94s]  So that's what we're gonna do there, all right?
[2142.94s -> 2146.78s]  And then we want to do what?
[2146.78s -> 2149.12s]  We want to do an else on this case.
[2149.12s -> 2150.78s]  So let's say that we had bad news,
[2150.78s -> 2153.10s]  the child didn't exit correctly.
[2153.10s -> 2158.10s]  We can printf child terminated abnormally, okay?
[2158.10s -> 2163.10s]  Something like that, okay?
[2165.56s -> 2167.24s]  And then we've got that,
[2167.24s -> 2170.84s]  and then after this we can just return zero.
[2170.84s -> 2173.28s]  Okay, so that's what's gonna happen, okay?
[2173.28s -> 2174.70s]  Anybody see any typos?
[2175.80s -> 2177.08s]  We'll find out.
[2177.08s -> 2181.32s]  Make separate, okay, looks good.
[2181.32s -> 2183.68s]  Okay, so if we run it, right?
[2183.68s -> 2186.20s]  It says before, after, after,
[2186.20s -> 2187.60s]  and then it says I am the child,
[2188.06s -> 2188.90s]  the parent will wait up for me,
[2188.90s -> 2190.90s]  child exited with status 110.
[2190.90s -> 2193.66s]  And it will always be in that order,
[2193.66s -> 2197.74s]  no matter how many times I run it, okay?
[2197.74s -> 2200.38s]  Because the parent is forced to wait
[2200.38s -> 2202.06s]  until the child exits,
[2202.06s -> 2206.56s]  at which point be that we are all set, okay?
[2206.56s -> 2207.82s]  All right, you might be asking yourself,
[2207.82s -> 2211.34s]  well, how could it exit abnormally?
[2211.34s -> 2216.34s]  Well, how might we make the child
[2217.90s -> 2219.76s]  exit in a bad way?
[2221.78s -> 2222.94s]  In other words, crash it.
[2222.94s -> 2224.50s]  Can I get the child to crash?
[2225.60s -> 2226.44s]  We can do a bunch of things.
[2226.44s -> 2228.20s]  We could divide by zero if we wanted to.
[2228.20s -> 2229.04s]  How about this?
[2229.04s -> 2229.90s]  This is one that I was like,
[2229.90s -> 2233.04s]  int star a equals null,
[2233.04s -> 2235.40s]  asterisk a equals five.
[2236.50s -> 2237.98s]  That would be bad news, right?
[2237.98s -> 2240.66s]  Try to dereference and place a value at null,
[2240.66s -> 2242.50s]  which is gonna be bad, bad news, right?
[2242.50s -> 2247.00s]  And if the compiler shouldn't actually care about it,
[2248.54s -> 2252.46s]  make separate, there we go, okay?
[2252.46s -> 2256.22s]  Separate, and before, after, after,
[2256.22s -> 2257.50s]  I am the child, the parent wait up for me,
[2257.50s -> 2259.84s]  child terminated abnormally, right?
[2259.84s -> 2260.76s]  We killed the child.
[2260.76s -> 2263.98s]  That got the exit status to tell you that,
[2263.98s -> 2268.30s]  oh, bad news, something happened, bad news, okay?
[2268.30s -> 2269.42s]  Question.
[2269.42s -> 2271.26s]  Is it possible for the child to print,
[2271.26s -> 2274.58s]  I am the child before the parent prints out there?
[2274.58s -> 2276.40s]  Is it possible for the child to print,
[2276.42s -> 2278.90s]  I am the child before the parent prints after?
[2278.90s -> 2279.94s]  It is possible.
[2279.94s -> 2281.58s]  It's probably not gonna happen in this case,
[2281.58s -> 2282.98s]  but that's perfect, yes, that's possible.
[2282.98s -> 2287.42s]  So I guess in this case it could happen
[2287.42s -> 2288.24s]  that that's the case.
[2288.24s -> 2289.42s]  It's probably not just because of this,
[2289.42s -> 2290.26s]  but that's a good point.
[2290.26s -> 2291.54s]  Yeah, so that is a,
[2291.54s -> 2293.26s]  by the way, this is a good term to learn.
[2293.26s -> 2294.90s]  That's called a race condition.
[2294.90s -> 2296.66s]  And a race condition means two things
[2296.66s -> 2299.90s]  are going down some paths at the same time.
[2299.90s -> 2301.14s]  One of them is gonna win,
[2301.14s -> 2302.86s]  but you don't know which one is gonna win.
[2302.86s -> 2305.54s]  We try to avoid race conditions in this class.
[2305.56s -> 2308.40s]  Sometimes you absolutely have race conditions,
[2308.40s -> 2312.44s]  and therefore you have to do some logic
[2312.44s -> 2315.52s]  to make sure you know what will happen.
[2315.52s -> 2317.76s]  Okay, when we get to threads, you'll see this a lot
[2317.76s -> 2320.36s]  with, well actually you'll see it in processes a lot too.
[2320.36s -> 2322.40s]  But in particular,
[2322.40s -> 2325.12s]  if you're trying to modify shared data structures,
[2325.12s -> 2325.96s]  you have race conditions
[2325.96s -> 2328.12s]  where they're both two things might be trying to do that,
[2328.12s -> 2329.24s]  you want to avoid that.
[2329.24s -> 2332.64s]  So you handle it in ways that we'll talk about.
[2332.64s -> 2333.96s]  Question.
[2333.96s -> 2334.80s]  Yeah.
[2334.94s -> 2339.82s]  In the else statement, what is called weight PID?
[2339.82s -> 2342.58s]  In the else statement where it calls weight PID down here,
[2342.58s -> 2343.42s]  yes.
[2343.42s -> 2344.46s]  Isn't it, so where is the parent,
[2344.46s -> 2348.14s]  so isn't the first argument to weight PID,
[2348.14s -> 2351.66s]  isn't that supposed to be the child's PID?
[2351.66s -> 2353.34s]  Isn't that supposed to be the child's PID?
[2353.34s -> 2354.66s]  It is the child's PID.
[2354.66s -> 2358.10s]  Because remember, what is the return value for fork?
[2358.10s -> 2362.62s]  The parent gets the child's PID as its return value.
[2362.62s -> 2363.86s]  So yes, that's exactly,
[2364.12s -> 2366.44s]  and that's why that happens, so you can use it.
[2366.44s -> 2369.12s]  As it turns out, yeah, good question.
[2369.12s -> 2370.68s]  Any other questions on this?
[2370.68s -> 2373.44s]  Okay, let's keep going.
[2373.44s -> 2378.44s]  So this function, the output's the same every time,
[2378.56s -> 2382.34s]  barring that one thing where the child could print the,
[2382.34s -> 2385.16s]  could print the after, and then it's lined
[2385.16s -> 2387.16s]  before the parent even gets to after.
[2388.44s -> 2392.40s]  The parent, the whole reason this works
[2392.42s -> 2394.50s]  and the order we expect is because the parent waits
[2394.50s -> 2399.50s]  for the child to end, and then you use these macros
[2399.82s -> 2401.78s]  to actually get more information out about this.
[2401.78s -> 2402.98s]  And you might be able to say, wait a minute,
[2402.98s -> 2407.58s]  how can you overlap the return value
[2407.58s -> 2409.94s]  and other information, right?
[2409.94s -> 2412.02s]  Wasn't the return value an int?
[2412.02s -> 2413.78s]  Not really, return values are supposed
[2413.78s -> 2415.26s]  to be between zero and 255.
[2415.26s -> 2417.38s]  So you have lots of extra bits in that int
[2417.38s -> 2419.36s]  to store other information.
[2419.36s -> 2421.68s]  That's the way return values should be.
[2421.70s -> 2423.78s]  They are ints, but you should limit them
[2423.78s -> 2425.54s]  between zero and 255.
[2425.54s -> 2428.30s]  That's the way it goes, okay?
[2428.30s -> 2430.30s]  And then, as I said, the Wait PID
[2430.30s -> 2434.00s]  does donate the resources back to the system.
[2434.00s -> 2435.90s]  In other words, it's kind of the cleanup
[2435.90s -> 2438.26s]  that you like to do at the end of the program
[2438.26s -> 2439.10s]  when something happens.
[2439.10s -> 2441.22s]  So you should be doing this Wait PID
[2441.22s -> 2443.74s]  for all of your children, as it turns out.
[2443.74s -> 2444.78s]  Okay, it's better for them.
[2444.78s -> 2446.38s]  In the end, no matter what,
[2446.38s -> 2447.58s]  the system will clean up for you,
[2447.58s -> 2450.66s]  but it's just like doing free after you do a malloc.
[2450.68s -> 2452.84s]  It's nice to do because it cleans things up.
[2454.52s -> 2455.36s]  All right.
[2456.48s -> 2457.68s]  What else?
[2458.76s -> 2463.76s]  Okay, so let's look at another example, okay?
[2464.20s -> 2466.26s]  In this other example, we're gonna see,
[2466.26s -> 2469.00s]  it's kind of a little bit of a brain teaser,
[2469.00s -> 2471.28s]  and we're just gonna kind of walk through it and say,
[2471.28s -> 2473.08s]  and it's gonna demonstrate to you
[2473.08s -> 2477.12s]  how deep this copy actually is, okay?
[2477.12s -> 2478.88s]  This one is going to be called what?
[2478.90s -> 2483.42s]  This one is gonna be parentchild.c.
[2483.42s -> 2484.82s]  Okay, here's what we're gonna do in here.
[2484.82s -> 2486.92s]  This is gonna involve random numbers, woo-hoo.
[2486.92s -> 2489.62s]  Okay, we're gonna have some randomness in here, okay?
[2489.62s -> 2492.26s]  And in this case, what we're gonna do
[2493.38s -> 2498.38s]  is we're gonna first say print f I am unique
[2498.78s -> 2503.78s]  and just get printed once, okay?
[2504.34s -> 2505.58s]  And we know why that's the case
[2505.60s -> 2509.44s]  because there's no forking yet, okay?
[2509.44s -> 2514.06s]  And then we'll do PID T PID equals fork,
[2514.06s -> 2515.40s]  like we kind of always do.
[2515.40s -> 2518.44s]  Then I'm gonna just figure out a little Boolean.
[2519.64s -> 2524.64s]  Boolean parent equals PID equals, let's see,
[2528.12s -> 2533.12s]  PID is not equal to, oops, not equal to zero.
[2533.12s -> 2534.36s]  Okay, what is that all about?
[2534.38s -> 2536.70s]  Basically, it's saying if it's the parent,
[2536.70s -> 2538.78s]  in other words, if the PID is not zero, it's the parent,
[2538.78s -> 2539.82s]  and it's just gonna set that.
[2539.82s -> 2541.98s]  Otherwise, it's not gonna be the parent, okay?
[2541.98s -> 2545.40s]  It's just kind of a fancy way of doing that, okay?
[2545.40s -> 2550.40s]  All right, and then we are going to say, okay,
[2551.38s -> 2556.38s]  if random, which is going to give you a random number,
[2557.10s -> 2562.10s]  okay, mod two equals zero, and that equals the parent.
[2563.14s -> 2564.34s]  In other words, and this is C,
[2565.32s -> 2567.28s]  so one and zero are true and false, basically, okay?
[2567.28s -> 2569.36s]  If that equals the parent,
[2569.36s -> 2573.72s]  then we are going to sleep for one second.
[2573.72s -> 2574.56s]  That's what this means, okay?
[2574.56s -> 2576.88s]  Sleep is another command that basically says
[2576.88s -> 2580.12s]  turn your process off for that amount of time,
[2580.12s -> 2582.96s]  and then wake it up again after that amount of time.
[2582.96s -> 2583.80s]  Okay?
[2584.84s -> 2588.36s]  All right, and then if we are the parent,
[2588.36s -> 2593.36s]  we are going to await PID for PID null,
[2594.96s -> 2599.56s]  oops, null, and zero for basically,
[2599.56s -> 2601.96s]  because we're not doing any things there, okay?
[2603.72s -> 2608.72s]  Parent waits for child in that case, okay?
[2608.88s -> 2610.80s]  And then we are going to say print F,
[2610.80s -> 2614.50s]  I get printed twice.
[2616.32s -> 2621.32s]  This one is from percent S, comma,
[2625.32s -> 2628.52s]  from the parent, I'm going to print out parent.
[2628.52s -> 2632.98s]  Otherwise, I'm going to print out child, okay?
[2632.98s -> 2635.68s]  And then we're going to return zero, okay?
[2635.68s -> 2638.56s]  So what this is doing is this is going to set up
[2638.56s -> 2643.56s]  so that only one of the two actually gets to sleep,
[2643.82s -> 2645.88s]  right, and if it's the parent,
[2645.88s -> 2649.64s]  it's going to have to wait for the child, okay?
[2649.64s -> 2653.44s]  Make parent child, okay, parent child.
[2653.44s -> 2655.46s]  Now, you kind of have to, I'm going to put it up here,
[2655.46s -> 2657.42s]  you kind of have to watch this pretty closely
[2657.42s -> 2659.58s]  because it's only one second, right?
[2659.58s -> 2661.18s]  But watch what happens.
[2661.18s -> 2662.86s]  Boom, I am unique and get printed once,
[2662.86s -> 2664.38s]  it waited for a little bit of time,
[2664.38s -> 2666.78s]  and then I get printed twice, okay?
[2666.78s -> 2668.98s]  If I run it again,
[2668.98s -> 2672.26s]  it printed that I got printed twice immediately,
[2672.26s -> 2674.98s]  and then printed the next one.
[2674.98s -> 2677.62s]  I'll show you again, let's see which one happens here.
[2677.62s -> 2679.36s]  Okay, so that means that the parent
[2679.36s -> 2682.42s]  was the one that had to sleep, okay?
[2682.44s -> 2683.44s]  And then maybe I'll do it again,
[2683.44s -> 2685.96s]  and the child is the one that had to sleep.
[2685.96s -> 2687.56s]  Okay, everybody see how that's working?
[2687.56s -> 2689.72s]  Only one of them actually allowed to do that.
[2689.72s -> 2692.64s]  What seems weird about this?
[2692.64s -> 2694.68s]  We've got random numbers in here,
[2694.68s -> 2696.76s]  what seems a little bit weird?
[2696.76s -> 2698.24s]  Why wouldn't it ever be the case
[2698.24s -> 2700.04s]  that two of them could sleep?
[2701.20s -> 2703.00s]  It's a random number for each one.
[2704.20s -> 2705.04s]  Yeah?
[2705.04s -> 2706.72s]  Is the seed of the random number
[2706.72s -> 2708.84s]  you're sharing changed your confidence?
[2708.84s -> 2710.38s]  That's a perfect answer.
[2710.40s -> 2714.00s]  The seed is actually shared between the two processes,
[2714.00s -> 2715.52s]  because everything is shared.
[2715.52s -> 2717.88s]  In other words, random numbers are not really random,
[2717.88s -> 2719.20s]  they're pseudo random numbers,
[2719.20s -> 2720.64s]  which means that there's an algorithm
[2720.64s -> 2723.04s]  which decides which number comes next, okay?
[2723.04s -> 2726.20s]  And it should be seemingly random, okay?
[2726.20s -> 2728.96s]  And what's going on here is we're saying,
[2728.96s -> 2733.26s]  oh, okay, we are both calling the random function
[2733.26s -> 2734.56s]  in two different processes,
[2734.56s -> 2736.82s]  but it's the exact same random generator,
[2736.82s -> 2738.96s]  so the next random number will be the same for both,
[2738.98s -> 2741.72s]  meaning only one of them will end up sleeping.
[2743.34s -> 2744.18s]  Question?
[2744.18s -> 2745.96s]  So that's finding the S random?
[2747.38s -> 2750.62s]  Yeah, so the S random is just seeding the random number
[2750.62s -> 2752.68s]  with the current time, as it turns out.
[2752.68s -> 2754.30s]  Don't worry about random numbers too, too much,
[2754.30s -> 2756.82s]  but a pseudo random number generator says,
[2756.82s -> 2760.34s]  I'm gonna start somewhere in my list of random numbers,
[2760.34s -> 2761.62s]  and I'm gonna start giving you
[2761.62s -> 2763.34s]  what look like random numbers after that,
[2763.34s -> 2765.22s]  and the seed says start here,
[2765.22s -> 2767.78s]  basically the way it works, okay?
[2767.80s -> 2769.54s]  So it's not really random, it's pseudo random,
[2769.54s -> 2771.16s]  but it kind of demonstrates that, oh yeah,
[2771.16s -> 2773.16s]  they both have the same memory, as it turns out.
[2773.16s -> 2774.00s]  Yeah?
[2774.00s -> 2776.52s]  What happens if you comment out the 19?
[2776.52s -> 2778.24s]  What happens if you comment out the 19?
[2778.24s -> 2779.40s]  If you commented out the 19,
[2779.40s -> 2781.92s]  nothing would happen to have been any different,
[2781.92s -> 2784.52s]  except that it would, well, I guess that's not true.
[2784.52s -> 2786.48s]  It would probably do the exact same thing every time,
[2786.48s -> 2787.80s]  because the random number generator
[2787.80s -> 2790.24s]  starts at a particular value every time,
[2790.24s -> 2792.04s]  and we can see if that's the case.
[2792.04s -> 2793.56s]  We can try it and see if that'll do it.
[2793.56s -> 2796.12s]  In other words, no matter when you start a program,
[2796.14s -> 2799.66s]  it's going to do that, so let's see.
[2799.66s -> 2803.74s]  If we run parent child, looks like the parent slept,
[2803.74s -> 2806.18s]  the parent slept, the parent slept,
[2806.18s -> 2807.62s]  so it's gonna be the same one every time.
[2807.62s -> 2809.62s]  We could probably print out the random number,
[2809.62s -> 2811.66s]  and it's gonna be the same one every time.
[2811.66s -> 2812.50s]  Yeah?
[2812.50s -> 2816.54s]  Why isn't the parent sleeping when it goes slow like that?
[2816.54s -> 2818.66s]  Why isn't the parent sleeping when it goes slow like that?
[2818.66s -> 2819.54s]  Good question.
[2819.54s -> 2821.50s]  What's the code look like?
[2821.50s -> 2822.58s]  Right, the code says,
[2822.58s -> 2823.96s]  I'm gonna take this back out again,
[2823.96s -> 2825.14s]  or put that back in again.
[2825.56s -> 2828.32s]  It says, if you are the parent,
[2828.32s -> 2830.84s]  or if the random number equals what the parent is,
[2830.84s -> 2832.40s]  in other words, if the parent is one,
[2832.40s -> 2835.00s]  then the random number's one, then sleep.
[2835.00s -> 2837.36s]  Otherwise, the other one has to be the one sleeping,
[2837.36s -> 2838.36s]  which is the child.
[2839.76s -> 2842.22s]  And remember, the parent is the one
[2842.22s -> 2844.50s]  that is not going to even print,
[2844.50s -> 2846.92s]  I get printed twice until after the child ends,
[2846.92s -> 2848.96s]  so if it's sleeping, it's gonna wait
[2848.96s -> 2852.02s]  until the child prints it, and then the parent does.
[2852.02s -> 2852.86s]  Make sense?
[2853.86s -> 2855.44s]  Let's look at it again.
[2855.44s -> 2856.28s]  Yeah, question?
[2856.28s -> 2859.08s]  Does sleep sleep both the parent and the child,
[2859.08s -> 2860.40s]  or just the parent?
[2860.40s -> 2862.84s]  The sleep has to just sleep the parent, right?
[2862.84s -> 2865.56s]  Because it's only whatever process it's in.
[2865.56s -> 2867.28s]  Okay, let's look at it again here.
[2867.28s -> 2869.52s]  Parent, child, okay, I'm gonna need to print it once,
[2869.52s -> 2873.28s]  and then the child got printed beforehand.
[2873.28s -> 2874.72s]  You could see that it waited a little bit,
[2874.72s -> 2877.12s]  then the child got printed immediately, right?
[2877.12s -> 2879.00s]  And now it's gonna be, well, in this case,
[2879.00s -> 2880.94s]  it's always gonna be the child is gonna print.
[2880.94s -> 2882.24s]  No, it's not necessarily.
[2882.96s -> 2887.08s]  It is, let's see, did I make it again?
[2887.08s -> 2888.74s]  Hang on, hang on.
[2891.84s -> 2893.16s]  Did I make it again?
[2893.16s -> 2895.00s]  I thought I did.
[2895.00s -> 2897.24s]  Oh, I did, hang on.
[2897.24s -> 2899.64s]  Parent, child, I need to print it once.
[2899.64s -> 2900.64s]  Let's try to get it there, guys.
[2900.64s -> 2904.14s]  Okay, so the child got printed at that time immediately
[2904.14s -> 2906.40s]  because it didn't sleep, right?
[2906.40s -> 2907.60s]  It's always gonna be in this order
[2907.60s -> 2909.74s]  because the parent has to wait until the child prints,
[2909.74s -> 2912.36s]  but whether or not the child prints immediately
[2912.74s -> 2915.30s]  or waits a second is the difference.
[2915.30s -> 2916.48s]  Does that help?
[2918.12s -> 2919.14s]  Let's look at it again.
[2919.14s -> 2921.06s]  I mean, just quick, let's just look at it again.
[2921.06s -> 2923.74s]  If you, and this is the logic part
[2923.74s -> 2926.78s]  that you definitely need to kind of understand.
[2926.78s -> 2930.74s]  Okay, if the parent ends up having to sleep,
[2930.74s -> 2931.56s]  that's your question in a minute.
[2931.56s -> 2933.50s]  If the parent does have to sleep,
[2933.50s -> 2935.70s]  then the parent will sleep
[2935.70s -> 2937.86s]  and the child will immediately print it.
[2938.98s -> 2941.62s]  That make sense, everyone, does that make sense?
[2941.64s -> 2943.92s]  If the child is the one that sleeps,
[2943.92s -> 2946.84s]  both of them have to wait until the child prints it
[2946.84s -> 2948.52s]  because the parent is definitely waiting for the child.
[2948.52s -> 2950.80s]  So the parent has to wait anyway,
[2950.80s -> 2952.92s]  but only because the child hasn't finished yet,
[2952.92s -> 2955.00s]  not because it's sleeping.
[2955.00s -> 2955.84s]  Yeah?
[2955.84s -> 2957.64s]  Can you tell the child that you wanted
[2957.64s -> 2960.68s]  to use a random number in both of them?
[2960.68s -> 2963.72s]  How would you actually feed the random generators
[2963.72s -> 2964.96s]  in each time, right?
[2964.96s -> 2965.80s]  Yeah, good question.
[2965.80s -> 2968.40s]  If you wanted to use the,
[2968.40s -> 2970.32s]  if you wanted to have a random number in both
[2970.32s -> 2971.34s]  that was different,
[2971.34s -> 2974.34s]  you would seed the random number generator after the fork.
[2974.34s -> 2975.70s]  But can you actually tell time
[2975.70s -> 2977.74s]  because it's very technically the same?
[2977.74s -> 2979.18s]  Oh, that's a good question.
[2979.18s -> 2980.46s]  Can you actually use time
[2980.46s -> 2982.18s]  because it would probably be the same time?
[2982.18s -> 2983.66s]  Yeah, that's gonna be a little bit of trouble too.
[2983.66s -> 2985.50s]  You'd have to figure out some other way
[2985.50s -> 2987.38s]  to get a different seed
[2987.38s -> 2988.98s]  and time would not be the best one.
[2988.98s -> 2991.06s]  Yeah, there are other ways to get seeds,
[2991.06s -> 2993.54s]  but that's a good point, very good point, yeah.
[2993.54s -> 2994.42s]  Question over here.
[2994.42s -> 2996.58s]  Yeah, sorry, would you mind explaining
[2996.88s -> 3000.64s]  why it only forces only the parent or the child to sleep?
[3000.64s -> 3001.74s]  Yeah, so the question is,
[3001.74s -> 3003.40s]  why does it only make the parent or the child?
[3003.40s -> 3005.52s]  Okay, you will agree that,
[3005.52s -> 3006.52s]  hopefully you'll agree at this point
[3006.52s -> 3009.68s]  that both share the same exact memory,
[3009.68s -> 3012.24s]  meaning that the random number generator in both
[3012.24s -> 3014.80s]  is gonna give the same number, okay?
[3014.80s -> 3018.84s]  One of them, based on the PID value that gets back,
[3018.84s -> 3021.02s]  is either the parent ones the child.
[3021.02s -> 3022.96s]  This line right here says,
[3026.60s -> 3030.28s]  if the number mod two equals the parent, right,
[3030.28s -> 3032.40s]  then sleep for one,
[3032.40s -> 3034.20s]  meaning that if it's a parent and the mod number
[3034.20s -> 3036.74s]  then the number was one, then it would sleep.
[3036.74s -> 3039.40s]  If it's a child, it would not, but it can't be both
[3039.40s -> 3042.52s]  because they're both gonna have different Boolean values.
[3042.52s -> 3044.28s]  Parent and child are both different Boolean values.
[3044.28s -> 3046.12s]  There was a question up here, yeah.
[3046.12s -> 3046.96s]  So I have a question.
[3046.96s -> 3049.60s]  Based on the way this code is written,
[3050.88s -> 3053.04s]  so we can't talk all the results
[3053.04s -> 3058.04s]  because not both of them are sleeping, right?
[3058.22s -> 3060.30s]  Correct, only one of them is sleeping, yes.
[3060.30s -> 3061.90s]  Yeah, but we can talk without that,
[3061.90s -> 3063.68s]  at least one of them is sleeping.
[3063.68s -> 3065.62s]  At least one of them is sleeping, yes, absolutely.
[3065.62s -> 3067.32s]  So one of them is absolutely sleeping
[3067.32s -> 3070.14s]  because they're both different Boolean values.
[3070.14s -> 3070.98s]  Good, yes.
[3070.98s -> 3072.58s]  What's the mod two doing here?
[3072.58s -> 3073.70s]  What's the mod two doing?
[3073.70s -> 3076.58s]  The random function call gives you a number
[3076.58s -> 3079.18s]  between zero and two to the 32 minus one.
[3079.18s -> 3081.30s]  Whoever's trying to make it between zero and one.
[3081.32s -> 3083.56s]  So, the number of mod two is between zero and one.
[3083.56s -> 3084.40s]  Yes?
[3084.40s -> 3085.24s]  If you sleep for longer,
[3085.24s -> 3089.04s]  does the child come in when the child wakes up?
[3089.04s -> 3091.24s]  If you sleep for longer, could the child wake?
[3091.24s -> 3094.48s]  Yes, the child actually almost always does
[3094.48s -> 3096.00s]  when you're sleeping.
[3096.00s -> 3096.96s]  Yeah, let's do this.
[3096.96s -> 3100.24s]  Here, one thing we can check is, let's see.
[3100.24s -> 3103.60s]  If parent, let's see.
[3103.60s -> 3106.26s]  If parent, here's what we're gonna do.
[3106.26s -> 3107.70s]  We're gonna change this a little bit
[3107.70s -> 3112.70s]  and we're gonna say int PID return equals wait PID.
[3115.24s -> 3117.12s]  And we're gonna just print it out and see what happens.
[3117.12s -> 3119.80s]  Print f PID return.
[3120.80s -> 3121.96s]  It may actually, you know what,
[3121.96s -> 3125.84s]  it may actually always give the value of the child.
[3125.84s -> 3127.04s]  I think it actually will.
[3127.04s -> 3128.48s]  It may give negative one, we'll find out
[3128.48s -> 3129.32s]  if it's already ended.
[3129.32s -> 3131.32s]  But I think it's gonna,
[3131.32s -> 3132.32s]  I think this is not gonna be
[3132.32s -> 3133.16s]  what I thought it was gonna be.
[3133.16s -> 3137.24s]  But anyway, PID return like that.
[3138.08s -> 3139.28s]  Yeah, that should do it.
[3139.28s -> 3143.68s]  And let's see, make parent child, parent child.
[3143.68s -> 3148.44s]  Okay, return is that one and then now it's waiting.
[3148.44s -> 3150.76s]  No, it will always, it looks like it will always
[3150.76s -> 3152.64s]  give back to parent the child's one,
[3152.64s -> 3154.16s]  even if it's already ended.
[3154.16s -> 3155.48s]  In fact, it would return immediately
[3155.48s -> 3157.08s]  if the child has already ended.
[3158.36s -> 3160.52s]  All right, anything else on that one?
[3160.52s -> 3161.60s]  Fun stuff, huh?
[3161.60s -> 3163.30s]  We're getting there on this stuff.
[3163.30s -> 3164.14s]  Okay.
[3164.14s -> 3169.14s]  So what happens when we want to have multiple children?
[3171.44s -> 3173.88s]  Okay, if we have multiple children,
[3173.88s -> 3177.48s]  then we can actually wait for all of them.
[3177.48s -> 3180.52s]  Okay, and we can wait for all of them
[3180.52s -> 3184.12s]  by using negative one as the PID,
[3184.12s -> 3188.54s]  as the first parameter in PID, or wait PID,
[3188.54s -> 3190.60s]  which means wait for any child.
[3190.60s -> 3192.52s]  Okay, and if a child has ended,
[3192.54s -> 3195.62s]  return to me and give me the PID and so forth.
[3195.62s -> 3196.46s]  Okay.
[3197.62s -> 3200.34s]  Any, it's absolute to any child.
[3200.34s -> 3202.38s]  So you're gonna see we're gonna do this in a while loop
[3202.38s -> 3203.22s]  and it's gonna say, okay,
[3203.22s -> 3204.40s]  we're gonna wait for all the children.
[3204.40s -> 3207.18s]  You'll see as we do this.
[3207.18s -> 3209.98s]  So reap as they exit dot C.
[3209.98s -> 3211.94s]  Okay, here's what we're gonna do.
[3211.94s -> 3215.78s]  Okay, we are going to do the fun.
[3215.78s -> 3217.30s]  We're gonna create eight children.
[3217.30s -> 3222.30s]  For size T i equals zero, i is less than zero.
[3222.54s -> 3227.14s]  And eight, i plus plus, okay.
[3227.14s -> 3232.14s]  If fork, okay, equals equals zero,
[3232.38s -> 3233.34s]  what's that mean?
[3234.30s -> 3235.98s]  The child, okay.
[3235.98s -> 3240.62s]  We're gonna exit with a value of 110 plus i.
[3240.62s -> 3241.98s]  So we'll get a different return value
[3241.98s -> 3245.46s]  for each one of those, 110, 111, 112, et cetera.
[3245.46s -> 3248.44s]  Okay, and then that should do it.
[3248.44s -> 3249.82s]  So we'll always exit there.
[3249.82s -> 3251.72s]  And we're gonna do eight of those.
[3251.94s -> 3252.78s]  Question?
[3252.78s -> 3254.86s]  Yeah, is there a reason why you're using exit
[3254.86s -> 3258.30s]  instead of just going return 110 plus i?
[3259.50s -> 3261.00s]  You could do return 110 plus i.
[3261.00s -> 3263.92s]  We normally exit out of the children instead of return.
[3263.92s -> 3266.22s]  It doesn't really matter as it turns out.
[3266.22s -> 3268.38s]  But yeah, that's a good question.
[3268.38s -> 3269.92s]  We normally do that.
[3269.92s -> 3270.76s]  Okay, so we're gonna do that.
[3270.76s -> 3273.66s]  And then now we're going to say, okay, fine.
[3273.66s -> 3275.90s]  We are going to do while.
[3275.90s -> 3277.54s]  We're gonna do a while true in this case
[3277.54s -> 3278.94s]  because I'm gonna demonstrate something else for you.
[3278.94s -> 3279.98s]  We could search for it.
[3280.00s -> 3282.28s]  We could wait for all of them
[3282.28s -> 3284.88s]  because we know there's gonna be eight of them in this case.
[3284.88s -> 3286.00s]  But we're gonna just do this.
[3286.00s -> 3291.00s]  Status PIDT PID equals wait PID negative one.
[3293.84s -> 3296.52s]  And we're gonna pass in the status like we did there.
[3296.52s -> 3298.80s]  And then zero, okay.
[3298.80s -> 3301.56s]  And then we're gonna look and if we find out
[3301.56s -> 3305.24s]  that if PID equals negative one,
[3305.24s -> 3307.36s]  well that means there were no more children to wait for
[3307.38s -> 3311.26s]  so we can stop our while loop in this case, okay.
[3311.26s -> 3313.06s]  And what we actually wanna do in this case,
[3313.06s -> 3313.94s]  you don't always have to do this
[3313.94s -> 3315.68s]  but it's a little bit of error checking.
[3315.68s -> 3317.90s]  We're gonna assert in this case
[3317.90s -> 3321.12s]  that the error number equals each child.
[3321.12s -> 3322.78s]  I'll tell you what that is in a second.
[3322.78s -> 3324.74s]  And then we're gonna break, okay.
[3324.74s -> 3327.40s]  What we're doing here is we're saying,
[3327.40s -> 3329.50s]  well the return value is negative one.
[3329.50s -> 3332.58s]  Technically, if the return value is negative one,
[3332.58s -> 3334.92s]  yes, it meant that there were no more children.
[3334.92s -> 3336.76s]  But it also could mean,
[3337.02s -> 3340.26s]  hey there's an actual error here in your wait PID call.
[3340.26s -> 3341.54s]  It's kind of overloaded.
[3341.54s -> 3343.90s]  So it's got a wait PID, it's got an error.
[3343.90s -> 3345.48s]  It definitely could be an error
[3345.48s -> 3348.98s]  but what it does is it sets error no to each child
[3348.98s -> 3351.26s]  which means the reason I gave you an error
[3351.26s -> 3352.98s]  is because there were no more children left.
[3352.98s -> 3356.02s]  And if you check that, then that's actually okay.
[3356.02s -> 3358.78s]  In fact, it works perfectly for our purposes.
[3358.78s -> 3362.42s]  Okay, yes it's an error but oh, it's the child issue?
[3362.42s -> 3365.26s]  Fine, let's just go ahead and go on.
[3365.28s -> 3368.08s]  Okay, so that's what we're doing with that one, okay.
[3368.08s -> 3373.08s]  And then we should just check our W if exited,
[3374.16s -> 3376.36s]  status here, okay.
[3376.36s -> 3381.36s]  And then let's print child percent D exited,
[3383.02s -> 3386.44s]  status percent D,
[3386.44s -> 3391.44s]  and let's do the PID and the exit status.
[3391.50s -> 3395.34s]  So you can get the exit status from the status itself
[3395.34s -> 3399.90s]  which will be the return value for the child, okay.
[3399.90s -> 3401.72s]  And then it looks like I have something wrong here.
[3401.72s -> 3402.56s]  Hold on, let's see.
[3402.56s -> 3405.90s]  Print child extra that, child extra status that,
[3405.90s -> 3407.96s]  PID, W exit status.
[3411.58s -> 3414.82s]  Wave, I did it, there we go, okay.
[3414.82s -> 3415.66s]  How's that?
[3415.66s -> 3416.50s]  That'll probably do it but I don't think
[3416.50s -> 3417.34s]  that's the actual, I don't know
[3417.34s -> 3419.42s]  if that's the actual issue there.
[3419.42s -> 3421.10s]  Oh, there's a bracket, yeah.
[3421.60s -> 3426.60s]  And then else and then print child percent D exited abnormally.
[3434.72s -> 3437.40s]  And we'll give it just PID
[3437.40s -> 3438.68s]  because there's nothing else there
[3438.68s -> 3442.40s]  and that should do it and then our return zero.
[3442.40s -> 3444.92s]  Okay, so let's see what happens when we do this.
[3444.92s -> 3446.44s]  Whoops, that I don't wanna do.
[3446.44s -> 3448.76s]  Okay, anybody ever done that where they encrypt their file?
[3448.76s -> 3450.16s]  It's bad, let me try to do it.
[3450.18s -> 3454.10s]  Okay, make reap as they exit.
[3454.10s -> 3457.70s]  Okay, reap as they exit and what should happen
[3457.70s -> 3461.54s]  is it does 10, 11, 12, 13, 14, 15, 16, 17
[3461.54s -> 3463.26s]  but let's do it again.
[3463.26s -> 3466.66s]  Let's see, 10, 11, 12, there we go.
[3466.66s -> 3468.86s]  Okay, finally I got it in the wrong order.
[3468.86s -> 3471.50s]  10, 11, 12, 16, 13, 17, 14, 15.
[3471.50s -> 3473.54s]  This is not in a particular order
[3473.54s -> 3477.42s]  because we are saying wait for any child to exit.
[3477.44s -> 3480.44s]  Any one of those children could exit before any other one
[3480.44s -> 3482.96s]  although it's likely that the one that came first
[3482.96s -> 3485.60s]  exits first because it's just farther along
[3485.60s -> 3488.24s]  in the process but it's not guaranteed.
[3488.24s -> 3492.52s]  So we can still get some non-deterministic behavior here.
[3492.52s -> 3495.36s]  Okay, everyone see what's happening there.
[3495.36s -> 3498.80s]  Negative one for weight PID does that for you.
[3500.16s -> 3503.80s]  Okay, all right, let us say wait,
[3503.80s -> 3506.76s]  what if we wanted to actually wait for them in order?
[3506.90s -> 3508.54s]  Could we wait for them in order?
[3508.54s -> 3512.62s]  Okay, we certainly, this is what it does do by the way.
[3512.62s -> 3514.46s]  This is what does that.
[3514.46s -> 3516.82s]  Then I said talk about error number and all that.
[3516.82s -> 3518.74s]  What if we did want to wait for them in order?
[3518.74s -> 3520.96s]  Let's take a look at another program.
[3522.06s -> 3525.20s]  This one's going to be reaped in fork order
[3525.20s -> 3526.46s]  because we want to actually do it
[3526.46s -> 3530.66s]  in the order they are in, okay.
[3530.66s -> 3532.28s]  So let's do same sort of thing
[3532.28s -> 3534.92s]  except now if we want to wait for them in order
[3534.96s -> 3537.98s]  we better know what the order is, okay.
[3537.98s -> 3540.50s]  So we probably want to do something like
[3540.50s -> 3545.50s]  PID t children array of eight, right.
[3546.34s -> 3548.14s]  Because now we need to keep track of all the PIDs
[3548.14s -> 3550.14s]  if we're going to wait for them in order.
[3550.14s -> 3555.14s]  We're going to have a same size t i equals zero,
[3556.10s -> 3561.02s]  i is less than eight, i plus plus
[3561.60s -> 3566.60s]  and then we are going to do status in here PID t,
[3571.44s -> 3573.40s]  sorry wrong one here.
[3573.40s -> 3576.08s]  In this case we're just going to create them all here.
[3576.08s -> 3581.08s]  If children of i equals fork, fork equals zero
[3587.38s -> 3588.96s]  that means we're the child, okay.
[3588.98s -> 3593.78s]  But we're storing the PID to the parent if we're not zero,
[3593.78s -> 3595.78s]  okay so we also stored in the child
[3595.78s -> 3598.14s]  but it doesn't matter as it turns out, okay.
[3598.14s -> 3603.14s]  We're going to exit one ten plus i in that case, okay.
[3603.58s -> 3606.78s]  All right and then we're going to do,
[3606.78s -> 3608.02s]  now we're going to go through them all
[3608.02s -> 3610.60s]  for another size t i equals zero.
[3610.60s -> 3612.42s]  Not a while true loop is this case
[3612.42s -> 3613.94s]  although you could probably make it work
[3613.94s -> 3615.98s]  if you really wanted to, okay.
[3616.08s -> 3621.08s]  And in this case we are going to now do PID t,
[3621.24s -> 3626.24s]  PID equals wait PID for a particular child i,
[3629.20s -> 3632.60s]  status zero, okay.
[3632.60s -> 3634.32s]  Let's assert that we got the right child
[3634.32s -> 3635.92s]  even though we almost always would,
[3635.92s -> 3640.92s]  well PID equals equals children i, okay.
[3641.08s -> 3644.36s]  And then assert, we're not waiting for anyone,
[3644.38s -> 3645.94s]  we're waiting for a specific one right now.
[3645.94s -> 3650.84s]  And let's do exited status again,
[3650.84s -> 3651.68s]  we're going to just kind of check
[3651.68s -> 3653.30s]  a couple things at once here.
[3653.30s -> 3658.30s]  W exit status, status equals one ten plus,
[3660.62s -> 3665.02s]  this is like lots of extra checking just in case here,
[3665.02s -> 3670.02s]  okay and then we're going to print child with PID percent d
[3671.00s -> 3676.00s]  is accounted for and return status of percent d.
[3682.56s -> 3687.56s]  Period, new line, children i and we'll give
[3690.20s -> 3695.00s]  the actual status of it which is the return value.
[3695.00s -> 3696.76s]  Okay and that's that.
[3696.76s -> 3697.60s]  Say again.
[3698.02s -> 3701.04s]  I do not need to initialize stat,
[3701.04s -> 3703.18s]  oh I need to declare it, I do indeed need to declare it.
[3703.18s -> 3704.54s]  I don't need to initialize though.
[3704.54s -> 3705.90s]  Thank you, thank you, thank you.
[3705.90s -> 3707.76s]  Okay, anybody else issues?
[3707.76s -> 3708.70s]  Let's try it.
[3708.70s -> 3712.42s]  Make reap in fork order, okay looks good.
[3712.42s -> 3715.66s]  Now in this case it has to wait for each one
[3715.66s -> 3719.90s]  so we are going to always get them in order.
[3719.90s -> 3722.34s]  This is waiting for one ten, then one eleven,
[3722.34s -> 3723.90s]  then one twelve, et cetera.
[3723.90s -> 3726.20s]  And all of them might be ending in different orders.
[3726.22s -> 3729.82s]  It's just going to eventually reap the process.
[3729.82s -> 3731.14s]  In other words, wait PID is going to work.
[3731.14s -> 3733.30s]  Specifically going to ask for a specific one
[3733.30s -> 3735.90s]  and it's going to return and say yes, you got it.
[3736.82s -> 3740.06s]  Okay, what questions do you have on that?
[3740.06s -> 3740.90s]  Yeah.
[3740.90s -> 3742.86s]  Can you go back just a while to the line
[3742.86s -> 3744.70s]  where you said if statement,
[3744.70s -> 3748.14s]  when you assign the fork to the children
[3748.14s -> 3752.90s]  and populate the step with the PID number, right?
[3752.90s -> 3756.06s]  So then how does that equal zero?
[3756.92s -> 3758.32s]  That's a very good question and you have to be careful.
[3758.32s -> 3760.72s]  The question was doesn't it populate
[3760.72s -> 3764.44s]  the children array with the PID?
[3764.44s -> 3768.76s]  Only for the parent, it gives it the child's PID.
[3768.76s -> 3771.88s]  Remember, what is the child's PID?
[3771.88s -> 3774.68s]  Or what's the result of fork for the child?
[3775.52s -> 3776.72s]  Zero.
[3776.72s -> 3779.44s]  It is not the child's PID.
[3779.44s -> 3782.00s]  It's only zero if you are the child.
[3782.00s -> 3783.84s]  So in this case, I kind of briefly mentioned this.
[3783.86s -> 3786.54s]  In this case, yeah, it's putting a zero in there
[3786.54s -> 3789.42s]  for the child's version of that array,
[3789.42s -> 3790.50s]  but we're going to ignore it.
[3790.50s -> 3793.78s]  We don't care, except to say is it zero or not.
[3793.78s -> 3795.26s]  What, you got a follow up?
[3795.26s -> 3796.10s]  Yeah.
[3796.10s -> 3796.92s]  Yeah.
[3796.92s -> 3800.78s]  In this order, then when you wait for children I,
[3800.78s -> 3802.54s]  you know it's going to be zero.
[3802.54s -> 3803.94s]  Ah, good question.
[3803.94s -> 3805.62s]  When you wait for children I down here,
[3805.62s -> 3807.30s]  isn't always going to be zero.
[3807.30s -> 3809.66s]  There are two arrays every time you fork now.
[3809.66s -> 3812.06s]  There's a parent array, you fork,
[3812.06s -> 3813.74s]  the child has its own version of the array,
[3814.68s -> 3816.40s]  and the parent still has its same version as before.
[3816.40s -> 3818.88s]  It gets the, the parent gets the child PID,
[3818.88s -> 3821.76s]  the child gets zero, but it's initially,
[3821.76s -> 3823.28s]  immediately exits.
[3824.12s -> 3824.96s]  Oh, it works, yeah.
[3824.96s -> 3826.82s]  This is why I want to be really careful about,
[3826.82s -> 3829.52s]  that return value for fork is not a PID,
[3829.52s -> 3830.68s]  except for the parent.
[3830.68s -> 3833.16s]  It's only the child's PID for the parent.
[3833.16s -> 3835.26s]  It is always zero for the child.
[3835.26s -> 3837.36s]  If the child wants its PID for some reason,
[3837.36s -> 3838.76s]  it has to call get PID.
[3839.92s -> 3840.76s]  Question.
[3840.88s -> 3844.02s]  None of the children ever do the second for loop.
[3844.02s -> 3846.70s]  None of the children ever do the second for loop, exactly.
[3846.70s -> 3848.06s]  Yep, good question.
[3848.06s -> 3848.90s]  Yes.
[3857.98s -> 3860.42s]  Some of the children have already exited, yes.
[3860.42s -> 3862.38s]  In fact, most of them after the first couple loops
[3862.38s -> 3863.94s]  have probably already exited.
[3865.66s -> 3868.02s]  You can wait for a child after it's exited,
[3868.02s -> 3868.94s]  and it still returns the value.
[3868.94s -> 3870.50s]  We tested that a little earlier.
[3871.08s -> 3871.90s]  Good question.
[3871.90s -> 3872.74s]  Yeah.
[3883.16s -> 3885.68s]  No, yes, it could.
[3885.68s -> 3887.80s]  Sure, yeah, this is a good question.
[3887.80s -> 3891.88s]  Could the, could the child, the sixth or seventh child
[3891.88s -> 3894.04s]  see all the values of the PIDs for the previous,
[3894.04s -> 3896.00s]  sure, it's still the, before that it's still the
[3896.00s -> 3899.24s]  parent's, it's the same, it's the, yeah,
[3899.24s -> 3901.78s]  the parent keeps it and keeps populating it, so sure.
[3901.78s -> 3903.98s]  Now you're not trying to hide that from the children.
[3903.98s -> 3906.62s]  It wouldn't be in that case, good question.
[3906.62s -> 3907.46s]  Yeah.
[3916.54s -> 3918.94s]  Would you, why can you wait for a child after it's exited
[3918.94s -> 3921.30s]  and wouldn't you want to reuse that child
[3921.30s -> 3923.34s]  for a process or something else?
[3923.34s -> 3926.50s]  It hasn't been cleaned up yet until wait PID is called.
[3926.50s -> 3927.70s]  So you're still waiting for it.
[3927.72s -> 3930.24s]  In fact, there is some extra overhead
[3930.24s -> 3932.00s]  because it hasn't been cleaned up yet.
[3932.00s -> 3934.08s]  That's really the difference.
[3934.08s -> 3935.68s]  Once it ends, it's waiting for somebody
[3935.68s -> 3937.52s]  to do a wait PID on it, basically.
[3938.52s -> 3940.32s]  That's the cleanup process, yeah.
[3945.52s -> 3947.36s]  Yeah, why doesn't the first four of them create a tree?
[3947.36s -> 3949.00s]  You tell me, what's happening
[3949.00s -> 3950.16s]  in this first one right here?
[3950.16s -> 3951.52s]  What happens at each child?
[3951.52s -> 3953.32s]  What does each child immediately do?
[3954.88s -> 3957.52s]  Dies, so it never gets to the next loop, right?
[3957.58s -> 3958.40s]  Because it exits.
[3960.74s -> 3962.66s]  All right, good.
[3962.66s -> 3964.14s]  This is like, you can see why this stuff
[3964.14s -> 3966.30s]  is like challenging to get the first time,
[3966.30s -> 3968.90s]  first couple of times you see it, okay?
[3968.90s -> 3971.18s]  This is what it is ever, in theory,
[3971.18s -> 3974.26s]  you could have any of the children end in any order,
[3974.26s -> 3976.06s]  but the loop is still gonna be held up
[3976.06s -> 3977.78s]  waiting for that first child to end,
[3977.78s -> 3980.30s]  then the second, then the third, then the fourth.
[3980.30s -> 3984.30s]  That's just the way these ones work, okay?
[3984.30s -> 3985.30s]  All right.
[3985.32s -> 3989.96s]  So, that's fork.
[3989.96s -> 3993.60s]  Now, we have showed some interesting examples of fork,
[3993.60s -> 3994.68s]  and how you've got your program
[3994.68s -> 3996.00s]  going in different directions,
[3996.00s -> 3998.12s]  and you've got your code in the child
[3998.12s -> 4001.04s]  and your code in the parent, and so forth.
[4001.04s -> 4005.00s]  It turns out that most times you use fork,
[4005.00s -> 4008.20s]  it is not going to be to do your code
[4008.20s -> 4010.60s]  in both the parent and the child.
[4010.60s -> 4013.00s]  It turns out that what normally happens
[4013.00s -> 4017.62s]  is we are going to make another program run,
[4017.62s -> 4022.10s]  we're gonna set some other program off to run
[4022.10s -> 4024.70s]  such that it does its thing,
[4024.70s -> 4027.50s]  and we may or may not capture the output,
[4027.50s -> 4030.02s]  but we actually are running some other program.
[4030.02s -> 4032.30s]  That was kind of the original reason.
[4032.30s -> 4035.38s]  Fork a process, have the other process, the child,
[4035.38s -> 4037.12s]  run some other program.
[4037.12s -> 4038.60s]  That's mainly what it's for.
[4038.60s -> 4039.98s]  You can do what we've been doing,
[4039.98s -> 4041.84s]  where we show these kind of interesting tree examples
[4041.98s -> 4043.26s]  and interesting child,
[4043.26s -> 4046.26s]  but most of the time, this is what we're gonna be doing.
[4046.26s -> 4048.70s]  We're gonna run a completely separate program,
[4048.70s -> 4051.62s]  and we may or may not capture its standard out,
[4051.62s -> 4053.14s]  and we may or may not send it
[4053.14s -> 4054.78s]  information in standard in.
[4056.10s -> 4058.50s]  This is what your shell does.
[4058.50s -> 4063.50s]  When you type LS in your shell,
[4065.30s -> 4068.58s]  well, what happens is the shell is a program,
[4068.58s -> 4070.06s]  and when you type LS,
[4070.08s -> 4072.04s]  it takes that and says,
[4072.04s -> 4075.36s]  oh, okay, there's a program called LS on the system,
[4075.36s -> 4077.72s]  and it runs that program, waits for it to end,
[4077.72s -> 4080.04s]  and gives you a prompt back.
[4080.04s -> 4082.96s]  That's what's happening with the shell.
[4082.96s -> 4084.40s]  So the shell is doing exactly this.
[4084.40s -> 4086.28s]  It's doing what we call forking,
[4086.28s -> 4091.28s]  and then EXECVP, which is another system call,
[4092.48s -> 4095.48s]  and this system call does the following.
[4095.48s -> 4099.12s]  It basically reboots the process
[4099.12s -> 4101.94s]  with some other program, okay?
[4101.94s -> 4103.66s]  And this is one way to do it,
[4103.66s -> 4106.06s]  and in fact, kind of the default way to do it,
[4106.06s -> 4107.50s]  and that paper I showed you earlier
[4107.50s -> 4108.98s]  is probably complaining about this.
[4108.98s -> 4110.98s]  It's complaining about like, why have we do it this way?
[4110.98s -> 4112.86s]  There's other better ways of doing this and so forth,
[4112.86s -> 4114.50s]  but this is what it does.
[4114.50s -> 4119.22s]  EXEC CVP, it's basically a family of commands,
[4119.22s -> 4123.28s]  all called EXEC, as in execute, I guess,
[4123.28s -> 4125.62s]  and the VP happens to be a certain variety
[4125.62s -> 4126.64s]  that we're gonna use.
[4126.64s -> 4128.06s]  You can go look up all the other ones.
[4128.08s -> 4133.08s]  If you type man EXECVP, man EXEC CVP,
[4137.32s -> 4139.88s]  you can see that it actually shows a whole bunch of them.
[4139.88s -> 4142.94s]  EXECL, EXECLP, and so forth.
[4142.94s -> 4144.88s]  The one we use, and it's just so you can have
[4144.88s -> 4146.88s]  different environment variables and everything,
[4146.88s -> 4148.32s]  not really that important.
[4148.32s -> 4150.04s]  The one we're gonna use and focus on
[4150.04s -> 4154.56s]  is EXECVP, which basically takes a path
[4154.56s -> 4157.22s]  and then takes an argument array,
[4157.22s -> 4162.22s]  just like argv, and it runs the program
[4162.80s -> 4165.98s]  at that path with the argument string
[4165.98s -> 4168.92s]  or array passed into it, okay?
[4168.92s -> 4172.76s]  As it turns out, just like all your other
[4172.76s -> 4177.28s]  regular programs, the path and argv zero
[4177.28s -> 4179.88s]  are gonna be the same, because the first argument
[4179.88s -> 4183.24s]  in argv is always the name of the program,
[4183.24s -> 4185.98s]  so therefore we're gonna have the name of the program
[4185.98s -> 4190.52s]  as the path, which is also the same as argv zero, okay?
[4190.52s -> 4192.04s]  So that's just the way that works.
[4192.04s -> 4194.48s]  And all it does is it runs it,
[4194.48s -> 4198.70s]  and it basically takes over that process,
[4198.70s -> 4201.08s]  runs that program in it, and that's that.
[4201.08s -> 4203.28s]  Now what's interesting about this is
[4203.28s -> 4205.66s]  if it doesn't work, like let's say you gave it
[4205.66s -> 4207.44s]  a bad path and the path didn't work,
[4207.44s -> 4209.28s]  it would not actually run anything.
[4209.28s -> 4211.68s]  It would return to you and give you an error message,
[4211.68s -> 4213.76s]  or an error return value of negative one,
[4213.78s -> 4214.98s]  and you can capture that and say,
[4214.98s -> 4216.90s]  oh, there was an error, okay?
[4216.90s -> 4219.10s]  If it does succeed, like in other words,
[4219.10s -> 4222.22s]  if it runs that program, it never returns
[4222.22s -> 4223.98s]  to the calling function.
[4223.98s -> 4225.04s]  It just does never return.
[4225.04s -> 4225.88s]  Why?
[4225.88s -> 4226.90s]  Because it's a whole new process.
[4226.90s -> 4229.66s]  Well, it's actually cannibalized the process
[4229.66s -> 4232.52s]  to the extent that it is now the same process
[4232.52s -> 4234.02s]  that you just created with fork,
[4234.02s -> 4237.42s]  except it's its own, got its own everything else, okay?
[4237.42s -> 4240.74s]  So that's what's happening with exe, cvp,
[4240.74s -> 4243.56s]  and Jerry put this in here, he said that hashtag deep,
[4243.56s -> 4246.28s]  right, that it never returns if it succeeds.
[4246.28s -> 4248.80s]  That's the way it goes, okay?
[4248.80s -> 4250.16s]  So that's what exe, cvp does.
[4250.16s -> 4253.54s]  This is mainly the big reason we're gonna use fork,
[4253.54s -> 4258.00s]  is to do that and to call that, okay?
[4258.00s -> 4259.52s]  What example are we gonna do?
[4259.52s -> 4264.52s]  I've got seven minutes, and I guess I can do the whole,
[4264.92s -> 4267.12s]  yeah, it's actually not that bad.
[4267.14s -> 4271.38s]  We're gonna do a little system example, okay?
[4271.38s -> 4273.62s]  We're basically gonna do a tiny little shell.
[4273.62s -> 4276.14s]  If you guys are in cs107e, you know all about shells,
[4276.14s -> 4277.52s]  and you're gonna build one for an assignment
[4277.52s -> 4279.34s]  in this class as well.
[4279.34s -> 4283.98s]  But for right now, we are going to do a tiny little one
[4283.98s -> 4286.26s]  called my system, okay?
[4286.26s -> 4289.38s]  And what it's going to do is it's gonna cheat
[4289.38s -> 4290.22s]  a little bit.
[4290.22s -> 4293.50s]  It's going to use a shell program
[4293.50s -> 4295.62s]  to run a program we give it.
[4295.62s -> 4296.46s]  Why?
[4296.64s -> 4297.84s]  Because you don't want to have to parse out
[4297.84s -> 4300.68s]  the different parts of the command line.
[4300.68s -> 4301.96s]  You'll see what happens when we do this,
[4301.96s -> 4304.04s]  and it's a good first example anyway.
[4304.04s -> 4307.24s]  Okay, we're gonna actually do the my system function
[4307.24s -> 4310.12s]  itself, it's gonna be passed in a command
[4310.12s -> 4312.48s]  that we want to run, okay?
[4312.48s -> 4315.04s]  And here's how it's gonna work, okay?
[4315.04s -> 4317.84s]  PID equals fork.
[4317.84s -> 4319.80s]  So the first thing you do when you do this exe cvp
[4319.80s -> 4321.40s]  is you need another process.
[4321.40s -> 4322.80s]  You don't have to have another process,
[4322.80s -> 4323.62s]  but if you don't have one,
[4323.62s -> 4325.24s]  you never get back to your original program.
[4325.26s -> 4327.26s]  It gets cannibalized, okay?
[4327.26s -> 4331.46s]  If PID equals zero, that means we are the child,
[4331.46s -> 4333.88s]  then what we're going to do in this case
[4333.88s -> 4337.90s]  is we're gonna say, all right, our arguments equals,
[4337.90s -> 4339.84s]  and what we're gonna do is we're going to say,
[4339.84s -> 4342.62s]  run this program called bin slash sh,
[4342.62s -> 4344.90s]  and that's the program that's gonna get run.
[4344.90s -> 4347.50s]  Bin slash sh, if you want to run another program
[4347.50s -> 4349.38s]  from within that, you have to do a command,
[4349.38s -> 4351.50s]  a parameter called dash c,
[4351.50s -> 4355.10s]  and then here's the command itself,
[4355.92s -> 4357.16s]  which you have to make it constant,
[4357.16s -> 4359.20s]  or you have to make it non-constant, as it turns out.
[4359.20s -> 4361.00s]  It'll just be a warning, it doesn't really matter,
[4361.00s -> 4363.36s]  but it's passed in as a constant in that case.
[4363.36s -> 4366.20s]  Command and null, okay?
[4366.20s -> 4370.48s]  You have to end your, it's this one, thank you.
[4370.48s -> 4371.32s]  Sorry about curly breaks.
[4371.32s -> 4373.28s]  That's just creating an array, by the way,
[4373.28s -> 4375.20s]  is really all that's doing, okay?
[4375.20s -> 4378.36s]  And you have to end the last argument with null.
[4378.36s -> 4380.60s]  It's just the way that we do these kind of arrays,
[4380.60s -> 4382.52s]  because they're all strings, we can do that,
[4382.52s -> 4384.64s]  as it turns out, okay?
[4385.18s -> 4386.14s]  So that's what we're gonna do,
[4386.14s -> 4389.06s]  and then at this point, then we can say,
[4389.06s -> 4394.06s]  oh great, exec c v p, the arguments zero,
[4395.38s -> 4399.82s]  which is the bin slash sh, and then arguments,
[4399.82s -> 4403.14s]  and then that will actually do the process, right?
[4403.14s -> 4408.14s]  If we can say print, if we get to this point,
[4408.54s -> 4410.42s]  it means we failed, because why?
[4410.42s -> 4412.54s]  Because it never returns if it doesn't get to this,
[4412.56s -> 4415.80s]  if it doesn't, if it works.
[4415.80s -> 4418.54s]  Okay, failed to invoke,
[4419.80s -> 4424.80s]  failed to invoke slash bin slash sh to execute
[4424.80s -> 4429.80s]  the supplied command, sad face, okay?
[4430.80s -> 4432.96s]  And I guess we should probably do,
[4432.96s -> 4435.02s]  that doesn't really matter, we'll get a new line later.
[4435.02s -> 4437.50s]  Okay, and then exit zero, just to say,
[4437.50s -> 4440.36s]  well, we got it, we have our fork, but we're done.
[4441.02s -> 4445.30s]  And that will do that, if we are the parent,
[4445.30s -> 4447.86s]  what we're gonna do, int status, right?
[4447.86s -> 4450.38s]  Well, we're gonna wait for it, right?
[4450.38s -> 4455.38s]  Wait, PID, PID, status, and zero,
[4456.34s -> 4458.58s]  and, oops, sorry, I'm not going.
[4458.58s -> 4463.58s]  Okay, and then return w if exited status.
[4466.10s -> 4468.94s]  Okay, if that's true, we're gonna say the exit status,
[4470.86s -> 4473.14s]  otherwise, we're gonna return,
[4473.14s -> 4475.94s]  we're gonna return the negative of the termination status,
[4475.94s -> 4479.10s]  which just basically says, well, what happened?
[4479.10s -> 4481.70s]  Don't worry too much about that for that.
[4481.70s -> 4484.26s]  I think it's term sig, yeah, that should be it.
[4484.26s -> 4485.60s]  And then that's that.
[4485.60s -> 4487.54s]  So that's our function, okay?
[4487.54s -> 4492.54s]  Let's write a little kind of a driver for it here, okay?
[4493.06s -> 4495.90s]  And the driver is going to be just the main part
[4495.90s -> 4498.78s]  that's gonna call it, so let's actually set it up.
[4498.80s -> 4500.32s]  Okay, we'll make it like a little terminal,
[4500.32s -> 4502.88s]  it'll just keep going in some loop until you do it.
[4503.88s -> 4508.88s]  Let's see, we wanna do, let's do create a char, command,
[4509.68s -> 4511.88s]  let's make it K max line, let's just say
[4511.88s -> 4514.44s]  you can't type more than 2,048 characters
[4514.44s -> 4516.20s]  in your command, okay?
[4516.20s -> 4518.32s]  And then while true, we're just gonna
[4518.32s -> 4519.72s]  keep doing this forever.
[4521.44s -> 4525.56s]  While true, we're going to print F a little prompt,
[4525.58s -> 4529.22s]  like that, and then use F get S,
[4529.22s -> 4531.94s]  which basically is a nice way of getting
[4531.94s -> 4534.62s]  something from a file descriptor, right?
[4534.62s -> 4535.94s]  And in this case, we're going to,
[4535.94s -> 4538.18s]  or not, it's a kind of a different kind of file
[4538.18s -> 4539.86s]  descriptor, but it's a similar sort of thing.
[4539.86s -> 4543.02s]  K max line, just in case you type too much,
[4543.02s -> 4546.40s]  and then we're gonna get it from standard in,
[4546.40s -> 4548.46s]  which is the way you can do this for this.
[4548.46s -> 4551.86s]  And if, F-E-O-F standard in,
[4551.86s -> 4553.50s]  which basically means if we have the,
[4553.50s -> 4556.84s]  if we've ended, if we do control D, this will end it,
[4556.84s -> 4559.24s]  we're gonna break out of our loop,
[4559.24s -> 4562.46s]  and otherwise, we're gonna say command,
[4563.96s -> 4568.96s]  and we're going to overwrite the last part of the command
[4571.88s -> 4576.88s]  with a zero instead of a new line,
[4577.48s -> 4580.96s]  it gets, you get the new line back, oops, like that,
[4581.90s -> 4584.06s]  okay, we're gonna overwrite the end there,
[4584.06s -> 4585.94s]  and what did I do wrong there?
[4585.94s -> 4588.86s]  Probably forgot to print the thing here, there we go.
[4588.86s -> 4591.72s]  Okay, and then, finally, we're gonna print out,
[4591.72s -> 4596.72s]  print F, return code, and percent D,
[4597.62s -> 4602.62s]  and my system, command, like that.
[4604.38s -> 4607.50s]  Okay, and then we're gonna print a new line,
[4607.50s -> 4612.50s]  and we're going to, we're gonna return to it, okay?
[4612.64s -> 4615.64s]  That is going to, hopefully, if I did everything right,
[4615.64s -> 4620.64s]  make my system, oh no, let's see, expected cost char,
[4625.36s -> 4628.86s]  let's see, hang on, passing argument
[4628.86s -> 4632.94s]  makes a pointer from integer, what did I do here?
[4633.60s -> 4638.60s]  Oh, char star arguments, is that not right?
[4639.24s -> 4640.96s]  I don't wanna keep you guys much longer,
[4640.96s -> 4644.52s]  I just wanna run it for you, hang on, let's see,
[4644.52s -> 4646.96s]  char star, oh, arguments,
[4646.96s -> 4649.00s]  think it needs to be a array, doesn't it?
[4649.00s -> 4654.00s]  Then my system needs to be an array, thank you.
[4658.76s -> 4661.80s]  That should do it, maybe, there we go, okay.
[4661.80s -> 4663.62s]  Now my system will give you a prompt,
[4663.62s -> 4664.46s]  so there's your little prompt,
[4664.46s -> 4667.60s]  and if you type LS, it runs LS, right?
[4667.60s -> 4670.08s]  And there's our prompt, and if we say,
[4670.08s -> 4672.06s]  we could actually run Python or something, right?
[4672.06s -> 4673.82s]  And whatever you want, right?
[4673.82s -> 4675.38s]  If you wanna run, and it does the return code,
[4675.38s -> 4676.70s]  if you type some bogus something,
[4676.70s -> 4678.32s]  it'll say, hey, permission denied,
[4678.32s -> 4679.16s]  or something else, and it'll say,
[4679.16s -> 4682.90s]  return code 127, which is incorrect, okay?
[4682.90s -> 4685.14s]  That's the first example of exact CBP.
[4685.14s -> 4688.06s]  We will start with that on Monday, see you then.
