# Detected language: en (p=1.00)

[0.00s -> 3.88s]  All right, we might as well, might as well get going. That seems a little loud.
[3.88s -> 8.88s]  I'll try not to blast your ears out. Okay, so definitely the day before
[8.88s -> 12.48s]  midterm. You've got lots on your plate. I can see why some people might not be
[12.48s -> 16.80s]  showing up. Wouldn't it be terrible if this was the day that the screencast
[16.80s -> 20.76s]  failed? You guys all here would be happy, but everybody else wouldn't be, I
[20.76s -> 27.60s]  suppose. A couple things. First things, no labs this week. They're instead, we're
[27.60s -> 30.88s]  just asking that you watch a little short video. It's five minutes long. Some of you
[30.88s -> 37.64s]  actually already seen it. If you took CS106A maybe like last summer or two
[37.64s -> 44.56s]  summers ago or something, you might have also seen it. But anyway, it's a short
[44.56s -> 49.12s]  little video, literally five minutes, and it's other graduates from Stanford
[49.12s -> 53.48s]  mostly who have, we're just going to talk about CS a little bit. So give it
[53.48s -> 56.78s]  a watch. That's going to be your lab check-in for the week. Otherwise, you
[56.78s -> 61.34s]  probably want the hour and 20 minutes back to study, do work on the Stanford
[61.34s -> 68.22s]  Shell, etc. All right, so enjoy that and that's what will be instead of
[68.22s -> 74.22s]  lab for this week. The other day, what did I do? I got confused. So I
[74.22s -> 78.74s]  teach another class. Is Mark here? You don't see him. I teach another class and a
[78.74s -> 80.98s]  couple people in this class are actually in that class as well. It's
[80.98s -> 85.02s]  on teaching computer science, an introductory computer science class.
[85.10s -> 89.10s]  I literally used the example from what happened in class the other day as I
[89.10s -> 93.18s]  was talking about, hey guess what? Sometimes professors mess up and they
[93.18s -> 96.14s]  or they can't fix their live code or they can't find the bugs and this
[96.14s -> 99.66s]  is exactly what happened on Wednesday. So I apologize about that, but as
[99.66s -> 103.66s]  promised, I did go back and figure out what was going on with that compile
[103.66s -> 108.94s]  bug. It was a little bit subtle, not to say that was a good reason why I
[108.94s -> 113.58s]  didn't figure it out, but it was a little bit subtle as to why the
[113.62s -> 117.90s]  error happened. Here was the code again. This was the error. We were
[117.90s -> 123.66s]  focusing, I was focusing in the lecture on this line right here. Ticket agents
[123.66s -> 130.70s]  line 62 near the end of the line actually, which is this line right here
[130.70s -> 134.58s]  near the end here. So let's say right around here. That turns out to be
[134.58s -> 139.50s]  where the issue was. What are we doing here? We are sending a reference
[139.50s -> 145.66s]  to remaining tickets to a function, to the thread function, which will
[145.68s -> 151.62s]  repackage it and forward it on to the ticket agent function. So
[151.62s -> 154.38s]  that's kind of what's going on there. There's a little bit of C
[154.38s -> 157.78s]  plus plus black magic under there that happens at that point. But
[157.78s -> 161.26s]  if you look up here, we've got ticket agent. And so this is
[161.26s -> 164.46s]  what's going on with the remaining tickets there. Anybody notice
[164.50s -> 170.34s]  what might be the issue at this point? It wasn't that I just passed
[170.34s -> 174.30s]  it. I did pass it correctly, and it is a reference. The problem
[174.30s -> 176.58s]  is that little error message just told me to look here. It didn't
[176.58s -> 180.02s]  say anything about up here. And it also explicitly didn't say, it
[180.02s -> 184.96s]  did say something about a type issue. So what's the type of
[184.96s -> 190.10s]  remaining tickets? Size T. What type did I tell this to look for?
[190.78s -> 194.12s]  An unsigned int, which is kind of like a size T, except an
[194.12s -> 197.54s]  unsigned long is what a size T is. And so the compiler went,
[197.82s -> 199.74s]  you're trying to do two different types here, give me a
[199.74s -> 202.42s]  break, and then gave me some terrible error message about
[202.42s -> 206.94s]  that. But anyway, that was the issue. Once I went back and
[206.94s -> 211.98s]  fixed that, made it size underscore T ampersand, then it
[211.98s -> 216.30s]  worked just fine. So yeah, so bugs happen to everybody who
[216.82s -> 220.22s]  has ever programmed. So don't think you're on your own when
[220.22s -> 222.58s]  you hit all those bugs. They're tough to find, and they're
[222.58s -> 226.50s]  tricky. I had somebody in office hours yesterday who had
[226.50s -> 229.70s]  a bug that, honestly, the only reason I figured out what it
[229.70s -> 233.10s]  was because I have 25-30 years worth of programming
[233.10s -> 235.62s]  experience, right? It was such a subtle little bug that I
[235.62s -> 238.30s]  thought, oh, that one's a hard one to find. So anyway,
[238.30s -> 240.18s]  it was a good thing that that person came into office
[240.18s -> 243.02s]  hours. But these are things that happen. It's just, you
[243.02s -> 246.42s]  know, bugs are hard, programming, challenging. So
[246.50s -> 250.90s]  anyway, there's what happened the other day. Alright, so
[250.90s -> 256.50s]  let's move on to a very cool problem that if you take a
[256.54s -> 260.30s]  multi-threading or even a multi-processor type class,
[260.34s -> 263.94s]  like this one, in particular, if you don't cover this
[263.94s -> 267.58s]  problem, it's kind of like never ever reading a Shakespeare
[267.58s -> 270.66s]  play in an English class somewhere, right? It's like,
[270.70s -> 275.50s]  this is like the quintessential deadlock problem for
[275.54s -> 278.42s]  multi-processing, multi-threading sort of
[278.90s -> 282.86s]  situations, okay? It is called the Dining Philosophers. It's
[282.86s -> 284.90s]  actually got a fun name, and it's Dining Philosophers.
[284.94s -> 288.46s]  Here's how it works. Let me see if I can get my whiteboard
[288.46s -> 292.74s]  here going. Here's how it works. There is a table. And
[293.10s -> 296.06s]  in the table, okay, my drawing skills are terrible, by
[296.06s -> 298.54s]  the way, that's supposed to be a circle. There's a table
[298.54s -> 302.02s]  here. There are five philosophers, and
[302.02s -> 305.46s]  philosophers have like big brains or whatever. There's
[305.46s -> 313.10s]  one, two, two, right? Okay, three over here. And then
[313.14s -> 316.14s]  four sitting at this table here. And then of course,
[316.14s -> 317.98s]  they're not, I guess there should be, they should be
[317.98s -> 320.42s]  even, even there. You can see why I was an art major
[320.42s -> 323.26s]  when I did this. Okay, five philosophers sitting around the
[323.26s -> 327.74s]  table, okay? They each have bowls of like spaghetti in
[327.74s -> 330.66s]  front of them, okay? Each have bowls of spaghetti, and they
[330.66s -> 334.30s]  want to do a few things. They want to both think and
[334.30s -> 336.62s]  then eat, okay? And this is what they do. They're
[336.62s -> 338.22s]  actually going to go through this three times. They're
[338.22s -> 341.06s]  going to think for a while, and they're going to eat,
[341.06s -> 342.30s]  and then they're going to think again, eat, think
[342.30s -> 346.66s]  again, and then eat three times. And what the
[346.66s -> 351.82s]  situation here is, is that there are one, I'm going to
[351.82s -> 356.62s]  just kind of draw them like this, two, three, four, five
[356.94s -> 360.66s]  forks, okay? Those are my little forks, okay? And
[360.70s -> 365.42s]  here's how the dining philosophers eat. If you are
[365.42s -> 369.10s]  about to eat, you grab the fork on your right, and
[369.10s -> 371.06s]  then you grab the fork on your left, and for
[371.06s -> 373.90s]  some reason, you eat spaghetti like this, right? Which is
[373.90s -> 377.38s]  ridiculous. This should have been, whoever did this
[377.38s -> 379.10s]  should have just used chopsticks, because that
[379.10s -> 381.26s]  actually makes sense. And that's a legitimate, like, you
[381.26s -> 384.06s]  need two chopsticks to eat, right? But anyway, well,
[384.10s -> 386.46s]  the original problem was forks, because whoever did
[386.46s -> 388.54s]  it, possibly never heard of chopstick, I don't know. But
[388.54s -> 390.46s]  anyway, point is that it's forks in this case, but
[390.46s -> 393.14s]  they each need one, and they're going to eat for a
[393.14s -> 396.38s]  little while, and they are going to, when they're
[396.38s -> 398.62s]  done eating, put the forks down in the same order
[398.62s -> 401.34s]  they pick them up in, like right and then left. And
[401.34s -> 403.18s]  then, I guess in the opposite order, we'll see
[403.18s -> 404.90s]  what the code does anyway. But the point is, that's
[404.90s -> 409.22s]  what's happening. Now, in the end, this, if you do
[409.22s -> 411.78s]  this, like, how many people, how many philosophers can
[411.78s -> 415.82s]  actually eat at the same time? Two, right? Like, that's
[415.82s -> 418.18s]  the maximum, right, even though they all might be
[418.18s -> 422.54s]  going for the forks, okay? So that's the big
[422.54s -> 424.26s]  issue. Like, there's two people that, but we want
[424.26s -> 426.22s]  to make it so that they all kind of share
[426.22s -> 427.34s]  this, because we don't know when they're going to
[427.34s -> 428.50s]  be thinking, when they're going to be trying to
[428.50s -> 432.26s]  eat, and that's that, okay? So that's the
[432.26s -> 437.46s]  setup for the problem. And what we're going to
[437.50s -> 439.14s]  do is we're going to just write a little code
[439.14s -> 441.66s]  to try to test this out, okay? And try
[441.66s -> 445.54s]  to actually write this, model this in the, in
[445.54s -> 447.66s]  C++. In fact, let's just go straight to code
[447.66s -> 452.78s]  and we will do this. Dining philosophers with deadlock,
[452.78s -> 454.70s]  which means we're going to probably cause an issue
[454.70s -> 458.66s]  here, okay? So here's what's going to happen. All
[458.66s -> 462.78s]  right, let's start with how a philosopher thinks, okay?
[462.78s -> 466.34s]  A philosopher thinks by basically, in our program,
[466.34s -> 468.90s]  basically just taking some time, some kind of
[468.90s -> 472.86s]  random amount of time, to actually go ahead and
[472.86s -> 474.42s]  think. So we're going to do something like this.
[474.42s -> 476.14s]  Remember we have, we're in threading mode. This
[476.14s -> 477.34s]  will be, this will be in a thread, by the
[477.34s -> 479.86s]  way. Each philosopher will get its own thread. And
[479.86s -> 483.30s]  we're going to do the OS lock, okay? And
[483.30s -> 486.34s]  then we're going to say something like, let's see,
[486.34s -> 490.94s]  ID, okay? That's the philosophers ID that
[490.94s -> 493.02s]  we're passing in here, zero through four, because
[493.06s -> 497.30s]  there's five dining philosophers, okay? ID and then
[497.30s -> 503.78s]  starts thinking, okay? And when the philosopher is
[503.78s -> 506.74s]  thinking, then we have to spend some, we have
[506.74s -> 509.26s]  to actually take some time to do this. So
[509.26s -> 511.70s]  we're going to do that, and then, and L,
[511.70s -> 515.78s]  and then we are going to do OS unlock,
[515.78s -> 521.30s]  like that, okay? And then, I don't know why it
[521.30s -> 526.42s]  never, never, well anyway, it doesn't do the indentation
[526.42s -> 529.50s]  for whatever reason sometimes. Okay, so anyway, we're gonna,
[529.50s -> 531.34s]  we're gonna print that out. Then we are going
[531.34s -> 534.66s]  to do a sleep. Now, in a thread,
[534.66s -> 537.50s]  you call sleep four, and then some number of
[537.50s -> 541.42s]  like milliseconds, generally it's milliseconds. So let's sleep
[541.42s -> 544.14s]  for some amount of time. We have another function
[544.14s -> 545.78s]  that's just gonna kind of randomize it. It's not
[545.78s -> 547.30s]  really important what it is, but we're gonna just
[547.54s -> 552.90s]  get think time, like that, okay? And then once
[552.90s -> 556.46s]  it's done sleeping, we're gonna say same thing, OS
[556.46s -> 565.30s]  lock, ID, done, all done thinking, okay? And L and
[565.30s -> 568.62s]  OS unlock. All right, that's all a philosopher has to
[568.62s -> 572.58s]  do to think, okay? Pretty straightforward. All right, then
[572.58s -> 577.34s]  the philosopher has to eat, okay? And to eat, we're
[577.34s -> 580.50s]  gonna use our mutex that we learned about last time.
[580.50s -> 583.50s]  Okay, remember what a mutex is. A mutex is a data
[583.50s -> 588.50s]  structure such that many different threads might be
[588.50s -> 593.42s]  trying to grab control of that lock in the data
[593.42s -> 596.70s]  structure. The other ones, if they, if it's already
[596.70s -> 598.66s]  locked when they try to grab control, they just wait
[598.66s -> 601.94s]  around until it unlocks, and then they try to grab
[601.94s -> 603.98s]  again. And at that point, you might have contention
[604.62s -> 606.50s]  between the two. So because we've got two forks,
[606.50s -> 608.70s]  we're gonna have a left fork and a right fork, and
[608.70s -> 611.98s]  we're going to have the philosophers actually try
[611.98s -> 613.50s]  to eat. So what we're gonna do, they're gonna
[613.50s -> 615.14s]  pick up the left one, as it turns out first, I
[615.14s -> 617.38s]  think I might have said right before. They're
[617.38s -> 622.34s]  going to lock, do the left lock, okay? And
[622.34s -> 627.90s]  then right lock, okay? And then we're gonna say,
[627.94s -> 630.90s]  okay, look, at this point, now they can start
[630.90s -> 635.06s]  to sleep, or they can start to, well, eat, which
[635.06s -> 637.46s]  is kind of sleeping in this case. Okay, so
[637.46s -> 656.38s]  they're gonna say, ID starts eating, okay, nom, nom, nom, nom, like that. Okay, and L, and then OS unlock, like that, okay? And then we're
[656.38s -> 658.42s]  gonna model this by, again, doing some sleep,
[658.42s -> 661.82s]  sleep for, it's a thread way of sleeping, for
[661.82s -> 664.06s]  getEatTime, a slightly different one, which just
[664.06s -> 666.10s]  basically says some amount of time that it's
[666.10s -> 667.78s]  going to get. In fact, I just realized I
[667.78s -> 670.34s]  actually didn't call the function up here. There
[670.34s -> 673.38s]  we go. Okay, so we're gonna do sleep for
[673.38s -> 676.06s]  eat time, and then we're going to say, see
[676.06s -> 705.82s]  out, OS lock, ID, all done eating, and, and L, and then OS unlock, like that. And then, of course, now we're done eating, so we can put the forks back down. We are going to do it in the same order we picked them up in, as it turns out. So, left.unlock, and right.unlock. Okay, now, we are going to have to pass the forks that are
[705.82s -> 734.30s]  next to the dining philosophers in there, right? So, if you looked at that circle again before, right, it's whichever one, whichever two forks were next to a particular philosopher. Here and here is the left for this one and the right for that. Okay? All right, so that's how that works. And that's the, that is the eat function. Okay, let's go and look at what a philosopher actually does. Okay, a
[734.30s -> 764.14s]  philosopher does the following. The philosopher is for size t, i equals zero, i is less than three, i plus plus. Remember, they're going to do this three times in a row. Okay, what are they going to do? They are going to think, and then they are going to eat, and we have to pass in the left and the right. Okay, so far, so good on what's going on there. Okay, that's
[764.14s -> 794.06s]  what's happening, but for each philosopher. Now, we have to do our main function here. Okay, and the main function, we have to set up these mutexes for each fork. Okay, so let's do that. Mutex forks, we'll do five of them. Okay, and then we'll have philosophers, we'll have five of them. Okay, and then for size t, i equals zero, i is less than five, i
[794.06s -> 822.62s]  plus plus. Okay, and in here, we're going to actually launch each thread, like we've done in the past before here. Okay, what we want to do though, first is we need to set up which who gets what fork, right? So we can do mutex left, oops, left equals forks i. Okay, and then we can do, oops, maybe I need a semicolon there, mutex
[822.62s -> 851.14s]  right equals forks i, we'll do it this way, i plus one mod five, right? That'll just give you the one around the corner, the one on the other side. Okay, the mod in there wraps around if necessary. Okay, and then we actually have to do philosophers, i equals thread. So now we're calling thread that we are, or we're setting up a thread.
[852.94s -> 882.26s]  Philosopher was the name of the, philosopher, I had to spell it right, the name of the function. And then we are passing in the ID, we are passing in a reference to the left, a reference to the right. And we are passing in a ref permits. Okay, and then, oops, sorry, not permits, wrong, wrong, I'm looking at the wrong one here. We're passing in just a reference to the right, left,
[882.26s -> 912.14s]  reference to the right, and that's it, that's all we need. Okay, all right, after you do all the threads, you need to, you need to join them all. Okay, so another for size t, i equals zero, i is less than five, i plus plus, and you can just do, can we do it that way? I guess we'll do it the way we did before. Like, the way we've been doing it in the past, which is just thread ampersand t equals,
[912.26s -> 941.86s]  thread ampersand, well, we'll call it p for philosophers, it doesn't really matter, philosophers, and then p.join, like that, and then we can return. Okay, so that's our whole program, and it's going to set it up so that we're, let's see what happens when we, when we run it. Okay, make dining philosophers with deadlock, of course there's an error, of course there's an error, let's see.
[942.26s -> 972.18s]  On 82 and 83, like that, you mean, and that, we are trying to, yes, thank you very much, although did that, oops, ah, thank you very much. Okay, so anyway, if we do dining philosophers with deadlock, if we do that, now you'll watch, and it actually seems to go all right.
[972.50s -> 998.02s]  Okay, and we go, well, our program's correct, right? And what happened was, let's look at, look at exactly what happened here. Okay, zero start, they all start thinking, and then three happened to finish first, as it turns out, because of the timing or whatever, and then it started, and three started eating, so three grabbed the left fork and the right fork, I should do it backwards, you guys left and right, and then did that, and they all ended up working just fine. Okay, and you might say, hey, this is great, we're done.
[998.66s -> 1027.78s]  But what happens if we artificially put in a race condition that would, like, not be a very good, like, would make it so that they all tried to start eating at the same time? Okay, what if we did the following? Okay, what if we put a little sleep for, let's say, five seconds in there, five seconds, right in there, basically saying all of them are going to do a little bit of waiting,
[1027.90s -> 1035.30s]  and they're all going to try to eat at the same time, and then they're all going to grab their left forks at the same time? Can you kind of see what's going to happen here?
[1037.18s -> 1054.82s]  Make dining philosophy strong, and that. Okay, well, they all get to a point where they all think, and some of them get done in various orders, but then they're waiting around after they pick up their left fork, until each one of them picks up a left fork.
[1055.34s -> 1080.50s]  Well, what's the next thing they're trying to do? They're waiting for the, they're trying to pick up the right fork, right? So if we go back to our diagram here, right, we've got, we've got this one, let's go from the top here, this one picks up their left fork, which is this one, and then this one picks up left, and then left, and then left, and then left, and then this one goes and tries to pick up the right fork at some point.
[1080.94s -> 1098.66s]  Well, this one is not there, because the other ones are all waiting to pick up their right forks as well, they just picked them up. This is deadlock, right? It's deadlock specifically because everybody's waiting on everybody else to be done eating, because you've only got those five forks, and there's five people vying for them.
[1099.66s -> 1125.10s]  Okay, so do you see what the, what the issue is, right? This is how the deadlock actually ends up happening, okay? And what we want to do is we want to try to avoid that, okay? Because when you have these kind of race conditions that lead to something like this, you're going to be in trouble, so we end up having to, having to quit that, okay? All right, so this is all the code that we just, just went through.
[1126.10s -> 1149.26s]  And here's an important part, by the way. We should be able to insert this sleep for call pretty much anywhere in a thread, and not have it matter to the rest of the program. Like, that's one of the ways to check for deadlocks and for other kind of race conditions, to just say, look, let's artificially make it such that some weird condition happens where you could end up doing, doing that. Okay? Question.
[1149.26s -> 1178.26s]  Yeah, the good question. Did we get lucky that it worked before? Yeah, you just kind of got lucky. The odds are pretty good the way we've set up the timing that it turns out that all five won't be trying to eat at exactly the same time until, and even if, if one ever gets both forks, well, then they're going to be done eating, and that will open it up for others and so forth. But there is that weird condition where they all go for the left fork at the same time. Oops, now you've got five forks, and everybody's waiting for that other fork, and nobody's going to be able to do that.
[1180.26s -> 1191.26s]  And that's the issue. Does lock have a return value? I don't believe lock has a return value at all. I just think it, I think it's void. If it does, we really never use it.
[1191.26s -> 1217.26s]  Oh, no, like, can you check lock before you, like, do that? In this case, it really wouldn't matter. I mean, because what are you going to, you know, what are you going to do there? I mean, I guess you could, I guess you, if you, yeah, it's not a bad idea. I hadn't thought about that. If you, like, somehow check and see, wait, are all of them taken, all of them taken? If you keep track of them, yeah, and that's kind of what we're going to do, like keep track of them in the bigger picture.
[1221.26s -> 1250.26s]  Yes, the question is, when you do sleep for 5,000, that's saying, by five seconds, everyone's going to be done thinking, trying to grab their left fork, okay? And remember, they only grab their left fork, like, they grab their left fork first, right? And they already did that, sorry. They already all grabbed the left fork, or at least they're trying to, and then they're waiting around to grab the right one. By that time, everybody has grabbed a left fork, and that's that.
[1250.26s -> 1263.26s]  Other questions? Can we get this idea, though? This is the classic, like, you will, at some point, again, hear dining philosophers and go, ah, I know what that is, right? I know all about that. And that's where it comes from.
[1263.26s -> 1276.26s]  So, how are we going to actually fix it? Well, mutexes are going to probably be one way to solve this. We just need to have some more logic in there to make it so that it actually works, okay?
[1276.26s -> 1286.26s]  We've already kind of talked about, it's impossible for three philosophers to be eating at the same time, right? You can only have two philosophers eating at the same time.
[1286.26s -> 1298.26s]  But, you could have four philosophers trying to eat at the same time, but as long as there aren't all five trying to eat at the same time, somebody will be able to get that other fork and start eating.
[1298.26s -> 1306.26s]  Does that make sense? If you have four of them, and the fifth one is just kind of waiting around, not doing anything yet, at least one of those four will be able to eat.
[1306.26s -> 1314.26s]  It may not be two in that case, but at least one of them will be able to eat. Does that make sense? I see some people going, oh, it doesn't quite. Think that one through for a second.
[1314.26s -> 1328.26s]  The diagram might help a little bit more. As long as one of them is not, say this one is not eating at all, not doing anything, then this one will eventually be able to get its right fork.
[1328.26s -> 1338.26s]  So we can do that. Now, we could do this in a couple different ways when we're going to actually solve this. We could say, well, let's just make it so that only two can ever eat at the same time.
[1339.26s -> 1347.26s]  That's fine. I mean, that would probably be relatively efficient. But you could also make the argument that, well, we don't know how long any of them are going to be waiting.
[1347.26s -> 1354.26s]  So let's at least make the maximum number possible to be able to eat so that it kind of continues through. There's arguments on both sides.
[1354.26s -> 1364.26s]  We're going to go with the preference to say, let's make a limited amount of bottleneck, and we'll just make sure that we can't do deadlock.
[1364.26s -> 1371.26s]  And that would be, let four of them vie for it. Just make the fifth one have to wait. That's what we're going to end up doing.
[1371.26s -> 1380.26s]  So, how are we going to do this? Well, we're going to introduce an idea of a permission slip.
[1380.26s -> 1387.26s]  And the permission slip is basically going to be, basically saying, hey, there's going to be four permission slips.
[1387.26s -> 1393.26s]  The first four philosophers who get those permission slips are going to be able to try to eat. They're going to be able to vie for those forks.
[1393.26s -> 1399.26s]  The fifth one just has to wait until one of the other ones is done eating. Then we'll have that.
[1399.26s -> 1406.26s]  We're going to call it permits in this case, permission slips. And we're just going to use a counter to count them up and down.
[1406.26s -> 1414.26s]  So let's actually look at this. Dining philosophers, we'll call it busy waiting. Do we like busy waiting?
[1414.26s -> 1419.26s]  No? Well, we've got to get there. We'll get to trying to fix that in a little bit.
[1419.26s -> 1428.26s]  But let's see how we might solve this first of all. Some of the things are the same, so I'm not like think is exactly the same. I haven't changed that at all.
[1428.26s -> 1436.26s]  We're going to have a wait for permission and a grant permission. But before we do that, let's actually set up main first.
[1436.26s -> 1441.26s]  Most of main is going to be roughly the same. But some of main is going to be a little different.
[1441.26s -> 1445.26s]  We're still going to have five forks. We're still going to have five philosophers and so forth.
[1445.26s -> 1451.26s]  But what we're going to do now is we're going to say size t permits equals four.
[1451.26s -> 1453.26s]  Because we're saying we're going to start out and there's going to be four permits.
[1453.26s -> 1457.26s]  And every time a philosopher gets a permit, that number is going to go down.
[1457.26s -> 1461.26s]  And when it gets to zero, too bad. There's no more permits left. Make sense?
[1461.26s -> 1467.26s]  So that's what we're going to do there. We're still going to have the forks set up like this.
[1468.26s -> 1475.26s]  We are also going to have another mutex for the permits lock.
[1475.26s -> 1482.26s]  Well, if we have a permit and if we have this permit variable and any of the threads are going to try to modify it,
[1482.26s -> 1487.26s]  we better lock around that so that they don't both try to modify it and we get a race condition there.
[1487.26s -> 1491.26s]  So that's another issue with race condition. We're going to have to fix that.
[1491.26s -> 1495.26s]  Same thing, we're going to start all of them. We're going to get the left and the right. Nothing's going to change there.
[1495.26s -> 1499.26s]  What we are going to change now is we're going to do the same thing.
[1499.26s -> 1504.26s]  Philosopher i equals thread as before.
[1504.26s -> 1509.26s]  We're still going to do the same function. We'll finish those up in a minute.
[1509.26s -> 1519.26s]  Philosopher and i and a ref for the left and a ref for the left and a ref for the right.
[1519.26s -> 1524.26s]  And we are also going to have to send a ref for the permits because we have the permits.
[1524.26s -> 1531.26s]  And we're also going to have to send a ref for the permits lock as well.
[1531.26s -> 1536.26s]  Because now we have to send more information so that they can actually use these permits effectively.
[1536.26s -> 1540.26s]  And then we're still going to join them at the end. Question?
[1540.26s -> 1545.26s]  Is permits a global variable for the permits?
[1545.26s -> 1550.26s]  Is permits a global variable for the permits? It's not a global variable, but it is going to be passed to each philosopher.
[1551.26s -> 1557.26s]  Is it the same actual variable for each one?
[1557.26s -> 1560.26s]  Remember, threads can share variables in the same space.
[1560.26s -> 1562.26s]  So yes, it's exactly the same one. And that's how it's going to work.
[1562.26s -> 1565.26s]  Because all the threads are going to go, hey, are there any permits left?
[1565.26s -> 1567.26s]  Oh, I'm going to grab them.
[1567.26s -> 1570.26s]  And it's going to use them.
[1570.26s -> 1572.26s]  Say again?
[1572.26s -> 1574.26s]  When one philosopher takes the permit, the others see the change.
[1574.26s -> 1577.26s]  When one philosopher takes the permit, the others see the change. Yes.
[1577.26s -> 1579.26s]  You'll see how that works, but exactly.
[1579.26s -> 1581.26s]  Okay, that's exactly what's going on there.
[1581.26s -> 1585.26s]  Okay, so let's go modify some of these other ones here.
[1585.26s -> 1588.26s]  Let's go modify, we've got think.
[1588.26s -> 1590.26s]  eat is going to have to change a little bit.
[1590.26s -> 1592.26s]  Let's do that one right now.
[1592.26s -> 1596.26s]  For eat, we're basically going to have to get permission.
[1596.26s -> 1599.26s]  So let's create a function, and we'll do that in a minute.
[1599.26s -> 1603.26s]  We'll say, wait for permission.
[1603.26s -> 1606.26s]  We're going to pass in permits to this function.
[1606.26s -> 1610.26s]  And then we're going to pass in permits lock as well.
[1610.26s -> 1612.26s]  Okay.
[1612.26s -> 1617.26s]  And then if we get a permission slip, then we can go and do our locking.
[1617.26s -> 1619.26s]  That's actually going to work just fine.
[1619.26s -> 1620.26s]  Okay.
[1620.26s -> 1628.26s]  And then after we are done eating, we can say, okay, well, let's give back like our permit.
[1628.26s -> 1632.26s]  So basically we can say grant, we'll have a one called grant permission.
[1632.26s -> 1635.26s]  And this will be permits.
[1635.26s -> 1639.26s]  And it will be permits lock again, same sort of thing.
[1639.26s -> 1640.26s]  Okay.
[1640.26s -> 1643.26s]  And then after that is when we can do the unlocking and locking.
[1643.26s -> 1647.26s]  Okay, so it's kind of wrapping those in the get a permission slip and then give one back.
[1647.26s -> 1648.26s]  Question.
[1648.26s -> 1653.26s]  Why do we have to unlock the permit after we do the sleep?
[1653.26s -> 1656.26s]  Like isn't the deadlock about locking the forks?
[1656.26s -> 1661.26s]  So could we unlock the deadlock after we lock our forks?
[1661.26s -> 1662.26s]  Good question.
[1662.26s -> 1666.26s]  So the question is, could we unlock it after we've locked the forks?
[1666.26s -> 1672.26s]  Well, I guess you could, but then you still might have a race condition in there.
[1672.26s -> 1677.26s]  You still might have a race condition where, let's see.
[1677.26s -> 1682.26s]  Yeah, I think in that case, you still could get to a point where you're all still trying to get the same one, even though you have a permit.
[1682.26s -> 1683.26s]  Maybe not.
[1683.26s -> 1684.26s]  Maybe you could rewrite it that way.
[1684.26s -> 1686.26s]  But in this case, let's not worry about that.
[1686.26s -> 1690.26s]  Let's only get grant permission again once we're done eating and once we're done with everything.
[1690.26s -> 1693.26s]  There might be a way to do it, but yeah, in this case, I would say let's not do that yet.
[1693.26s -> 1696.26s]  We could probably analyze it a little bit more and see, but not at this point.
[1696.26s -> 1699.26s]  Let's just say, just grant permission once you're done eating.
[1699.26s -> 1706.26s]  You certainly could do it before you do all done eating and so forth, but I don't know that I'd do it before you sleep in that case.
[1706.26s -> 1713.26s]  It might not actually change the logic as it turns out, but either way, somebody's going to be waiting around and they aren't going to get a permit until,
[1713.26s -> 1718.26s]  they aren't going to actually be able to eat until, or do the locks until later.
[1718.26s -> 1721.26s]  So anyway, that's that. Let's go write these other functions up here.
[1721.26s -> 1723.26s]  Let's go write waitForPermission.
[1723.26s -> 1725.26s]  Actually, let's write grantPermission.
[1725.26s -> 1727.26s]  This is the easier one.
[1727.26s -> 1731.26s]  GrantPermission is going to simply,
[1731.26s -> 1735.26s]  PermitsLock.Lock
[1735.26s -> 1742.26s]  because it's about to do something to the permit, so it's got to be the only thread that's doing that, changing the permits.
[1742.26s -> 1755.26s]  Basically, it does Permits++ because we're going to give back the permit, so you'll see that waitPermission decrements it.
[1755.26s -> 1761.26s]  GivebackPermission and then PermitsLockUnlock.
[1761.26s -> 1762.26s]  That's all that's doing.
[1762.26s -> 1764.26s]  It's just basically incrementing the permits.
[1764.26s -> 1771.26s]  Now, waitForPermission is a little bit more involved because it's got to actually do the actual waiting.
[1771.26s -> 1773.26s]  Well, what does it have to do?
[1773.26s -> 1779.26s]  The waitForPermission, basically, we're going to wrap it in a while true loop.
[1779.26s -> 1783.26s]  And it's going to check the permits.
[1783.26s -> 1785.26s]  Well, how do you check the permit?
[1785.26s -> 1787.26s]  Well, you'd better lock first.
[1787.26s -> 1792.26s]  PermitsLock.Lock.
[1792.26s -> 1798.26s]  And then if Permits is greater than zero, we're going to break.
[1798.26s -> 1799.26s]  We're going to be done.
[1799.26s -> 1801.26s]  That means that there is a permit available.
[1801.26s -> 1803.26s]  Let's go get it.
[1803.26s -> 1810.26s]  And then we are going to do PermitsLockUnlock.
[1810.26s -> 1814.26s]  And then we are going to...
[1814.26s -> 1818.26s]  And the reason we do this here, by the way, is we were not successful.
[1818.26s -> 1824.26s]  Like, if Permits was not greater than zero, in other words, if Permits was zero, well, let somebody else try
[1824.26s -> 1826.26s]  because we're not going to keep that lock for now.
[1826.26s -> 1828.26s]  Because there needs to be people who can increment it.
[1828.26s -> 1832.26s]  Anybody who's eating now has to be able to use that lock later and increment it.
[1832.26s -> 1834.26s]  Does that make sense about why we're doing there?
[1834.26s -> 1840.26s]  And then after we do that, well, if we just left this while loop as it was,
[1840.26s -> 1842.26s]  this would be a spinning loop that would be really bad.
[1842.26s -> 1844.26s]  It would really like hammer.
[1844.26s -> 1846.26s]  For every thread, it would hammer a processor.
[1846.26s -> 1850.26s]  So let's at least do something at least somewhat nice.
[1850.26s -> 1853.26s]  Sleep for, let's say, 10 milliseconds or something like that.
[1853.26s -> 1856.26s]  At least that throws it off the processor for a second and does that.
[1856.26s -> 1857.26s]  Question, Sam?
[1857.26s -> 1861.26s]  Do we decrement the permits here?
[1861.26s -> 1863.26s]  Not quite yet.
[1863.26s -> 1867.26s]  We will do that after we check and make sure there's a permit available.
[1867.26s -> 1869.26s]  Well, that's not what this is doing.
[1869.26s -> 1871.26s]  It is, but we haven't decremented yet.
[1871.26s -> 1872.26s]  You'll see.
[1872.26s -> 1874.26s]  Okay, well, think about what's happening here.
[1874.26s -> 1880.26s]  This while loop is basically saying, okay, look, grab the lock so nobody else can check, do anything with permits.
[1880.26s -> 1881.26s]  Is permits greater than zero?
[1881.26s -> 1885.26s]  If it's not, give back the lock, sleep for a little bit, and then try again.
[1885.26s -> 1886.26s]  That's what this loop is doing.
[1886.26s -> 1891.26s]  If the permits was greater than zero, then we go, great, there's a permit available.
[1891.26s -> 1894.26s]  Let's break out of this loop so then we can go and do the decrement.
[1894.26s -> 1899.26s]  You could do it in here and then break if you wanted to.
[1899.26s -> 1900.26s]  It doesn't really matter.
[1900.26s -> 1908.26s]  The point is that it's actually here that we're going to say, permits minus minus.
[1909.26s -> 1917.26s]  And then, because we broke before we unlocked here, we then have to do permits, lock, unlock.
[1917.26s -> 1922.26s]  Okay, and that means that we're the ones who have taken the permit, decremented it, and gone with it.
[1922.26s -> 1923.26s]  Is that your question?
[1923.26s -> 1924.26s]  Yeah.
[1924.26s -> 1930.26s]  And by the way, I'm about to show you something where this weirdness where you have to unlock two places when you only lock once.
[1930.26s -> 1934.26s]  We're going to get rid of that with a very cool class in a second.
[1934.26s -> 1939.26s]  So for the sleep for ten, what would happen if we didn't do that?
[1939.26s -> 1940.26s]  Good question.
[1940.26s -> 1946.26s]  If we left out the sleep for ten, the only thing that would happen is that we'd really be spinning like crazy,
[1946.26s -> 1951.26s]  and the processor would peg to 100%, and the fans would come out on your computer and warm up,
[1951.26s -> 1955.26s]  and 107 students wouldn't get their myth computers done.
[1955.26s -> 1956.26s]  It would behave differently.
[1956.26s -> 1958.26s]  It would not behave any differently, no.
[1958.26s -> 1962.26s]  But this is called busy waiting, not really spinning quite as much.
[1962.26s -> 1967.26s]  The reason it's busy waiting is because we are waking up every ten milliseconds and going,
[1967.26s -> 1971.26s]  is there a permit left? Back to sleep. Is there a permit left? Back to sleep.
[1971.26s -> 1972.26s]  And that's not the best way to do that.
[1972.26s -> 1974.26s]  In fact, that's not really a good way of doing anything.
[1974.26s -> 1982.26s]  We kind of want, just like SIG suspend for processes, we want the kernel to go, or somebody else,
[1982.26s -> 1988.26s]  in fact not the kernel necessarily, somebody else to say, go ahead and check now.
[1988.26s -> 1991.26s]  I've released this so that you can check.
[1991.26s -> 1997.26s]  So it just completely sleeps until it gets a message that says, oh, now I can go look and hopefully it will be ready.
[1997.26s -> 2002.26s]  There are five philosophers. Good question. Who else is there?
[2002.26s -> 2005.26s]  There are five philosophers all vying for the permit.
[2005.26s -> 2007.26s]  Not the kernel, but somebody else.
[2007.26s -> 2010.26s]  Yes, somebody else. One of the other threads. You'll see.
[2010.26s -> 2012.26s]  Good question. You'll see.
[2012.26s -> 2017.26s]  Here's the thing. Notice what's going on down here. We'll get to this later.
[2017.26s -> 2026.26s]  Down here, we are unlocking there. Isn't this a great opportunity to tell all the other threads that are waiting?
[2026.26s -> 2030.26s]  Guess what? I just released one. You can go grab a fork now.
[2030.26s -> 2034.26s]  So that's what we're going to end up doing. We just have to figure out a way to do that.
[2034.26s -> 2039.26s]  And you actually need a little more support from the operating system to do that, as it turns out.
[2039.26s -> 2042.26s]  What questions do you have about this so far before we test it?
[2043.26s -> 2046.26s]  No other questions? Okay. Let's test it. Anybody see any bugs?
[2046.26s -> 2052.26s]  Make Dining. Now I'm all worried that I'm going to find a bug I can't fix again.
[2052.26s -> 2054.26s]  Oh, well. You can do it, Chris.
[2054.26s -> 2059.26s]  Okay. Make Dining Philosophers with Busy Waiting.
[2059.26s -> 2063.26s]  All right. There we go. There it is. Let's see.
[2063.26s -> 2067.26s]  Thanks for telling me now. Which one?
[2068.26s -> 2070.26s]  Main.
[2070.26s -> 2073.26s]  All right. Let's see. You know what else we didn't do?
[2073.26s -> 2076.26s]  We actually didn't do Illustriote, because we have to do that.
[2076.26s -> 2079.26s]  So I'm glad it actually broke. Which one did I spell wrong?
[2079.26s -> 2083.26s]  Oh, I did that earlier. Hang on.
[2083.26s -> 2087.26s]  Mutext. Sorry. Mutext. I did that earlier when I did this too.
[2087.26s -> 2090.26s]  I think because I'm used to typing text.
[2090.26s -> 2097.26s]  There. Thank you. Thank you. Good catch.
[2097.26s -> 2102.26s]  All right. Now, before we go on and actually try this, it would have been really ugly if it didn't work at all.
[2102.26s -> 2104.26s]  We just kind of didn't do anything.
[2104.26s -> 2109.26s]  Let's actually do our Philosopher's, Philosopher here, okay?
[2109.26s -> 2112.26s]  We're still going to do a forelook. We're still going to think, okay?
[2112.26s -> 2114.26s]  But now we just have to pass in the other details.
[2114.26s -> 2119.26s]  That's the only other difference here. Left, right, and then we have to do the Permits.
[2119.26s -> 2125.26s]  And then Permits Lock. Like that. Okay?
[2125.26s -> 2131.26s]  Okay, why don't we have to wrap ref around this one?
[2131.26s -> 2138.26s]  Any ideas?
[2138.26s -> 2141.26s]  I guess my bigger question is, why haven't we ever used ref before?
[2141.26s -> 2147.26s]  Until one day ago. In any C++ class you've ever taken.
[2147.26s -> 2151.26s]  They've always been what? Yeah, they've always been in the right context.
[2151.26s -> 2154.26s]  Let's go look and see what Eat is expecting here.
[2154.26s -> 2157.26s]  Eat is expecting a Permit reference, right?
[2157.26s -> 2161.26s]  So you don't need to say ref around it because it's actually already expecting it.
[2161.26s -> 2164.26s]  If you did wrap it around, it actually wouldn't matter, but you don't need to in this case.
[2164.26s -> 2169.26s]  Because it's not like the Thread class, which has no idea what these parameters are.
[2169.26s -> 2171.26s]  It's just going to take them and pass them along.
[2171.26s -> 2174.26s]  If you don't pass a ref that case, it's just going to go, I don't know which one you want.
[2174.26s -> 2178.26s]  And that's that. So in this case we don't have to, just like we always haven't had to.
[2178.26s -> 2181.26s]  So, that's that. Okay, let's see if this works now.
[2181.26s -> 2184.26s]  Make Dining Philosophers, there we go.
[2184.26s -> 2187.26s]  Okay, Dining Philosophers with busy way. This is not going to look any different.
[2187.26s -> 2190.26s]  It's basically going to work them.
[2190.26s -> 2197.26s]  And if we put that sleep in there, which we put, where did we put that in here?
[2197.26s -> 2200.26s]  We put it right after here, right?
[2200.26s -> 2204.26s]  Sleep for 5,000, right?
[2204.26s -> 2210.26s]  Let's see what happens when we do this.
[2210.26s -> 2213.26s]  And there, and then, now everybody's going to start thinking and sleeping.
[2213.26s -> 2216.26s]  But now we're all sleeping, it should wake back up again.
[2216.26s -> 2220.26s]  There we go, and it continues on because now we've got the right permits in there.
[2220.26s -> 2227.26s]  Okay, now I just artificially put all these weights in there, but that's how it'll go.
[2227.26s -> 2230.26s]  Alright, what questions do you have? And it's going to continue for a little bit.
[2230.26s -> 2235.26s]  What other questions do you have out of that? Anything else?
[2235.26s -> 2239.26s]  Can you explain why we need to lock the permits before we increment it?
[2239.26s -> 2243.26s]  Good question. Why do we need to, let's see if we can find it in here.
[2243.26s -> 2250.26s]  Why do we need to lock the permits before we decrement it or increment it here?
[2250.26s -> 2257.26s]  Yeah, so let's say two threads end up stopping at exactly the same time, which would be possible,
[2257.26s -> 2260.26s]  and going and trying to release their permit, right?
[2260.26s -> 2263.26s]  Well, couldn't you end up with, they both did Permits++,
[2263.26s -> 2267.26s]  you could end up with a situation where, in the assembly code,
[2267.26s -> 2271.26s]  one of them increments it and the other one is reading it but gets the wrong value
[2271.26s -> 2273.26s]  and then increments it, and there might be two increments there,
[2273.26s -> 2276.26s]  or there might only be one increment instead of two.
[2276.26s -> 2278.26s]  It's actually, it's a race condition there.
[2278.26s -> 2284.26s]  So you always want to wrap around your data structures that multiple threads could be modifying.
[2284.26s -> 2287.26s]  Does that help, or is it still why?
[2287.26s -> 2289.26s]  So you're saying that it's possible if Permits is zero,
[2289.26s -> 2291.26s]  and then if they both try to increment at the same time,
[2291.26s -> 2294.26s]  do I end up as Permits is increment one?
[2294.26s -> 2297.26s]  Yes, if Permits is zero and they both try to increment at once,
[2297.26s -> 2300.26s]  then you could end up with just Permits being one instead of two.
[2300.26s -> 2303.26s]  Because of that race condition and because of the assembly language like we talked about the other day,
[2303.26s -> 2306.26s]  it's not, plus plus is not an atomic operation.
[2306.26s -> 2314.26s]  In other words, you can't guarantee that inside there another, one of the threads will end up reading,
[2314.26s -> 2319.26s]  both will read, one will update, and the other one will also, it'll be a little bit different.
[2319.26s -> 2322.26s]  It won't necessarily be the exact, be correct.
[2322.26s -> 2323.26s]  Question?
[2323.26s -> 2324.26s]  Two questions.
[2324.26s -> 2328.26s]  Why do you have to lock when you're looking at Permits?
[2328.26s -> 2329.26s]  Good question.
[2329.26s -> 2330.26s]  Same issue.
[2330.26s -> 2332.26s]  Why do you have to lock when you're looking at Permits?
[2333.26s -> 2338.26s]  Well, what if someone else came in and decremented after you checked?
[2338.26s -> 2342.26s]  Then you would both decrement, and then you'd be negative one Permits,
[2342.26s -> 2345.26s]  and then all of a sudden you'd be in a deadlock condition again as well.
[2345.26s -> 2346.26s]  Right?
[2346.26s -> 2348.26s]  So it's again, even if you're reading it.
[2348.26s -> 2352.26s]  Now, there are times where you will be able to read from a data structure,
[2352.26s -> 2356.26s]  as long as you can guarantee no one else is writing to it, that's fine.
[2356.26s -> 2357.26s]  Okay?
[2358.26s -> 2362.26s]  In things like maps and sets and things, you can read from some of those
[2362.26s -> 2365.26s]  without worrying that someone else will be overstepping it.
[2365.26s -> 2368.26s]  It's a little more subtle than that, but you'll get to some assignments where that's possible.
[2368.26s -> 2370.26s]  But in this case, it's not.
[2370.26s -> 2372.26s]  Second question, and this might just be, I'm forgetting,
[2372.26s -> 2375.26s]  but why do you have to say ref instead of ampersand?
[2375.26s -> 2376.26s]  Right.
[2376.26s -> 2377.26s]  Good question.
[2377.26s -> 2378.26s]  Why do you have to say ref instead of ampersand?
[2378.26s -> 2381.26s]  And it definitely bears repeating.
[2381.26s -> 2382.26s]  We do that right here.
[2382.26s -> 2388.26s]  Remember, the thread class has this interesting function signature
[2388.26s -> 2394.26s]  where it says, I will take as many parameters as you want to give me.
[2394.26s -> 2399.26s]  And what I will do is then I will take all of the parameters after the first one
[2399.26s -> 2404.26s]  and pass them into the first one as the parameters for that function
[2404.26s -> 2405.26s]  when I start the thread.
[2405.26s -> 2406.26s]  That make sense?
[2406.26s -> 2413.26s]  Okay, when that happens, the thread has no idea if this function philosopher
[2413.26s -> 2417.26s]  is going to take a reference or is going to take a value.
[2417.26s -> 2420.26s]  So when you pass the value into the thread, it just goes, I don't know.
[2420.26s -> 2423.26s]  And I suppose maybe you could go write a compiler that goes and looks at philosopher
[2423.26s -> 2425.26s]  and goes, oh, this one needs this.
[2425.26s -> 2431.26s]  But it's not necessarily going to work the way you want it to.
[2431.26s -> 2434.26s]  So this is why I just say, look, make it a reference, and there you go.
[2434.26s -> 2437.26s]  In fact, I think if you didn't make it a reference, it would probably cause that same similar error
[2437.26s -> 2439.26s]  we had the other day, and you would have to go fix it.
[2439.26s -> 2444.26s]  But then the fix is to put that ref in there and say, look, it has to be a reference.
[2444.26s -> 2445.26s]  Good question.
[2445.26s -> 2446.26s]  Yeah?
[2446.26s -> 2450.26s]  So I thought the problem with the incrementing and decrementing
[2450.26s -> 2454.26s]  was that you could either increment too much or decrement too much.
[2454.26s -> 2460.26s]  I mean, because if they could happen to where they interpret an increment together,
[2460.26s -> 2462.26s]  it's just one increment.
[2462.26s -> 2467.26s]  Yeah, so the question is, look, I thought it was that the permits were,
[2467.26s -> 2469.26s]  you could either increment or decrement too much.
[2469.26s -> 2472.26s]  But no, it's actually more likely that it's going to be too few.
[2472.26s -> 2475.26s]  They will both try to increment, and you want it to increment.
[2475.26s -> 2477.26s]  Let's say two threads come in, they both increment.
[2477.26s -> 2481.26s]  You could get two, which is what you want.
[2481.26s -> 2484.26s]  But you could also just end up getting one increment because they both...
[2484.26s -> 2490.26s]  Go back to Monday's lecture and take a look at the assembly code
[2490.26s -> 2495.26s]  and see that, oh, look, if this one reads the value before it updates,
[2495.26s -> 2497.26s]  then the other one reads the value and then updates.
[2497.26s -> 2501.26s]  This one will update to the same value and not one more than it should be.
[2501.26s -> 2502.26s]  Go back and look at that.
[2502.26s -> 2505.26s]  You'll figure it out once you go through the assembly code.
[2505.26s -> 2511.26s]  And permits.lock makes sure nothing, like only one thing is accessed,
[2511.26s -> 2516.26s]  and then it blocks the rest of them accessing through that line.
[2516.26s -> 2518.26s]  Yes, and this also bears repeating.
[2518.26s -> 2522.26s]  When we say permits.lock, think about what's happening.
[2522.26s -> 2526.26s]  Many threads are all going to be at that same line at the same time.
[2526.26s -> 2528.26s]  Okay, they're all maybe.
[2528.26s -> 2531.26s]  Let's assume they all go and try to run that line at the same time.
[2531.26s -> 2535.26s]  Only one of them will actually get the hold of the lock.
[2535.26s -> 2538.26s]  The rest will have to wait until that lock gets released.
[2538.26s -> 2539.26s]  So that's what it does.
[2539.26s -> 2542.26s]  It doesn't tell anything to anybody else.
[2542.26s -> 2547.26s]  It basically says if everybody's trying to access that variable, that lock,
[2547.26s -> 2549.26s]  only one will win.
[2549.26s -> 2553.26s]  All the rest will just wait until that one releases it with an unlock.
[2553.26s -> 2555.26s]  That's the difference there.
[2555.26s -> 2556.26s]  Good question.
[2556.26s -> 2558.26s]  And that's critical to get what lock is doing.
[2558.26s -> 2561.26s]  It's not like telling the kernel, hey, don't let anybody else touch this.
[2561.26s -> 2564.26s]  It's much more simple than that, as it turns out.
[2564.26s -> 2565.26s]  Mark?
[2565.26s -> 2568.26s]  How is that waiting implemented?
[2568.26s -> 2569.26s]  How is which?
[2569.26s -> 2571.26s]  How is the waiting implemented?
[2571.26s -> 2573.26s]  Oh, how is the waiting implemented?
[2573.26s -> 2574.26s]  Yeah, good question.
[2574.26s -> 2577.26s]  It's a nice sleep wait.
[2577.26s -> 2587.26s]  When lock unlocks, it will actually set a global variable more or less
[2587.26s -> 2589.26s]  that everybody else reads.
[2589.26s -> 2591.26s]  And they do it atomically.
[2591.26s -> 2595.26s]  There are other instructions, underlying assembly code instructions, that are atomic.
[2595.26s -> 2600.26s]  And so the way it's built is on those instructions such that only one is successful as it comes out.
[2600.26s -> 2605.26s]  But it does wait until it doesn't do any spinning or anything.
[2605.26s -> 2607.26s]  Don't even worry about that.
[2607.26s -> 2611.26s]  Now, let's see a couple different ways of doing this.
[2611.26s -> 2614.26s]  This was one way of doing this.
[2614.26s -> 2617.26s]  Except that we still had this busy wait.
[2617.26s -> 2620.26s]  We still go to sleep for 10 milliseconds, wake up, go, hey, is there a perm available?
[2620.26s -> 2622.26s]  Go back to sleep, and so on.
[2622.26s -> 2625.26s]  And that's not really that great an idea.
[2625.26s -> 2629.26s]  It's not the end of the world, but it's not a particularly good strategy.
[2629.26s -> 2638.26s]  In order to have this set up so that we can actually wait for the permits to become available,
[2638.26s -> 2644.26s]  we have to use another language feature, or another type of variable,
[2644.26s -> 2648.26s]  which is going to be called a condition variable any.
[2648.26s -> 2651.26s]  There's also just a condition variable.
[2651.26s -> 2652.26s]  You can use either.
[2652.26s -> 2657.26s]  We'll just use condition variable any because it works with multiple different types of locks.
[2657.26s -> 2666.26s]  Basically what it does is it allows you to say, okay, I'm about to wait for some lock to be ready.
[2666.26s -> 2668.26s]  Please put me to sleep until that happens.
[2668.26s -> 2672.26s]  So it's very analogous to sig suspend in that case.
[2672.26s -> 2674.26s]  It's very analogous to that.
[2674.26s -> 2676.26s]  Here's what it actually looks like.
[2676.26s -> 2677.26s]  A couple of details about it.
[2677.26s -> 2679.26s]  By the way, this is not meant to scare you.
[2679.26s -> 2682.26s]  Jerry Cain thinks this is the hardest thing to understand in 110.
[2682.26s -> 2683.26s]  I'm not sure I agree.
[2683.26s -> 2688.26s]  But condition variable any's take a little bit of like, oh, and then you get it, right?
[2688.26s -> 2692.26s]  It took me a little while, but I'll try to do my best explaining it,
[2692.26s -> 2694.26s]  and then you'll just have to test it and see what happens.
[2694.26s -> 2696.26s]  But here's what happens.
[2696.26s -> 2702.26s]  You declare a condition variable any, and it has a weight function in it.
[2702.26s -> 2704.26s]  It actually has two weight functions.
[2704.26s -> 2705.26s]  We'll talk about the second one in a minute.
[2705.26s -> 2711.26s]  But it takes a weight, and it takes a new text variable as the parameter for weight.
[2711.26s -> 2714.26s]  So you have some lock that you've locked.
[2714.26s -> 2720.26s]  Then you call this condition variable any weight function with that lock.
[2720.26s -> 2725.26s]  What it does is it puts the thread to sleep,
[2725.26s -> 2732.26s]  and then unlocks the lock until some other thread basically signals.
[2732.26s -> 2735.26s]  In fact, there's two notify commands here.
[2735.26s -> 2742.26s]  The other threads notify the weight condition to wake up.
[2742.26s -> 2744.26s]  So that's what's happening here.
[2744.26s -> 2747.26s]  There are actually two notifies.
[2747.26s -> 2751.26s]  Always use notify all.
[2751.26s -> 2754.26s]  As it turns out, notify one is a little wonky sometimes.
[2754.26s -> 2755.26s]  It doesn't matter.
[2755.26s -> 2760.26s]  Notify one would be if you know that there's only one thread waiting.
[2760.26s -> 2764.26s]  You do notify one, and that one thread is the only one that will get notification.
[2764.26s -> 2769.26s]  Or if you have multiple ones, it will only notify one of the multiple ones waiting.
[2769.26s -> 2773.26s]  It's just better to write your logic to use notify all, as it turns out.
[2773.26s -> 2775.26s]  That's not particularly important.
[2775.26s -> 2778.26s]  Just know that we're generally going to see notify all to say,
[2778.26s -> 2782.26s]  anybody waiting for this, it's yours to try to get for the lock.
[2782.26s -> 2784.26s]  That's kind of what's going on.
[2784.26s -> 2791.26s]  So, to reiterate, we have this condition variable any variable.
[2792.26s -> 2794.26s]  When you use it, you declare the variable.
[2794.26s -> 2796.26s]  Everybody shares it, by the way.
[2796.26s -> 2798.26s]  Same thing, just like a mutex.
[2798.26s -> 2804.26s]  And then you pass in a lock that needs to be waited on.
[2804.26s -> 2809.26s]  It unlocks that, waits on it, and then when it gets a signal,
[2809.26s -> 2813.26s]  it relocks the lock, if it gets the lock, and then goes on.
[2813.26s -> 2815.26s]  That's how it works.
[2815.26s -> 2817.26s]  And you might be asking yourself, why does it unlock?
[2817.26s -> 2819.26s]  We'll see why it has to unlock.
[2819.26s -> 2822.26s]  If it doesn't unlock while it's waiting, bad things could happen.
[2822.26s -> 2827.26s]  It's just like, why does sigsuspend unblock the signals when it's actually waiting?
[2827.26s -> 2831.26s]  Because it kind of has to, in order for the rest of the logic to work.
[2831.26s -> 2832.26s]  Okay?
[2832.26s -> 2833.26s]  All right.
[2833.26s -> 2836.26s]  So, does that start to make sense about how that works?
[2836.26s -> 2837.26s]  Yeah.
[2837.26s -> 2844.26s]  Is the conditional variable any, like a C++ thing, or is it something that you made for this class?
[2844.26s -> 2845.26s]  Good question.
[2845.26s -> 2846.26s]  It's a very good question.
[2846.26s -> 2852.26s]  The conditional variable any is a C++ standard class, as it turns out.
[2852.26s -> 2857.26s]  We will see one in a few minutes that actually could be, but they never built it, so we'll use a different one.
[2857.26s -> 2858.26s]  You'll see.
[2858.26s -> 2859.26s]  I'll explain that in a minute.
[2859.26s -> 2860.26s]  But another thing.
[2860.26s -> 2861.26s]  But that's why it's a good question.
[2861.26s -> 2863.26s]  Because yeah, this one happens to be built for you.
[2863.26s -> 2868.26s]  And you do need it to be built for you, because you need the kernel to help out with this waiting business.
[2868.26s -> 2870.26s]  Just like you did in sigsuspend.
[2870.26s -> 2871.26s]  You're going to have a race condition otherwise.
[2871.26s -> 2872.26s]  So that's that.
[2872.26s -> 2875.26s]  Okay, let's actually go and build this one.
[2875.26s -> 2880.26s]  Them dining philosophers with CV wait one.
[2880.26s -> 2881.26s]  We will do two of these.
[2881.26s -> 2882.26s]  Whoops.
[2882.26s -> 2884.26s]  That'll be a CC.
[2884.26s -> 2885.26s]  Okay.
[2885.26s -> 2889.26s]  And what we're going to do here is it's basically going to be the same sort of thing.
[2889.26s -> 2891.26s]  I'm waiting on, there we go.
[2891.26s -> 2895.26s]  Basically the same idea as before.
[2895.26s -> 2897.26s]  We have to do a wait for permission, grant for permission, etc.
[2897.26s -> 2899.26s]  But let's start with main.
[2899.26s -> 2901.26s]  Some of these are going to stay the same, by the way.
[2901.26s -> 2904.26s]  We're not going to have to do any change, make any change to eat or think.
[2904.26s -> 2908.26s]  We'll probably make philosopher changes just because of some variables that we have to pass in.
[2908.26s -> 2911.26s]  But that's that.
[2911.26s -> 2914.26s]  Okay, well we might have to change the parameters a little bit as well.
[2914.26s -> 2916.26s]  In fact, I've already got it in here.
[2916.26s -> 2918.26s]  There's a condition variable any already in there.
[2918.26s -> 2920.26s]  I guess I left it.
[2920.26s -> 2921.26s]  But here's what we're going to do.
[2921.26s -> 2924.26s]  For main, again, same idea.
[2924.26s -> 2926.26s]  We're still going to have the permits.
[2926.26s -> 2929.26s]  Okay, we're still going to have the mutex.
[2929.26s -> 2933.26s]  The mutexes for the actual forks in there.
[2933.26s -> 2936.26s]  We're going to have another mutex, just kind of like what we did before.
[2936.26s -> 2938.26s]  We called it Permits Lock Before.
[2938.26s -> 2940.26s]  We're just going to call it M.
[2940.26s -> 2942.26s]  You will see this one a lot for mutex.
[2942.26s -> 2946.26s]  And we're just going to use that name for now.
[2946.26s -> 2950.26s]  Okay, and then we're going to have this condition variable any.
[2950.26s -> 2954.26s]  Condition variable any.
[2954.26s -> 2957.26s]  And we'll call that CV for condition variable.
[2957.26s -> 2959.26s]  Okay, same sort of thing here.
[2959.26s -> 2961.26s]  We're going to have the philosophers.
[2961.26s -> 2964.26s]  We're going to walk through each philosopher and start the threads.
[2964.26s -> 2966.26s]  We have to start them off again.
[2966.26s -> 2968.26s]  Philosophers.
[2968.26s -> 2971.26s]  I equals Thread.
[2971.26s -> 2973.26s]  In this case, philosopher.
[2973.26s -> 2975.26s]  Philosopher is the function.
[2975.26s -> 2979.26s]  I ref left ref right.
[2979.26s -> 2982.26s]  Ref Permits again.
[2982.26s -> 2988.26s]  And in this case, we're going to have ref CV for the condition variable.
[2988.26s -> 2992.26s]  And we need that Permits Lock as well.
[2992.26s -> 2999.26s]  Because remember, weight takes a mutex itself that's going to use to actually do the unlocking and locking.
[2999.26s -> 3004.26s]  So we have to do ref M as well.
[3004.26s -> 3006.26s]  Oh, thank you.
[3006.26s -> 3009.26s]  I'm missing prints on ref right.
[3009.26s -> 3010.26s]  All right.
[3010.26s -> 3011.26s]  There we go.
[3011.26s -> 3012.26s]  Let's see.
[3012.26s -> 3014.26s]  Let's see if this one.
[3014.26s -> 3015.26s]  Yes, it looks right there.
[3015.26s -> 3016.26s]  Thank you.
[3016.26s -> 3017.26s]  Okay, so that's that.
[3017.26s -> 3019.26s]  I don't believe there's anything else we have to do here.
[3019.26s -> 3020.26s]  We're still going to join.
[3020.26s -> 3022.26s]  Same thing as before.
[3022.26s -> 3023.26s]  All right.
[3023.26s -> 3029.26s]  Let's go look at some of these other functions that we have to do.
[3029.26s -> 3030.26s]  Let's see.
[3030.26s -> 3031.26s]  Are we going to have to change?
[3031.26s -> 3034.26s]  Oh, I already changed eat in this case.
[3034.26s -> 3040.26s]  So what we're going to do is we are going to do our wait for permission and our grant permission.
[3040.26s -> 3046.26s]  Now, this is where I'm going to show you a very cool new way to use a lock around a variable.
[3046.26s -> 3048.26s]  It is called a lock guard.
[3048.26s -> 3050.26s]  Okay, here's how it's going to work.
[3050.26s -> 3054.26s]  Lock guard, it goes like this.
[3054.26s -> 3056.26s]  Mutex, because it takes a parameter like that.
[3056.26s -> 3059.26s]  Lock guard M.
[3059.26s -> 3061.26s]  And here's what this does.
[3061.26s -> 3063.26s]  This is why it's such a cool class.
[3063.26s -> 3065.26s]  It's the easiest class in the world.
[3065.26s -> 3068.26s]  All it has is a constructor and a destructor.
[3068.26s -> 3075.26s]  In the constructor, the only thing it does is calls lock on that mutex.
[3075.26s -> 3082.26s]  When you create this, so at this point, after this line, the mutex has been locked.
[3082.26s -> 3088.26s]  The only thing the destructor does is call M.unlock.
[3088.26s -> 3093.26s]  What's nice about classes like this, and in C++ this is true,
[3093.26s -> 3097.26s]  whenever a variable goes out of scope, what happens?
[3097.26s -> 3099.26s]  The destructor gets called.
[3099.26s -> 3104.26s]  So we don't need to worry about unlocking this as long as we want to unlock as we leave.
[3104.26s -> 3107.26s]  We just say, well, it's out of scope, it's going to get unlocked.
[3107.26s -> 3113.26s]  It's the cleverest little class I've ever seen because of that.
[3113.26s -> 3118.26s]  Now, what we're going to do here is we're going to do a while loop.
[3118.26s -> 3121.26s]  Permits equals zero.
[3121.26s -> 3125.26s]  And then we're going to do cv.wait.
[3125.26s -> 3131.26s]  And then we're going to wait on the lock that we already just locked.
[3131.26s -> 3146.26s]  And then if at any time we get notified that the permit has actually gone above zero,
[3146.26s -> 3151.26s]  whenever we get notified, we will check again to see if it's still zero.
[3151.26s -> 3153.26s]  Then we will do that.
[3153.26s -> 3161.26s]  After the cv.wait, it unlocks so that it can go back and do the check again.
[3161.26s -> 3163.26s]  I'm sorry, relocks.
[3163.26s -> 3167.26s]  So it can do the check again so that you don't have two different threads trying to do that.
[3167.26s -> 3168.26s]  I'll go over that again.
[3168.26s -> 3174.26s]  And then after here, we know that at this point we have gotten to a place where permits equals zero.
[3174.26s -> 3176.26s]  We have the lock still.
[3176.26s -> 3180.26s]  And then we know that we can do permits.
[3180.26s -> 3183.26s]  Permits is not equal to zero at this point, I should say.
[3183.26s -> 3188.26s]  We can do permits minus minus like that.
[3188.26s -> 3193.26s]  At what point does the lock unlock for reals after 62?
[3193.26s -> 3199.26s]  After we leave the function, it's out of scope, the destructor gets called, the lock gets unlocked.
[3199.26s -> 3201.26s]  So let's walk through it one more time.
[3201.26s -> 3203.26s]  This is definitely challenging.
[3203.26s -> 3209.26s]  We lock the lock using this lock guard so we know it's going to get unlocked.
[3209.26s -> 3210.26s]  We now hold it.
[3210.26s -> 3214.26s]  Now, many threads could be contending on this, but one of them is going to get it.
[3214.26s -> 3216.26s]  Assume that our thread is the one that gets it.
[3216.26s -> 3225.26s]  Then we go down and we say, oh, if permits is zero, then we better wait because there are no permits available.
[3225.26s -> 3234.26s]  What happens is we tell wait, use my mutex variable to wait on and unlock it after you push me off the processer.
[3234.26s -> 3239.26s]  It unlocks the mutex and then sits around waiting for it to be notified.
[3239.26s -> 3248.26s]  When it gets notified, it reacquires that lock, if it can, and then it goes and checks and then comes back up to the top of the while loop again
[3248.26s -> 3253.26s]  and checks, sorry, the while loop again, and checks to see if permits is zero again.
[3253.26s -> 3259.26s]  At this point, hopefully it is not. In fact, it wouldn't be if we acquired the lock and we got notified that it wouldn't be
[3259.26s -> 3264.26s]  and then it would get out of the while loop decrement permits because we are now holding one.
[3264.26s -> 3265.26s]  Yes?
[3265.26s -> 3276.26s]  It's waiting for whoever notifies it.
[3276.26s -> 3278.26s]  Now, let's see who notifies it. Let's go on to the next thing.
[3278.26s -> 3288.26s]  Oh, yeah, if you unlock it, good question. If you unlock it, it's not even guaranteed that the same thread will get the lock again.
[3288.26s -> 3296.26s]  The CV wait tries to unlock. If it can't unlock, it just goes back to sleep until it gets another notification.
[3296.26s -> 3299.26s]  Because it tried and it can't do it, so that's that.
[3299.26s -> 3305.26s]  It tries to, sorry, it tries to relock. Yes, thank you. It tries to relock.
[3305.26s -> 3309.26s]  If it can't, it just goes, oh, I'll wait around again. I'll keep waiting until I get another notification.
[3309.26s -> 3313.26s]  Let's see who notifies it. Well, there's only one other thing that really could notify it in this case.
[3313.26s -> 3316.26s]  Right, it's grant permission. Let's see how that works.
[3316.26s -> 3325.26s]  Grant permission is also going to use a lock guard for a Nutex LGM.
[3325.26s -> 3331.26s]  Okay, and now all lock guard, remember all lock guard needed to do before was update permits.
[3331.26s -> 3338.26s]  Permits++ because it's releasing the lock or the permit that it just finished eating.
[3338.26s -> 3341.26s]  Therefore, it's going to release this and we're good to go.
[3341.26s -> 3349.26s]  Okay, well, now once it's released it, right, what does it need to do?
[3349.26s -> 3355.26s]  Well, it needs to tell everybody else, hey, guess what, there's a permit there.
[3355.26s -> 3361.26s]  Now, what is the only case where it would matter if we have four permits?
[3361.26s -> 3364.26s]  One, that's the only one that would matter, right?
[3364.26s -> 3370.26s]  So if permits equals one, because we're the ones who just made it go from zero to one,
[3370.26s -> 3373.26s]  meaning there's going to be someone possibly waiting for that,
[3373.26s -> 3382.26s]  then we might as well notify, sorry, cv, I should say cv.notifyall.
[3382.26s -> 3388.26s]  And that will send a notification to the other threads that are waiting
[3388.26s -> 3393.26s]  for them all to try to wake up and reacquire that lock.
[3393.26s -> 3399.26s]  And when they reacquire that lock, then the one that does gets the permit and moves on.
[3399.26s -> 3400.26s]  Question?
[3400.26s -> 3404.26s]  Is that only for clarity, or would something break if we didn't actually keep it?
[3404.26s -> 3407.26s]  Like, maybe if we didn't make it only a permit, we could do more.
[3407.26s -> 3409.26s]  Oh, is it only for clarity?
[3409.26s -> 3413.26s]  Like, you know, if you just said cv.notify after you do that, it probably wouldn't matter, actually,
[3413.26s -> 3415.26s]  because they're all checking for zero anyway.
[3415.26s -> 3418.26s]  So if there's one available, then, yeah, I don't think that would, I think that would,
[3418.26s -> 3420.26s]  it's not necessarily just for clarity.
[3420.26s -> 3423.26s]  It's just for, let's not send more notifications than we need to either.
[3423.26s -> 3428.26s]  There's definitely not going to be any worry if there's two or more than one at that point.
[3429.26s -> 3430.26s]  Okay.
[3432.26s -> 3434.26s]  How does everybody feel about this one at this point?
[3434.26s -> 3435.26s]  Let's try it.
[3435.26s -> 3438.26s]  Anybody see any bugs?
[3438.26s -> 3444.26s]  Make Dining Philosophers with CV Wait 1.
[3444.26s -> 3451.26s]  Alright, Dining Philosophers with CV Wait 1, and there we go, and it should, there we go.
[3451.26s -> 3454.26s]  Continue, continue, continue until they all do it.
[3454.26s -> 3455.26s]  Okay?
[3455.26s -> 3457.26s]  So that's how that works.
[3457.26s -> 3458.26s]  Question.
[3458.26s -> 3464.26s]  How does CV know how many threads there are?
[3464.26s -> 3466.26s]  How does CV know how many threads there are?
[3466.26s -> 3467.26s]  It has no idea.
[3467.26s -> 3469.26s]  Does it need to?
[3469.26s -> 3475.26s]  It doesn't really need to, it just, your logic is what kind of dictates when these things,
[3475.26s -> 3478.26s]  we do know that permits is what we're looking for.
[3478.26s -> 3481.26s]  We're looking for four permits, there's four permits available.
[3481.26s -> 3484.26s]  If four Dining Philosophers already have those permits,
[3484.26s -> 3487.26s]  we are not going to let another Dining Philosopher even pick up the first fork,
[3487.26s -> 3489.26s]  that's what's happening there, right?
[3489.26s -> 3497.26s]  And we're using this idea that we are trying, when we first go in to lift up the left fork,
[3497.26s -> 3501.26s]  we're going in and saying, get us permission first.
[3501.26s -> 3506.26s]  And that's where the permission, that's where the wait for permissions comes into play.
[3506.26s -> 3509.26s]  Which says, okay, everybody's going to do this first,
[3509.26s -> 3511.26s]  they're going to try to acquire the lock,
[3511.26s -> 3515.26s]  if they acquire it, they're going to check and see if there are permits available.
[3515.26s -> 3520.26s]  If there are not permits available, then they're going to wait for a permit to be available.
[3520.26s -> 3523.26s]  When one becomes available, they're going to try to reacquire that lock,
[3523.26s -> 3528.26s]  and then decrement permits such that they actually hold one.
[3528.26s -> 3530.26s]  Yeah, one second.
[3530.26s -> 3532.26s]  So Notify All, how does it know?
[3532.26s -> 3537.26s]  Oh, Notify All, it's like some global variable that everybody's looking at basically.
[3537.26s -> 3542.26s]  I think the kernel has some role in this as well, the thread manager or whatever,
[3542.26s -> 3545.26s]  but it's built in such that when you say Notify All,
[3545.26s -> 3550.26s]  anybody who happens to be waiting has registered to get that notification when it happens.
[3550.26s -> 3556.26s]  Why didn't we use a Lambda function one? We will.
[3556.26s -> 3558.26s]  We're going to see a different one in a second.
[3558.26s -> 3563.26s]  Because this while loop is here,
[3563.26s -> 3567.26s]  this is a really common way of doing this.
[3567.26s -> 3571.26s]  You can't really say if Permits equals equals zero
[3571.26s -> 3574.26s]  because there is going to be some sort of a race condition in there
[3574.26s -> 3578.26s]  to actually reacquire that lock later.
[3578.26s -> 3582.26s]  So this while some condition is true, wait on it,
[3582.26s -> 3586.26s]  that's so common that they've built it into the condition variable any.
[3586.26s -> 3589.26s]  So if you didn't have the while loop, then you'd use the Lambda function?
[3589.26s -> 3591.26s]  If you didn't have the while loop, you will.
[3591.26s -> 3596.26s]  Let's see what that Lambda function that you're talking about looks like in a second.
[3596.26s -> 3601.26s]  We talked about all of this with requiring lock.
[3601.26s -> 3606.26s]  Like I said, because this is such a common thing to do,
[3606.26s -> 3609.26s]  we have it built in such that it looks like this.
[3609.26s -> 3613.26s]  It's actually a templated function, which basically means that
[3613.26s -> 3616.26s]  you don't know exactly what the type is going to be, but that's okay.
[3616.26s -> 3618.26s]  Here's what you do.
[3618.26s -> 3623.26s]  Instead of doing a while loop, you let the wait statement do that while loop for you
[3623.26s -> 3629.26s]  by passing in some other function that makes a decision
[3629.26s -> 3636.26s]  and returns true or false based on that question.
[3636.26s -> 3641.26s]  In this case, you would say, and this is exactly what it's doing in here,
[3641.26s -> 3644.26s]  is that while loop, which is doing it for you.
[3644.26s -> 3646.26s]  So what could this predicate be?
[3646.26s -> 3651.26s]  Well, it could be a function that checks to see if permits is zero or not.
[3651.26s -> 3652.26s]  Okay, that's what it is.
[3652.26s -> 3656.26s]  You can't just pass in the value permits equals equals zero
[3656.26s -> 3659.26s]  because you need to check it every time and it could change.
[3659.26s -> 3662.26s]  So if you tried to pass it in directly as that, you have to do it.
[3662.26s -> 3663.26s]  So what do you do?
[3663.26s -> 3670.26s]  You pass it in as a function or, since we're in C++, as a Lambda function,
[3670.26s -> 3673.26s]  which is the way we can actually do this here.
[3673.26s -> 3677.26s]  Let's think about what this is actually doing.
[3677.26s -> 3680.26s]  You would say, and this is the same function we had before,
[3680.26s -> 3683.26s]  CV wait, there's your mutex lock.
[3683.26s -> 3686.26s]  Remember, it's going to unlock it and reacquire it later.
[3686.26s -> 3695.26s]  You're going to say, give me access in here to the reference of the permits variable in that function.
[3695.26s -> 3700.26s]  And in that function, you are going to check and see if permits is greater than zero
[3700.26s -> 3702.26s]  and return true if it's greater than zero.
[3702.26s -> 3704.26s]  That's basically the exact same check you were doing before.
[3704.26s -> 3707.26s]  It's the inverse of the check that's equal equals zero.
[3707.26s -> 3716.26s]  The Lambda that you pass has to be a Boolean return.
[3716.26s -> 3720.26s]  Because it's asking, it has to know when to get out of that.
[3720.26s -> 3722.26s]  Remember, here's how it's built, right?
[3722.26s -> 3725.26s]  While that, which is true or false, right?
[3725.26s -> 3727.26s]  So that's that.
[3727.26s -> 3730.26s]  It could return something that can be converted into a true or false,
[3730.26s -> 3733.26s]  but that has to be true or false in that sense.
[3733.26s -> 3735.26s]  So that's how you use that.
[3735.26s -> 3737.26s]  And you don't need to worry about even the while loop.
[3737.26s -> 3742.26s]  So this is why these CV variables are relatively common.
[3742.26s -> 3749.26s]  So, we can go one step further.
[3749.26s -> 3754.26s]  This idea that maybe we're waiting for a whole bunch of threads,
[3755.26s -> 3760.26s]  some concrete maximum number of them can do something.
[3760.26s -> 3764.26s]  We could use this CV with this permits variable.
[3764.26s -> 3770.26s]  Why not wrap it into another type of data structure or class
[3770.26s -> 3776.26s]  that actually allows us to do this for any number of various permits, etc.
[3777.26s -> 3785.26s]  This is what we call a semaphore, which is basically this whole idea
[3785.26s -> 3792.26s]  of I have X number of threads and I have only some of those
[3792.26s -> 3795.26s]  allowed to do something at a given time.
[3795.26s -> 3798.26s]  In our case, it's pick up forks, which seems a little silly.
[3798.26s -> 3802.26s]  In a real life scenario, when you're going to code up for the next assignment,
[3803.26s -> 3805.26s]  you're going to be querying the internet
[3805.26s -> 3808.26s]  and you're going to be doing it in many threads.
[3808.26s -> 3811.26s]  And what we want to do is we want to limit the number of threads
[3811.26s -> 3814.26s]  that are actually accessing a particular web page.
[3814.26s -> 3818.26s]  I don't know if you know, have you ever heard of a DDoS,
[3818.26s -> 3821.26s]  a distributed denial of service attack?
[3821.26s -> 3824.26s]  It basically means that you have a website
[3824.26s -> 3826.26s]  and it's able to take a bunch of connections
[3826.26s -> 3828.26s]  for people who want the web pages.
[3828.26s -> 3833.26s]  And what happens is various nefarious people get lots of servers
[3833.26s -> 3837.26s]  that try to hammer away at asking for requests from that web server
[3837.26s -> 3839.26s]  and it can't field them all.
[3839.26s -> 3842.26s]  And so people who aren't nefarious are trying to access it
[3842.26s -> 3844.26s]  and it basically brings the website down
[3844.26s -> 3846.26s]  or it makes it really hard to access it quickly.
[3846.26s -> 3848.26s]  You don't want to do that if you're nice.
[3848.26s -> 3850.26s]  So you want to limit the number of threads
[3850.26s -> 3853.26s]  that can access a particular website at a given time.
[3853.26s -> 3855.26s]  We're going to do it somewhat artificially,
[3855.26s -> 3856.26s]  but you want to be able to do that.
[3856.26s -> 3859.26s]  You want to be nice and many times you want to limit the number of things
[3859.26s -> 3861.26s]  that can happen at a particular time.
[3861.26s -> 3862.26s]  This is how you'll do it.
[3862.26s -> 3865.26s]  So you might have 100 threads ready to go to that website
[3865.26s -> 3866.26s]  asking for something, but you say,
[3866.26s -> 3869.26s]  no, no, let's only let 10 do it at a time
[3869.26s -> 3872.26s]  so that we're nice so other people can get in there and do that.
[3872.26s -> 3873.26s]  That's what's happening.
[3873.26s -> 3875.26s]  And this is a very common sort of idea.
[3875.26s -> 3880.26s]  And in this case, we're going to use a thing called a semaphore to do this.
[3881.26s -> 3883.26s]  Your question came up earlier.
[3883.26s -> 3887.26s]  Is condition variable any built into C++?
[3887.26s -> 3889.26s]  Yes, they're a library.
[3889.26s -> 3892.26s]  The bigger question is why isn't a semaphore built into the library?
[3892.26s -> 3893.26s]  Who knows?
[3893.26s -> 3895.26s]  It turns out it's really easy to build one
[3895.26s -> 3897.26s]  because all we're doing is really wrapping around that variable
[3897.26s -> 3899.26s]  that's the number and account we have.
[3899.26s -> 3901.26s]  Why didn't they just build it in there?
[3901.26s -> 3902.26s]  Who knows?
[3902.26s -> 3904.26s]  Maybe some other version of C++ will have that in there,
[3904.26s -> 3905.26s]  but they don't have it.
[3905.26s -> 3909.26s]  But let's actually see how it's built.
[3910.26s -> 3911.26s]  The semaphore constructor,
[3911.26s -> 3914.26s]  it says the semaphore constructor is so short that it's inlined.
[3914.26s -> 3917.26s]  Let me actually show you this.
[3917.26s -> 3922.26s]  CD slash user slash class CS110 local include.
[3922.26s -> 3924.26s]  I had to look up what this was.
[3924.26s -> 3927.26s]  And then semaphore dot h.
[3927.26s -> 3928.26s]  Here we go.
[3928.26s -> 3930.26s]  Here's the class itself.
[3930.26s -> 3933.26s]  There's the class definition right there.
[3933.26s -> 3935.26s]  And notice that constructor.
[3935.26s -> 3937.26s]  That constructor has an integer,
[3937.26s -> 3940.26s]  as the value, and it just either sets it to zero
[3940.26s -> 3944.26s]  or it sets it to whatever value number you pass in in the constructor.
[3944.26s -> 3948.26s]  So if you say I want five dining philosophers,
[3948.26s -> 3951.26s]  you would say semaphore parentheses five,
[3951.26s -> 3953.26s]  and it just sets that variable to five.
[3953.26s -> 3955.26s]  Just like we did with permits equals,
[3955.26s -> 3957.26s]  or I guess semaphore equals four, let's say.
[3957.26s -> 3958.26s]  Permits equals four.
[3958.26s -> 3960.26s]  It's exactly what that's doing here.
[3960.26s -> 3965.26s]  That's all the semaphore needs to do for this case.
[3965.26s -> 3966.26s]  Okay?
[3967.26s -> 3971.26s]  And then there is a wait function as part of the semaphore.
[3971.26s -> 3972.26s]  It's very simple.
[3972.26s -> 3975.26s]  It's exactly what we've already kind of seen here.
[3975.26s -> 3981.26s]  It basically puts a lock around the mutex that it's got,
[3981.26s -> 3986.26s]  and then it calls the wait function to try to wait for it
[3986.26s -> 3991.26s]  based on the value being greater than zero.
[3991.26s -> 3993.26s]  And the value being greater than zero
[3993.26s -> 3996.26s]  is the number of permits, if you will, that we have.
[3996.26s -> 3999.26s]  If that number is greater than zero,
[3999.26s -> 4002.26s]  then it decrements it and ends up
[4002.26s -> 4006.26s]  making it so that it keeps track of those permits.
[4006.26s -> 4009.26s]  So it's really a very simple wrapper
[4009.26s -> 4013.26s]  around a condition variable any
[4013.26s -> 4015.26s]  that does all the stuff we wanted to do.
[4015.26s -> 4018.26s]  Again, it's because we do this so often.
[4018.26s -> 4019.26s]  Okay?
[4019.26s -> 4021.26s]  So that's how the mutex works.
[4021.26s -> 4022.26s]  Okay, like that.
[4022.26s -> 4025.26s]  At the end, when you are done,
[4025.26s -> 4028.26s]  or when you are done with your permit,
[4028.26s -> 4030.26s]  all you need to do is call signal.
[4030.26s -> 4031.26s]  You don't need to worry about whether or not
[4031.26s -> 4033.26s]  the permits are greater than or equal to zero.
[4033.26s -> 4034.26s]  It just does exactly that.
[4034.26s -> 4038.26s]  It does what we did before in the actual class.
[4038.26s -> 4040.26s]  It increments it.
[4040.26s -> 4041.26s]  Okay?
[4041.26s -> 4045.26s]  We'll talk about another interesting use of this, by the way,
[4045.26s -> 4048.26s]  as we'll see this kind of next time, next week,
[4048.26s -> 4049.26s]  when we get on there.
[4049.26s -> 4053.26s]  But in this case, let's see how we might modify our
[4053.26s -> 4056.26s]  we might modify our dining philosophers in this case.
[4056.26s -> 4061.26s]  Well, we can say semaphore permits.
[4061.26s -> 4062.26s]  Okay?
[4062.26s -> 4065.26s]  We can say semaphore permits of however many we want.
[4065.26s -> 4067.26s]  No more need for a condition variable any.
[4067.26s -> 4069.26s]  It's already built into the semaphore,
[4069.26s -> 4071.26s]  meaning that all we need to do now
[4071.26s -> 4075.26s]  is pass in a reference to that semaphore
[4075.26s -> 4077.26s]  as the permits.
[4077.26s -> 4078.26s]  Okay?
[4078.26s -> 4081.26s]  And everything else stays the same except
[4081.26s -> 4086.26s]  now we don't need to call a particular function on this.
[4086.26s -> 4087.26s]  We've got the semaphore,
[4087.26s -> 4090.26s]  which is doing all of that like checking for us.
[4090.26s -> 4092.26s]  So we just say permits.wait.
[4092.26s -> 4093.26s]  What does that mean?
[4093.26s -> 4097.26s]  It will wait until there are at least one permit available
[4097.26s -> 4099.26s]  or there is at least one permit available.
[4099.26s -> 4101.26s]  And that's where it will do it.
[4101.26s -> 4102.26s]  Okay?
[4102.26s -> 4104.26s]  And if you want to, when you're done with your permit,
[4104.26s -> 4106.26s]  you call permits.signal.
[4106.26s -> 4109.26s]  So it's all that stuff we just talked about that simplifies it.
[4109.26s -> 4111.26s]  And says, oh, now we've got this thing called a semaphore,
[4111.26s -> 4113.26s]  which says you have, you know,
[4113.26s -> 4115.26s]  X number of things that can do it at a time
[4115.26s -> 4119.26s]  and maybe X plus Y number of things that want it.
[4119.26s -> 4125.26s]  Wait until there are at least one available to do that.
[4125.26s -> 4130.26s]  When can't you use semaphores?
[4130.26s -> 4131.26s]  When can't you use semaphores?
[4131.26s -> 4134.26s]  When is it more better to use that?
[4134.26s -> 4136.26s]  You will see a couple of examples in the lab next week,
[4136.26s -> 4137.26s]  no labs this week.
[4137.26s -> 4139.26s]  You'll see a couple of examples in the lab next week
[4139.26s -> 4141.26s]  or the week after where you'll see this CV and you'll go,
[4141.26s -> 4144.26s]  oh, now I see why that might be important to use that.
[4144.26s -> 4146.26s]  But better generally, we're going to almost always use,
[4146.26s -> 4152.26s]  you will probably need one for a future assignment
[4152.26s -> 4155.26s]  where you're not really waiting for a whole bunch of things.
[4155.26s -> 4160.26s]  And by the way, a mutex is just a semaphore with a value of one
[4160.26s -> 4163.26s]  because a mutex is either locked or unlocked for one thing.
[4163.26s -> 4164.26s]  That's really all it is.
[4164.26s -> 4169.26s]  So mutex is like a special version of semaphore for only one thing.
[4169.26s -> 4171.26s]  Okay, but yeah, we'll see some more examples
[4171.26s -> 4174.26s]  where you will probably need a condition variable.
[4174.26s -> 4178.26s]  But in general, most of the time you'll be able to use semaphores for this.
[4178.26s -> 4179.26s]  Okay, all right.
[4179.26s -> 4181.26s]  I think we should probably stop there.
[4181.26s -> 4184.26s]  You guys have midterm coming up, you have other things and that's that.
[4184.26s -> 4186.26s]  Are there any last minute questions?
[4186.26s -> 4188.26s]  I'm going to also go back from here,
[4188.26s -> 4190.26s]  back to my office for another hour and a half or so
[4190.26s -> 4193.26s]  for office hours if you want to come by.
[4193.26s -> 4199.26s]  All right, we'll see you tomorrow for the midterm.
