# Detected language: en (p=1.00)

[0.00s -> 1.58s]  Welcome
[1.58s -> 3.34s]  All right
[3.34s -> 5.78s]  Welcome to the 19 of you that are here
[6.34s -> 9.66s]  No, it's more than that for people watching this on video. There's more fuel than that here
[10.26s -> 11.42s]  so
[11.42s -> 13.10s]  assignment three
[13.10s -> 16.78s]  Hopefully ended up. Okay, there were lots of Piazza questions and lots of
[17.58s -> 22.66s]  consternation about race conditions and this and that and that's the kind of thing you have to deal with when you're doing
[23.18s -> 26.74s]  multi processing also multi threading which we're going to talk about today and
[27.08s -> 28.40s]  And
[28.40s -> 32.32s]  You will do more multi processing for this week's assignment
[32.32s -> 37.34s]  And then of course you'll practice it a little bit on the midterm as well. So big week this week
[37.34s -> 44.08s]  I think I'm already behind but we will keep going forward here today
[46.28s -> 49.48s]  The midterm is Thursday the
[50.00s -> 54.16s]  It's 6 to 8 p.m. Hewlett 200, which is across the hall. It's not this one
[54.16s -> 59.18s]  Don't sit in here and think where's everybody it's across the hall. If you are taking an alternate exam
[59.18s -> 61.48s]  Hopefully you already emailed me if you haven't please do that
[62.10s -> 66.50s]  Today so I can set things up and same thing for any accommodations that you have
[66.98s -> 73.06s]  Do that I plan on sending out emails about that this evening for people who talk to me about those things already
[73.72s -> 79.98s]  The exam is going to be on blue book who has used blue book before raise your hands about
[80.40s -> 82.40s]  Half of you maybe
[82.60s -> 88.52s]  to the other half what it is is you have your laptop and you load a program on it that tape that you take the
[88.52s -> 93.84s]  test on and it submits it to us and we grade it all kind of digitally the
[94.56s -> 98.32s]  Nice thing about blue book is that you get to type your answers some people think that's nice anyway
[98.76s -> 105.24s]  But it feels very much like taking a paper exam in that we don't really we can't compile code
[105.24s -> 109.88s]  You can't look things up. You can't copy and paste within the application and so forth
[110.42s -> 114.90s]  But you should get get it working on your computer before coming to the midterm
[114.98s -> 120.70s]  What happens is we will publish an encrypted exam sometime on either Wednesday night or Thursday
[121.86s -> 125.90s]  Morning that is that you can download and then when you get to the exam
[125.90s -> 132.74s]  We give you a password and then it starts the exam for you and it is timed on the computer and so forth
[132.94s -> 138.54s]  If for some reason you don't have a laptop or your laptop battery is going to die after five minutes or something
[139.08s -> 144.08s]  You should talk to me sooner than later so we can find you another laptop to to use or
[145.44s -> 150.24s]  Like for your battery issues, we will have some plugs but they're not going to be like for everybody. So
[151.08s -> 153.56s]  Most most people's laptops these days will last two hours
[153.56s -> 156.08s]  Although I know some people are hurt
[156.08s -> 159.30s]  There's only last like an hour and a half and you have to have to get near a power plug
[159.30s -> 164.32s]  We will have that available for some extent you are allowed one back in front piece of paper
[166.04s -> 168.04s]  For your own notes or whatever
[168.56s -> 174.72s]  Please don't bring any magnifying devices regular glasses are fine. Like I don't see people like, you know, like microscope here
[175.60s -> 180.24s]  The I think I told this to people in 106 B when I was doing a similar sort of thing
[180.24s -> 182.56s]  I once heard and I mentioned somebody else recently
[182.56s -> 188.40s]  I once heard of a professor saying you can use anything you can bring in to the exam
[188.80s -> 193.68s]  For notes or to use for the exam and somebody came in carrying a graduate student
[193.68s -> 195.68s]  Oh
[196.70s -> 201.80s]  No, you're that one piece of paper back in front we will also did that did the joke just finally sicken
[202.58s -> 205.66s]  We will we'll also give you a somewhat limited
[206.18s -> 211.06s]  resource resources sheet it looks kind of like this where basically gives you all of the
[212.86s -> 218.10s]  Prototypes and things for functions that you'll need and then some some specific constants and things that you'll need
[218.54s -> 221.30s]  We are not trying to make you memorize those sorts of things
[221.32s -> 224.48s]  So if in the middle of the exam you like I forget how to do that it's probably not going to matter
[224.48s -> 228.52s]  We're not going to try to compile your code necessarily, but but either way
[228.52s -> 233.68s]  It's not that that we're not testing you on that do the best you can with those sorts of things
[234.80s -> 241.60s]  Let's see. I think that's about it. All the comments I have about the midterm any questions at this point about the midterm
[242.68s -> 243.84s]  comments
[243.84s -> 245.20s]  It's to our exam
[245.20s -> 249.44s]  I'm gonna try to make it so that you finish it that most people finish within an hour and a half or so
[249.44s -> 256.18s]  I mean, I don't want this to be a test of your ability to like race through hard problems because they are sometimes difficult
[267.18s -> 270.34s]  Good question, what's the format going to be? Is it going to be like the practice ones?
[270.34s -> 275.58s]  I would say it's going to be kind of most like the last practice one, which is a couple of programming problems
[276.16s -> 278.28s]  I'll try to walk you through the details of that pretty
[278.28s -> 282.98s]  I'm not I don't want a wall of text if I can help it and then maybe a problem like the
[283.12s -> 285.28s]  Try to figure out what's going on with these signals
[285.28s -> 290.92s]  Like what's the output sort of thing and then some then some short answer questions, which kind of cover the spectrum
[291.12s -> 294.12s]  That's probably the way it'll be. I'm still in the middle of finishing it
[294.72s -> 296.72s]  Writing it anybody else
[297.60s -> 300.80s]  Okay, so we have another assignment
[301.14s -> 303.14s]  This
[303.50s -> 307.54s]  Assignment Stanford shell I'm going to do a little demo of it to show you what it's what it is
[307.82s -> 312.22s]  Is a is kind of a neat assignment. It's basically building the shell
[312.82s -> 317.58s]  that you use every day and have used since 107 and it's
[318.22s -> 320.42s]  It needs to handle certain things
[320.78s -> 323.90s]  You need to be able to do the basic things like quit it or exit it
[323.90s -> 330.06s]  You will be putting processes in the background or in the foreground kind of like what we did in our simple shell
[330.52s -> 332.92s]  So you can use that as a hey, how did we do it then?
[332.92s -> 334.92s]  And what do we need to do differently now?
[334.92s -> 339.68s]  You also have to keep track of all the processes so you'll be able to have multiple processes
[339.68s -> 344.44s]  You can throw in the background and then maybe a foreground process as well and your program has to handle all of those
[344.80s -> 349.36s]  Okay, so you need to be able to use FG to bring a background process into the foreground
[349.44s -> 356.40s]  You need to be able to do BG which restarts a stopped background process and you can tell it which one as well
[356.88s -> 363.06s]  You also have to be able to kill a set of processes and this is an interesting one. We have this term this
[363.58s -> 369.30s]  command called slay which basically will you will send to a process group and
[370.42s -> 374.58s]  That's a the group of processes like for instance down here. We have
[375.12s -> 380.64s]  LS piped through grab piped through cut well, they will all be in the same process group
[380.64s -> 382.64s]  And if you kill the process group, they all die
[382.64s -> 385.48s]  So that's the sort of thing you're gonna have to think about when you're doing this
[385.48s -> 390.96s]  You also can halt a process that's currently running. You're gonna send a SIG stop to it or actually a SIG
[391.30s -> 393.54s]  Actually, I think it is a SIG stop to it you
[394.10s -> 395.62s]  Will be able to continue a process
[395.62s -> 401.22s]  You'll also be able to tell what jobs are running with a command so you can see what the process IDs for all those
[401.22s -> 404.58s]  Jobs are and you're gonna be responsible for setting up the pipelines
[404.58s -> 409.08s]  I think this is one of the trickier parts of this assignment is getting this to work where you have
[409.42s -> 413.38s]  LS piped through grab piped through cut for any number of these
[413.68s -> 416.18s]  And you'll also have to do things like sort
[416.96s -> 419.96s]  Input from a file as standard in error
[419.96s -> 424.60s]  I guess read from yeah standard in and then maybe output to another file
[424.60s -> 428.74s]  So those are things you're gonna have to think about as well. So there's a lot of moving parts to this
[429.40s -> 434.14s]  For that the piping you have to think about what's happening here and you have to go. Okay. Well
[434.56s -> 437.40s]  LS needs to have its standard out going to
[437.70s -> 442.10s]  Grep is it standard in it sounds a lot like pipeline right which you've already done
[442.10s -> 445.58s]  but this is a more robust version and then same thing for
[446.42s -> 449.78s]  Grep has to send its output to cut so guess what?
[449.78s -> 455.10s]  There's gonna be like a pipe here and another pipe here and they're not going to be the same pipe and you have to
[455.10s -> 460.36s]  Start them and stop them different places. And so it's it's a little bit trickier to get that that going
[461.22s -> 465.88s]  You'll also have to be handoff terminal control to foreground process
[466.14s -> 468.14s]  Sometimes when you type when you type in
[468.82s -> 473.42s]  Process. Well, your terminal isn't really grabbing the input anymore. It's whatever program is running
[473.42s -> 477.52s]  So there's a little bit of a handoff there. That's not actually one of the hardest things about the program
[477.52s -> 479.52s]  You just have to end up thinking about it question
[484.02s -> 485.30s]  It is a good question
[485.30s -> 490.06s]  It's not gonna rely on pipeline surprise you kind of recreate them in the form that we at least the pipeline one in the
[490.06s -> 495.48s]  Form that you that we will have for you. Yeah, what are their questions just so far on this?
[496.88s -> 500.24s]  All right this evening I will do my best to put up a little video
[501.38s -> 503.78s]  Describing some of the details a little bit better
[504.40s -> 506.24s]  There are a lot of moving parts to this
[506.24s -> 511.22s]  Okay, there's a ton of moving parts because you have to kind of think about all the little nuances to this shell
[511.56s -> 516.60s]  There's a bunch of header files always read through those first if you've already downloaded the assignment read through those
[516.62s -> 518.62s]  You're only going to be putting
[518.62s -> 524.70s]  Modifying one program. So that's at least like good. It won't be like trying to you know, figure out six different programs
[525.34s -> 530.32s]  You can test those shell either by running programs. I'll show you in a second or through a
[531.02s -> 536.42s]  Driver program which basically runs the shell using some input so you can see the output
[536.74s -> 539.62s]  You know in a way that you can test a little better. So it's a good way to test
[539.62s -> 542.22s]  So get used to using the little driver
[543.14s -> 545.14s]  you would definitely have to
[545.14s -> 549.14s]  Have a SIG child handler because all of your children are going to be
[549.58s -> 554.86s]  Starting continuing stopping all that kind of stuff and it's the child handler that's going to be
[555.78s -> 560.44s]  Manipulating those and taking care of which programs are stopping when and so forth
[561.50s -> 564.38s]  In some sense. It's a little like farm in that
[564.38s -> 569.30s]  You have to get your SIG child handler pretty robust to get these you'll also have another
[569.70s -> 575.74s]  Handler or maybe two and by the way, you can make these into one handler if you want your shell now
[575.74s -> 577.74s]  If I go to a shell by the way
[577.74s -> 582.12s]  If I go over to a shell and I type ctrl C my shell doesn't die
[582.58s -> 587.90s]  Right, you're gonna have your shell also make it so that it doesn't die when you do ctrl C
[587.90s -> 592.66s]  Well, that's actually where but to do that you have to handle and you have to capture
[593.10s -> 596.86s]  SIG int which is the interrupt and SIG stop which is ctrl Z and
[597.66s -> 599.66s]  they should affect your
[600.46s -> 604.62s]  Processes that you have but not your shell itself. So there's a little bit of that going on as well
[605.42s -> 609.02s]  As I said the piping between processes is is a little bit tricky
[609.50s -> 614.62s]  You'll have to take some time to get through that this assignment has lots of a whole list of milestones
[614.62s -> 618.70s]  You should probably do this then this then this than this if you can follow those milestones
[618.70s -> 622.90s]  You'll be able to do some testing and it will be a little more straightforward
[622.90s -> 627.14s]  Don't try to jump to the last part or like just go down some route test as often as you can
[627.50s -> 629.50s]  Is the big thing now?
[629.78s -> 633.08s]  This is a detailed assignment. We also have a midterm coming up this week
[633.20s -> 638.52s]  It's due next Wednesday, which is a week and a half. This should be about a week-long assignment
[638.52s -> 643.12s]  So I'm giving you a little bit of buffer room in there if you wait until Friday to start it
[643.76s -> 648.36s]  You can get it done, but it's gonna be a lot of work over the weekend and over beginning of next week
[648.56s -> 652.76s]  So I would at least start the assignment and by the way, it's got all the signal handling stuff
[652.76s -> 657.88s]  You will need to know for the exam. We will not ask specific questions. Although the practice midterms did on
[658.88s -> 661.20s]  Stanford shell but we will
[662.12s -> 668.54s]  The material is ostensibly the same. So you'll like starting to do the assignment. At least you'll start you'll continue to think about those
[669.16s -> 674.96s]  Okay. All right, and then we'll see how it goes as far as how people are doing after beginning of next week
[675.28s -> 678.52s]  All right, what questions on the assignment at this point?
[681.04s -> 686.18s]  This one's a fun one, too. It's definitely got a lot of parts as I said
[686.18s -> 687.94s]  Okay
[687.94s -> 689.94s]  All right, then let's move on
[690.46s -> 694.30s]  Back to threads now remember we have left
[695.14s -> 699.86s]  Multiprocessing world and we are now in multi threading world. The biggest difference is that
[700.94s -> 705.62s]  Threads are all under one single process, which means they share their memory
[705.62s -> 710.84s]  They have a different stack space for each thread, but they can relate to each other's stack frames
[710.84s -> 714.10s]  You can pass references to global variables and that works just fine
[714.70s -> 716.70s]  And you can have
[716.82s -> 718.66s]  You can have threads
[718.66s -> 724.10s]  Interacting with like say one global data structure very easily. That's one of the benefits of threats
[724.10s -> 728.66s]  They're considered lightweight processes in the sense that they really are doing different things
[728.66s -> 731.78s]  you can actually set the affinity on threads to run on different cores and
[732.44s -> 735.30s]  They really do run in parallel, especially if you have different cores
[735.46s -> 738.54s]  So there's there are benefits to using threading
[738.70s -> 741.50s]  But there's a lot of little things you have to think about just like
[741.84s -> 748.62s]  Multiprocessing and there are many analogous things to multi-processing that you'll that you'll have to to look at. Okay on
[749.66s -> 756.54s]  When's last Wednesday? What we did was we looked at the C version of p threads now threading doesn't come
[757.02s -> 762.14s]  Standard with Unix. Okay, just it's kind of attached and it's a it's kind of well
[762.14s -> 765.66s]  It's more or less added these days, but it's it's another library that you have to run
[765.66s -> 768.02s]  So this is why we had p threads and for C
[768.02s -> 770.90s]  of course, you have to do all these things with void star and and
[771.42s -> 775.18s]  Point pointers to send various blocks of data and it's kind of annoying
[775.82s -> 780.46s]  Turns out in C++ 11, which is the version that we are using
[781.54s -> 788.18s]  in C++ 11 we have actual support for threading built into the language and
[788.66s -> 791.90s]  It works a little bit better and is actually much cleaner
[792.22s -> 794.66s]  Once you get to once you get to understand it then
[795.06s -> 799.54s]  P threads are so we're going to trend quickly transition into that and then never speak of p threads again
[799.70s -> 804.06s]  Although if you take a networks class or maybe an operating systems class
[804.06s -> 807.08s]  You're gonna have to probably implement those and think about those in the future. Yeah
[810.34s -> 814.88s]  No, no, there's no threading on the midterm no good question. Yeah, unless you want me to put it on there
[817.46s -> 819.70s]  So anyway, let's take a look at
[820.46s -> 822.46s]  We'll go back and look at the
[823.94s -> 829.30s]  Recharge or the the introverts program that we that we had before
[829.86s -> 834.62s]  Okay, so let's actually log on a myth here. Oh, I forgot to show you I'm going to show you Stanford shell
[834.62s -> 836.62s]  I forgot about that
[839.18s -> 843.54s]  For samples no, not samples samples
[844.54s -> 849.44s]  S T SH solution. There we go. So Stanford shell looks like this, right?
[849.44s -> 857.10s]  You can do things like LS you can do things like sleep in the background and it will and it will oops needs a needs a
[857.66s -> 863.08s]  Sleep something like 10 in the background and then it goes in the background and you can type jobs
[863.08s -> 867.06s]  And it will tell you that there's a sleep running if I quickly do another one. I don't think I'm gonna have time
[867.06s -> 873.06s]  Let's do sleep 20 and then job jobs. Then there's still only one. Let's do another one sleep
[873.54s -> 878.22s]  In the background now if we do jobs, there should be two now. There are two jobs in the background
[878.58s -> 882.90s]  We should be able to I think kill did I say it's not kill its
[883.50s -> 885.14s]  Slay
[885.14s -> 889.22s]  1 8 4 0 8 and there we go. And then jobs in the background is on one now
[891.10s -> 894.46s]  So you should be able to do that you should also be able to do things like cat
[895.18s -> 900.66s]  What do we have STS H dot CC piped through sort or something like that?
[900.74s -> 902.74s]  And it will sort all the lines in there
[903.14s -> 905.58s]  You should you can by the way can use the up and down air keys
[905.58s -> 910.54s]  We built that in for you already and then you could put that through word count and so forth
[910.82s -> 914.02s]  Okay, you could also do that and then output it to
[915.06s -> 920.30s]  word count out got TXT and then we could do cat word count
[921.10s -> 925.58s]  TXT it should look very much like a terminal. Okay, and that's what you do
[925.58s -> 927.30s]  I shouldn't be able to do ctrl C
[927.42s -> 930.18s]  It actually says ctrl C, but it doesn't kill the shell
[930.62s -> 935.66s]  Okay, it shouldn't anyway and then ctrl Z will not do the same thing if I do something like
[936.34s -> 939.86s]  Let's do sleep 20 and then I do ctrl Z now
[939.86s -> 944.86s]  It it should bring you back and then have a background job there, which it does
[944.86s -> 948.98s]  So there's all the different parts what you're gonna have to do for that assignment
[950.50s -> 955.68s]  What is the 12 means the 12th job that you've actually launched so far I think in your shell
[955.80s -> 957.80s]  I think that's all that's all it means. Yeah, Berkham
[966.00s -> 971.12s]  Oh, well cat will the good the question was why are we using stsh for cat cat actually
[971.64s -> 976.20s]  Will print out a particular file. That's all we're doing there. I'm just and I happen to have that in
[976.20s -> 979.44s]  I'm in that folder so I know that file is there. So that's why I just
[979.96s -> 982.72s]  I just happen to know that file exists there
[983.56s -> 987.28s]  Any other question, okay and then do exit quit or exit
[987.96s -> 991.68s]  Okay, that's Stanford shell you will get used to that
[991.68s -> 998.80s]  And by the way, use that solution one to see what the output should be like and you bet some people sometimes miss that
[999.96s -> 1001.96s]  All right. Let's see
[1002.48s -> 1003.96s]  threads
[1003.96s -> 1007.16s]  Cpp now. Okay. Let's look at a new introverts
[1007.80s -> 1012.68s]  Program. Okay. This is the recharge basically what we're going to do
[1012.72s -> 1014.96s]  is the same thing as
[1016.76s -> 1020.04s]  Same thing as we did for the same program
[1020.04s -> 1025.64s]  It basically has ten threads or I guess six threads in this case and they're all going to print out something about
[1026.24s -> 1029.32s]  Recharging when you're alone. Okay. In fact, we'll we'll do that right now
[1029.32s -> 1034.56s]  We are in C++ now so we can start to use C out. Okay, and if we do C out I
[1035.28s -> 1038.92s]  recharge by spending time alone
[1039.88s -> 1044.64s]  Okay, and then and then and L one thing about C out is
[1045.44s -> 1048.96s]  Unlike printf it is actually not thread safe
[1049.08s -> 1054.78s]  Which means that and it turns out here's how it's not thread safe, by the way each one of these
[1055.52s -> 1061.80s]  Less than less thans are a new function. So basically this can print
[1062.44s -> 1067.68s]  Separately from the end L and so we want to avoid that actually
[1067.68s -> 1070.84s]  Well, we don't you might not want to avoid that but let's say you want to avoid that
[1070.84s -> 1077.46s]  We normally will we want that entire C out statement to print without any other thread interrupting it
[1077.68s -> 1080.68s]  By the way, it probably won't do it like between time and alone
[1080.68s -> 1084.68s]  But it will do it like anytime you have this so if we wanted to not interrupt that
[1085.12s -> 1087.52s]  what we can do is we can actually use a
[1088.44s -> 1091.48s]  function that Jerry Kane created which is just a
[1092.40s -> 1098.16s]  Lock on it which says hey after that I say OS lock inside a C out statement
[1098.48s -> 1103.24s]  Or inside a C app function. I just want to not have any other thread
[1104.20s -> 1107.34s]  Get in there and on and do something
[1107.84s -> 1114.76s]  While it's still doing that and then after this we should also have OS unlock and this is using a
[1115.28s -> 1120.60s]  Header file called ostream lock that will just link you to okay question chase
[1121.48s -> 1125.48s]  Couldn't you just use print F?
[1125.96s -> 1128.84s]  Sure, but there might be some things that you want to print
[1128.84s -> 1131.96s]  You might want to see out that are easier to do it to see out maybe some
[1132.68s -> 1134.68s]  output of some other
[1135.24s -> 1142.38s]  Oh, I don't know some other type or something that has a built-in a built-in overload for out or something like that
[1143.80s -> 1148.44s]  But yeah, you should you should just probably stick to see out in this for C++
[1148.44s -> 1150.44s]  It's also the better way to do C++. Yeah
[1152.40s -> 1154.40s]  In
[1155.32s -> 1160.76s]  This case you could use a newline character. Yes, although newline may not flush in this case
[1160.76s -> 1165.00s]  But yeah, you probably could use a newline this good but but sometimes what if we wanted to do something like this
[1166.28s -> 1172.60s]  I'll just do it this way like see out. This is I should do it in like var a
[1173.24s -> 1179.44s]  Colon a you know what I mean like that, you know period or whatever then we we still want to wrap it in that
[1179.44s -> 1181.44s]  OS lock OS unlock
[1181.64s -> 1183.48s]  It's easy to use anyway
[1183.48s -> 1188.64s]  All right, and that's that somebody else had a question up here or maybe it's the same. No, okay
[1188.64s -> 1191.36s]  So anyway, that's what we're gonna do there. In fact
[1192.44s -> 1197.72s]  That's all this function actually does. Okay, and then what we're going to do is we're going to
[1199.96s -> 1208.12s]  Use the actual threading library built into C++. Okay, so like let's hear from
[1209.28s -> 1210.40s]  k
[1210.44s -> 1212.44s]  num introverts
[1214.40s -> 1216.40s]  Space introvert
[1217.68s -> 1221.80s]  Period and why didn't I use the OS lock there?
[1222.44s -> 1225.10s]  We're not in a thread yet. Like we're not even in a thread yet
[1225.10s -> 1229.12s]  So not really necessary and the LDO wouldn't break if we did use it
[1229.12s -> 1232.76s]  It's just don't don't use if you don't need to. Okay, there's a thread library
[1232.76s -> 1236.88s]  I'll talk about the details of the thread library after we see the example. Okay, here's how it works
[1236.88s -> 1239.20s]  We're going to do the following introverts
[1240.16s -> 1244.38s]  Okay, and k num introverts
[1246.76s -> 1248.32s]  Introverts
[1248.32s -> 1253.80s]  Okay, and that is actually setting up. It's calling the default constructor for this thread
[1254.72s -> 1260.96s]  Class and it is placing them in the into that array one after the other now you would think
[1260.96s -> 1261.36s]  Oh
[1261.36s -> 1262.72s]  Does that mean that it's actually
[1262.72s -> 1268.38s]  Launching a thread as it turns out the default constructor doesn't do that and then I'll show you what we do in a minute
[1268.46s -> 1272.42s]  This is actually a nuanced thing of C++ 11 that I'll show you
[1272.42s -> 1278.46s]  But for now just know that that sets up the array of threads and then we can do the following you can say for
[1279.50s -> 1281.02s]  thread
[1281.02s -> 1284.86s]  Definitely need the ampersand on there to make it a reference and you by the way
[1284.86s -> 1286.06s]  You could put that reference there, too
[1286.06s -> 1286.82s]  I like to put it here
[1286.82s -> 1291.92s]  But some people like to put it before or with a space or whatever. It doesn't matter as far as C++ is concerned
[1292.74s -> 1294.30s]  introvert
[1294.30s -> 1296.30s]  in introverts
[1297.26s -> 1300.06s]  Okay, and then what we were going to do is we are going to
[1300.82s -> 1303.22s]  Do the following say introvert?
[1303.86s -> 1304.94s]  equals
[1304.94s -> 1310.46s]  Thread recharge and that's all you need to do to actually say hey
[1310.94s -> 1314.82s]  Here's a new thread with the recharge function launch it
[1315.30s -> 1319.54s]  Okay, there's some more prayer you can have as many parameters as you want here
[1319.54s -> 1321.96s]  Like if you want to send in other parameters, we'll do that in a second
[1321.96s -> 1326.12s]  You can do that but that's this is for the for the simple example. That's all you need to do now
[1326.12s -> 1330.10s]  The interesting part is happening right here where you're doing this weird
[1330.76s -> 1333.20s]  And if I spell the introvert, right, that would be better
[1335.64s -> 1337.64s]  You're you're doing the
[1338.88s -> 1342.74s]  Exchange as it turns out instead of just setting it equal
[1342.74s -> 1344.12s]  I'll talk about that more in a minute
[1344.12s -> 1349.76s]  But you might think to yourself wait didn't I just start ten threads and now I'm doing a copy of ten more threads and that
[1349.76s -> 1355.08s]  How does that work and so forth? It actually is because C++ allows it to work as it turns out
[1355.44s -> 1359.48s]  Okay, then what we can do is we can do another same sort of thing thread
[1361.12s -> 1363.12s]  introvert in
[1363.56s -> 1365.56s]  introverts
[1365.76s -> 1372.56s]  Okay, and then we are just going to do introvert because this is C++ as a class join
[1372.96s -> 1377.36s]  Which does the exact same thing as join the function call did in
[1378.12s -> 1383.76s]  In C and it waits for that particular thread to end before it moves on to the next one in the for loop
[1385.52s -> 1391.88s]  That's the beginning one. Let's see if it works anybody notice any typos still. I don't see make introverts
[1393.68s -> 1398.26s]  Okay looks so good introverts and there we go I recharge by spending time alone six times
[1399.52s -> 1406.56s]  Okay, so let's go back and talk about the details of this a little more in a little bit more detail
[1407.52s -> 1410.28s]  Anybody have any particular questions so far on this?
[1415.08s -> 1417.08s]  That
[1417.12s -> 1422.40s]  Very good question. You're getting the introvert by reference in the line down here
[1422.40s -> 1427.20s]  Yes, and here you're getting it by reference from the actual introverts array
[1427.84s -> 1431.92s]  And well, yeah, good question. Why are you doing that? We need to
[1432.40s -> 1436.04s]  As it turns out this is the C++ part and I guess we should just talk about that right now
[1436.40s -> 1443.12s]  we're we're trying to take a thread that we're creating and plop it into a
[1444.12s -> 1445.60s]  Into an array
[1445.60s -> 1452.68s]  Normally, what would happen is you would copy all the resources out of the thread and place it into that array, right?
[1452.68s -> 1455.08s]  Well, that would mean there's now kind of two threads
[1455.64s -> 1459.76s]  that are going and there's no real way to like shut down the one and
[1460.32s -> 1465.88s]  Start up the one in the array just happens that that doesn't doesn't work in C++. Normally well
[1466.40s -> 1469.96s]  C++ itself. I think this is on the next page has a
[1470.68s -> 1472.76s]  new function which is
[1473.12s -> 1479.48s]  Here it is operator equals thread to ampersands other it's just a syntax thing
[1479.48s -> 1481.80s]  It basically means we are setting up this
[1482.44s -> 1484.04s]  move
[1484.04s -> 1486.04s]  type of
[1486.40s -> 1488.24s]  Equality basically, it's
[1488.24s -> 1493.36s]  Swapping the two things. Okay, and all you need to really know about that is that this works
[1493.56s -> 1500.60s]  That's kind of the bottom line is that when you do this when you do the actual equals right down here
[1500.60s -> 1504.20s]  And you say okay look the thread that we are creating here is
[1504.72s -> 1512.56s]  actually going to be placed into the place where the reference is in the array and it actually does a complete swap and places the
[1513.56s -> 1514.80s]  non-working
[1514.80s -> 1516.80s]  Thread that we constructed in the array
[1517.24s -> 1523.28s]  Into our actual as the kind of thread over on the other on the right hand side of the equation
[1523.56s -> 1529.08s]  Again, the details not really important if you want to go look up move semantics and C++ 11
[1529.08s -> 1535.64s]  You can get lots of details about it. But the idea is this works. Whereas in in a normal copy
[1535.64s -> 1540.60s]  It wouldn't work very well because you've got too many resources that you can't really make a copy of
[1541.16s -> 1542.36s]  And so it doesn't work
[1542.36s -> 1547.92s]  So anyway, this does work if you're scratching your head about why it's because they've added something to C++
[1548.40s -> 1553.76s]  That's kind of the the bottom line the bottom line there. But anyway point is you just say oh look
[1553.76s -> 1558.56s]  Here's how I get this thread that I'm just creating into this array. I can do it by reference
[1558.88s -> 1561.24s]  In this new special C++ way
[1561.88s -> 1563.88s]  question
[1564.80s -> 1570.28s]  Yeah, can I go over join again good question so join that member each one of these threads is now in a
[1570.84s -> 1573.96s]  In the array and so when I loop back over those threads
[1573.96s -> 1577.42s]  You've got this thread and you say join and all that means is
[1578.60s -> 1581.36s]  Pause until that thread actually completes
[1581.76s -> 1587.16s]  So it's very similar to wait PID with a zero as the first parameter where you're just going
[1587.16s -> 1589.48s]  Okay, look, I just I'm gonna wait around until this this ends
[1590.12s -> 1596.96s]  You could have something similar where you actually set up a thread to be what we call detached where you don't have to join
[1597.08s -> 1601.40s]  But this does the cleanup and also makes it so the program doesn't end before all the threads end
[1601.84s -> 1604.64s]  If we didn't have that join in there, we would get a terminal
[1605.36s -> 1609.20s]  Back, we're gonna terminal prompt back before all the threads ended. Yeah
[1611.76s -> 1613.76s]  It's to make sure the main
[1614.68s -> 1618.98s]  No, no exactly it's it's the main program waiting for the threads individual threads
[1619.04s -> 1622.96s]  Yeah, and we call it on each thread as it turns out
[1623.44s -> 1625.44s]  Okay, and you do have to call it on each thread
[1625.46s -> 1628.72s]  You can't just say like join all you know, wait for all my threads
[1628.72s -> 1631.72s]  You can't really do that in the same way that you would have done that with multi-processing
[1644.40s -> 1648.32s]  Yeah, good question are there things like W no hang and and
[1648.96s -> 1653.48s]  W untraced and all that not really it's not the same. You're not gonna have the same models
[1654.02s -> 1655.76s]  When you're doing this, okay
[1655.76s -> 1660.16s]  You're basically you're most often in a joint at the end and it's not like you're gonna stop a thread
[1660.48s -> 1662.72s]  Using sig stop and so forth not like you're sending them
[1662.72s -> 1664.36s]  It's not a process in itself, right?
[1664.36s -> 1668.52s]  Most of the things that we did with threads are processes in that sense are not going to be
[1668.92s -> 1672.88s]  Really in the same model of threading. Okay threading is most of the time
[1673.58s -> 1677.24s]  Breaking up a problem into many sub problems to solve kind of independently
[1677.24s -> 1683.10s]  We'll see an example of that in a few minutes and that's where it differs a little bit from from all that processing remember
[1683.40s -> 1686.52s]  Most of the time multi-processing is fork exec
[1686.88s -> 1692.36s]  Fork exact fork exact that's most of the time what we do with processes so that we can launch other programs
[1692.48s -> 1695.48s]  This is now saying everything's gonna be in my one program
[1695.48s -> 1698.40s]  But I'm gonna say I'm gonna make them all kind of happen in parallel
[1698.88s -> 1700.88s]  Yeah, good question
[1701.04s -> 1703.04s]  All right, so that's
[1703.68s -> 1706.72s]  The actual policy. What else can we talk about here?
[1707.44s -> 1714.02s]  This is the important part. We declare an empty thread had the empty thread handles array. That's the important one
[1714.32s -> 1719.76s]  Okay, and then we install the recharge function into temporary threads
[1719.76s -> 1725.64s]  That's just saying thread and then the name of the function and then they get copied over or I should say moved
[1726.04s -> 1727.48s]  into the array
[1727.48s -> 1730.48s]  Okay, that's kind of a new C++ part, all right
[1731.60s -> 1735.72s]  And you can read a little more details about that as you go join method we talked about
[1736.76s -> 1740.00s]  The read the function can be anything we want
[1740.46s -> 1744.92s]  Normally, we just have a void function because we don't actually ever get the return value of it
[1744.92s -> 1751.68s]  It's not you can't really get the return value in the same sense that you you can in wait PID
[1752.40s -> 1755.40s]  But it can be the function could be anything so you'll see lots of functions
[1755.40s -> 1762.12s]  You're right that we actually launch in a thread and it's actually pretty nice. It's it's in some ways much simpler than
[1763.16s -> 1765.16s]  Multiprocessing and that you don't have to have any special
[1765.16s -> 1769.28s]  Types of function just call the function with the parameters you want and there it is now it's running in its own thread
[1769.28s -> 1771.28s]  It's actually relatively clean
[1774.80s -> 1778.04s]  You can give arguments we will talk about that now good question
[1778.60s -> 1780.60s]  Okay. All right, so
[1780.84s -> 1785.12s]  Let's move on to a different example. Okay, this is going to be a
[1785.84s -> 1792.20s]  greeter program and it's going to be just a program where we are going to have a number of threads run and
[1792.84s -> 1798.68s]  Print out a little greeting based on their thread number that we're assigning it. So let's look at that
[1802.24s -> 1804.24s]  That's the one
[1804.60s -> 1811.80s]  Hope that's the one. There we go. There we go. Okay greeters dot CPP. Nope, maybe not
[1812.64s -> 1814.64s]  See
[1815.00s -> 1819.88s]  Greeders dot see not CPP see see see we go. Okay. So in this one
[1820.48s -> 1825.00s]  We are going to have a function. Okay, that takes a parameter
[1825.00s -> 1827.52s]  And so this is we have to know how to actually send that parameter
[1827.68s -> 1831.08s]  You can send it by value or reference as it turns out you can do either
[1831.56s -> 1836.28s]  We can we'll show you how to do both of those. Okay in this case
[1836.28s -> 1840.16s]  We're gonna have each greeter greet a whole bunch of number of time a whole number of times
[1840.24s -> 1843.60s]  I'll show you what I mean. Okay size T
[1845.08s -> 1847.08s]  Size T
[1847.12s -> 1853.68s]  Equals zero I is less than the ID. So whatever I do pass and it's going to greet them that many times
[1854.00s -> 1857.88s]  Why not? It's kind of a silly program. Okay, I plus plus and
[1858.56s -> 1861.72s]  Then in here, we're going to see out
[1861.72s -> 1866.84s]  Remember we have to do OS lock because we are in a thread and we can say greeter
[1867.20s -> 1870.40s]  Number and then ID
[1872.24s -> 1874.24s]  Says
[1874.36s -> 1876.36s]  Hello
[1876.80s -> 1880.80s]  And L and then we do OS unlock
[1881.80s -> 1883.80s]  Because that's after the entire line
[1884.16s -> 1887.78s]  Okay. All right, and then what we're gonna do is we're actually going to
[1889.28s -> 1891.28s]  Do something here where we
[1891.64s -> 1897.12s]  Where we pause for a little bit of time so that you can see the interleaving of the threads
[1897.24s -> 1901.16s]  So we're going to do kind of this interesting thing. We're just going to use a little time
[1902.64s -> 1905.22s]  Structure called T time spec
[1905.94s -> 1907.40s]  You don't have to know about it
[1907.40s -> 1911.36s]  And then we'll never ask you about that TS equals and you can set it up like this
[1911.36s -> 1914.68s]  it it's got a few different things at random and
[1915.68s -> 1922.34s]  Then we are going to it's random mod 1 1 2 3 4 5 6 7 8 9 a big number
[1922.92s -> 1924.76s]  okay, and
[1924.76s -> 1929.62s]  Let's see. I think that's that there we go. And then we're gonna do this thing called nano sleep
[1930.92s -> 1937.72s]  For that amount of time which is actually slightly small amount of time because it's time divided by a billion
[1938.36s -> 1943.28s]  Okay, and then we are going to end our loop. I don't know why this is not
[1944.00s -> 1947.48s]  There we go, okay, and then we are going to
[1948.76s -> 1954.40s]  Do another see out OS lock and we're gonna say greeter number
[1956.00s -> 1962.72s]  ID as issued all of their hellos
[1964.36s -> 1966.36s]  Comma and
[1967.14s -> 1971.18s]  Then you can I guess I guess because the next line here we'll do it on the next line
[1971.50s -> 1973.50s]  Who's there go
[1974.10s -> 1978.02s]  let's see, so they go home and
[1979.26s -> 1984.20s]  L and then OS unlock and that's that
[1985.12s -> 1987.58s]  Okay, so that's our greeting function
[1988.28s -> 1990.28s]  Okay question
[1995.14s -> 1997.30s]  Is there get PID can you join in this function
[1997.82s -> 2001.02s]  There is a get thread ID like you can get your threads ID
[2001.02s -> 2004.68s]  Which is more or less a process like ID if you want to do that
[2004.80s -> 2008.30s]  No, you wouldn't be joining inside the thread. You don't want to be joining inside the thread
[2008.30s -> 2010.62s]  You want the main program to do the joining? Yeah
[2011.22s -> 2014.64s]  Maybe some nuances that but in general don't try to join another thread
[2014.64s -> 2021.82s]  And by the way again multi-processing and multi-threading don't really mix too. Well, you don't want to fork inside a thread
[2021.82s -> 2024.36s]  Otherwise lots of things could be bad
[2024.80s -> 2029.04s]  You could put you could do threads inside a process that you forked but not the other way around
[2029.56s -> 2033.64s]  Just the way it works, which you got to be you got to use that. Okay
[2033.64s -> 2037.56s]  So anyway, that is our British just make sure we made that make readers
[2038.82s -> 2040.40s]  Looks good
[2040.40s -> 2046.08s]  Define, but I used okay good. All right, so then in Maine what we're gonna do is we are going to
[2046.96s -> 2050.36s]  Do something like see out welcome to Greenland
[2051.48s -> 2053.48s]  Welcome to Greenland
[2053.92s -> 2058.66s]  Should probably capitalize that it's a proper now. Okay, and then
[2059.36s -> 2062.56s]  And L okay, and then thread
[2063.56s -> 2065.56s]  Greeters, this should look familiar
[2065.92s -> 2068.72s]  k num greeters and
[2069.88s -> 2073.32s]  then for size T I
[2073.84s -> 2076.70s]  Equals zero I is less than k num
[2077.40s -> 2078.72s]  greeters
[2078.72s -> 2080.72s]  Semicon I plus plus
[2081.18s -> 2083.18s]  Okay, we can do
[2083.48s -> 2088.70s]  Greeters, we could have done it the way we did before but this is just a slightly different way of doing without the reference
[2088.76s -> 2091.74s]  Well still doing a copy like we did before a move like we did before
[2092.26s -> 2094.48s]  Okay, greeters I equals
[2095.40s -> 2097.20s]  thread and
[2097.20s -> 2102.52s]  Greet and then what we do is we just pass the parameter as the next parameter and that's what it does
[2102.52s -> 2108.00s]  It calls greet with the parameter I plus one passed by value. Did I do something wrong? Oh
[2109.84s -> 2112.04s]  Not I plus I that would've been an interesting program
[2113.04s -> 2116.42s]  Okay, all right, I plus one there we go like that
[2117.04s -> 2121.40s]  Okay, and then that's that and then we need to join them for psi
[2121.88s -> 2123.88s]  I'll just do this
[2126.00s -> 2129.92s]  Okay for size T k num greeters, okay, and then we just do a greeter
[2131.56s -> 2133.80s]  No, actually in this case, we don't want to do that
[2133.80s -> 2137.36s]  Do we we want to do the actual threat? I can't do it the way I wanted to
[2137.36s -> 2141.62s]  I guess we probably could we could but in this case, we'll do it the way we did before
[2142.32s -> 2143.72s]  thread
[2143.72s -> 2145.72s]  ampersand greeter
[2146.04s -> 2147.84s]  mix-and-match
[2147.84s -> 2149.26s]  Greeter
[2149.26s -> 2152.36s]  That and then in this case we want to do greeter
[2153.24s -> 2155.24s]  dot
[2155.48s -> 2157.32s]  Join
[2157.32s -> 2164.80s]  Okay, that will wait for them all. Okay, and then we want to just say see out everyone
[2166.40s -> 2171.64s]  All greeted out and out, okay
[2172.04s -> 2174.04s]  That's what we're going to do.
[2176.28s -> 2177.76s]  The original for loop would have worked
[2177.76s -> 2182.20s]  I just decided to do a different way the original fork would have in this we could have done the week would have just done the
[2182.24s -> 2183.72s]  greeters I
[2183.72s -> 2189.72s]  Dot join instead that would work. Yeah, but different way of doing it show you both question
[2192.12s -> 2195.46s]  Good question if you join right if you created it, what would happen you tell me
[2199.08s -> 2201.08s]  It would do something what would it do
[2203.04s -> 2205.04s]  I
[2207.08s -> 2208.84s]  Would serialize everything
[2208.84s -> 2213.80s]  If you can't create the thread and then immediately join then it won't go on and it won't even go to the next loop
[2214.00s -> 2216.10s]  until that thread finishes
[2217.48s -> 2222.92s]  So you need to this because you want to launch all the threads let them all work in parallel and then wait for them
[2222.92s -> 2226.90s]  All afterwards. In fact, that's a very good point that this is actually kind of key
[2227.54s -> 2234.58s]  This is very much non-blocking right this loop happens super duper fast, right what happens
[2234.58s -> 2240.78s]  It just basically calls this thread function with a function name and says on your own time as soon as possible
[2241.14s -> 2244.42s]  Launch this thread and it moves on to the next iteration of the loop
[2244.74s -> 2250.46s]  Okay, so there's no waiting at all on this and that's actually kind of key. All right, let's see if we did this
[2250.46s -> 2252.46s]  right make greeters
[2252.98s -> 2254.98s]  So far so good greeters
[2255.34s -> 2259.34s]  All right, and then greeters there we go, okay, so members wait pausing a little bit in there
[2259.34s -> 2262.58s]  That's why it does that how many times should six say hello
[2263.82s -> 2268.82s]  six should say hello six times I believe unless I did the less than instead of less than or equal to but
[2269.58s -> 2275.06s]  Anyway, that's what is one only says hello once and then one happens to the first one that's issued all of its hellos
[2275.06s -> 2278.58s]  So that they go home and so on and so on and so forth
[2285.82s -> 2291.60s]  If you okay, so first of all OS lock is not for processes it's only for see out
[2292.02s -> 2294.98s]  So OS lock is on we'll talk about locks and things in a minute
[2295.18s -> 2298.18s]  As we go forward if you wanted to do it in order
[2298.30s -> 2300.30s]  You just probably wouldn't have threads number one
[2300.30s -> 2304.82s]  And number two if you want you really could just join after you do each thread and then it would do it
[2304.82s -> 2308.60s]  But that that's not really the not really the way you would normally use threads anyway
[2309.74s -> 2313.48s]  Okay. All right questions on this one on this greeter function
[2313.48s -> 2315.56s]  You can actually pass the fun pass parameters in. Yeah
[2328.72s -> 2330.60s]  Right, there's a good question
[2330.60s -> 2334.52s]  The question is wait a minute and I think you're alluding to a wait PID where you can say
[2334.52s -> 2337.52s]  Oh this one ended. I'm gonna handle that one first. Not really in this case
[2337.52s -> 2340.52s]  You just got out you have to wait from all in kind of order in whatever order you want
[2340.56s -> 2344.28s]  But there's not really a way to as far as I know I'll look it up
[2344.28s -> 2347.36s]  But as I've never seen it where you've waited for things out of it
[2347.36s -> 2348.60s]  We've joined out of order
[2348.60s -> 2353.44s]  You kind of just go I'm gonna launch these threads and then wait for them all at the end in some sort of order
[2353.44s -> 2359.50s]  You can't say I'm gonna wait for any thread like that. Not that's not the same model as profit multi-processing. Good question
[2360.16s -> 2363.56s]  Okay. All right, so that's um
[2364.20s -> 2366.80s]  The greeter program and notice you can send in a parameter
[2368.36s -> 2370.36s]  All right
[2370.72s -> 2375.40s]  What we can do is we generally want to use threads to
[2375.72s -> 2379.90s]  Break up a smaller or a bigger problem such that some
[2380.52s -> 2384.36s]  Group of threads can work on individual parts of that problem independently
[2384.36s -> 2388.64s]  That's why we have multiple cores and multiple processors so that we can actually do this
[2388.80s -> 2396.00s]  It's actually a nice nice benefit of threads and probably the main reason threads were ever created in them in the beginning
[2396.32s -> 2397.84s]  so
[2397.84s -> 2400.72s]  What we're gonna do is we're gonna do another little program and we're gonna model
[2401.52s -> 2404.88s]  Ticket sales. Okay. Basically, this is where you call up
[2405.76s -> 2409.36s]  Like I don't know United Airlines in this case and you don't do that anymore
[2409.36s -> 2413.12s]  people used to actually call them instead of doing it online, but he would call them up and
[2413.72s -> 2419.12s]  Let's say we have ten ticket agents which all answer the telephone and when they answer a telephone they
[2419.68s -> 2424.92s]  Sell a ticket and we have 250 tickets that can be that can be sold
[2425.20s -> 2427.36s]  Okay, 256 tickets can be sold and
[2428.40s -> 2432.64s]  As they answer the telephone they get a caller and then they sell that ticket
[2432.80s -> 2433.28s]  Okay
[2433.28s -> 2438.72s]  and they sell one ticket now it might turn out that somebody wants to fly to the middle of
[2438.88s -> 2443.84s]  Nowhere or whatever and the ticket agent takes a little longer to actually process that ticket
[2443.84s -> 2447.68s]  And it might be that out some other ticket agent gets a whole bunch of people who just want to fly from New York
[2447.68s -> 2451.12s]  To Boston and it's an easy like, you know, two second call phone call and whatever
[2451.76s -> 2455.58s]  That's dinner so we don't want to necessarily limit all of the
[2456.28s -> 2462.48s]  We don't want to limit. Oh, no, why do you do this? Hang on. We don't want to limit the actual number of
[2464.32s -> 2466.32s]  Tickets to 10% of
[2466.76s -> 2472.10s]  Like 10% for each agent. Okay. We don't want to do that specifically so that we
[2472.76s -> 2477.80s]  Can allow them to do it a little more effectively. Okay. So what we might do is
[2478.48s -> 2480.36s]  Something like this
[2480.36s -> 2485.28s]  Okay, let me actually start I'll actually do this in the program because we're gonna run this for you in a minute
[2485.28s -> 2487.28s]  And let's see if I can clear it is okay
[2487.52s -> 2492.12s]  Let's see. This one is going to be called confused and you'll see why in a minute ticket agents
[2492.62s -> 2497.02s]  Okay, it's going to be a little bit confusing here, but this is what we might start out with
[2497.56s -> 2501.88s]  Okay, we might start out with something like this. All right thread
[2502.56s -> 2510.26s]  Agents 10. Okay, we could have a constant for that. That's that thread agents 10 size T remaining tickets
[2512.26s -> 2519.38s]  Tickets equals 250. Okay, so we're gonna 250 remaining tickets. All right, and then for size
[2520.56s -> 2526.54s]  T equals 0 I is less than 10 I plus plus
[2526.54s -> 2531.14s]  Okay, what we're gonna do here you're gonna say agents I
[2532.98s -> 2534.98s]  Equals thread
[2535.14s -> 2538.50s]  Ticket agent because that's the function we're going to create ticket agent
[2539.16s -> 2545.70s]  We'll give a ticket each ticket agent a little a number between 101 and I not sure why we gave it 101
[2545.70s -> 2552.14s]  But we did okay, I don't know and I and then we need to pass in the remaining tickets by reference. Okay now
[2552.86s -> 2559.90s]  Thread has no idea about a reference parameter versus a regular parameter. So if you tried to say this remaining
[2561.58s -> 2565.62s]  Remaining tickets like that, okay, then
[2566.34s -> 2571.78s]  What would happen is you would actually send it by value, which is not what you want to do
[2571.90s -> 2573.46s]  Okay, and there's no real easy
[2573.46s -> 2574.86s]  Well, there is an easy way to do it
[2574.86s -> 2579.76s]  But something you may not have seen before if you want to specifically send a parameter by reference
[2579.76s -> 2582.36s]  You actually wrap it in a ref function
[2582.80s -> 2588.30s]  Okay, or maybe it's an operator. But anyway, it basically says send this by reference not by value
[2589.04s -> 2595.68s]  Okay, so that's what we're going to do for each thing because now we're going to have one remaining tickets that all the agents are
[2595.68s -> 2597.00s]  going to pull from
[2597.00s -> 2599.00s]  okay, all right and
[2599.52s -> 2604.04s]  Let's see that let's see. Is that the end of the function there?
[2604.04s -> 2606.04s]  Well, we've got it we've been branding that statement
[2606.12s -> 2610.12s]  Okay, and then there and then that actually launches them all and then we have for
[2611.44s -> 2613.32s]  thread
[2613.32s -> 2614.92s]  ampersand
[2614.92s -> 2616.92s]  agent in agents
[2618.40s -> 2620.40s]  Agent dot join
[2620.80s -> 2622.80s]  like that and
[2622.92s -> 2624.92s]  Then we will say see
[2625.48s -> 2627.48s]  and end of
[2629.04s -> 2631.04s]  Business day
[2631.88s -> 2635.72s]  Okay, so we're basically gonna after everybody finishes we will say end of business day
[2636.60s -> 2639.24s]  Okay. All right. Everybody get what's happening in Maine there
[2639.96s -> 2641.96s]  Okay, let's look at the actual
[2643.28s -> 2647.88s]  Remain or ticket agent function and see what we can come up with here, okay
[2648.60s -> 2652.28s]  well, we're gonna have each agent grab a ticket and
[2653.38s -> 2658.96s]  Sell it basically. Okay answer the phone call and then sell a ticket. Okay, so we could say something like
[2660.00s -> 2662.00s]  while remaining
[2662.16s -> 2664.16s]  Tickets is greater than zero
[2665.16s -> 2671.80s]  Okay, well in here we are going to say I have a function that handles the call, okay
[2671.80s -> 2676.12s]  You don't have to worry about the points up here somewhere. You can actually see it read it read it later
[2677.32s -> 2679.92s]  But don't in fact actually it's just basically
[2680.28s -> 2684.96s]  So it sleeps for a while to kind of mimic handling the call don't worry about these other functions yet
[2685.00s -> 2690.10s]  They are basically helpful helper functions for now. Okay, so we're gonna handle the call
[2690.58s -> 2692.58s]  Okay, and then this is gonna sleep
[2693.10s -> 2698.58s]  For a little while to basically mimic handling the call and however long it takes and that's a random number
[2699.02s -> 2701.82s]  Okay, and then we're gonna say remaining
[2702.46s -> 2703.78s]  tickets
[2703.78s -> 2705.78s]  Minus minus because we just sold one
[2706.66s -> 2711.62s]  okay, and then let's actually print out OS lock in this case and
[2712.42s -> 2714.42s]  agent number
[2715.18s -> 2717.38s]  And same thing ID
[2718.38s -> 2723.82s]  Sold a ticket like that. Okay, and then we will say
[2725.82s -> 2729.68s]  Remaining remaining tickets
[2733.14s -> 2735.14s]  More to be sold
[2736.18s -> 2738.18s]  like that and
[2738.42s -> 2740.42s]  Then we have to do the OS
[2741.74s -> 2743.18s]  unlock
[2743.22s -> 2745.86s]  Like that, okay, so we're basically saying okay
[2745.86s -> 2748.18s]  Well now a ticket ticket has been sold
[2748.30s -> 2752.28s]  Okay, and then we're gonna let the agent take a break if it's time for them to take a break
[2752.38s -> 2755.42s]  This is just to kind of interleave things a little bit more
[2756.02s -> 2758.02s]  It should take
[2758.58s -> 2760.06s]  break
[2760.06s -> 2762.06s]  then we are going to
[2763.50s -> 2765.10s]  basically
[2765.10s -> 2772.18s]  Take break. Okay. All right. Sometimes these get a little bit silly but and then that's it and then see out
[2772.82s -> 2774.82s]  That
[2774.90s -> 2779.22s]  Is actually after sorry after the while loop right we get
[2779.94s -> 2784.98s]  Then we say oh great. We've sold all the tickets because the remaining tickets are not there's no more left
[2785.38s -> 2787.38s]  Okay, so we can say something like
[2787.78s -> 2789.06s]  agent
[2789.06s -> 2791.06s]  number ID
[2792.06s -> 2798.34s]  Notices all tickets are sold and goes home
[2799.34s -> 2800.34s]  Okay
[2800.34s -> 2802.34s]  And
[2802.38s -> 2805.34s]  OS on block I forgot to do this lock beginning
[2807.94s -> 2809.94s]  OS
[2810.66s -> 2814.70s]  Okay, all right, so this is our first attempt anybody see any bugs
[2816.10s -> 2823.26s]  This is our first attempt. Basically, we're gonna have each agent keep come down and go ahead do it. Okay make confused
[2824.22s -> 2826.22s]  ticket agents
[2826.58s -> 2828.42s]  Oh, no, here we go
[2828.42s -> 2833.42s]  Let's see no name type on line. Oh boy. I love C++ errors
[2834.06s -> 2835.54s]  Okay, hold on
[2835.54s -> 2839.42s]  Not there. Where's the actual error? Not there. Not there. Not there. Not there. Oh
[2840.54s -> 2842.98s]  They see where it is. Oh, there it is. 62 maybe
[2843.94s -> 2845.94s]  62
[2846.26s -> 2848.26s]  62
[2849.06s -> 2852.54s]  All right, what do we do here the red ticket agent
[2854.14s -> 2856.14s]  Raph remaining tickets
[2857.14s -> 2862.86s]  In agents we set up agents and then what else
[2863.86s -> 2867.62s]  See agent cycles thread ticket agent and hunter plus rough remaining tickets
[2873.22s -> 2875.22s]  Don't define ticket agent
[2876.22s -> 2878.22s]  It's up here, isn't it?
[2878.74s -> 2881.46s]  There it is right there. It's the function we're trying to send
[2883.78s -> 2885.78s]  See
[2886.14s -> 2888.14s]  Do
[2888.86s -> 2890.86s]  We need the ref
[2891.42s -> 2895.18s]  We do that's right that's gonna happen there we do need that I
[2897.18s -> 2899.18s]  Don't think so
[2900.14s -> 2904.38s]  See I'm trying to think there's anything let's look at the error again no name type
[2904.38s -> 2906.38s]  On
[2911.30s -> 2916.02s]  137 known type name type in class void. Hmm
[2917.74s -> 2921.74s]  Not sure well in the interest of time I happen to have the original
[2922.46s -> 2924.90s]  There let's just do it. Yeah, let's do it. Yeah
[2925.86s -> 2929.26s]  This is just in case this sort of thing happens and I can not good enough to find this
[2930.18s -> 2933.90s]  confused ticket agents original CC
[2934.78s -> 2936.62s]  Let's see
[2936.62s -> 2938.62s]  What did we do here? Oh
[2939.42s -> 2941.42s]  No, it doesn't look looks
[2941.86s -> 2943.86s]  much different I
[2945.54s -> 2951.90s]  Don't think it well, it's the one I promise you it should be the one now that's a hang on that is
[2953.38s -> 2958.74s]  It uses all the constants. Yeah, maybe I actually forgot a part of it here
[2959.58s -> 2965.74s]  No, I don't think so, well, here's what we're gonna do we're gonna copy it over and do and run it because
[2966.94s -> 2974.40s]  I'll look at here. Here's what I'll do. I'll make a copy of it right now confused ticket ticket agents dot CC to
[2974.58s -> 2975.82s]  confused
[2975.82s -> 2978.90s]  ticket agents Chris is confused
[2980.38s -> 2985.14s]  Got CC and I'll check it out later and then confused ticket agents dot
[2986.02s -> 2992.26s]  Original to confused ticket agents dot CC and right. Okay. Let's try it again confused
[2993.62s -> 2995.62s]  ticket agents
[2996.06s -> 2998.34s]  That time it worked. Okay now I
[2999.18s -> 3001.64s]  Swear work when I try to go there. Okay. So here's what it's gonna do
[3001.64s -> 3006.58s]  It's gonna go count down all 250 each each ticket agent is getting waiting some amount of time
[3007.38s -> 3011.82s]  Some may get five over the course of time some may get ten some may get twenty some may get thirty
[3011.82s -> 3015.26s]  Whatever it will finally will keep going and count down and then
[3016.58s -> 3020.90s]  That's gonna take a long time to get one more sold. Okay, so
[3021.74s -> 3025.90s]  And this is going to go on basically forever, right? In fact when it gets down about a zero again
[3025.90s -> 3028.78s]  It'll probably wrap around again. Okay, so we have an issue
[3029.38s -> 3031.80s]  What is our issue is the question?
[3032.90s -> 3039.14s]  Okay, let's look at the actual code here that we're we should have been doing here. Okay, that's main and then
[3039.94s -> 3042.42s]  That's main too. We already we know that's there
[3043.84s -> 3046.66s]  Let's see. Here's the ticket agent. Maybe I
[3048.18s -> 3050.06s]  Still looks alright
[3050.06s -> 3054.70s]  So here's what we're we're doing here. Is there a race condition?
[3055.50s -> 3059.26s]  Some of you already noticed it. I could tell when I was writing it. What's the race condition here?
[3060.58s -> 3062.58s]  Yeah
[3063.58s -> 3071.22s]  They all have access to remaining tickets, right and when the remaining tickets when it does the decrement there and the
[3072.06s -> 3079.22s]  Remaining tickets while remaining tickets greater than zero and then remaining tickets minus minus those it may not be true
[3079.62s -> 3086.82s]  That that actually that remaining tickets is still greater than zero because some other thread could have come in and done the exact same thing
[3087.66s -> 3089.66s]  Okay, so that's the issue
[3090.10s -> 3097.14s]  One of the issues here. In fact, it's much more subtle than that even okay, there's there's this idea that you can do that well
[3098.88s -> 3100.94s]  What happens is well
[3100.94s -> 3105.86s]  we we can see what happens there that it that it actually ends up going down and and wrapping around because
[3106.10s -> 3112.90s]  Two things have tried to decrement if actually indeed decremented the thread count before another thread came out and said oh there any left
[3112.90s -> 3116.26s]  Oh, yeah, there's four billion left. So that's the issue the
[3116.90s -> 3118.90s]  As I said, it's even more subtle than that
[3119.46s -> 3120.80s]  even
[3120.80s -> 3127.82s]  Remaining tickets minus minus itself is not necessarily atomic. Okay a C++
[3129.00s -> 3132.02s]  Statement is atomic in that it runs on its own
[3132.30s -> 3139.14s]  But remember what is a C++ statement do and all you people who took 107 would know that it gets translated into possibly a whole
[3139.14s -> 3146.66s]  Bunch of assembly code instructions each one of which is more or less atomic but together they certainly are not atomic
[3147.06s -> 3152.66s]  Okay, so this when you do remaining tickets minus minus if you go and decompile it, you can see that it ends up
[3153.30s -> 3159.80s]  Coming into some ends up something like this assembly code here where you've got five different instructions
[3159.94s -> 3165.74s]  Any which any one of which could get interrupted by going to the next thread and having a problem?
[3165.74s -> 3169.64s]  So what are we actually doing? We're getting the memory and then we are
[3170.22s -> 3173.90s]  decrementing it by one remember our favorite command le a for two people who took 107
[3174.26s -> 3178.34s]  And then we're decrementing by one and then we are moving it back into memory
[3178.38s -> 3183.42s]  well, if any other thread did some of those operations while these were happening like
[3184.10s -> 3189.98s]  Then the memory wouldn't necessarily be one removed. This is a classic race condition
[3190.30s -> 3194.02s]  Okay, absolutely classic race condition that that you need to be able to
[3194.82s -> 3196.34s]  handle
[3196.34s -> 3198.34s]  okay, so
[3199.34s -> 3201.34s]  What are the kinds of things we can do well
[3202.18s -> 3205.38s]  What we can do and this is built into the thread libraries we can say
[3206.04s -> 3210.18s]  okay, one of the programs is not going to
[3211.26s -> 3217.14s]  Is not going to run or one of the threads is going to have access to this
[3217.74s -> 3225.48s]  Data structure in other words the or time a data structures that remaining tickets variable while all the other ones have to wait on it
[3226.30s -> 3228.12s]  Okay, so that's what and by the way
[3228.12s -> 3233.36s]  I just realized what I can do here to make our code a little simpler as far as the
[3234.48s -> 3236.48s]  see them
[3237.48s -> 3239.48s]  Confused ticket agents
[3240.04s -> 3244.38s]  CC I'm just going to do the following that was which one that was the ticket agent
[3245.00s -> 3249.60s]  Again, I'll go home and pour over this and see why I made this mistake before but anyway
[3249.60s -> 3252.32s]  We'll paste that in there and then we will
[3252.88s -> 3254.88s]  Change main as well
[3259.12s -> 3263.00s]  It's going to be here, okay, and what we're gonna do
[3266.88s -> 3270.20s]  Okay, so let's see if that works now make confused
[3271.04s -> 3276.80s]  Ticket agents. Oh, no, that must be my I swear I typed this in the front well
[3277.32s -> 3281.88s]  Alright, hold on. Maybe we won't do that. Well, I mean, I'll show you what we're gonna actually do here
[3281.88s -> 3283.88s]  To
[3284.04s -> 3290.92s]  Yes, all right, what we have to do is we have to modify using this thing called a mutex
[3291.36s -> 3293.36s]  okay, and a mutex is
[3294.08s -> 3298.10s]  And where to go here a mutex this we already went through this
[3298.64s -> 3300.08s]  a
[3300.08s -> 3305.60s]  Mutex is a basically a lock that says when a particular thread
[3306.52s -> 3315.36s]  Calls lock on a mutex any other thread that also tries to call lock on that mutex has to wait
[3315.88s -> 3316.68s]  until
[3316.68s -> 3322.40s]  The previous thread releases it with an unlock. Okay, so here's how it goes
[3322.60s -> 3328.92s]  It's a class called mutex and what you do is you say mutex and for some mutex variable
[3329.36s -> 3332.40s]  Okay, and then if a thread says mutex dot lock
[3333.06s -> 3338.84s]  Another thread can come in and say mutex dot lock, but if the previous thread already has it locked
[3339.32s -> 3346.12s]  The new thread just kind of waits around until it unlocks. Okay, if multiple threads are trying to lock on a
[3348.12s -> 3354.96s]  Mutex then one of them will win during the unlock battle that happens after it gets released and all the others will go back
[3354.96s -> 3356.04s]  And wait again
[3356.04s -> 3358.12s]  Okay, so it's a way to say nope
[3358.24s -> 3363.80s]  Only one thread can handle this at a time and it's just using this variable as that
[3364.84s -> 3369.72s]  That beacon that says you are allowed to use it. You are not and that's how it works
[3370.20s -> 3373.82s]  Okay, it locks what we call critical regions of memory
[3374.26s -> 3380.80s]  Okay, and it's super useful and there's a couple other ones that we're going to learn about as well super useful to be able
[3380.80s -> 3383.74s]  To say oh great. Now we've got multiple
[3384.74s -> 3391.70s]  Threads here they all get to use that but nobody's gonna step on everybody anybody else trying to do the decrement question
[3397.70s -> 3402.22s]  That's good question is it possible that a single trouble always lose battle sure one thread might always lose battle
[3402.22s -> 3406.50s]  But then in the end if although I when everybody else finishes it will finally get it if your logic is right
[3406.50s -> 3411.34s]  It would eventually get it but you can't promise to any one thread. You're gonna be next
[3411.34s -> 3413.18s]  No way to do that with a mutex good idea
[3413.18s -> 3417.78s]  There are certain types of locking locks that have a priority associated with them
[3417.86s -> 3422.42s]  We'll get to that later, but the ones we're going to concentrate on have no you know, yeah
[3428.42s -> 3431.48s]  Yeah, the question was our C plus because C plus plus some
[3432.26s -> 3437.78s]  Statements are not C plus plus statements are not atomic because they're translating to assembly same exact industry for C
[3437.82s -> 3443.16s]  Yeah, all of that stuff that you did in 107 where you had to translate C statements into assembly
[3443.16s -> 3447.00s]  You had lots of assembly statements per C statement. So same exact thing
[3455.54s -> 3461.58s]  Very good question. Does it get expensive because if they're how about let's see what happens when we make a change here
[3461.58s -> 3465.14s]  And then we'll see what it what how it actually manifests itself
[3465.22s -> 3470.14s]  But good very good question and very pressing a question anybody else, okay, so
[3471.58s -> 3476.30s]  What is that mute where does mutex come from it stands for mutual exclusion and
[3477.10s -> 3481.26s]  It basically is solely there so that you can mark where critical
[3481.62s -> 3486.38s]  Places in your code are that multiple threads might be working on at the same time
[3486.74s -> 3490.62s]  okay, when you create a mutex it is unlocked a
[3491.46s -> 3494.58s]  Particular thread calls lock on it and then
[3495.38s -> 3498.70s]  Nobody else can call lock. They just wait until that lock is unlocked
[3498.70s -> 3501.56s]  The only thread that's allowed to call unlock
[3502.14s -> 3507.06s]  After locking is the one that locked it another thread could do it and it's undefined behavior
[3507.06s -> 3511.58s]  And you shouldn't do that only or have your logic so that nothing tries to unlock a lock. It doesn't hold
[3512.14s -> 3516.58s]  You'll see how that that it's not hard to get that right by the way, and then that's that
[3517.26s -> 3520.26s]  Okay, so let's actually see what we would have to do
[3520.86s -> 3524.14s]  To make our confused ticket agents
[3525.26s -> 3528.30s]  Hang on confused ticket agents
[3530.62s -> 3535.34s]  Program do this. Okay. All right. So here's where we've got the issue
[3536.14s -> 3539.02s]  Okay. Well what we need to do is we need to have a
[3539.62s -> 3544.68s]  Mutex that we send in to all of the threads so they all have one mutex
[3544.98s -> 3548.18s]  Okay, so let's go back down to main and actually do that
[3548.42s -> 3551.02s]  Okay in main what we're going to do is
[3553.34s -> 3557.22s]  Now we are going to say all right, let's have a
[3558.82s -> 3563.02s]  Mutex here that is let's say mutex
[3565.10s -> 3567.10s]  See I haven't done the
[3568.10s -> 3570.58s]  mutex tickets lock
[3571.70s -> 3572.82s]  Okay
[3572.82s -> 3574.18s]  All right
[3574.18s -> 3575.98s]  That's all you have to do for that
[3575.98s -> 3579.54s]  Okay, and then what we can do is we can
[3582.10s -> 3585.22s]  In here we actually now have to
[3586.02s -> 3588.30s]  Send it in. Okay, so we're just going to do this
[3588.30s -> 3590.06s]  We're going to say same thing as before
[3590.06s -> 3595.38s]  We're going to say I have the remaining tickets in here and then we're just going to put another
[3595.62s -> 3597.68s]  Parameter which is the same thing as before ref
[3598.42s -> 3599.74s]  tickets
[3599.74s -> 3601.02s]  lock
[3601.02s -> 3604.14s]  Okay, like that and then that will just send the other parameter in there
[3604.14s -> 3610.26s]  So we have to update our parameter list front for the function as well. So it can take the right function. Okay, and
[3611.54s -> 3615.62s]  Other than that, that's all we have to change in main. We're just creating in main and sending it into the
[3616.46s -> 3624.66s]  Threads. Okay. Now here we need to do a mutex reference mutex reference tickets
[3625.54s -> 3626.82s]  lock
[3626.82s -> 3628.82s]  Okay. All right, and
[3629.34s -> 3631.34s]  What are we changing here? Well?
[3631.98s -> 3633.90s]  instead of doing
[3633.98s -> 3635.66s]  remaining tickets
[3635.66s -> 3640.14s]  Is greater than zero let's do the following. Okay, let's do while true
[3641.16s -> 3643.80s]  Okay, and then let's do this tickets
[3644.86s -> 3646.86s]  lock dot lock
[3648.46s -> 3653.50s]  Actually, I'm going to reformat this there we go ticket block tickets lock dot lock, okay, and
[3654.38s -> 3658.88s]  Then we are going to do we're going to check and see if remaining
[3659.88s -> 3661.88s]  Tickets equals zero
[3662.48s -> 3667.48s]  Three in other words now, we're the ones who are going to have access to that remaining tickets
[3667.48s -> 3669.48s]  Nobody else can be changing it in the middle
[3669.56s -> 3675.08s]  We're gonna be changing we're gonna be checking it if it happens to be zero. We're done. No more tickets to go
[3683.48s -> 3687.16s]  Yeah, good question the question was does the lock really lock all the remaining
[3688.16s -> 3693.84s]  Variables it's much more simple than that lock says somebody else is going to want this exact
[3694.72s -> 3697.36s]  Data structure or want this critical piece of code
[3697.88s -> 3700.12s]  I'm going to just basically put the lock in here
[3700.12s -> 3703.96s]  Nobody else can access this critical bit based code because they're also going to ask for the lock
[3704.40s -> 3707.40s]  Okay, anything else like they're going to be doing the same sort of thing
[3707.40s -> 3712.36s]  So you have to get your logic right so that you know that Oh everybody who wants this critical
[3712.92s -> 3719.44s]  Data structure or in this case remaining tickets just lock around it and then that's all we need to do. Okay
[3727.88s -> 3733.08s]  Wow, right, so what do we have to do after the actual while statement here?
[3735.08s -> 3737.08s]  Tickets block unlock
[3738.76s -> 3740.32s]  Right
[3740.36s -> 3744.20s]  So we have to do that if we're gonna break out and unlock it there and then at that point everybody can do it
[3744.20s -> 3746.44s]  We're not quite done yet. You have a question before we go
[3752.88s -> 3757.12s]  None of this so all the threads are gonna eventually get to this line and they're gonna go
[3757.12s -> 3760.52s]  I'm gonna they're gonna go I want to lock that that variable one of them is gonna win
[3760.92s -> 3763.20s]  All the rest is gonna wait around till this one finishes
[3764.04s -> 3766.40s]  Okay. Now this may cause an issue. We'll talk to that
[3767.12s -> 3770.44s]  They're waiting at that lock, yeah, they're not doing any there's waiting at block. Yep
[3772.80s -> 3776.46s]  Yeah, good question, well we're locking after I look specifically because of that break
[3777.08s -> 3782.72s]  We break out, but we're still locked. So we better unlock but as I said, we're not quite done yet
[3782.72s -> 3784.72s]  We also want to lock
[3785.08s -> 3787.08s]  unlock actually
[3787.12s -> 3790.96s]  Let's say I guess we could do it either there or let's say not there
[3791.32s -> 3794.16s]  Let's say we want to lock like unlock right here
[3795.16s -> 3796.16s]  On
[3796.16s -> 3797.48s]  tickets
[3797.48s -> 3798.72s]  lock
[3798.72s -> 3801.18s]  unlock like that as well
[3801.64s -> 3806.60s]  Now we'll actually work out because you what we didn't want to do is relock try to relock the lock
[3807.24s -> 3811.12s]  Again, you would actually deadlock because you've got the hold of the lock and then you try to lock it again
[3811.12s -> 3813.84s]  And no you're gonna wait until yours you release it and that's impossible
[3814.16s -> 3819.28s]  But that's so so we do it in two different places in this case on next I guess on Wednesday
[3819.28s -> 3821.20s]  We will learn about another we do that or next week
[3821.20s -> 3823.56s]  We will learn about another way to do it where you don't need both unlocks
[3824.16s -> 3828.88s]  It's a different actually a very clever piece of code. Well, we'll learn about that later, but that's why we did it there
[3829.36s -> 3830.36s]  Okay
[3830.36s -> 3831.60s]  so
[3831.60s -> 3836.36s]  I believe that is all we need to do at this point to make this now
[3837.24s -> 3839.48s]  Safe, right question
[3846.76s -> 3850.56s]  Yeah, the question was if once you got lock when it unlocks
[3851.44s -> 3857.08s]  Another thread can come in immediately and if it's waiting for that lock and then unlock it and two or more could be
[3857.44s -> 3860.00s]  Could be trying to do that and one of them will win and the other one
[3860.00s -> 3862.88s]  Let's go back and stay locked for a while or stay in that position
[3863.84s -> 3864.84s]  There's no race condition
[3864.84s -> 3866.16s]  Well, I mean there is a race condition in it
[3866.16s -> 3867.16s]  They're both looking for it
[3867.16s -> 3870.56s]  But you're hopefully your logic doesn't matter at that point because you're not trying to change something in there
[3870.64s -> 3874.44s]  You're not trying to serialize it or so forth. Okay, so
[3875.66s -> 3880.12s]  Let's see. What happens when we do this make confused ticket
[3880.76s -> 3882.76s]  Agents, these are not confused anymore. Hopefully
[3883.36s -> 3886.20s]  Let's see what happened. We do that confused ticket agents
[3887.04s -> 3889.04s]  Okay now
[3889.20s -> 3891.42s]  What's the first thing you notice about this?
[3892.86s -> 3895.84s]  Slower right, so there is an issue here
[3896.58s -> 3898.58s]  because we've now got
[3899.32s -> 3905.08s]  Like every ticket agent is saying okay. There's a ticket available. I am gonna go and I'm gonna sell it
[3905.96s -> 3907.60s]  right and
[3907.64s -> 3911.58s]  Then I'm going to decrement the remaining tickets and then I'm going to
[3913.20s -> 3916.56s]  And then I'm going to release the lock, okay
[3917.16s -> 3922.40s]  This the way what we've created is kind of inherently still serialized right now
[3922.40s -> 3925.36s]  There is that the break time which is not serialized. That's fine
[3925.36s -> 3927.80s]  I mean we get a little bit of benefit because we don't do that the break time
[3927.80s -> 3929.20s]  Anybody can be on break at the same time
[3929.20s -> 3933.54s]  They don't fight over the coffee machine or something or whatever they need to like, you know do on that
[3934.02s -> 3936.58s]  But but but otherwise it's taking a while
[3936.58s -> 3942.38s]  This is taking like over a minute actually to run this now and you think well that seems a little a little crazy
[3942.70s -> 3943.18s]  Okay
[3943.18s -> 3950.30s]  So is there a way to actually modify this so that we can do this and still end up?
[3950.82s -> 3957.82s]  Not blocking in quite like in such in a way that makes it so that we're slowing things down
[3957.82s -> 3960.78s]  And by the way, let's make sure let's see if it works when we get down to zero
[3960.78s -> 3962.98s]  It should be that there we go. Everybody goes home
[3963.54s -> 3965.54s]  okay, yay, we worked right because
[3965.98s -> 3967.66s]  they all
[3967.66s -> 3971.34s]  Got to a point near the end where they there were no more to be sold. And by the way
[3972.24s -> 3976.72s]  You let's see the singer. No, they all they all
[3977.34s -> 3980.98s]  Wait, notice the tickets are sold. They actually all happen to wait at the same time in that case
[3981.52s -> 3986.30s]  Okay, and then because or they all ended up that place because they're all waiting for that lock to do that check
[3986.98s -> 3992.34s]  So, what do you think? Can we fix this even to make it a little bit faster and maybe we have to
[3993.06s -> 3998.42s]  Change our own like understanding of what it means to sell a ticket like sometimes you can't get away with that
[3998.78s -> 4005.98s]  All right, but in this case, could we do something here to make it so this actually works and faster anyway
[4007.02s -> 4009.02s]  What do you think?
[4009.94s -> 4011.94s]  I
[4020.54s -> 4025.50s]  Put the remaining tickets there and then do this way
[4027.26s -> 4029.26s]  This one up here
[4031.10s -> 4033.10s]  Would that work I
[4033.10s -> 4035.10s]  Think
[4035.30s -> 4039.54s]  It would work right now we're assuming that the ticket gets sold
[4040.00s -> 4042.58s]  Right. So let's say the ticket agent gets on the phone
[4042.90s -> 4045.38s]  The ticket agent has already said I've got this thing
[4045.38s -> 4049.74s]  It's sold and then let's say that there's some logic where that I don't want that stupid ticket
[4049.74s -> 4052.14s]  Your airlines terrible to hang up on the phone or whatever, right?
[4052.14s -> 4055.68s]  Well, they have to somehow put the ticket back and we don't have that logic in here
[4055.68s -> 4059.20s]  But we could build it in if we I mean we could build it in somehow where we say
[4059.24s -> 4062.92s]  Oh look if you got the last ticket you better keep trying to sell it
[4062.92s -> 4068.46s]  You got to stay until it gets sold there's something like that, right, but I think this will actually this will actually work
[4069.40s -> 4071.40s]  see make confused tickets and then
[4075.52s -> 4081.52s]  Still much faster now, right? Not not like way way way faster, but definitely much faster
[4081.52s -> 4084.72s]  I'd say it is much faster. In fact, I'm just going a lot faster
[4084.72s -> 4087.46s]  But let's see what happens near the end here. See if it still work. There we go
[4087.98s -> 4094.94s]  Okay, so it did finish and lots of agents said zero more tickets and they let they went home while the other two agents were still
[4094.94s -> 4099.80s]  Selling right, but who cares at that point? We assume that each agent sells their ticket
[4100.54s -> 4104.42s]  Okay, so that's one way to do it. So what you read the takeaway on this is
[4105.54s -> 4110.76s]  If you can make your logic such that you lock for a very short amount of time
[4111.38s -> 4112.90s]  That's the best way to do it
[4112.90s -> 4116.22s]  Don't try to lock around important things like handle call
[4116.50s -> 4121.06s]  Handle call that has nothing to do with whether or not the ticket itself has been decremented or not
[4121.06s -> 4125.30s]  Now, maybe we need more logic to put it back and it doesn't get sold and you know
[4125.30s -> 4129.74s]  That's a different different program in some sense, but you do have you do want to not
[4130.50s -> 4132.50s]  lock around
[4132.54s -> 4137.46s]  Extended places that don't matter for that lock don't don't have the ticket agent
[4137.58s -> 4141.86s]  Say you can't touch the ticket queue until I'm done selling my ticket, which is what we just did. Yep
[4143.82s -> 4145.82s]  Right
[4164.50s -> 4166.50s]  Right, so like right here it says
[4166.90s -> 4171.66s]  Six more tickets to be sold from two different agents. Is that your concern? Yeah in that case
[4172.22s -> 4176.72s]  It probably doesn't matter. You're you'd still have some other maybe we should have put the
[4177.06s -> 4181.50s]  Print statement before the unlocked or something if we wanted to we could have done that too
[4181.50s -> 4184.18s]  But that's just a print statement in that case. We could probably clean that up
[4184.18s -> 4186.56s]  In fact, we could try and see if that if it makes sense for our
[4187.46s -> 4189.14s]  for our thing here
[4189.14s -> 4192.72s]  Let's see. Yeah, I mean you would have to break it up here and say, you know
[4192.72s -> 4197.52s]  Put the number of tickets to be sold up farther and the agent sold the ticket below
[4197.52s -> 4199.50s]  You could break that see out statement up and do that
[4199.54s -> 4201.82s]  But yeah, that's a that's another race condition in that sense
[4201.82s -> 4204.98s]  Oh to two people think that there's the same amount of tickets left be sold. That seems a lot
[4205.42s -> 4209.70s]  But in the end our logic for the stopping still works out. But yeah, that was kind of another
[4210.62s -> 4213.36s]  Anomaly that you'd have to fix. Yeah, good question
[4221.38s -> 4224.56s]  Is there any way to make it near as fast this is pretty close actually
[4224.56s -> 4227.22s]  I don't know if you remember from before it's about it's a it's pretty close
[4227.74s -> 4228.48s]  But no
[4228.48s -> 4234.24s]  I mean locking will involve some overhead because there is a time where two threads are trying to get the same
[4234.54s -> 4242.54s]  Data structure or a variable and it's going to take more time and that's just a that's a downside but a necessary downside of
[4243.32s -> 4247.18s]  Making it so that's functional. That's so the program works. But yeah, good question. Yep
[4247.18s -> 4249.18s]  I
[4253.62s -> 4254.82s]  Yes, good question
[4254.82s -> 4255.50s]  so
[4255.50s -> 4256.68s]  So it's a I'm saying wait
[4256.68s -> 4261.70s]  What if is there a way to lock when there's like a certain number of tickets left or something so that more people can go?
[4261.70s -> 4263.70s]  In and tell that there is
[4263.86s -> 4269.44s]  They're called conditional variables actually and there's also another one that will build ourselves called a semaphore
[4269.46s -> 4275.02s]  Which does that it allows you to basically have a count in which case you only lock when that count ends up at zero
[4275.06s -> 4281.94s]  And then before then anybody can go in and grab as many as they can grab one until that count becomes zero good good point
[4281.94s -> 4283.94s]  We'll get there. Good question
[4289.64s -> 4294.06s]  Yeah, good question well why is handled when handle call was inside the lock wise is slower
[4294.06s -> 4296.06s]  Well handle call does what it just is asleep
[4296.50s -> 4302.42s]  Right, and if all the if you have not unlocked yet by the time when handle call gets called
[4302.78s -> 4308.76s]  Everybody else is standing around looking at that one ticket agent trying to sell the ticket because they can't get into the shape to modify
[4308.76s -> 4309.42s]  It right
[4309.42s -> 4312.14s]  So there's where the inherent like slowness happened before
[4312.46s -> 4317.54s]  Every ticket agent was on and on their own selling a ticket with all the other ones waiting around going
[4317.54s -> 4320.58s]  I can't even sell a ticket because I can't even get out there the thing so
[4320.86s -> 4326.38s]  So our model wasn't perfect in the in that sense, right but knowing that a tickets always sold makes it so we can do
[4326.38s -> 4328.38s]  it, okay
[4328.38s -> 4330.38s]  Other questions on this
[4332.42s -> 4336.78s]  Alright threading is kind of fun stuff, but you can see lots of issues
[4336.78s -> 4342.76s]  We will get to many more different types of locks as we go along. Alright, I will see you Wednesday
