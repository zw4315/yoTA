# Detected language: en (p=1.00)

[0.00s -> 2.84s]  All right, so welcome.
[2.84s -> 7.40s]  We have a presentation which you probably heard when you were in 106B or 106X and 107
[7.40s -> 9.20s]  and you're hearing it again.
[9.20s -> 10.20s]  This is Sonya.
[10.20s -> 16.28s]  She is one of the CS198 section leader coordinators and she is going to talk to
[16.28s -> 17.56s]  you about section leading.
[17.56s -> 19.76s]  How many section leaders do we have in here already?
[19.76s -> 21.54s]  A whole bunch of you.
[21.54s -> 26.00s]  So people with your hands up, other people can ask questions of you as well.
[26.00s -> 29.00s]  Feel free to chime in if you have comments about this.
[29.00s -> 36.64s]  Look, when you are in 106A, 106B, or 106X there are these section leaders and they were possibly
[36.64s -> 39.00s]  quite important to your life.
[39.00s -> 43.16s]  It is an awesome opportunity, I'm not going to steal Sonya's thunder, but I think it's
[43.16s -> 49.64s]  a great opportunity to actually give something back to computer science and also improve
[49.64s -> 50.64s]  your own skills.
[50.64s -> 54.68s]  Trust me, when you teach something you learn it much better than you do when you're just
[54.68s -> 56.20s]  like in a class.
[56.20s -> 57.20s]  All right, over to Sonya.
[57.20s -> 58.20s]  Cool.
[58.40s -> 59.40s]  Thanks so much, Chris.
[59.40s -> 60.40s]  Cool.
[60.40s -> 63.60s]  So who here has taken a 106 class here at Stanford?
[63.60s -> 66.64s]  Nice, vast majority, almost everybody.
[66.64s -> 72.36s]  So a lot of you know what section leaders are, but they are undergraduate TAs who lead
[72.36s -> 77.12s]  sections and for this round of applications we're looking for people like you who have
[77.12s -> 81.84s]  completed 106B and X, so we're looking for people from all sorts of different backgrounds.
[81.84s -> 86.24s]  Like if you're a conflict major, great, we want you and I guess if you're a CS major,
[86.28s -> 91.88s]  which I'm sure there are lots of you in 110, we also want you to apply, so do apply.
[91.88s -> 93.08s]  What do section leaders do?
[93.08s -> 98.44s]  You teach a 50-minute section, you help students in the lair and teach them like
[98.44s -> 103.48s]  good debugging strategies, you grade assignments, you hold interactive grading sessions, so
[103.48s -> 107.08s]  you get lots of one-on-one time with your students and you grade things and you
[107.08s -> 110.48s]  get paid $17.50 an hour starting salary.
[110.52s -> 116.32s]  And the next year it'll be $18 an hour starting salary and more, the seniority.
[116.32s -> 121.60s]  And you get to be part of a really cool community who has lots of fun doing things.
[121.60s -> 126.68s]  So timing requirements, you'll need to section lead for two quarters.
[126.68s -> 131.80s]  So if you want to study abroad, that's totally fine, we're cool with you deferring that,
[131.80s -> 134.16s]  just let us know when you're applying.
[134.16s -> 139.76s]  And then in your very first quarter, we want you to take CS 198 for three or four
[140.04s -> 146.12s]  years, come to Monday meetings, which are every Monday for 30 to 6 PM,
[146.12s -> 150.92s]  and attend workshops in the very first four weeks that you're a section leader.
[150.92s -> 152.32s]  Just because we want to get you oriented.
[153.52s -> 155.36s]  So why section lead?
[155.36s -> 159.04s]  Well, teaching is the biggest and
[159.04s -> 163.40s]  most valuable way, as Chris said, to master a subject.
[163.40s -> 167.96s]  And it actually helps you develop a lot of skills that come in use
[167.96s -> 172.76s]  later in life if you want to go into management or if you want to just talk or
[172.76s -> 177.44s]  if you want to be a mentor, teaching is a really great way to hone those skills.
[177.44s -> 180.44s]  You also get an opportunity to work directly with students,
[180.44s -> 185.16s]  more so than in other TAships that are available to you here at Stanford.
[185.16s -> 188.20s]  Because you've got these 15 minute interactive grading sessions with your
[188.20s -> 192.40s]  students after every single assignment, you really get to develop a relationship with
[192.40s -> 199.44s]  them and play an important role in their education and their love of computer science.
[199.44s -> 204.32s]  You get to be participating in fun events and you also get to join an awesome
[204.32s -> 210.04s]  group of people who really care about teaching well and teaching CS.
[210.04s -> 211.72s]  And then leave your mark on campus.
[211.72s -> 216.92s]  You can make a significant difference in a student's life, so keep that in mind.
[216.92s -> 218.64s]  These are some of the fun events that we do.
[218.64s -> 221.64s]  We dress up and help people debug their code.
[221.64s -> 224.92s]  And we also eat breakfast, yay.
[224.92s -> 228.28s]  And then we also have corporate partnerships and
[228.28s -> 232.16s]  we do special events just for section leaders.
[232.16s -> 235.00s]  So yeah, we cooked things at Google and
[235.00s -> 238.28s]  went onto boats in the bay once upon a time.
[238.28s -> 241.48s]  And also you can be like one of these people if you're a section leader.
[241.48s -> 244.20s]  All of these were section leaders here at Stanford.
[244.20s -> 248.08s]  So I encourage you to become the next mayor on Suhami.
[249.08s -> 256.44s]  So the applications are open right now, and they are due this Thursday at 11.59pm.
[256.44s -> 261.84s]  And you can access them at cs198.stanford.edu, cool.
[261.84s -> 262.56s]  Any questions?
[266.56s -> 270.60s]  Awesome, great, we'll apply, hope to see you soon.
[270.60s -> 272.16s]  Actually, can I add one last thing?
[272.16s -> 275.80s]  If you have applied before in the past and didn't get it,
[275.80s -> 279.20s]  I'd say that we really would love for you to apply again.
[279.20s -> 282.92s]  And in our interview process, we care about making you better teachers.
[282.92s -> 285.52s]  So we're happy to provide you feedback.
[285.52s -> 290.36s]  So many section leaders don't get it until they apply two or
[290.36s -> 292.24s]  three or four times.
[292.24s -> 294.28s]  So I encourage you to keep applying and keep asking for
[294.28s -> 298.28s]  feedback if you're interested in it, but it hasn't worked out for you in the past.
[298.28s -> 298.96s]  Cool.
[298.96s -> 300.00s]  All right, thank you, Tony.
[300.00s -> 310.00s]  All right, I think section leading is a great opportunity all around.
[310.00s -> 312.48s]  And like Sonya said, if you've applied before and didn't get it for
[312.48s -> 315.64s]  some reason, don't let that discourage you too much.
[315.64s -> 318.52s]  Because many people try lots of times before they get it.
[318.52s -> 320.88s]  And that's the way it goes.
[320.88s -> 321.40s]  All right, thanks Tony.
[322.80s -> 327.08s]  Okay, so how's assignment, what are we up to now?
[327.08s -> 329.44s]  Three, how's assignment three going?
[329.44s -> 330.76s]  Going all right?
[330.76s -> 331.80s]  It's such a tricky one.
[333.08s -> 335.68s]  I would say it's probably one of the longer ones, believe it or not.
[335.68s -> 337.16s]  There's lots of moving parts to it.
[338.32s -> 341.76s]  And I promised you I would talk about it today.
[341.76s -> 344.60s]  But I didn't prepare anything to talk about today.
[344.60s -> 345.76s]  Here's what I'll do.
[345.76s -> 350.44s]  I totally blanked that I was gonna tell you about this, the assignment.
[350.44s -> 351.92s]  Many of you have already started it.
[351.92s -> 353.16s]  If you haven't, please do it soon.
[354.84s -> 356.68s]  Here's what I'll do.
[356.68s -> 359.04s]  When I get home today, Ali is gonna remind me of this.
[359.04s -> 361.28s]  Cuz she's gonna send me an email anyway, and
[361.28s -> 362.36s]  she's gonna send me an email about that.
[362.36s -> 366.00s]  Remind me in that too, do a little video this afternoon about that.
[366.00s -> 367.92s]  Okay, I'll post it this evening.
[367.92s -> 370.36s]  Okay, but anyway, that'll be about the assignment.
[370.36s -> 372.20s]  Sorry I didn't prepare that now.
[372.20s -> 375.44s]  And where did this go?
[378.16s -> 379.00s]  Firefox closed?
[379.00s -> 379.84s]  It did close.
[379.84s -> 381.44s]  Hm, all right.
[381.44s -> 386.44s]  So we are on to, we're still talking about signals.
[387.20s -> 391.60s]  And signals can be tricky, okay?
[391.60s -> 399.72s]  Processes when they run with signals tend to have lots of race conditions.
[399.72s -> 403.64s]  And we want to avoid those race conditions if we can.
[403.64s -> 406.00s]  We have to talk about some of the places those happen,
[406.00s -> 407.44s]  some of the times those happen.
[407.44s -> 412.36s]  And how to actually remove those race conditions or
[412.36s -> 415.96s]  make it so that the race conditions don't happen because our logic is correct.
[415.96s -> 417.76s]  So that's what we're trying to do.
[417.76s -> 422.80s]  Speaking of not being correct, last Wednesday I misled you a bit,
[422.80s -> 424.36s]  and I apologize about that.
[424.36s -> 427.08s]  One of the CAs was watching the video and he goes,
[427.08s -> 429.08s]  I don't think you were right at the end there when you said this thing.
[429.08s -> 432.56s]  And I went back and thought about it, and I went, I can see why, yes,
[432.56s -> 433.80s]  that was wrong.
[433.80s -> 435.04s]  I can see what you're talking about.
[435.04s -> 435.72s]  Here's what I said.
[435.72s -> 439.28s]  So I don't know if you remember this example from last week.
[439.28s -> 445.24s]  But what we did was we had, my pen is not working again.
[445.24s -> 449.32s]  Hold on one second, I'm gonna try this one more time.
[449.32s -> 455.44s]  This, and this, I swear it was working before.
[458.44s -> 467.96s]  It might be, Pen, let's see, there we go, all right, we'll try that.
[467.96s -> 472.96s]  So the example that we worked on last week was this
[472.96s -> 480.36s]  example where we had a SIG child that we had, okay?
[480.36s -> 484.16s]  That we signaled it, and it's a special function that we call.
[484.16s -> 489.64s]  And this is how signal handlers work.
[489.64s -> 491.68s]  We say signal, and then the type of signal, and
[491.68s -> 494.76s]  then the signal handling function.
[494.76s -> 499.52s]  And what I said for this one, this was the one that printed out the job list.
[499.52s -> 501.56s]  And it said, and we had a problem with it to begin with.
[501.76s -> 506.12s]  First thing we said, wait a minute, sometimes when we add a job to the job
[506.12s -> 511.48s]  list, it will say, job removed from the job list before it even gets to job is
[511.48s -> 515.00s]  added to the job list, because we've got this specifically,
[515.00s -> 516.80s]  because we've got this crazy sleep in there.
[516.80s -> 519.40s]  And we're saying, before you even add it to the job list,
[519.40s -> 522.04s]  do some other stuff, basically sleep.
[522.04s -> 527.64s]  And by the time that wakes up, the parent adds it to the job list
[527.68s -> 532.80s]  after the process has already ended, called the signal handler, and
[532.80s -> 535.76s]  said that it was removed, and we didn't like that.
[535.76s -> 540.96s]  When we have our logic so that a job gets removed from some job list
[540.96s -> 544.80s]  before it gets added, that's not really a good thing, okay?
[544.80s -> 546.60s]  That just logically doesn't make sense, number one.
[546.60s -> 547.84s]  It didn't break our program,
[547.84s -> 550.16s]  because our program wasn't really breakable in that sense.
[550.16s -> 553.16s]  But it doesn't look right, and if we had added more to it,
[553.16s -> 555.00s]  to actually add and remove jobs,
[555.04s -> 557.84s]  it doesn't make any sense to remove it before it's added.
[557.84s -> 563.48s]  So what we did was we said, all right, there's this sig proc mask
[563.48s -> 567.64s]  system call, which will allow us to block a signal.
[567.64s -> 572.56s]  And in this case, we're going to block the set of signals,
[572.56s -> 576.68s]  which includes just the child process, which means that
[576.68s -> 582.24s]  that signal handler will not get called until we unblock those.
[582.24s -> 584.52s]  Okay, so that's what's happening with this system.
[584.52s -> 588.52s]  We're basically saying, okay, look, now we're saying only unblock
[588.52s -> 593.56s]  after we print out our message, in the parent anyway,
[593.56s -> 596.24s]  after we print out that we've added the job to the job list.
[596.24s -> 598.96s]  Okay, now what I said in lecture the other day was, hey,
[598.96s -> 604.92s]  what happens if the child ends up sending,
[604.92s -> 611.08s]  if the child, let's say, sends a message that says,
[612.00s -> 616.24s]  or the child process does this execs the CVP, where is it here,
[616.24s -> 621.72s]  in the, let's see, I'm missing it here.
[621.72s -> 623.28s]  Oh, you know what, yeah, here it is, down here.
[623.28s -> 627.24s]  Okay, when the child does this, what if that process had its own children,
[627.24s -> 630.72s]  would the child signal handler get called,
[630.72s -> 634.08s]  and will we get this weird job removed from job list
[634.08s -> 636.20s]  when it wasn't even part of our program?
[636.20s -> 637.88s]  And the answer I said was, oh, it depends,
[637.88s -> 640.00s]  and we would have to check it out, and we'd have to block the signal.
[640.00s -> 642.84s]  No, I was wrong on that.
[642.84s -> 644.80s]  Here's what happens, and this is actually critical
[644.80s -> 651.20s]  to understanding the actual, the workings of this system.
[651.20s -> 656.96s]  When you call exe CVP, your entire program that is already running
[656.96s -> 659.84s]  in that child process is destroyed.
[659.84s -> 662.24s]  The new program is what starts running.
[662.24s -> 666.00s]  So there is no longer a signal handler
[666.00s -> 669.96s]  for the actual child process you created,
[669.96s -> 672.56s]  because by the time you do exe CVP,
[672.56s -> 678.16s]  there are no more functions in that original process to begin with.
[678.16s -> 681.60s]  Okay, so it doesn't really matter that the child has children processed.
[681.60s -> 685.72s]  Now, it does matter for blocked signals.
[685.72s -> 690.68s]  The signals get blocked across the exec CVP boundary as well,
[690.68s -> 695.84s]  so we do want to remove the signal right,
[695.84s -> 700.32s]  let's see, we want to unblock when we go into the child,
[700.32s -> 705.72s]  so the child, if the child's program did have its own children,
[705.72s -> 709.84s]  it wouldn't automatically have those children's signal blocked.
[709.84s -> 711.88s]  Does that hopefully clear things up a little bit?
[711.88s -> 716.16s]  The big idea is that exec CVP destroys everything in your original program,
[716.16s -> 719.36s]  so it's not like anything in the original program can get called again.
[719.36s -> 721.48s]  So that's what's happening there.
[721.48s -> 723.36s]  Okay, all right.
[723.40s -> 727.08s]  So, hang on, now my, now my, this won't clear.
[727.08s -> 729.96s]  I think this tablet is not long for this world.
[729.96s -> 733.04s]  Hang on a sec, clear.
[733.04s -> 736.40s]  Okay, we're going to do this, and clear.
[736.40s -> 738.44s]  There we go, okay.
[738.44s -> 741.28s]  All right, back to here.
[741.28s -> 744.28s]  So, we're going to keep talking about some signals, okay?
[744.28s -> 747.72s]  The two signal question, is there, no, yeah.
[747.88s -> 753.72s]  When you call exec CVP, does that trigger the child?
[753.72s -> 757.32s]  When you call exec CVP, that does not trigger the significant child.
[757.32s -> 761.40s]  Oh, and this was a good, that's a good point that I forgot to mention.
[761.40s -> 764.36s]  Somebody on Piazza said, oh, when exec CVP happens,
[764.36s -> 767.36s]  you get a whole new process ID and all that, you don't.
[767.36s -> 771.08s]  It's actually the same process ID that you started with in your child.
[771.08s -> 776.44s]  Okay, so to your question, when exec CVP happens,
[776.44s -> 779.60s]  the child is still alive throughout the running of that program.
[779.60s -> 783.36s]  When that program ends, the child itself ends.
[783.36s -> 785.32s]  Does that help?
[785.32s -> 790.84s]  I thought that when you call exec CVP, it doesn't return, so.
[790.84s -> 794.28s]  When you do exec CVP, it does not return, but it's still the child process.
[794.28s -> 799.08s]  And when that ends, that's when your child handler gets called.
[799.08s -> 801.04s]  Good question.
[801.04s -> 802.92s]  All right, all right.
[803.00s -> 809.60s]  So the other day I did mention two new kinds of system calls called kill and
[809.60s -> 810.92s]  raise.
[810.92s -> 815.68s]  Kill is a way to send a signal to another process, or your own process, but
[815.68s -> 817.56s]  you would use raise for that generally.
[817.56s -> 819.88s]  And you can send all the different signals, and
[819.88s -> 824.12s]  that's how you actually do it to notify the other
[825.96s -> 829.24s]  process that you actually are sending it some signal.
[829.24s -> 831.00s]  You use the kill command.
[831.00s -> 833.88s]  Now, unfortunately, because of the naming,
[833.88s -> 837.00s]  kill is not really named particularly well.
[837.00s -> 841.08s]  But let me just show you an example of how we might do this.
[841.08s -> 842.44s]  Let's do this first.
[842.44s -> 846.48s]  Man to kill, let's see.
[846.48s -> 848.92s]  So it's these two, I always get these wrong.
[851.56s -> 854.56s]  These two handlers right here, okay.
[854.56s -> 859.56s]  And then, or these two includes vim test kill dot.
[859.64s -> 862.92s]  Actually, we'll do test raise, cuz we'll send it to ourself.
[862.92s -> 866.04s]  Let's see, okay, we're gonna do that.
[866.04s -> 875.64s]  And we will also pound include stdio.h, okay, int main.
[875.64s -> 882.04s]  All right, printf, I am about to terminate my own process.
[884.64s -> 887.84s]  Sad face, okay.
[887.84s -> 894.48s]  And then we are going to use the raise command, or the raise system call.
[894.48s -> 896.60s]  The raise system call just takes the signal that you want it.
[896.60s -> 902.76s]  So if we send sig kill, that actually, we can say return zero.
[902.76s -> 903.88s]  But we will never get there,
[903.88s -> 907.72s]  because by the time we get there, this will already be terminated.
[907.72s -> 910.20s]  And that should actually do it.
[910.20s -> 916.92s]  Let's see, make test raise, okay, test raise kill.
[918.04s -> 920.92s]  All right, what happened was we sent a signal to our own process using
[920.92s -> 924.16s]  the raise system call, and it just terminated the process.
[924.16s -> 929.60s]  Okay, we could have done other ones as well, but that one will do that.
[929.60s -> 933.72s]  If we did, for instance, let's try a different one.
[933.72s -> 938.92s]  Sig stop, I think that might be the one.
[938.92s -> 941.72s]  I think that's the one.
[941.72s -> 944.96s]  Make test raise, oop, maybe it's not.
[945.56s -> 951.68s]  Let's see, does it say the different one?
[951.68s -> 955.24s]  Sig, did I spell it wrong?
[955.24s -> 957.32s]  It's not S-T, okay, of course.
[957.32s -> 960.72s]  Of course, I thought maybe they removed that O too.
[960.72s -> 965.56s]  Oop, maybe if I spell it right, how about that?
[965.56s -> 967.28s]  There we go, it's even in red.
[967.36s -> 978.20s]  Okay, so, oops, make test raise.
[978.20s -> 982.68s]  Sometimes the best laid plans, okay, test raise, okay, stop.
[982.68s -> 985.76s]  And then it actually stopped it, so it is still running as it turns out.
[985.76s -> 988.64s]  Well, it's not running anymore because the program actually, well,
[988.64s -> 991.64s]  it will, when I do this, it will actually say, go back into it and
[991.64s -> 996.08s]  end immediately, but sig stop pauses your program, right?
[996.12s -> 998.12s]  And actually, you use that for
[998.12s -> 1002.52s]  the Python program you're using in this week's assignment actually does that.
[1002.52s -> 1006.44s]  So the sig stop, which you can send to yourself, pauses your program
[1007.44s -> 1010.40s]  in temporarily, although I think it's a slightly different one that we're using.
[1010.40s -> 1010.96s]  Yes?
[1010.96s -> 1014.48s]  Why is it that the FG can actually continue to program?
[1014.48s -> 1017.44s]  FG, good question, the question is why does FG continue to program?
[1017.44s -> 1021.00s]  So once you have a background process, you can actually see all the different
[1021.00s -> 1025.32s]  jobs, FG puts one of them back in the foreground for you, FG for foreground.
[1026.24s -> 1032.96s]  Okay, so if we, let's do test raise again, and then it's in there.
[1032.96s -> 1036.12s]  If I type jobs, I believe, yeah, there we go,
[1036.12s -> 1037.96s]  it just tells you there's one stock job.
[1037.96s -> 1043.44s]  I could run the other one too, and then now there's two stock jobs like that.
[1043.44s -> 1045.84s]  And so if I put, I can put one of them back and then put the other one back,
[1045.84s -> 1047.76s]  and now that just starts them back up again.
[1047.76s -> 1048.64s]  Question, Sam?
[1048.64s -> 1051.84s]  Sleep keeps it in the foreground, or sleep also keeps it in the foreground?
[1051.84s -> 1055.88s]  Sleep does keep it in the foreground, so if we type just sleep,
[1056.72s -> 1060.96s]  it will keep it in the foreground and just not be running the program necessarily,
[1060.96s -> 1066.56s]  but not give back the terminal access to it.
[1066.56s -> 1067.80s]  Yeah, good question.
[1067.80s -> 1068.96s]  Okay.
[1068.96s -> 1069.84s]  All right, yes?
[1069.84s -> 1083.12s]  If you, good question, so if you, your question is if I'm like the child,
[1083.12s -> 1084.76s]  and I call SIG stop on the parent,
[1084.76s -> 1087.08s]  does the child, does it affect the child or the exec CVPR?
[1087.08s -> 1088.76s]  No, it doesn't affect that at all.
[1088.76s -> 1091.92s]  Once you have two processes, they can work independently
[1091.92s -> 1094.20s]  of each other almost completely, right?
[1094.20s -> 1096.60s]  Even the parent can end first, the child can end first,
[1096.60s -> 1098.76s]  or completely independently in that sense.
[1098.76s -> 1100.36s]  Yeah, good question.
[1100.36s -> 1101.96s]  Anybody else?
[1101.96s -> 1110.16s]  All right, so that's the kill system call and the raise system call,
[1110.16s -> 1113.56s]  and they just are used to actually send these signals.
[1113.60s -> 1115.52s]  Okay? All right.
[1115.52s -> 1121.48s]  Let's move on to some more signal handling, especially handling things
[1121.48s -> 1125.40s]  like race conditions and another thing called spinning,
[1125.40s -> 1127.72s]  which is what we want to avoid, and I'll show you what
[1127.72s -> 1130.12s]  that means as we get to it.
[1130.12s -> 1132.80s]  So remember the job, well, this is the program we just looked at,
[1132.80s -> 1135.76s]  the job list program that we had.
[1135.76s -> 1139.12s]  The reason we needed the fixed version was to have
[1139.84s -> 1145.48s]  that SIGPROC mask blocking our SIG child until the time
[1145.48s -> 1149.52s]  when we wanted it to actually work, okay?
[1149.52s -> 1157.00s]  The processes, okay, do have some control over SIG child signals,
[1157.00s -> 1162.92s]  and when you use the signal handling, the parent shouldn't need
[1162.92s -> 1168.00s]  to do anything special to like handle children anymore outside
[1168.00s -> 1173.44s]  of the actual signal handler, okay?
[1173.44s -> 1177.96s]  So, and by the way, signals, when you block them,
[1177.96s -> 1180.88s]  you might think to yourself, oh, that sounds draconian and whatever.
[1180.88s -> 1182.20s]  It's all about your process.
[1182.20s -> 1184.56s]  It's not like you're blocking things for other processes.
[1184.56s -> 1187.32s]  I mean, unless you exec CVP and so forth, but potentially
[1187.32s -> 1189.16s]  or ostensibly you know what you're doing
[1189.16s -> 1190.84s]  when you're writing your own program.
[1190.84s -> 1193.80s]  So it does seem somewhat draconian to do this,
[1193.80s -> 1196.36s]  like I'm blocking this whole signal from happening.
[1196.36s -> 1197.76s]  Well, you're writing the program,
[1197.76s -> 1200.92s]  so you get control over that, okay?
[1200.92s -> 1202.44s]  All right, so let's look at,
[1202.44s -> 1205.48s]  remember the simple shell example, and in fact, again,
[1205.48s -> 1209.08s]  you're going to write a much more advanced shell that we had.
[1209.08s -> 1211.08s]  Here's what it looks like, okay?
[1211.08s -> 1213.12s]  I'll blow this up here, all right?
[1213.12s -> 1220.28s]  The simple shell function actually does what?
[1220.28s -> 1225.12s]  It forks off of, there's other stuff in here too,
[1225.12s -> 1226.88s]  but it basically forks off,
[1226.88s -> 1228.20s]  there's code that we don't have in there
[1228.20s -> 1229.64s]  to initialize the command,
[1229.64s -> 1232.96s]  forks off a process that you type in a command for,
[1232.96s -> 1236.52s]  and then if you type the ampersand on it on the end,
[1236.52s -> 1239.52s]  it's in the background, and so it ends up in the background
[1239.52s -> 1241.36s]  and you get your shell prompt back.
[1241.36s -> 1244.52s]  If not, we've got this interesting wait PID in here
[1244.52s -> 1247.00s]  for foreground processes actually,
[1247.00s -> 1250.80s]  because the shell is waiting for the child to end.
[1250.80s -> 1253.32s]  When the child process is in the foreground,
[1253.36s -> 1256.16s]  the parent process wants to wait for it,
[1256.16s -> 1259.56s]  so that's why we have the wait PID here, okay?
[1259.56s -> 1262.80s]  Well, once we have signal handling,
[1262.80s -> 1264.72s]  maybe we want to change this a little bit, okay?
[1264.72s -> 1266.92s]  Because we haven't had signal handling before,
[1266.92s -> 1268.84s]  so we did it in this kind of,
[1268.84s -> 1270.36s]  this method where we've got,
[1270.36s -> 1272.96s]  oh, we're going to just wait PID, and by the way,
[1272.96s -> 1275.92s]  when does the background process
[1275.92s -> 1278.04s]  get cleaned up in this program?
[1278.04s -> 1283.04s]  I'm seeing some heads shaking.
[1284.52s -> 1286.56s]  Yeah, the background process doesn't get cleaned up
[1286.56s -> 1287.76s]  in this program, okay?
[1287.76s -> 1289.88s]  So that's kind of an error on our part.
[1289.88s -> 1291.72s]  We didn't even know how signals work before,
[1291.72s -> 1293.44s]  so we didn't have signal handlers,
[1293.44s -> 1296.16s]  so it was going to be impossible to actually do this.
[1296.16s -> 1299.44s]  But do you see how there is no wait PID
[1299.44s -> 1301.56s]  for the background process?
[1301.56s -> 1305.12s]  The background process prints the command
[1305.12s -> 1306.28s]  that's in the background,
[1306.28s -> 1309.04s]  and then it goes back and prints another terminal,
[1309.04s -> 1313.00s]  and then it never again cleans up that process, okay?
[1313.00s -> 1314.68s]  Which actually means it turns out
[1314.68s -> 1317.36s]  that as long as that shell is running,
[1317.36s -> 1320.04s]  that process is still not cleaned up, okay?
[1320.04s -> 1323.12s]  So it's kind of, I mean, it's kind of an error
[1323.12s -> 1326.20s]  in the sense that it's like not freeing memory
[1326.20s -> 1327.92s]  that should be freed and so forth.
[1327.92s -> 1331.16s]  So we want to avoid that if we can, okay?
[1331.16s -> 1334.08s]  So let's change this, okay?
[1334.08s -> 1338.88s]  So let's actually look at our simple shell program again.
[1338.88s -> 1342.38s]  Simple shell dot C, okay?
[1342.38s -> 1347.38s]  There are, let's see, let's see, do we have the actual,
[1347.88s -> 1350.24s]  yeah, this is the original here, okay?
[1350.24s -> 1352.92s]  And what we're gonna do is we are going to
[1352.92s -> 1355.32s]  add a couple things to this, okay?
[1355.32s -> 1360.32s]  We are going to, actually let me not use this one.
[1360.36s -> 1364.60s]  Let's do simple shell with redundancy,
[1366.12s -> 1367.80s]  which is a, there we go, okay.
[1367.80s -> 1369.88s]  So now we're going to have a reprocess
[1369.88s -> 1371.92s]  for our simple shell, okay?
[1371.92s -> 1376.56s]  And we are going to, actually this is here,
[1376.56s -> 1378.56s]  now gotten all that in there, okay?
[1378.56s -> 1380.90s]  We are gonna change this so that we actually use
[1380.90s -> 1384.72s]  that signal handler in our program, okay?
[1385.56s -> 1388.44s]  So what we want to do, okay,
[1388.44s -> 1393.36s]  is we want to do the same basic thing as before, okay?
[1393.36s -> 1395.84s]  We're gonna fork, okay?
[1395.84s -> 1398.08s]  And we are going to,
[1400.92s -> 1403.00s]  actually we should probably keep track of it,
[1403.00s -> 1406.70s]  PID T PID equals fork, okay?
[1406.70s -> 1411.02s]  We're gonna fork in our process here, okay?
[1411.02s -> 1415.36s]  If we are the child, okay, what are we going to do?
[1415.36s -> 1420.36s]  We are going to exec cvp argv zero and argv.
[1424.28s -> 1426.48s]  Now, by the way, this is not error checking.
[1426.48s -> 1428.00s]  In fact, let's do at least a little bit
[1428.00s -> 1429.40s]  of error checking in here.
[1430.58s -> 1433.82s]  In other words, if the exec cvp command fails,
[1433.82s -> 1436.34s]  which could be just because we typed the wrong command,
[1436.34s -> 1437.84s]  that would be bad, okay?
[1437.84s -> 1441.04s]  But so what we want to do is let's just print f,
[1441.88s -> 1446.88s]  I don't know, percent s, command not found,
[1447.98s -> 1451.12s]  or something like that, okay?
[1451.12s -> 1454.66s]  And then exit zero, and something like that.
[1456.46s -> 1458.12s]  Thank you, I need to tell which book it is.
[1458.12s -> 1463.12s]  Do I, by the way, let's see, argv zero.
[1463.52s -> 1467.68s]  Do I, by the way, need to have some if statement
[1467.68s -> 1469.36s]  in here to see whether or not
[1469.44s -> 1471.44s]  the command was not found.
[1471.44s -> 1472.34s]  Why not?
[1473.68s -> 1476.78s]  Because it'll never get there if exec cvp actually works,
[1476.78s -> 1478.68s]  destroys the entire program, okay.
[1478.68s -> 1480.04s]  So anyway, so that's that.
[1480.04s -> 1484.48s]  All right, now we're gonna have if is background.
[1484.48s -> 1486.28s]  Okay, what we're gonna do is we're gonna
[1486.28s -> 1490.24s]  just do the same thing as before, print f, okay,
[1490.24s -> 1495.24s]  percent d, percent s, n, okay?
[1495.32s -> 1498.88s]  Count PID, command, okay?
[1499.40s -> 1504.28s]  And we are going to do that, okay?
[1504.28s -> 1506.48s]  And this will get handled by the signal handler,
[1506.48s -> 1509.16s]  which we haven't installed yet, okay?
[1509.16s -> 1512.42s]  But what we wanna do is if it's not in the background,
[1512.42s -> 1514.28s]  okay, we wanna call this other function
[1514.28s -> 1518.62s]  called wait for background process.
[1518.62s -> 1521.56s]  And I'll show you how that works in a minute.
[1521.56s -> 1526.56s]  Process PID, and that, okay.
[1526.60s -> 1530.56s]  And then, let's see, do I need one more in here?
[1530.56s -> 1532.36s]  Nope, okay.
[1532.36s -> 1533.52s]  And so that's that.
[1533.52s -> 1534.98s]  Let's install a signal handler.
[1534.98s -> 1536.84s]  We're going to have a signal handler.
[1536.84s -> 1539.08s]  Oh, I got it, I guess I didn't put it up here already.
[1539.08s -> 1542.60s]  We're gonna have a signal handler for reprocesses, okay?
[1542.60s -> 1547.60s]  The reprocesses signal is going to do the following,
[1549.88s -> 1554.58s]  okay, while true, same thing as we've done
[1554.62s -> 1558.10s]  a number of times for these signals, okay?
[1558.10s -> 1563.10s]  While true, PID t PID equals wait PID negative one,
[1563.90s -> 1565.86s]  because we don't know which one we're waiting for.
[1565.86s -> 1570.58s]  W no hang, because we don't want it to actually wait
[1570.58s -> 1572.22s]  for the return, because we don't like it
[1572.22s -> 1574.26s]  when it waits long in a signal handler anyway,
[1574.26s -> 1575.78s]  and we don't have to do this anyway.
[1575.78s -> 1579.76s]  If PID is less than or equal to zero, break,
[1579.76s -> 1582.30s]  that means we either have it still running,
[1582.30s -> 1584.22s]  or something's, a process is still running,
[1584.82s -> 1587.90s]  or we don't have any left, okay?
[1587.90s -> 1592.90s]  And if PID equals, well, we are going to add
[1593.02s -> 1597.54s]  a new variable, okay, to see which,
[1597.54s -> 1599.42s]  if we have our child process, okay?
[1599.42s -> 1602.48s]  I'm gonna call it FGID, okay?
[1602.48s -> 1605.54s]  And I'm just gonna actually reset it to zero,
[1605.54s -> 1609.70s]  which is clearing it, foreground process, okay?
[1609.70s -> 1612.26s]  This, because we have,
[1614.90s -> 1619.32s]  because we have the F P I G,
[1619.32s -> 1623.92s]  we have to actually make it a global variable, okay?
[1623.92s -> 1628.92s]  So we have to do something like static PID t F G PID,
[1630.10s -> 1632.38s]  oops, sorry, F G, am I doing it,
[1632.38s -> 1636.18s]  yeah, I guess we do F G PID, foreground PID, rather.
[1636.18s -> 1639.66s]  Okay, foreground PID, all right?
[1639.66s -> 1643.66s]  And we actually will set it equal to zero,
[1643.66s -> 1646.02s]  and it's gotta be global, because we need a way
[1646.02s -> 1649.38s]  to communicate between our signal handler and our other one.
[1649.38s -> 1650.22s]  Yes?
[1653.58s -> 1654.78s]  Hang on.
[1654.78s -> 1659.78s]  Oh, over, thank you, right there.
[1660.02s -> 1661.26s]  We'll get there, there we go, okay.
[1661.26s -> 1663.58s]  So anyway, did I not do it right?
[1665.58s -> 1669.78s]  Oh, F P G I D, how's that?
[1669.82s -> 1674.58s]  Four, oh my gosh, I'm losing it today.
[1676.38s -> 1678.26s]  Anybody have those kind of days?
[1678.26s -> 1681.78s]  F foreground process ID, that's what it is.
[1683.06s -> 1686.78s]  All right, oh man, okay, thank you for keeping me honest.
[1686.78s -> 1688.60s]  Okay, so anyway, now what have we done?
[1688.60s -> 1692.78s]  We've said, okay, we've got this foreground process ID
[1692.78s -> 1696.10s]  that we have to set in another function
[1696.10s -> 1698.64s]  that we are about to create, okay?
[1698.64s -> 1701.92s]  Let's create a function, static void,
[1701.92s -> 1706.92s]  wait for foreground process, PIDT PID, okay?
[1709.28s -> 1712.32s]  In here, what we wanna do is, let's see if I get this
[1712.32s -> 1716.76s]  right, F G PID equals the PID that we have, okay?
[1716.76s -> 1721.76s]  And then while F G PID equals PID,
[1721.82s -> 1723.20s]  we're gonna do this weird thing
[1723.20s -> 1727.20s]  where we're just gonna sit here and kind of wait, okay?
[1727.20s -> 1729.96s]  By waiting, we are doing this thing called spinning,
[1729.96s -> 1732.52s]  as it turns out, okay?
[1732.52s -> 1734.88s]  So let's actually test this,
[1734.88s -> 1738.36s]  but this basically, here's what happens, okay?
[1738.36s -> 1741.52s]  We're going to, if we're a background process,
[1741.52s -> 1743.88s]  we're just going to let the signal handler
[1743.88s -> 1746.48s]  take care of it, okay, when it ends.
[1746.48s -> 1747.90s]  If we're the foreground process,
[1747.90s -> 1751.12s]  we are also going to basically let the,
[1751.12s -> 1754.04s]  the back of the process handle, yeah?
[1754.08s -> 1758.12s]  For those, when we pass through these processes,
[1758.12s -> 1760.16s]  why don't we use a lambda function
[1760.16s -> 1761.56s]  so we can capture the variable,
[1761.56s -> 1765.20s]  like is there still a reason why we can't do that?
[1765.20s -> 1766.56s]  Good question, the question was,
[1766.56s -> 1768.44s]  why can't we use,
[1768.44s -> 1770.42s]  why aren't we using a lambda function for this?
[1770.42s -> 1773.76s]  We are in C land, there are no lambda functions,
[1773.76s -> 1774.72s]  actually, yeah.
[1774.72s -> 1778.96s]  So if we're in C++, could you use this to do that?
[1778.96s -> 1781.52s]  I don't believe you even could do that.
[1781.52s -> 1783.16s]  You might be able to, I'm not sure,
[1783.20s -> 1785.58s]  but we're using that now, especially because we're in C.
[1785.58s -> 1788.06s]  Yeah, good question, okay.
[1788.06s -> 1793.06s]  All right, so I think that is about it.
[1794.48s -> 1799.24s]  Let's see, at this point, right.
[1799.24s -> 1801.56s]  So let's try it and see what happens.
[1801.56s -> 1805.64s]  And make simple shell with redundancy.
[1807.00s -> 1811.04s]  Okay, all right, simple shell with redundancy.
[1811.08s -> 1812.64s]  Okay, so we can do ls,
[1812.64s -> 1814.36s]  and it gives us back our prompt after that.
[1814.36s -> 1816.96s]  We could do ls, let's just make this do up here,
[1816.96s -> 1819.00s]  ls ampersand, okay,
[1819.00s -> 1824.00s]  and it should have put our little command down here,
[1824.68s -> 1826.36s]  all the way at the top, there's lots of stuff here.
[1826.36s -> 1830.28s]  There it is, it printed out the PID that just relaunched
[1830.28s -> 1833.22s]  and then it immediately printed a prompt back for us
[1833.22s -> 1834.06s]  to do that.
[1834.06s -> 1836.44s]  Let's do one that's a little more reasonable.
[1836.44s -> 1839.02s]  Let's do, if we just do sleep 10,
[1839.02s -> 1842.30s]  it will sleep for 10 seconds in the foreground, okay.
[1842.30s -> 1845.30s]  And then when the child ends,
[1850.30s -> 1853.34s]  in this case, we actually get the signal handed out.
[1853.34s -> 1857.82s]  But we can do sleep 10 in the background,
[1857.82s -> 1859.30s]  and then now it's sleeping.
[1859.30s -> 1860.94s]  And if we type ps, actually, we can see,
[1860.94s -> 1863.10s]  there's our sleep right there,
[1863.10s -> 1865.02s]  our sleep command right there.
[1865.02s -> 1867.72s]  In the background, we don't have too many issues.
[1867.72s -> 1870.28s]  In the foreground, well, if we do this,
[1870.28s -> 1871.76s]  let's do sleep 100, let's say.
[1871.76s -> 1873.44s]  So it's just gonna sleep 100.
[1873.44s -> 1875.20s]  What is our program doing?
[1875.20s -> 1876.84s]  Let's go back and look at our program here,
[1876.84s -> 1878.42s]  because it's still sleeping, by the way.
[1878.42s -> 1883.42s]  Okay, our program has now gone into, let's see.
[1885.52s -> 1886.36s]  Oops, hang on.
[1887.48s -> 1889.12s]  Is this one in here?
[1889.12s -> 1890.20s]  Let's see.
[1890.20s -> 1891.56s]  Oh no, you know what, I might have jumped,
[1891.56s -> 1892.96s]  I might have jumped ahead a little bit.
[1892.96s -> 1894.04s]  Yeah, I went to the wrong one.
[1894.04s -> 1895.76s]  This is with the race condition.
[1896.76s -> 1898.52s]  Let me go ahead and show you that one here.
[1898.52s -> 1901.16s]  In this case, what's happening is we're doing
[1901.16s -> 1906.16s]  this sleep here, or not sleep, this spinning here,
[1906.64s -> 1911.64s]  which is happening because we are in the foreground
[1912.72s -> 1916.76s]  process, the shell would be the foreground process,
[1916.76s -> 1918.68s]  and the sleep is the foreground process,
[1918.68s -> 1920.56s]  so it's gotta wait for that.
[1920.56s -> 1923.12s]  Now, I think we're still sleeping here.
[1923.12s -> 1924.68s]  Yeah, we're still sleeping for 100.
[1924.72s -> 1928.16s]  If I open up another terminal here,
[1928.16s -> 1932.80s]  and go to the same myth, myth 55,
[1937.52s -> 1940.96s]  and then type this command called htop.
[1940.96s -> 1943.64s]  Notice something up there, there's one process,
[1943.64s -> 1945.70s]  this htop program, I think I've shown you this before,
[1945.70s -> 1947.72s]  shows all, maybe I haven't, shows all the different
[1947.72s -> 1950.36s]  processors on the computer we're running on,
[1950.40s -> 1955.40s]  and it shows how much each core is being used.
[1955.64s -> 1958.46s]  One of them is 100%, the others are like almost nothing.
[1958.46s -> 1959.68s]  One of them's 100%.
[1959.68s -> 1961.88s]  Guess whose program it is?
[1961.88s -> 1966.44s]  Oh, it's simple shell with redundancy at 100% CPU,
[1966.44s -> 1969.48s]  which is my program, okay?
[1969.48s -> 1972.76s]  Well, why is that the case?
[1972.76s -> 1975.10s]  Well, it's because it's spinning, and it's actually
[1975.10s -> 1977.72s]  sitting in this while loop going, and it finally ended,
[1977.72s -> 1979.82s]  by the way, and then now it's back to zero,
[1980.14s -> 1982.66s]  when the sleep 100 ended, okay?
[1982.66s -> 1984.50s]  Well, why is that bad?
[1984.50s -> 1986.98s]  Well, it's bad because, unfortunately,
[1986.98s -> 1988.74s]  there's some poor, like, 107 students
[1988.74s -> 1991.82s]  sitting over on a myth machine going,
[1991.82s -> 1995.02s]  why is my terminal stalled right now, right?
[1995.02s -> 1998.42s]  Because you're running your 100% CPU thing.
[1998.42s -> 2000.66s]  Now, there's eight cores, and they're not really,
[2000.66s -> 2002.34s]  because there's lots of other cores doing other things,
[2002.34s -> 2004.74s]  but the machine might be heating up a little bit more,
[2004.74s -> 2007.54s]  and it's using that core that it shouldn't be, right?
[2007.54s -> 2012.18s]  We shouldn't be able to actually do that, okay?
[2012.18s -> 2014.62s]  And the question is, why?
[2014.62s -> 2016.54s]  Like, how do we get around that?
[2016.54s -> 2019.06s]  We will get to that, okay?
[2019.06s -> 2021.62s]  Oh, by the way, you can run,
[2021.62s -> 2023.66s]  I'll have to install HTOP, you can't run it,
[2023.66s -> 2025.62s]  I installed it locally for my own machine,
[2025.62s -> 2027.94s]  I'll install it and send you guys an email
[2027.94s -> 2030.42s]  about how to run that, okay?
[2030.42s -> 2033.58s]  The original one here that I skipped, okay,
[2033.62s -> 2034.46s]  it looks like this.
[2034.46s -> 2039.46s]  This is if we wanted to reap all the processes, okay?
[2041.22s -> 2045.54s]  With this extra weight PID in here, okay?
[2045.54s -> 2049.26s]  So this is kind of what we had before, all right?
[2049.26s -> 2052.38s]  We had this before where instead of,
[2052.38s -> 2055.46s]  or now we're actually capturing the child process, okay?
[2055.46s -> 2059.10s]  The child process gets reaped up here, okay?
[2059.10s -> 2063.46s]  And like it always, or like it would
[2063.46s -> 2065.58s]  because we're using the signal handler.
[2065.58s -> 2070.30s]  But down here, we have this strange-like situation
[2070.30s -> 2074.70s]  where we're calling weight PID without WNOHANG,
[2074.70s -> 2077.38s]  which means this is gonna sit here and wait
[2077.38s -> 2078.90s]  for the child to end,
[2078.90s -> 2081.34s]  but we're handling it up in the reprocesses.
[2081.34s -> 2082.98s]  In fact, that happens first.
[2082.98s -> 2086.22s]  The signal handler will get called immediately,
[2086.22s -> 2090.70s]  handle the signal, it will return the correct PID
[2090.70s -> 2095.06s]  for the child process, and then the parent,
[2095.06s -> 2097.02s]  which is down here in weight PID,
[2097.02s -> 2100.82s]  actually the weight PID call down here finishes
[2100.82s -> 2104.46s]  with an error that says there are no more children left.
[2104.46s -> 2106.94s]  So isn't that a little strange?
[2106.94s -> 2108.38s]  Let me rephrase it again.
[2108.38s -> 2112.94s]  Down here, we have said if the child is the foreground,
[2112.94s -> 2114.50s]  we wanna wait for it to end.
[2115.38s -> 2118.62s]  But instead of letting,
[2118.62s -> 2121.82s]  well, we're letting the signal handler
[2121.82s -> 2125.02s]  clean up the weight PID, clean up the child,
[2125.02s -> 2128.26s]  and then this one is getting kind of redundant
[2128.26s -> 2131.34s]  because it actually gets called after the child handler
[2131.34s -> 2133.38s]  cleans it up, and then this one happens,
[2133.38s -> 2137.66s]  and you go, oh, that seems a little logically odd
[2137.66s -> 2141.10s]  to like know that this one's gonna fail, okay?
[2141.10s -> 2144.58s]  Now, it works, but we'd like to do it a little bit better,
[2144.58s -> 2147.38s]  which is why we kind of handled the previous,
[2147.38s -> 2150.90s]  or we kind of did it the other way, okay?
[2150.90s -> 2152.62s]  What questions do you have on this one for a sec?
[2152.62s -> 2153.46s]  Yeah.
[2153.46s -> 2155.70s]  So spinning is bad?
[2155.70s -> 2157.26s]  Spinning is bad, I'll show you what the,
[2157.26s -> 2159.70s]  yeah, I jumped ahead and we did the spinning one first,
[2159.70s -> 2163.78s]  but the spinning is not good because it really,
[2163.78s -> 2165.86s]  I'll show you what the spinning one does.
[2165.86s -> 2168.98s]  Right here, what's happening here?
[2169.02s -> 2173.34s]  It's basically checking this global variable FGPID, okay?
[2173.34s -> 2176.94s]  And if the entire time the child process is running,
[2176.94s -> 2179.78s]  they are not the same because we set it equal to the,
[2179.78s -> 2181.46s]  we set FGPID equal to zero,
[2181.46s -> 2186.46s]  and then the PID is the PID for the process, okay?
[2186.50s -> 2188.06s]  And it just does this while loop
[2188.06s -> 2189.98s]  again and again and again and again and again,
[2189.98s -> 2193.06s]  and that's wasting processing time
[2193.06s -> 2194.78s]  because it's thinking it's trying to do something,
[2194.78s -> 2199.78s]  and the only, by the way,
[2200.02s -> 2203.38s]  the only reason the compiler actually allows this to happen
[2203.38s -> 2205.90s]  is because we have a global variable in there, right?
[2205.90s -> 2207.42s]  Otherwise, the compiler would go,
[2207.42s -> 2209.50s]  wait, this function's not changing it,
[2209.50s -> 2211.38s]  how can it ever not be one thing?
[2211.38s -> 2212.38s]  And it will just do it once.
[2212.38s -> 2213.94s]  It'll turn that while in an if statement
[2213.94s -> 2215.78s]  and then not even run the way we want.
[2215.78s -> 2219.58s]  If you took 107E, you'd know all about that.
[2219.58s -> 2221.26s]  And we can deal with this,
[2221.26s -> 2222.54s]  it actually, the compiler says,
[2222.54s -> 2225.46s]  oh, global variables, I don't optimize for those.
[2225.46s -> 2227.70s]  Does that answer your question about what spinning is?
[2227.70s -> 2230.02s]  It's this tight little loop that's doing stuff
[2230.02s -> 2231.70s]  that doesn't do any good for us.
[2231.70s -> 2235.54s]  We'd rather the process be off the processor altogether
[2235.54s -> 2237.50s]  and have the kernel wait,
[2237.50s -> 2242.50s]  like make it actually do what it should be doing, okay?
[2242.82s -> 2244.06s]  So that's that.
[2244.06s -> 2247.82s]  To this other, to the previous one that I skipped here,
[2249.06s -> 2251.46s]  with this one where we have this little wait PID,
[2251.46s -> 2255.82s]  we definitely want to not have that wait PID happen once.
[2255.82s -> 2257.78s]  We want it to happen, or twice,
[2257.78s -> 2259.38s]  we want it to happen just once
[2259.38s -> 2261.78s]  and let the signal handler take care of all of it.
[2261.78s -> 2262.62s]  Question?
[2262.62s -> 2265.18s]  Do you have to put volatile before the global variable?
[2265.18s -> 2267.42s]  You do not have to put volatile before the global variable.
[2267.42s -> 2268.54s]  Good question.
[2268.54s -> 2270.54s]  And if you've never heard about volatile,
[2270.54s -> 2272.66s]  it basically just means that,
[2272.66s -> 2275.26s]  oh, this variable is special, don't optimize it out
[2275.26s -> 2276.58s]  because you don't know what's going on with it.
[2276.58s -> 2278.46s]  But no, you don't need to for global variable,
[2278.46s -> 2280.66s]  at least for this compiler we're using.
[2281.50s -> 2284.90s]  Okay, so other questions on this one.
[2284.90s -> 2288.14s]  You get why we don't like to have wait PID in two places?
[2288.14s -> 2292.02s]  By the way, last quarter we asked a midterm exam question
[2292.02s -> 2294.50s]  where the students could, if they wanted to,
[2294.50s -> 2297.50s]  put the wait PID in two places and we took points off.
[2297.50s -> 2298.34s]  So be careful.
[2298.34s -> 2300.42s]  You can do it like we just showed you before
[2300.42s -> 2303.02s]  where there's one wait PID.
[2303.02s -> 2305.58s]  I'll show you how to get rid of that race condition
[2305.58s -> 2307.42s]  in a second, okay?
[2307.42s -> 2309.42s]  But here's the race condition one.
[2309.46s -> 2311.02s]  What's nice about this?
[2311.02s -> 2315.82s]  Well, okay, we're not actually doing any more wait PID.
[2315.82s -> 2317.94s]  In fact, wait for foreground process,
[2317.94s -> 2319.68s]  the wait for foreground process function
[2319.68s -> 2324.26s]  does not have any wait PID in it.
[2324.26s -> 2327.06s]  It's got this strange spinning loop
[2327.06s -> 2328.90s]  which we want to try to avoid.
[2328.90s -> 2332.32s]  But all of the children do get handled up here.
[2332.32s -> 2335.22s]  Now, more critically,
[2335.22s -> 2339.16s]  we actually have a bigger bug than the spin.
[2339.16s -> 2340.66s]  The spin isn't going to do anything
[2340.66s -> 2342.40s]  except make your computer warm up a little more,
[2342.40s -> 2343.52s]  make the fans come on,
[2343.52s -> 2347.16s]  and make your computer have less of a long lifespan
[2347.16s -> 2348.86s]  because it's doing more work, right?
[2348.86s -> 2350.24s]  That's not the biggest deal in the world.
[2350.24s -> 2351.08s]  The biggest deal in the world
[2351.08s -> 2354.76s]  is there's an actual race condition in here, okay?
[2354.76s -> 2358.58s]  Anybody see where the race condition might be?
[2358.58s -> 2360.68s]  Race conditions happen when you're doing something
[2360.68s -> 2363.00s]  where you're forking and various things can happen
[2363.00s -> 2364.68s]  before other things.
[2364.68s -> 2365.78s]  What do you think?
[2365.78s -> 2367.28s]  Anybody see a race condition here?
[2367.28s -> 2368.12s]  Yeah.
[2369.16s -> 2374.16s]  And you're checking it in wait for foreground process.
[2381.52s -> 2382.92s]  Why is that a race condition?
[2387.48s -> 2388.44s]  What could happen first?
[2388.44s -> 2389.52s]  Like, what could happen here?
[2389.52s -> 2391.00s]  Let's think about the two different possibilities.
[2391.00s -> 2391.92s]  Yeah, you have an idea?
[2391.92s -> 2392.74s]  Go ahead.
[2399.16s -> 2404.16s]  Yeah, the y-loop is not going to ever end, right?
[2407.44s -> 2409.96s]  If you have a slightly off,
[2409.96s -> 2413.48s]  slightly interesting situation here.
[2413.48s -> 2415.48s]  Okay, so let's walk through this.
[2415.48s -> 2420.00s]  If we fork, okay, and then we exec CVP,
[2420.00s -> 2421.66s]  what if that was really fast?
[2421.66s -> 2423.68s]  We did something that was super duper fast
[2423.68s -> 2426.40s]  and the child ended, okay?
[2426.40s -> 2429.16s]  Well, we would get up here into reap process.
[2429.16s -> 2431.72s]  Let's pretend that before we ever even get
[2431.72s -> 2434.66s]  to wait for foreground process, okay?
[2435.68s -> 2440.68s]  We actually go and immediately the child ends
[2441.28s -> 2446.28s]  and we go up here and we reap the process, okay?
[2446.34s -> 2447.18s]  So what happens?
[2447.18s -> 2450.16s]  Well, it goes and it says, all right,
[2450.16s -> 2453.68s]  well, let's see, in this case, actually,
[2453.68s -> 2455.42s]  depending on what the previous PID would be,
[2455.46s -> 2456.86s]  it wouldn't actually matter.
[2456.86s -> 2458.42s]  So I guess it doesn't matter if it does immediately,
[2458.42s -> 2460.38s]  but what happens if it does it here?
[2460.38s -> 2461.30s]  And this is what you were saying.
[2461.30s -> 2465.18s]  It does it right after this line right here.
[2465.18s -> 2470.18s]  So this line right here, okay, sets F, P, I, or F,
[2470.54s -> 2472.02s]  let's see, is it going to be before that or after?
[2472.02s -> 2473.66s]  I'm getting this mixed up now.
[2473.66s -> 2476.34s]  It is, this is why race conditions are hard.
[2476.34s -> 2478.90s]  It's always tough to remember exactly where it is.
[2480.06s -> 2485.06s]  If FGPID is set to,
[2486.10s -> 2490.94s]  PID, and then FGPID equals here, right.
[2490.94s -> 2494.82s]  If the signal handler was called before that
[2494.82s -> 2499.50s]  and gets down here and sets the FPGID to zero,
[2499.50s -> 2503.56s]  at this point, we would then set FGPID to PID
[2503.56s -> 2505.04s]  and then this while loop would never end
[2505.04s -> 2507.92s]  because we would never get this set to zero again.
[2507.92s -> 2509.86s]  That's the issue, okay?
[2509.86s -> 2512.10s]  So basically we're saying
[2512.74s -> 2517.26s]  that there's the race condition,
[2517.26s -> 2518.58s]  let me see, let me read it off here.
[2518.58s -> 2521.06s]  It's probably easier to, here.
[2521.06s -> 2523.18s]  If the foreground process finishes
[2523.18s -> 2524.62s]  and reprocess is invoked
[2524.62s -> 2528.10s]  before normal execution flow updates FGPID,
[2529.46s -> 2531.50s]  if that happens, the signal is going to spin forever.
[2531.50s -> 2535.86s]  So again, we could end up here
[2536.82s -> 2540.48s]  because the child process has already been reaped
[2540.48s -> 2543.16s]  basically between this line and,
[2543.16s -> 2546.60s]  or right before this line, okay?
[2546.60s -> 2548.00s]  Right before this line.
[2548.00s -> 2549.16s]  The child process gets reaped,
[2549.16s -> 2552.24s]  it changes the PID to zero,
[2552.24s -> 2555.48s]  and then we update it here, go into this while loop,
[2555.48s -> 2559.44s]  no more child to actually reep, okay?
[2559.44s -> 2562.44s]  So that's the issue right there.
[2564.68s -> 2567.28s]  That would be a bad race condition to have.
[2567.28s -> 2570.36s]  So how do we deal with this race condition?
[2571.28s -> 2573.62s]  What we want to do is we wanna actually remove
[2573.62s -> 2578.62s]  that race condition using a different type of,
[2579.00s -> 2581.40s]  actually, before we even do that,
[2581.40s -> 2586.40s]  let's actually, yeah, we want to,
[2588.00s -> 2590.20s]  yes, we'll do this one right now.
[2590.20s -> 2593.08s]  This is where we're gonna block the child appropriately
[2593.08s -> 2596.08s]  like we did before so that we don't actually
[2596.08s -> 2601.08s]  need to, so we don't actually have
[2604.52s -> 2605.68s]  that race condition at all,
[2605.68s -> 2608.20s]  just like what we did kind of before, okay?
[2608.20s -> 2611.76s]  So let's see, we can do it the same one in here again.
[2611.76s -> 2614.28s]  Oh, actually, let's do it in a different one here.
[2614.28s -> 2617.40s]  Let's do it in a simple shell
[2617.40s -> 2620.16s]  with just, we'll leave the spin for now
[2620.16s -> 2624.20s]  because that's not actually the most important one, okay?
[2624.20s -> 2625.72s]  We'll leave the spin in there now
[2626.24s -> 2630.80s]  and we will reprocess these, it's not going to change, okay?
[2630.80s -> 2632.68s]  What we need to do down here
[2632.68s -> 2635.08s]  is we need to block the signals like we said before.
[2635.08s -> 2637.08s]  In fact, we're gonna have,
[2637.08s -> 2639.68s]  instead of doing the blocking like one line at a time
[2639.68s -> 2641.04s]  where it would set up the empty set
[2641.04s -> 2646.04s]  and then set it to be, or actually declare the signal set
[2646.80s -> 2648.36s]  and then set up the empty set and so forth,
[2648.36s -> 2650.00s]  let's have little functions that do that.
[2650.00s -> 2652.16s]  I'll show you those functions in a minute, okay?
[2652.16s -> 2654.96s]  So we're going to do this where?
[2654.96s -> 2658.00s]  We are going to block the signals, okay?
[2658.00s -> 2663.00s]  Right after we get, or right before we do the fork, okay?
[2663.88s -> 2668.88s]  Let's block the child signal, okay?
[2669.16s -> 2671.16s]  All right, there's a function that's gonna do this,
[2671.16s -> 2672.36s]  I'll show you that in a second.
[2672.36s -> 2673.72s]  Okay, we're gonna block before we fork.
[2673.72s -> 2677.94s]  So therefore, the signal handler can't get called
[2677.94s -> 2681.50s]  in the parent process while the signal is blocked, okay?
[2681.50s -> 2683.52s]  All right, then we are going to fork.
[2683.52s -> 2685.80s]  If the PID is zero, it's the child,
[2685.80s -> 2687.56s]  we don't care if that signal's blocked.
[2687.56s -> 2689.56s]  In fact, we want it to not be blocked.
[2691.08s -> 2693.64s]  So we're gonna call unblockSigChild,
[2694.60s -> 2695.52s]  which is the other function
[2695.52s -> 2698.62s]  that we're gonna show you in a second, okay?
[2698.62s -> 2703.24s]  And then we are going to also unblock it
[2703.24s -> 2706.76s]  if it is a background process
[2706.76s -> 2708.60s]  because we don't care about,
[2708.76s -> 2713.76s]  there's no need to worry about the actual blocking there,
[2716.44s -> 2717.80s]  that's not where the problem is, okay?
[2717.80s -> 2720.48s]  It was the foreground process that we had the problem,
[2720.48s -> 2724.60s]  okay, unblockSigChild here, okay?
[2726.36s -> 2728.80s]  It's a foreground process, or the background process,
[2728.80s -> 2733.80s]  so there's not gonna be that issue, okay?
[2734.20s -> 2736.32s]  And then we've got waitForForegroundProcess.
[2736.32s -> 2738.80s]  Well, let's look at waitForForegroundProcess.
[2738.80s -> 2743.80s]  It's after we do the setting here
[2744.24s -> 2748.32s]  where we want to unblock the SigChild again.
[2749.76s -> 2753.92s]  This should now, like, we're only lifting this
[2753.92s -> 2758.92s]  after fgPID is set, okay?
[2760.36s -> 2761.76s]  That's what's happening here.
[2761.76s -> 2766.76s]  We've now got the blocking happening
[2766.88s -> 2770.76s]  until the point where we don't need it anymore.
[2770.76s -> 2773.20s]  Now we can't get the, we won't have that race condition.
[2773.20s -> 2774.04s]  Yes?
[2774.04s -> 2776.60s]  Sorry, but when we, before we had the blocking
[2776.60s -> 2779.60s]  and the unblocking, and fgPID is called,
[2783.32s -> 2785.92s]  but since we had it equal to zero in the first place,
[2785.92s -> 2790.92s]  how could we ever race conditions on the same place?
[2791.76s -> 2796.76s]  Before we set it to a PID in waitForForegroundProcess?
[2798.32s -> 2801.24s]  Let's see, your question is,
[2801.24s -> 2804.16s]  how do we actually race condition on it here,
[2804.16s -> 2807.80s]  because, well, let's see.
[2809.24s -> 2812.32s]  When we are doing...
[2812.32s -> 2817.00s]  So it's zero until we call waitForForegroundProcess,
[2817.00s -> 2821.12s]  and then it's equal to the PID that we're waiting for,
[2821.28s -> 2823.48s]  and then, because it'll never be...
[2823.48s -> 2827.12s]  Right, so what happens when, what's that?
[2827.12s -> 2828.44s]  Sorry, say again.
[2828.44s -> 2832.16s]  So when we first call it, fgPID is zero,
[2832.16s -> 2833.60s]  that's what we set it to,
[2833.60s -> 2835.32s]  and then it's equal to the PID,
[2835.32s -> 2837.80s]  and then we call waitForegroundProcess.
[2837.80s -> 2842.04s]  If the child is already changed before that,
[2842.04s -> 2846.16s]  how do we have a race condition on it?
[2846.16s -> 2847.28s]  That is a good question.
[2847.28s -> 2849.24s]  The question is when do we,
[2849.24s -> 2851.92s]  or how do we actually have the race condition
[2851.92s -> 2854.68s]  in there at all?
[2854.68s -> 2856.24s]  Let me check one thing here.
[2856.24s -> 2858.40s]  I'm just making sure I didn't miss setting it.
[2858.40s -> 2860.96s]  Actually, let's go back up in here and look again.
[2860.96s -> 2862.80s]  I think that's actually a good question.
[2862.80s -> 2863.64s]  Hang on.
[2866.20s -> 2867.04s]  Okay.
[2869.08s -> 2871.16s]  We are not setting it there, are we?
[2871.16s -> 2875.36s]  Oh, and the parent, we're setting PID here.
[2875.36s -> 2877.24s]  Right, we're setting the PID here.
[2877.88s -> 2878.72s]  Okay.
[2879.84s -> 2881.36s]  And then fgPID is still there.
[2881.36s -> 2882.64s]  Let me get back to you on that.
[2882.64s -> 2884.48s]  I know this is a race condition, but you're right.
[2884.48s -> 2885.48s]  There's either one line missing,
[2885.48s -> 2887.80s]  or I'm not thinking it through quite correctly.
[2887.80s -> 2889.08s]  But good catch on that.
[2889.08s -> 2889.92s]  Yeah.
[2904.36s -> 2906.24s]  Right, good point.
[2906.28s -> 2909.64s]  Okay, so here's the answer, good answer over there.
[2909.64s -> 2914.20s]  Okay, weight PID gets, or reprocesses gets called once
[2914.20s -> 2916.88s]  when the child ends, okay?
[2916.88s -> 2920.38s]  All right, let's assume that the,
[2920.38s -> 2924.74s]  let's assume that fgPID is still zero, right?
[2924.74s -> 2926.56s]  Well, it's not going to reset it.
[2926.56s -> 2929.28s]  It doesn't actually, it's already, fgPID is already zero.
[2929.28s -> 2930.72s]  So this is gonna end.
[2930.72s -> 2935.40s]  Okay, if that ends, and then we set it here,
[2935.40s -> 2936.92s]  and then we do this while loop,
[2936.92s -> 2939.02s]  well, it's already ended, and then that's where it is.
[2939.02s -> 2939.86s]  Yeah, that's a good point.
[2939.86s -> 2941.56s]  Thank you for that clarification.
[2943.24s -> 2947.20s]  Yeah, the race condition is in the case
[2947.20s -> 2950.56s]  where we're waiting for the foreground process,
[2950.56s -> 2954.88s]  and it's already happened that the child is finished.
[2954.88s -> 2956.64s]  It was so fast that the child finished.
[2956.64s -> 2957.60s]  And then all of a sudden we're waiting,
[2957.60s -> 2958.44s]  we're not doing anything.
[2958.44s -> 2960.04s]  Yeah, good question, good call, good call.
[2960.04s -> 2963.56s]  Now, why does this fix the situation, okay?
[2963.60s -> 2964.80s]  This fixes the situation,
[2964.80s -> 2966.28s]  this is the one that I just typed up here.
[2966.28s -> 2967.76s]  This fixes the situation
[2967.76s -> 2971.92s]  because we're not actually allowing this,
[2971.92s -> 2975.16s]  the child handler to get caught
[2975.16s -> 2980.16s]  until after the actual fgPID sets equal to PID,
[2982.56s -> 2985.60s]  in which case it will get unset by the child handler,
[2985.60s -> 2987.68s]  and then we will go out of the while loop.
[2987.68s -> 2988.52s]  Yes, question.
[2989.72s -> 2991.16s]  Do you mind how the lock works?
[2991.20s -> 2993.44s]  So like when the child process is pretty much finished
[2993.44s -> 2995.64s]  but then it's just kind of like just holding on
[2995.64s -> 2996.68s]  and sending out the signal?
[2996.68s -> 2997.88s]  Yes, good question.
[2997.88s -> 2998.84s]  How does blocking work?
[2998.84s -> 3002.04s]  Does the child process just wait around
[3002.04s -> 3003.54s]  if it can't send the signal?
[3003.54s -> 3005.32s]  It's the kernel that's sending the signal,
[3005.32s -> 3008.66s]  and the kernel knows that the child process ends.
[3008.66s -> 3011.66s]  It wants to send the signal to your parent process,
[3011.66s -> 3012.82s]  but your parent process says,
[3012.82s -> 3014.56s]  I'm not accepting that signal now,
[3014.56s -> 3016.68s]  so the kernel will just wait until it gets unblocked
[3016.68s -> 3018.16s]  and then send the signal.
[3018.16s -> 3019.64s]  Child finishes, right?
[3019.64s -> 3022.28s]  Child finishes and it's fine.
[3022.28s -> 3024.16s]  It just hasn't gotten cleaned up yet,
[3024.16s -> 3025.60s]  but the child is done,
[3025.60s -> 3028.20s]  and then eventually the parent says,
[3028.20s -> 3030.38s]  now you can send the signal,
[3030.38s -> 3031.66s]  and then that's when the kernel says,
[3031.66s -> 3034.32s]  okay, here's your signal immediately at that point.
[3034.32s -> 3035.74s]  Yeah, good questions.
[3035.74s -> 3038.08s]  All right, stuff is tricky.
[3038.08s -> 3039.58s]  Other questions on this one?
[3041.88s -> 3043.80s]  Let's get, oh, here's those two signals,
[3043.80s -> 3047.80s]  those two functions, actually there's three functions here.
[3047.80s -> 3050.08s]  You can do toggle SIGCHILD block,
[3050.08s -> 3051.36s]  which is a little more advanced,
[3051.36s -> 3053.96s]  or you could, and this one we are calling
[3053.96s -> 3055.04s]  from block SIGCHILD,
[3055.04s -> 3056.80s]  then we're calling from unblock SIGCHILD.
[3056.80s -> 3057.96s]  Okay, what is it doing?
[3057.96s -> 3062.10s]  It's setting the signal set to some mask,
[3062.10s -> 3064.20s]  okay, or it's setting it, it's creating it,
[3064.20s -> 3065.22s]  and then it's emptying it,
[3065.22s -> 3066.88s]  so it's basically initializing it,
[3066.88s -> 3070.50s]  and then we are adding the mask itself,
[3070.50s -> 3073.72s]  we're adding SIGCHILD to the mask by doing add set,
[3073.72s -> 3077.96s]  and then we are either blocking or unblocking,
[3077.96s -> 3079.96s]  depending on how we call this function,
[3079.96s -> 3084.04s]  the signal, okay, that's how it works.
[3084.04s -> 3084.88s]  Yeah?
[3090.92s -> 3093.82s]  Why do we call block SIGCHILD before we fork?
[3093.82s -> 3096.12s]  Are you saying we could call it after we fork?
[3101.36s -> 3102.36s]  Yeah, that's a good question.
[3102.40s -> 3104.76s]  We probably could do this.
[3104.76s -> 3107.20s]  Well, no, we can't actually, as it turns out, we can't.
[3107.20s -> 3108.72s]  Here's what happens.
[3108.72s -> 3110.68s]  Remember, we're talking about a race condition here
[3110.68s -> 3112.24s]  that could happen really fast.
[3112.24s -> 3117.24s]  If we wait to block down like after the, in the parent,
[3118.16s -> 3120.40s]  yes, the parent will be the only thing that gets blocked
[3120.40s -> 3122.00s]  but it might already be too late.
[3122.00s -> 3123.20s]  The child might have already ended
[3123.20s -> 3124.44s]  and called the signal and the signal,
[3124.44s -> 3126.68s]  or sent the signal and the signal handler happened.
[3126.68s -> 3128.44s]  Yeah, so we have to block before we even fork
[3128.44s -> 3130.48s]  because we don't want the child to end
[3130.48s -> 3133.64s]  before we can allow the parent to be ready for it.
[3133.64s -> 3134.94s]  Good question.
[3134.94s -> 3136.60s]  Yeah, very good question on that.
[3137.60s -> 3139.92s]  Okay, any others on this one?
[3139.92s -> 3143.92s]  Okay, let's take care of that race
[3143.92s -> 3147.92s]  or that spinning issue that we had, okay?
[3147.92s -> 3150.30s]  So the race condition's gone.
[3151.20s -> 3154.76s]  We want to do the unblocking in the child
[3154.76s -> 3156.16s]  because we don't like having that signal
[3156.16s -> 3158.48s]  blocking the child but we already set it
[3159.12s -> 3162.96s]  before we fork so it is set, so let's unblock it.
[3162.96s -> 3167.96s]  And then we still need to deal with this spinning, okay?
[3171.36s -> 3173.80s]  All right, we could do something like this.
[3173.80s -> 3178.80s]  We could say, while FGPID equals PAD sleep
[3179.16s -> 3181.20s]  or microsleep as this one's called,
[3181.20s -> 3185.56s]  for 100,000 microseconds, okay?
[3185.56s -> 3189.56s]  And then that would actually work okay, all right?
[3191.08s -> 3193.96s]  I believe microsleep actually does not wake up
[3193.96s -> 3196.56s]  when a signal happens, so it would kind of not
[3196.56s -> 3199.40s]  be the best thing anyway, but we would just wait
[3199.40s -> 3201.96s]  and then the child would end and then eventually
[3201.96s -> 3203.40s]  sleep would wake up and we'd go,
[3203.40s -> 3205.64s]  ah, we changed anything and then we'd do that.
[3205.64s -> 3208.00s]  The sleep at least takes it off the processor.
[3208.00s -> 3211.32s]  So that would work, it's just not particularly elegant.
[3211.32s -> 3213.24s]  It would work though, okay?
[3213.44s -> 3217.56s]  Um, but we really wanna keep the OS like,
[3217.56s -> 3222.12s]  the OS can figure out when our child process ends
[3222.12s -> 3224.44s]  so we might as well utilize that, okay?
[3225.40s -> 3226.24s]  What else could we do?
[3226.24s -> 3229.08s]  There is a pause function, okay?
[3229.08s -> 3234.08s]  Which actually would also have, might work, okay?
[3235.04s -> 3237.28s]  The pause function forces the process to sleep
[3237.28s -> 3240.92s]  until some unblocked signal arrives.
[3240.92s -> 3242.16s]  Okay, well that's nice.
[3242.20s -> 3244.32s]  It just says, oh okay, so now we're going to
[3244.32s -> 3246.48s]  just wait until it unblocks signal arrives.
[3246.48s -> 3251.48s]  The problem here though is that we have a situation,
[3252.64s -> 3254.84s]  another situation where we have a race condition
[3254.84s -> 3257.32s]  and we could end up in this thing called deadlock
[3257.32s -> 3259.68s]  and that's the situation that we would have had
[3259.68s -> 3262.96s]  in the previous race condition too, where,
[3262.96s -> 3264.60s]  well it's a little bit different.
[3264.60s -> 3266.64s]  It's basically one process is waiting on the other
[3266.64s -> 3268.44s]  which is waiting on the other process
[3268.44s -> 3270.00s]  and now we've got two processes kind of waiting
[3270.00s -> 3272.20s]  on each other, that's considered deadlock,
[3272.20s -> 3273.72s]  where you have to have some logic
[3273.72s -> 3276.54s]  that actually figures that out, okay?
[3276.54s -> 3281.32s]  So you could try doing this with a pause
[3281.32s -> 3283.04s]  but that might put it into a situation
[3283.04s -> 3288.04s]  where you won't actually, if we had the following,
[3289.56s -> 3294.56s]  if, again, if the signal arrives after the FGPID
[3295.04s -> 3298.60s]  equals PID but before the call to pause,
[3298.60s -> 3300.00s]  well then what's happening?
[3300.00s -> 3301.68s]  Pause says, okay, I'm waiting for the signal
[3301.68s -> 3303.16s]  while the signal handler's saying,
[3303.16s -> 3305.20s]  oh I haven't, or I've already been hit
[3305.20s -> 3308.40s]  so it's not gonna actually end up working.
[3308.40s -> 3313.40s]  And you could try doing some like unblock and then block
[3313.94s -> 3315.40s]  but you've still got the problem
[3315.40s -> 3319.32s]  because between unblock SIGGILD and pause,
[3319.32s -> 3322.92s]  isn't there some time for something else to happen?
[3322.92s -> 3327.92s]  Yeah, so we want a way to make something work
[3328.36s -> 3330.78s]  so that we say, basically, look,
[3330.78s -> 3333.54s]  we know you're gonna be put off the CPU.
[3336.84s -> 3338.44s]  We know this process is gonna wait.
[3338.44s -> 3341.00s]  We know we have to unblock some signals.
[3341.00s -> 3343.00s]  Let's make it so that that happens
[3343.00s -> 3344.88s]  after we are guaranteed
[3344.88s -> 3347.32s]  that the process is already off the CPU.
[3348.18s -> 3349.52s]  Okay, how do we do that?
[3349.52s -> 3354.52s]  Well, we have this other system call called SIGSUSPEND.
[3354.52s -> 3359.52s]  SIGSUSPEND, okay, and SIGSUSPEND does the following.
[3360.12s -> 3365.12s]  SIGSUSPEND says, oh, okay, we are going to unblock signals
[3368.88s -> 3371.20s]  or I guess we're going to basically set
[3371.20s -> 3374.28s]  this other blocked set which we can make the empty set
[3375.52s -> 3379.56s]  after we remove the process from the CPU
[3379.56s -> 3382.76s]  so that it can't have this weird deadlock condition.
[3383.76s -> 3385.44s]  Okay, so that's what's happening here.
[3385.44s -> 3387.12s]  What we do is we say this.
[3387.12s -> 3389.44s]  We set up another signal set and we make it empty
[3389.44s -> 3390.92s]  and we actually just set it to empty
[3390.92s -> 3392.56s]  but don't change anything.
[3392.56s -> 3393.72s]  Here's what happens.
[3393.72s -> 3396.82s]  Okay, we say while FGPID equals PID,
[3396.82s -> 3399.44s]  we are going to say SIGSUSPEND on the empty set.
[3399.44s -> 3401.64s]  Now, remember, at this point,
[3401.64s -> 3404.72s]  didn't we already block the signal for SIGGILD?
[3404.72s -> 3405.96s]  It's already been blocked before.
[3405.96s -> 3407.80s]  We did it before we even forked.
[3407.80s -> 3410.34s]  Okay, so the SIGGILD is blocked.
[3410.86s -> 3415.22s]  When you say SIGSUSPEND, it says, oh, okay,
[3415.22s -> 3417.66s]  I'm going to unblock all the signals
[3417.66s -> 3421.14s]  after I push the process off the processor
[3421.14s -> 3424.58s]  and therefore, it's going to wait
[3424.58s -> 3426.84s]  until that child actually happens
[3426.84s -> 3428.38s]  and then when the child happens,
[3428.38s -> 3431.46s]  the SIGSUSPEND wakes up after the process,
[3431.46s -> 3433.30s]  the child handler happens.
[3433.30s -> 3434.14s]  Question.
[3434.14s -> 3436.54s]  So SIGSUSPEND unblocks all signals
[3436.54s -> 3438.58s]  not in the set that you did?
[3439.58s -> 3440.42s]  The good question.
[3440.42s -> 3443.42s]  It blocks, it says, set the signal set
[3443.42s -> 3445.78s]  that's blocked to this set, right?
[3445.78s -> 3448.18s]  So when you say set it to the empty set,
[3448.18s -> 3450.06s]  it means no signals are blocked.
[3450.06s -> 3452.22s]  Now, you might have a situation
[3452.22s -> 3454.26s]  where you need some signals to remain blocked
[3454.26s -> 3456.46s]  and you can do that,
[3456.46s -> 3459.14s]  but in this case, we're basically saying,
[3459.14s -> 3463.90s]  okay, fine, the SIGGILD is blocked
[3463.90s -> 3464.90s]  before this while loop.
[3464.90s -> 3465.74s]  You get into the while loop,
[3465.74s -> 3467.40s]  SIGGILD is still blocked.
[3467.40s -> 3470.24s]  You call the SIGSUSPEND system call
[3470.24s -> 3471.88s]  and it goes, oh, okay,
[3471.88s -> 3476.12s]  I am now taking the processor off
[3476.12s -> 3477.88s]  and waiting until that SIGGILD happens.
[3477.88s -> 3479.70s]  Now I'm unblocking.
[3479.70s -> 3481.98s]  And so if the SIGGILD happens,
[3481.98s -> 3485.06s]  it will be able to run in the child handler
[3485.06s -> 3487.04s]  and then after it finishes,
[3487.04s -> 3489.56s]  it will come and stop this SIGSUSPEND,
[3489.56s -> 3490.76s]  go back in the while loop
[3490.76s -> 3494.24s]  and then we will have already changed FGP80
[3494.24s -> 3497.48s]  or we will have changed FGP80 back to zero
[3497.48s -> 3500.86s]  and we're done, okay?
[3500.86s -> 3502.04s]  No, I'm seeing some people going,
[3502.04s -> 3503.64s]  no, what's going on?
[3503.64s -> 3506.20s]  Seeing a few different, like what's happening here?
[3508.80s -> 3510.40s]  What questions?
[3510.40s -> 3511.56s]  Yeah, I've got it, yeah.
[3511.56s -> 3512.40s]  Yeah.
[3514.40s -> 3516.56s]  Yeah, SIGSUSPEND is kind of like pause
[3516.56s -> 3518.56s]  in that it says, okay,
[3518.56s -> 3521.92s]  wait until a child handler happens and returns
[3521.92s -> 3523.36s]  and then you can keep going.
[3523.40s -> 3524.66s]  Wait for some signal basically.
[3524.66s -> 3527.84s]  That's seven block signals and pause.
[3527.84s -> 3528.74s]  This one, yeah.
[3528.74s -> 3530.44s]  So the SIGSUSPEND is a little bit strange.
[3530.44s -> 3533.48s]  It says set this block signals to this set,
[3533.48s -> 3535.60s]  which we are unblocking.
[3535.60s -> 3539.56s]  We're unblocking the SIGGILD in this case
[3539.56s -> 3541.44s]  because of this empty set.
[3541.44s -> 3543.68s]  And we're saying unblock that SIGGILD
[3543.68s -> 3546.00s]  after we've moved the process off process
[3546.00s -> 3549.12s]  so it can't, there's no race condition there anymore.
[3549.12s -> 3551.36s]  You will now, it'll unblock it.
[3551.80s -> 3553.44s]  The child handler will, it will just wait
[3553.44s -> 3556.08s]  until the child handler happens.
[3556.08s -> 3560.20s]  Child handler will do its thing, change FGPID to be zero
[3560.20s -> 3563.86s]  and then it will return.
[3563.86s -> 3566.60s]  This line will say, oh, then we've now got that signal
[3566.60s -> 3570.20s]  so now we're going to go back up here and change that.
[3570.20s -> 3572.20s]  Now you might be asking yourself,
[3572.20s -> 3573.52s]  one sec, you might be asking yourself,
[3573.52s -> 3577.00s]  wait, why do we even need this while loop in here?
[3577.00s -> 3578.96s]  Because if we're gonna wait for this signal,
[3578.96s -> 3580.84s]  why do we even need to do that?
[3580.88s -> 3584.08s]  It turns out that any signal that gets handled
[3584.08s -> 3587.38s]  will cause this SIGSUSPEND to end.
[3587.38s -> 3589.64s]  And so you need to, you want to say,
[3589.64s -> 3592.76s]  oh, well, in that case, let's make sure
[3592.76s -> 3594.42s]  that we check again to see if our condition
[3594.42s -> 3596.06s]  that we were supposed to set got set.
[3596.06s -> 3597.32s]  If not, we'll just loop again
[3597.32s -> 3598.64s]  and do another SIGSUSPEND.
[3598.64s -> 3599.62s]  Question?
[3599.62s -> 3600.62s]  That was your question, there you go.
[3600.62s -> 3602.56s]  I asked it before you got to it.
[3602.56s -> 3603.40s]  Yeah.
[3603.40s -> 3607.24s]  Can you just unblock if those are checking
[3607.24s -> 3610.12s]  and then block the couple of checks you wanted to do?
[3610.38s -> 3611.28s]  Let's see what's happening here.
[3611.28s -> 3614.60s]  Remember, well, okay, what have we done here?
[3614.60s -> 3616.04s]  We are a foreground process,
[3616.04s -> 3618.12s]  which means the parent needs to wait
[3618.12s -> 3620.52s]  for the foreground process to end.
[3620.52s -> 3623.20s]  We have blocked the signal child handler at this point.
[3623.20s -> 3624.64s]  We've come into here,
[3624.64s -> 3629.64s]  and the child could have ended already,
[3629.76s -> 3630.60s]  but it's been blocked,
[3630.60s -> 3633.12s]  so it's not a race condition in that sense.
[3633.12s -> 3637.26s]  We now say, okay, great, FGPID equals PID.
[3637.26s -> 3639.40s]  So we're saying that there's a foreground process,
[3639.56s -> 3641.08s]  and we want to set these two equal,
[3641.08s -> 3646.08s]  and then the child handler will unset FGPID.
[3647.12s -> 3648.40s]  Well, then we say, okay,
[3648.40s -> 3652.12s]  we're setting up the signal set to be this empty set.
[3652.12s -> 3654.40s]  We say, while FGPID equals PID,
[3654.40s -> 3656.16s]  is that going to be true the first time through,
[3656.16s -> 3658.26s]  even though the child has ended?
[3658.26s -> 3660.32s]  Yeah, it will be true the first time through,
[3660.32s -> 3661.96s]  which is fine.
[3661.96s -> 3663.84s]  Then we will do SIGSUSPEND,
[3663.84s -> 3667.46s]  which is going to push the parent process
[3667.46s -> 3669.10s]  off the processor,
[3669.10s -> 3672.34s]  because it's waiting for the child process to end,
[3672.34s -> 3674.18s]  okay, that handler to happen.
[3674.18s -> 3679.06s]  It calls, it unblocks the signal
[3679.06s -> 3681.22s]  after the process is off the processor.
[3681.22s -> 3683.70s]  At that point, the child has ended.
[3683.70s -> 3687.70s]  It calls signal handler, changes FGPID to be zero.
[3687.70s -> 3690.36s]  Well, and then it ends, and it wakes up here.
[3690.36s -> 3694.24s]  It goes back in this while loop and says,
[3694.24s -> 3698.56s]  oh, okay, now I've got zero, is not equal to the PID.
[3698.56s -> 3700.98s]  I can end, and then I can unblock SIGCHILD again.
[3700.98s -> 3703.98s]  By the way, when it comes out of this SIGSUSPEND,
[3703.98s -> 3706.84s]  it re-blocks the things that it would block before.
[3706.84s -> 3708.68s]  And that's the only good thing about that,
[3708.68s -> 3711.52s]  is so this while loop will actually work again.
[3711.52s -> 3713.84s]  Lots of good questions on this.
[3713.84s -> 3714.68s]  Yeah?
[3719.06s -> 3719.90s]  Yeah, good question.
[3719.90s -> 3721.06s]  Do I mean when I push off the processor,
[3721.06s -> 3722.92s]  push back in the OS scheduler?
[3722.94s -> 3724.30s]  We haven't talked about the scheduler itself,
[3724.30s -> 3726.46s]  but yes, it basically means put the parent process
[3726.46s -> 3729.26s]  to sleep, and when the parent process is to sleep,
[3729.26s -> 3732.78s]  there's nothing else happening in the actual code here
[3732.78s -> 3735.68s]  until that signal gets handled.
[3735.68s -> 3740.60s]  Why does it have to re-unblock SIGCHILD at the end?
[3740.60s -> 3741.44s]  Back to the end.
[3741.44s -> 3745.22s]  We have to, because when SIGSUSPEND ends,
[3745.22s -> 3748.06s]  it unblocks the signals.
[3748.06s -> 3749.82s]  It puts back the original block.
[3749.82s -> 3752.38s]  It puts back the original set, yes, good question.
[3752.64s -> 3754.16s]  So it re-blocks in that case.
[3754.16s -> 3755.52s]  Re-blocks the signals, yeah.
[3755.52s -> 3756.36s]  Yep?
[3759.58s -> 3762.28s]  Will the while loop ever iterate more in one time?
[3762.28s -> 3763.04s]  Let's see.
[3763.04s -> 3765.48s]  It shouldn't for this one child process.
[3765.48s -> 3768.00s]  Yeah, now, unless some other signal came in
[3768.00s -> 3771.00s]  and then it happened to un-suspend it.
[3771.00s -> 3772.88s]  So it could happen more than once
[3772.88s -> 3776.80s]  if another signal came in that happened to un-suspend it.
[3776.80s -> 3780.56s]  Does the suspend happen until any signal gets handled?
[3780.58s -> 3782.46s]  Now, if you were making this much more robust
[3782.46s -> 3783.70s]  and you cared about other signals,
[3783.70s -> 3785.62s]  you might not want to make it just the empty set
[3785.62s -> 3787.22s]  and so forth, but we don't care
[3787.22s -> 3788.98s]  about any other signals right now.
[3790.62s -> 3791.44s]  Okay.
[3792.62s -> 3796.06s]  That's a lot of stuff, that one thing.
[3796.06s -> 3799.46s]  You will use this extensively in the assignment three farm
[3799.46s -> 3801.90s]  which you are going to, which you are working on now,
[3801.90s -> 3803.22s]  and then assignment four.
[3803.22s -> 3805.76s]  Not extensively, but you'll use some of these
[3805.76s -> 3808.14s]  as you go through these, okay?
[3811.54s -> 3813.90s]  It's hard to reason about these things sometimes, okay?
[3813.90s -> 3814.74s]  Let's do this.
[3814.74s -> 3816.70s]  What I wanted to do is go through a couple questions.
[3816.70s -> 3820.62s]  Now, unfortunately, you have a midterm in a week and a half.
[3820.62s -> 3821.94s]  Unfortunately.
[3821.94s -> 3823.38s]  Nobody likes midterms.
[3823.38s -> 3824.58s]  I don't, we don't like grading them.
[3824.58s -> 3825.62s]  You guys don't like taking them.
[3825.62s -> 3826.54s]  We should just get rid of them,
[3826.54s -> 3829.38s]  but there's lots of barriers to that.
[3829.38s -> 3833.26s]  But if you have good ideas, certainly let me know.
[3833.26s -> 3834.70s]  Let's go through a couple questions.
[3834.70s -> 3835.90s]  We have about 15 minutes,
[3835.90s -> 3837.34s]  so we can get through these, I think.
[3837.34s -> 3839.50s]  Let's go through a couple questions related
[3839.56s -> 3842.52s]  to signal handling that you might see on midterm.
[3842.52s -> 3847.12s]  In fact, the two questions are from previous midterms, okay?
[3847.12s -> 3850.36s]  So here's the problem.
[3850.36s -> 3854.04s]  Consider this program and its execution, okay?
[3854.04s -> 3857.32s]  Assume that all processes run to completion
[3857.32s -> 3860.80s]  and all system calls and all printf succeed, et cetera.
[3860.80s -> 3863.08s]  Don't worry about any errors in this case.
[3863.08s -> 3868.08s]  And assume that all calls to printf are atomic.
[3868.38s -> 3873.22s]  Atomic means that it happens without anything else
[3873.22s -> 3875.66s]  being able to interrupt it, okay?
[3875.66s -> 3879.38s]  So in other words, if you're printing out ghost or pirate,
[3879.38s -> 3880.90s]  which is what we're printing out here,
[3880.90s -> 3883.58s]  you can't have it interrupted in the middle of the,
[3883.58s -> 3885.14s]  after the P in pirate.
[3885.14s -> 3887.50s]  It's not like a signal's gonna happen, okay?
[3887.50s -> 3889.50s]  And like interrupt it, okay?
[3889.50s -> 3892.66s]  This is actually more or less true for printf, okay?
[3892.66s -> 3896.96s]  Printf will print out its whole like stuff
[3896.98s -> 3898.86s]  before any other printf can get in there
[3898.86s -> 3899.70s]  and print stuff out.
[3899.70s -> 3901.68s]  So it's generally a good assumption in this case.
[3901.68s -> 3902.94s]  It's not true for cout,
[3902.94s -> 3906.30s]  which is why we had to write a little external function
[3906.30s -> 3908.32s]  for cout to make that work.
[3908.32s -> 3910.78s]  But that's what you have to assume here, okay?
[3910.78s -> 3913.08s]  You also can't assume anything about scheduling
[3913.08s -> 3915.78s]  or how long a time slice is or whatever.
[3915.78s -> 3916.82s]  You can just look at this and go,
[3916.82s -> 3919.34s]  hey, what can happen in this program?
[3919.34s -> 3921.78s]  What conditions could this program happen
[3921.78s -> 3924.60s]  if anything happened in any order
[3924.62s -> 3927.98s]  according to the rules that we have for our processes?
[3927.98s -> 3930.62s]  Okay, here is the program.
[3930.62s -> 3931.70s]  Let me do this.
[3931.70s -> 3933.60s]  Let me bump this up and we'll just go to this program.
[3933.60s -> 3935.78s]  Here, okay, we've got a main function.
[3935.78s -> 3939.74s]  It sets up a siguser1 signal.
[3939.74s -> 3942.98s]  That's just a signal that we can use
[3942.98s -> 3944.26s]  for whatever we want, okay?
[3944.26s -> 3946.84s]  We can send a siguser1 to another process.
[3946.84s -> 3950.30s]  In fact, we're going to send it to our child
[3950.30s -> 3951.50s]  in this case, okay?
[3952.44s -> 3954.72s]  The bat function is the function
[3954.72s -> 3959.72s]  that we are actually calling in as our signal handler.
[3960.12s -> 3963.58s]  Then we're printing pirate and then we're exiting, okay?
[3964.76s -> 3966.96s]  First question, by the way.
[3966.96s -> 3970.30s]  Does this function happen in the parent or the child?
[3971.84s -> 3972.92s]  In the parent, okay?
[3972.92s -> 3974.84s]  It's not happening in the child.
[3974.84s -> 3978.52s]  Sorry, depends who gets called, right?
[3979.38s -> 3983.34s]  Depends who gets it, as it turns out.
[3983.34s -> 3985.98s]  So that's a trick question, I suppose, right?
[3985.98s -> 3987.58s]  It would if it was a sigchild handler,
[3987.58s -> 3988.62s]  but it's not a sigchild handler.
[3988.62s -> 3989.66s]  It's an anything signaler.
[3989.66s -> 3991.82s]  It's a siguser1 handler,
[3991.82s -> 3993.02s]  which means we're just sending it.
[3993.02s -> 3995.38s]  So it depends who's calling it
[3995.38s -> 3997.28s]  and who's receiving it, okay?
[3997.28s -> 3999.42s]  We are setting up the signal handler.
[4000.46s -> 4003.46s]  The fork means that both the parent and the child
[4003.46s -> 4005.92s]  will have a signal handler,
[4005.92s -> 4007.58s]  but in this case, as you'll see,
[4008.00s -> 4009.08s]  it turns out it's just the child
[4009.08s -> 4011.40s]  that's actually getting the signal, okay?
[4011.40s -> 4013.00s]  All right.
[4013.00s -> 4015.20s]  Okay, so then it's going to fork
[4015.20s -> 4016.64s]  and then if we're the child,
[4016.64s -> 4019.04s]  we're gonna print ghost and return zero.
[4019.04s -> 4020.44s]  And then if we're the parent,
[4020.44s -> 4022.00s]  we're going to send the kill signal
[4022.00s -> 4025.88s]  with siguser1 to the child
[4025.88s -> 4030.72s]  and then we're gonna print ninja and then return zero, okay?
[4030.72s -> 4031.56s]  All right.
[4031.56s -> 4034.44s]  Can you say then what kill exactly does to the...
[4034.44s -> 4035.26s]  Yeah, good question.
[4035.26s -> 4036.10s]  What does kill exactly do?
[4036.12s -> 4038.26s]  It sends a signal to a process.
[4038.26s -> 4041.20s]  It sends siguser1 or it sends siguser1?
[4041.20s -> 4044.84s]  In this case, it sends siguser1 to the process PID.
[4044.84s -> 4046.64s]  Kill is not a good name for the function.
[4046.64s -> 4048.76s]  Okay, so raise means send it to ourself.
[4048.76s -> 4051.20s]  Yeah, raise means send it to ourself.
[4051.20s -> 4052.20s]  Kill means send it to somewhere else.
[4052.20s -> 4055.00s]  Now you could say kill get PID and send it to yourself,
[4055.00s -> 4056.48s]  but raise does that for you.
[4057.54s -> 4060.50s]  All right, now, question is,
[4060.50s -> 4064.86s]  write yes or no if there's a possible output here, okay?
[4065.68s -> 4068.24s]  Okay, and we can go through this and check and see,
[4068.24s -> 4073.00s]  is it possible for any of these outputs to happen?
[4073.00s -> 4074.32s]  Okay, well, let's see.
[4074.32s -> 4075.64s]  What would make it true
[4075.64s -> 4078.62s]  that ghost, ninja and then pirate happens?
[4078.62s -> 4079.76s]  Okay, let's see.
[4079.76s -> 4082.72s]  Well, for ghost, ninja, I'll make it big there.
[4082.72s -> 4085.80s]  Okay, for ghost, ninja and pirate to happen.
[4085.80s -> 4088.00s]  Well, how do we get ghost first?
[4088.00s -> 4091.02s]  Okay, we fork and then this happens immediately.
[4091.02s -> 4093.36s]  Could that happen before anything else happens?
[4093.36s -> 4094.20s]  Sure.
[4094.50s -> 4096.42s]  It looks like ghost could be printed immediately.
[4096.42s -> 4100.86s]  Okay, then for ninja to happen, okay,
[4100.86s -> 4104.42s]  we send a kill signal from the parent.
[4104.42s -> 4107.74s]  We send a sig user signal using the kill system call.
[4107.74s -> 4112.74s]  We send sig user, okay, to the child, okay?
[4112.94s -> 4115.74s]  And this can return immediately, by the way.
[4115.74s -> 4118.70s]  It doesn't wait for the child to do anything.
[4118.70s -> 4120.42s]  It just sends it and returns.
[4120.42s -> 4121.98s]  Could we send off that signal
[4121.98s -> 4123.82s]  and then really quickly print ninja?
[4124.38s -> 4125.66s]  Sure.
[4125.66s -> 4130.50s]  In the child, we have now had our signal handler called.
[4130.50s -> 4133.58s]  So can we print pirate and then end?
[4133.58s -> 4136.06s]  Yeah, so I think this one is fine.
[4136.06s -> 4137.20s]  Anybody have any questions why it's not?
[4137.20s -> 4138.04s]  Yeah.
[4138.04s -> 4140.58s]  Does have to have the kill signal
[4140.58s -> 4144.20s]  or like the kill call to prepare before the child is hired
[4144.20s -> 4145.70s]  or not?
[4145.70s -> 4147.04s]  Oh, good question.
[4147.04s -> 4151.28s]  This would have to happen between after this
[4151.28s -> 4152.58s]  and before this.
[4152.58s -> 4153.94s]  Yeah, and that could happen.
[4154.80s -> 4156.72s]  There's no reason it couldn't in this case, right?
[4156.72s -> 4158.80s]  We're looking at there's no reason that couldn't happen.
[4158.80s -> 4163.40s]  Okay, let's look about pirate and then ninja.
[4163.40s -> 4165.64s]  Let's see if that one's possible.
[4165.64s -> 4168.60s]  Okay, well, for pirate to happen,
[4168.60s -> 4172.80s]  we would have to fork, send a kill signal
[4172.80s -> 4175.12s]  before the child gets a chance to print ghost.
[4175.12s -> 4176.84s]  Is that possible?
[4176.84s -> 4179.76s]  Sure, it seems possible, right?
[4179.78s -> 4181.86s]  And then that will get,
[4181.86s -> 4185.34s]  we'll call the child's signal handler,
[4185.34s -> 4189.02s]  print pirate, which is good, and then that'll end.
[4190.46s -> 4193.38s]  And then we get, we're still over here,
[4193.38s -> 4196.18s]  then we could have ninja print at some point.
[4196.18s -> 4197.98s]  Does that make sense?
[4197.98s -> 4199.82s]  Okay, I think that's plausible.
[4199.82s -> 4201.22s]  I think that's a couple of plausible ones.
[4201.22s -> 4202.12s]  Let's look at the next one.
[4202.12s -> 4202.96s]  I'll make this better.
[4202.96s -> 4204.82s]  How about ninja and ghost?
[4204.82s -> 4208.00s]  What if bat returned instead of exit?
[4208.02s -> 4210.30s]  What if bat returned instead of exited,
[4210.30s -> 4214.46s]  then you would definitely get ghost at some point in there.
[4214.46s -> 4217.94s]  Right, because it exits, right, and doesn't return,
[4217.94s -> 4220.70s]  it exits the actual signal, the child itself.
[4220.70s -> 4223.92s]  It closes, it terminates the child process
[4223.92s -> 4228.06s]  by using exit, good question, good call.
[4228.06s -> 4230.30s]  Okay, let's look at the next one.
[4230.30s -> 4231.90s]  Ninja and ghost.
[4231.90s -> 4236.54s]  How could ninja happen before ghost?
[4236.54s -> 4240.84s]  Well, we could get down here.
[4240.84s -> 4243.68s]  Let's say that the child is just slow right now.
[4243.68s -> 4246.48s]  We get down here and we send this signal.
[4246.48s -> 4249.32s]  Okay, could it happen that this signal,
[4249.32s -> 4251.54s]  which is going to signal the child to say pirate,
[4251.54s -> 4254.56s]  could it happen that this signals
[4254.56s -> 4259.56s]  and then gets up here and then this prints
[4260.72s -> 4265.10s]  and returns, but then this never happens.
[4266.08s -> 4269.96s]  No, I don't think that could happen, right,
[4269.96s -> 4272.08s]  because the minute this signal handler happens,
[4272.08s -> 4274.68s]  it stops everything happening down here.
[4275.76s -> 4279.44s]  So if you were to get that case, right,
[4279.44s -> 4283.00s]  where you were trying to get ghost happening, right,
[4283.00s -> 4287.76s]  well, this has to happen before this happens
[4287.76s -> 4290.72s]  and therefore you're gonna get the signal called up here
[4291.56s -> 4295.22s]  and you're gonna end up getting pirate
[4295.22s -> 4296.30s]  before you're gonna get ghost.
[4296.30s -> 4299.66s]  So it's not really possible for ghost to happen
[4299.66s -> 4301.54s]  without having the pirate happening
[4301.54s -> 4305.54s]  if you do a SIG call or signal first.
[4308.70s -> 4310.30s]  So no, I don't think that, yeah.
[4310.30s -> 4313.50s]  Hold on, we know that the call to kill
[4313.50s -> 4314.54s]  has to happen right there,
[4314.54s -> 4317.44s]  but do we actually know anything about
[4317.44s -> 4320.54s]  when the child actually received the signal?
[4321.36s -> 4323.44s]  Like what if you sent the signal,
[4323.44s -> 4328.08s]  ninja gets printed out and then the child process
[4328.08s -> 4330.16s]  also prints out ghost and for some reason
[4330.16s -> 4333.00s]  it hasn't received the SIG user yet.
[4333.00s -> 4337.72s]  Right, so the SIG user, the signal happens immediately,
[4337.72s -> 4338.86s]  it's the next thing that happens.
[4338.86s -> 4341.00s]  So even if it got to print ghost,
[4341.00s -> 4343.72s]  it would still have the signal called actually
[4343.72s -> 4345.88s]  and then have to go up and print pirate.
[4345.88s -> 4349.12s]  So I think you're not really going to get,
[4349.14s -> 4350.34s]  remember we can't say that oh,
[4350.34s -> 4352.14s]  these two are gonna happen next to each other, right,
[4352.14s -> 4354.46s]  but we can say that the signal will definitely,
[4354.46s -> 4357.26s]  if that got printed, right,
[4357.26s -> 4358.86s]  well, by the time that got printed,
[4358.86s -> 4360.02s]  if this had already been printed,
[4360.02s -> 4361.90s]  that signal had already been sent.
[4361.90s -> 4364.54s]  So the fact that that signal got sent at all
[4364.54s -> 4367.46s]  means that even if this printed,
[4367.46s -> 4371.22s]  it would have to then go and do the pirate
[4371.22s -> 4373.62s]  because it would never get to the return zero.
[4374.90s -> 4376.72s]  Does that help?
[4376.72s -> 4377.56s]  Yeah, yeah.
[4377.58s -> 4382.58s]  The signal handler always pre-empts, is that what you were?
[4385.06s -> 4387.42s]  Yes, the signal handler stops because,
[4387.42s -> 4388.98s]  again, this is kind of my question earlier,
[4388.98s -> 4390.46s]  which one is happening, this happening,
[4390.46s -> 4392.30s]  it's happening in the child in this case,
[4392.30s -> 4394.66s]  the signal handler of the child is one process,
[4394.66s -> 4396.98s]  it can't have two things going on at once.
[4396.98s -> 4398.34s]  So it's either doing the signal handler
[4398.34s -> 4400.46s]  or it's doing the rest of the program
[4400.46s -> 4401.90s]  and if it's doing the signal handler,
[4401.90s -> 4403.50s]  the rest of the program is not happening.
[4403.50s -> 4404.34s]  Yeah.
[4404.72s -> 4407.96s]  If you had ghost and then it returned,
[4407.96s -> 4411.76s]  and then you tried to send it the signal handler.
[4411.76s -> 4413.80s]  If you had ghost and then it returned,
[4413.80s -> 4417.84s]  so returning from main is going to close the program,
[4417.84s -> 4420.84s]  it may take an instruction or two after that actually,
[4420.84s -> 4423.12s]  but I guess there's,
[4423.12s -> 4426.00s]  but that wouldn't happen in this program, you see why?
[4426.00s -> 4429.08s]  Because you send this kill signal,
[4429.08s -> 4432.00s]  even if it's too late to do this ghost one,
[4432.00s -> 4434.10s]  it's going to happen before the return.
[4435.16s -> 4438.92s]  Okay, because it happens the instant you send it
[4438.92s -> 4441.36s]  and it's not like the return to the ghost,
[4441.36s -> 4443.68s]  the kernel is going, oh my gosh, there's a signal,
[4443.68s -> 4445.78s]  I'm sending it immediately to the child.
[4451.12s -> 4454.16s]  If it did return, after printf ghost,
[4454.16s -> 4457.92s]  if it did return, there is some time in there still
[4457.92s -> 4461.16s]  where the signal handler could kill it and still happen,
[4461.16s -> 4462.68s]  but probably not very long.
[4464.52s -> 4468.48s]  Return does not immediately stop the program.
[4468.48s -> 4470.60s]  No, exit does, and exit's like we're done.
[4470.60s -> 4471.44s]  Yeah.
[4475.28s -> 4479.32s]  Why wouldn't ghost print after ninja?
[4479.32s -> 4482.30s]  Let's see, pirate does exit the,
[4483.80s -> 4487.20s]  it actually stops the child from being,
[4487.20s -> 4489.68s]  it terminates the child completely immediately.
[4489.68s -> 4490.96s]  Process is done.
[4490.96s -> 4492.56s]  Yes, good question.
[4492.56s -> 4493.40s]  Yeah.
[4494.48s -> 4497.28s]  Why would returning zero also work?
[4497.28s -> 4499.76s]  Again, returning zero does work eventually,
[4499.76s -> 4501.00s]  but there's actually a little bit of time
[4501.00s -> 4505.22s]  between return zero and the end of the program.
[4505.22s -> 4506.88s]  There's some more cleanup that's actually involved.
[4506.88s -> 4511.04s]  You actually propagate, it's actually a different path
[4511.04s -> 4514.08s]  through the, going back to the shell, as it turns out.
[4514.08s -> 4517.50s]  It's not returning, a function calls main.
[4517.50s -> 4519.56s]  When you say exit, it actually never returns
[4519.56s -> 4523.08s]  to that calling function, as it turns out.
[4523.08s -> 4526.06s]  It just ends it immediately, more or less.
[4526.06s -> 4528.02s]  I mean, there's still a little bit of time in there,
[4528.02s -> 4529.40s]  but it ends it immediately.
[4529.40s -> 4530.90s]  You can think of it that way.
[4532.26s -> 4533.94s]  But it does not return from the,
[4533.94s -> 4536.42s]  I guess the bigger thing is it does not return
[4536.42s -> 4538.30s]  so that this could ever get printed.
[4540.06s -> 4542.78s]  In other words, exit zero never makes,
[4542.78s -> 4545.18s]  it means it never makes it back to the parent at all,
[4545.18s -> 4548.26s]  so this couldn't get printed, right?
[4549.38s -> 4550.22s]  Okay.
[4550.22s -> 4551.06s]  All right, we've got two more,
[4551.06s -> 4552.20s]  let's look at the other ones here.
[4552.20s -> 4556.90s]  Could we do Ninja, Pirate, Ninja?
[4556.90s -> 4558.22s]  No, that's silly.
[4558.22s -> 4559.94s]  Ninja, Pirate, you're not gonna get two there.
[4559.94s -> 4562.50s]  Could you get Ninja, Pirate, Ghost?
[4562.50s -> 4563.82s]  Ninja, Pirate, this is what we were kind of
[4563.82s -> 4565.94s]  talking about before, right?
[4565.94s -> 4569.22s]  Ninja, Pirate, Ghost.
[4569.22s -> 4570.78s]  Well, Ninja and then Pirate,
[4570.78s -> 4573.02s]  and you'll never get back to here
[4573.02s -> 4577.26s]  if you have set the, if the Pirate happens,
[4577.26s -> 4579.90s]  you'll never get back to the other part
[4579.90s -> 4581.34s]  of the child process.
[4581.68s -> 4585.72s]  Yes, yes, no, no, yes, yes, no, no, no.
[4585.72s -> 4588.00s]  There we go, all right.
[4588.00s -> 4589.98s]  All right, there's another one that I don't have time
[4589.98s -> 4591.48s]  to do today, but another midterm,
[4591.48s -> 4593.16s]  we'll start with this one on Wednesday,
[4593.16s -> 4594.68s]  it's another race condition one.
[4594.68s -> 4595.80s]  Feel free to look at it if you want to,
[4595.80s -> 4597.64s]  but it's another one from the midterm.
[4597.64s -> 4599.00s]  See you guys Wednesday.
