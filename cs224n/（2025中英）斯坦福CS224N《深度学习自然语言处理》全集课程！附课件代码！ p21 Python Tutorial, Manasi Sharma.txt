# Detected language: en (p=1.00)

[0.00s -> 11.78s]  All right. Hi, everyone. Welcome to the 224n Python review session. The goal of the session
[11.78s -> 18.42s]  really will be to sort of give you the basics of Python and NumPy in particular that you'll
[18.42s -> 22.58s]  be using a lot in your second homework. And the homeworks will come after that as
[22.58s -> 28.50s]  well. We're sort of taking this tutorial from the background of anyone who hasn't
[28.50s -> 33.14s]  touched programming languages to some extent, but also for people who have will be sort
[33.14s -> 36.06s]  of going through a lot of that material very quickly and will be progressing to NumPy as
[36.06s -> 40.06s]  well. And as I mentioned, first and foremost, the session is really meant for the people
[40.06s -> 45.32s]  who are here in person. So if you'd like me to slow down, speed up at any point, need
[45.32s -> 50.10s]  time for clarifications, feel free to ask. It's really meant for you first here. And
[50.10s -> 54.34s]  I really would like it to be sort of an interactive session as well. All right. So
[54.34s -> 58.66s]  these are the topics we'll be covering today. Going through, first of all, why Python
[58.66s -> 62.26s]  is a language? Why have we chosen it for sort of discourse? And in general, why do
[62.26s -> 67.06s]  people prefer it to some extent for machine learning and natural language processing?
[67.06s -> 71.08s]  Some basics of the language itself, common data structures, and then getting to sort
[71.08s -> 74.90s]  of the meat of it through NumPy, which as I mentioned, you'll be extensively using
[74.90s -> 79.14s]  in your homeworks going forward. And then some practical tips about how to use things
[79.14s -> 83.70s]  in Python. All right. First thing, why Python?
[83.70s -> 89.30s]  So a lot of you who might have been first introduced to programming might have done Java
[89.30s -> 96.14s]  before. A lot of people use MATLAB in other fields as well. So why Python? Python is
[96.14s -> 100.34s]  generally used, for one, because it's a very high-level language. It can look very,
[100.34s -> 103.50s]  very English-like, and so it's really easy to work with for people, especially
[103.50s -> 107.62s]  when they get started out. It has a lot of scientific computational functionality
[107.62s -> 110.86s]  as well, similar to MATLAB. So when you talk about NumPy, you'll see that it has a
[110.86s -> 115.26s]  lot of frameworks of very, very quick and efficient operations involving math or matrices,
[115.26s -> 119.94s]  and that's very, very useful in applications such as deep learning. And for deep learning,
[119.94s -> 123.10s]  in particular, a lot of frameworks that people use, particularly, for example,
[123.10s -> 127.10s]  PyTorch and TensorFlow, interface directly with Python. And so for that,
[127.10s -> 130.54s]  those main reasons, people generally tend to use Python within deep learning.
[130.54s -> 137.50s]  Okay, so the setup information is in the slides, if you'd like to look at them offline. I will
[137.50s -> 142.18s]  be jumping over that for now, because I want to get to the introduction to the language itself.
[142.18s -> 146.54s]  And if you have time, come back to the setup information. A lot of it's pretty direct. You
[146.54s -> 151.86s]  can walk through it. It gives you steps for how to install packages, what is a Conda
[151.86s -> 156.46s]  environment, for example, and gets you set up with your first working Python environment,
[156.46s -> 160.54s]  so you can run simple and basic commands to get used to the language. But for now,
[160.54s -> 162.74s]  I'm going to be skipping over this and coming back to it if we have time.
[162.74s -> 170.58s]  All right, language basics. So in Python, you have variables, and these variables can take
[170.58s -> 175.98s]  on multiple values. The assignment operation, there's an equal sign, will allow you to assign
[175.98s -> 180.30s]  a particular value to a variable. A nice thing with Python is you don't have to instantiate the
[180.30s -> 184.66s]  type of the variable to begin with, and then only instantiate, or only assign values of that
[184.66s -> 189.90s]  type. So for example, in certain languages, we first say that this variable, x, is only
[190.02s -> 194.34s]  going to be of type int, and any value aside from that assigned to it will throw an error.
[194.34s -> 198.58s]  Python's pretty flexible, so if I want to, I can reassign. I can start with x is equal to 10,
[198.58s -> 203.30s]  and then later on, like five lines later, I can say x is equal to high as a string,
[203.30s -> 208.54s]  and there would be no issue. You can do simple mathematical operations, such as the plus
[208.54s -> 215.58s]  and division signs. You can do exponentiation, which is raising one value to another value,
[215.58s -> 221.30s]  so x to the power of y, for example, using the double asterisk. You can do type castings
[221.30s -> 225.18s]  for float division, so if you want to ensure that your values are being divided, resulting
[225.18s -> 228.54s]  in a float value and not just dividing two integers, you can cast two different types,
[228.54s -> 232.34s]  like float. If you want something to be explicitly an int, you can also just put
[232.34s -> 236.50s]  an int instead of the float with brackets around the result, and that will give you
[236.50s -> 242.02s]  an integer value. And then you can also do typecasting to, for example, convert from
[242.02s -> 246.82s]  integers to strings. So, in this case, if I wanted to, instead of doing 10 plus 3,
[246.82s -> 252.50s]  as a mathematical operation, I just want to write out 10 plus 3. Then I can convert
[252.50s -> 258.86s]  the x and y values, for example, to strings, and then add the plus sign as a character,
[258.86s -> 262.10s]  as well, to create a string. And so a lot of these common operations, you can look online,
[262.10s -> 266.34s]  as well. People have lists for them, and just see how they're sort of done in Python.
[266.34s -> 272.10s]  All right. Some other quick things. So, Boolean values, the true and the false,
[272.10s -> 274.94s]  they're always used with capital letters. In some of the languages,
[274.94s -> 279.18s]  they might be lowercase, so just one thing to know. Python also doesn't have a null value.
[279.18s -> 283.98s]  The equivalent of a null value is none. So, sometimes when you want to say that this value,
[283.98s -> 287.98s]  you want to return none, saying that I'm not really doing anything here. You want to do
[287.98s -> 294.02s]  checks, for example, in if statements, to say that this doesn't have a value, then you
[294.02s -> 299.10s]  can assign it to none. So, none sort of functions as a null equivalent. So,
[299.10s -> 303.02s]  you're not really returning anything. It doesn't have a value. Not the same as zero.
[303.02s -> 309.50s]  And another nice thing about Python is lists, which are sort of mutable. We'll come to that
[309.50s -> 314.42s]  a little bit later, but sort of mutable lists of objects and means that you can change them.
[314.42s -> 319.54s]  They can be of any type. So, you can have a mixture of integers, none values,
[319.54s -> 324.38s]  strings, etc. And yeah, functions can return the none value as well.
[324.38s -> 331.30s]  And another quick thing, instead of using the double and and in some of the languages,
[331.30s -> 334.94s]  as people might do, with Python, I mentioned earlier, it's very English-like. So,
[334.94s -> 341.38s]  you can actually just write out if x is equal to 3 and, and in English, y is equal to 4,
[341.38s -> 346.66s]  then return true or something. It's quite nice that way. So, you can use and, or, and not.
[346.66s -> 352.42s]  And then just the comparison operators of equal, equals to, and not equals to will check for
[352.42s -> 357.02s]  equality and inequality. This one's pretty standard, I feel, across many languages. And
[357.02s -> 361.06s]  you can use them in Python as well. And yeah, remember, just a quick thing,
[361.06s -> 364.34s]  the equal equal to sign is different from the assignment operator. This one checks for
[364.34s -> 368.58s]  equality. That one is just assigning a value. So, a single equal sign versus two of them.
[368.58s -> 373.90s]  All right. And then, also in Python, you don't use brackets. So, Python,
[373.90s -> 381.50s]  you can use basically spaces or tabs. So, either indents of 2 or 4 to be able to break
[381.50s -> 384.78s]  up what is contained within the function or contained within like an if statement,
[384.78s -> 389.66s]  a for statement, or any loops, for example. And so, the main thing is you can choose
[389.66s -> 395.10s]  whether to do 2 or 4. You just have to be consistent throughout your entire codebase.
[395.10s -> 399.62s]  Otherwise, they will throw an error. Now, go to some common data structures.
[399.62s -> 406.42s]  And for this, we'll transition to the Colab. So, this one will sort of show you in real time.
[406.42s -> 410.98s]  This is, by the way, a Colab. A Colab is basically a Jupyter notebook, for those of you
[410.98s -> 415.38s]  who are familiar with those, that you can use that it's hosted on Google servers.
[416.18s -> 419.38s]  The really nice thing about Jupyter notebooks is you don't have to run an entire
[419.38s -> 424.26s]  file altogether. You can run it step by step into what are these called cells.
[424.26s -> 428.02s]  So, if you want to see like an intermediate output, you can see that pretty easily.
[428.74s -> 434.26s]  And you can also write, for example, a lot of like descriptions pertaining to cells,
[434.26s -> 437.22s]  which is really, really nice to have as well. So, a lot of people like tend to use these when
[437.22s -> 441.62s]  they're sort of starting off the project and want to debug things. And Colab allows you to
[441.62s -> 447.70s]  use these Jupyter notebook type applications hosted on their servers for free, basically.
[447.70s -> 454.50s]  So, anyone can create one of these and run their code. All right. So, lists are mutable arrays.
[455.14s -> 459.06s]  Mutable means that you can change them so that once you declare them, you can add to them,
[459.06s -> 463.30s]  you can delete them, and they're optimized for that purpose. So, they expect to be changed
[463.30s -> 467.38s]  very often. We'll come to what are called NumPy arrays later, and those tend to be pretty
[467.38s -> 470.74s]  much fixed. When you create a new one, you'd have, when you change one, you'd basically have
[470.74s -> 474.42s]  to create a new array, which will have the additional information. So, this is highly
[474.42s -> 478.34s]  optimized for changing things. So, if you know, for example, and you're in a loop, you're
[478.34s -> 482.98s]  adding different elements to, let's say, a bigger entity, you'd want to use something like a
[482.98s -> 487.30s]  list because you're going to be changing that very often. So, let's see how they work.
[487.30s -> 493.30s]  So, we start off with a names array with Zach and Jay. You can index into the list
[494.18s -> 497.22s]  by, so what is this? Index into the list by index, which means that you can
[498.90s -> 503.14s]  list out the elements in the list depending on what's called the index. So, it's what
[503.14s -> 507.70s]  place that value is at within the list. So, zero refers to the first element. So, Python's
[507.70s -> 512.02s]  what's called zero index, which means it starts with zero and then it goes to one. So,
[512.02s -> 517.30s]  here zero will be Zach. And then let's say I want to append something to the end. So,
[518.02s -> 523.54s]  to add something to the end of the list, the term is append, not add. And so, if I want to append,
[524.90s -> 528.66s]  I can now create a separate list, which is the original list itself with the added
[528.66s -> 533.30s]  last element. And what would currently be the length of this? It would be three because you
[533.30s -> 537.22s]  have three elements. And you can just quickly get that by using the len function, not length,
[537.22s -> 543.70s]  just three letters, L-E-N. All right. It's also really nice because Python has
[543.70s -> 550.74s]  overloaded the plus operation to be able to concatenate lists. So, here I have a separate
[550.74s -> 554.58s]  list, right? And all you need for a list definition is just brackets. So, this is a
[554.58s -> 559.22s]  separate list altogether, even though I haven't saved it in the variable, just Abhi and Kevin.
[559.22s -> 563.54s]  And I can just do a plus equal to, which means that names is equal to names plus Abhi and
[563.54s -> 569.86s]  Kevin. And this should output this full list. You can create lists by just putting the plain
[569.86s -> 574.74s]  brackets or an existing list. And then, as I mentioned earlier, your list can have
[574.74s -> 578.50s]  a variety of types within them. So, here this list contains an integer value,
[578.50s -> 582.50s]  a list value. So, you can have a list of lists, as many sort of sub lists as you like,
[583.30s -> 587.30s]  a float value, and a none value. And this is completely valid within Python.
[588.18s -> 593.46s]  Slicing refers to how you can access only parts of the list. So, if I only want, for example,
[594.50s -> 600.58s]  in this numbers array, I only want 0, 1, 2. Slicing is a way that you can extract only
[600.58s -> 605.22s]  those parts. So, the way slicing works is the first element is included and the last element
[605.22s -> 612.66s]  is excluded. So, here I start with 0, 1, 2, 3. So, 3 is not included and so 0, 1, 2 will be
[613.30s -> 617.54s]  printed out. There's also short hands. So, if you know that you're going to be starting with
[617.54s -> 623.30s]  the first element of the array, so if you know I want 0, 1, 2 and it starts with 0, then you
[623.30s -> 627.38s]  don't need to even include the first index. You can just leave that and include the last
[627.38s -> 634.10s]  index that would be excluded. So, that would be blank semicolon 3. And same deal with the end.
[634.10s -> 639.62s]  If you know that you want to take everything, let's say from like 5 and 6 till the end of the
[639.62s -> 646.34s]  array, you can start with what you'd like. So, 0, 1, 2, 3, 4, 5 till the end and leave that.
[649.46s -> 653.62s]  Fun fact. So, this semicolon, when you take just the semicolon, it'll take everything in the
[653.62s -> 659.62s]  list, but it'll also create a duplicate in memory. That's a very slight, very useful thing
[659.62s -> 665.46s]  to know because sometimes when you like pass lists in Python, which is out of scope of
[665.46s -> 669.78s]  this tutorial, you'd only pass the reference to it. So, if you will change the array, that gets
[669.78s -> 674.10s]  changed. This will create an entirely separate copy in memory of the exact same array. So,
[674.10s -> 677.94s]  if you make any changes to it, it won't affect your original array. So, this is a
[677.94s -> 682.18s]  pretty neat way to do that. And then another fun thing that Python has, which is pretty
[682.18s -> 687.30s]  unique, is you can index negatively. So, negative indexing means you index from the back of
[687.30s -> 693.62s]  the array. So, minus 1 refers to the last element of the array. Minus 3 will refer to the
[693.62s -> 698.34s]  third last element. And so, what minus 1 will give you will be 6 in this case.
[698.34s -> 702.34s]  But minus 3 will give you will be everything because you're starting with the minus 3 elements.
[702.34s -> 708.74s]  So, minus 1, minus 2, minus 3 till the end. And then this one seems kind of confusing, right?
[708.74s -> 713.70s]  3 to minus 2. So, this will do is it will give you 0, 1, 2, 3. So, you start with 3.
[713.70s -> 719.94s]  And then minus 1, minus 2. So, you leave off the last because you excluded within
[719.94s -> 726.02s]  list. You'd only get 3 and 4. That's what this is. Okay, that's about lists.
[727.54s -> 732.50s]  Tupils are immutable arrays. So, once you declare the values of these, they cannot be changed.
[732.50s -> 736.18s]  So, I start with, remember we started with like the list of Zach and Jay.
[736.18s -> 741.30s]  Tupils, you start with Zach and Jay. And you can still access them. You know, I can still
[741.30s -> 746.82s]  print out names 0, same as I did with lists. But if I try to change it, in this case,
[746.82s -> 750.74s]  it'll throw an error. So, tuples, once you've instantiated them, they cannot be changed.
[751.62s -> 755.70s]  And to create an empty tuple, you just create, you can either use just a tuple sign.
[755.70s -> 759.30s]  Or oftentimes, you can just use the parentheses brackets. So, you can just say,
[759.30s -> 763.62s]  for example, as you did here, just parentheses to instantiate something.
[765.30s -> 769.94s]  All right. And yeah, this one we'll come to a little bit later in shapes.
[769.94s -> 773.78s]  But you can also have a tuple of a single value. And all you have to do there is just
[773.78s -> 777.30s]  put the value and put a comma. So, that just shows that you have a tuple,
[777.30s -> 781.06s]  which is like an immutable array. So, you can't change it. It's a list,
[781.06s -> 786.10s]  but only of one item. And that's here. Okay. I'll quickly move to dictionaries.
[786.82s -> 789.62s]  For those of you who might be familiar with other languages,
[789.62s -> 792.58s]  this is the equivalent of like a hash map or hash table.
[793.30s -> 796.82s]  What this is useful for essentially is mapping one value to another in a really,
[796.82s -> 800.82s]  really quick way. So, if I want to map, for example, a string to an index,
[800.82s -> 804.58s]  which you will happen to do a lot of in your homeworks, this is a really,
[804.58s -> 808.74s]  really useful way to do that. And so, what it does is you can instantiate this dictionary.
[809.62s -> 813.46s]  And it says, corresponding, that zach is going to correspond to this string value,
[813.46s -> 817.62s]  whatever it is. And so, anytime I want to retrieve the string value,
[817.62s -> 822.10s]  I just use this dictionary. I index by it, which is what I do here.
[822.10s -> 825.78s]  And then it outputs the corresponding value. And it does that really, really quickly.
[826.66s -> 832.34s]  And yeah, so it's really useful, very, very commonly used, especially when you sort of,
[832.34s -> 836.50s]  for example, you have like a list of strings or a list of items, and you want to have
[837.14s -> 842.18s]  a corresponding index for them because, and as you'll see in NLP, oftentimes you're using with,
[842.18s -> 846.82s]  you're working with indices and numbers in particular. So, it's a really great way to sort
[846.82s -> 853.30s]  of move from like string formats to just like numerical index values. There's some other things
[853.30s -> 856.58s]  you can do for dictionaries. You can check whether certain elements are in there. So, if you,
[856.58s -> 861.62s]  for example, try to index phone book is equal to monsey, they'll throw an error because there's no
[861.62s -> 865.38s]  string that says monsey in that phone book dictionary. And so, sometimes you might be wanting
[865.38s -> 870.18s]  to do checks before you extract a value. And so, this will just check, for example, if I do
[870.18s -> 873.78s]  print monsey in phone book, it should say false. Or for example, here, Kevin in phone book,
[873.78s -> 878.18s]  it should say false. While something that's actually in that dictionary, zach, will be true.
[878.98s -> 883.30s]  Okay, and then if you'd like to delete an entry from the, from the dictionary, you can just do
[883.30s -> 892.26s]  that using the del command. All right, let's move to loops quickly. So, loops are a really
[892.26s -> 898.26s]  great way to optimize for the same kind of operation you're doing. It's also a great way
[898.26s -> 904.82s]  to start to sequentially go over those list type or array type objects we were talking about
[905.70s -> 910.90s]  earlier. You know, you have like a list of names, right? How do you access all of them? So, loops
[910.90s -> 915.30s]  are a really great way to do that. In Python, they've abstracted away a lot of the confusing
[915.30s -> 920.82s]  sort of parts of other languages that might be. You can really, for example, first index on
[920.82s -> 925.46s]  numbers. So, what you do is you have like a range function that you call. So, here you say range
[926.26s -> 930.02s]  and the range of the last number you'd want. So, what this range function will return
[930.02s -> 934.98s]  is 0, 1, 2, 3, 4, and that's what will be stored in this i value, and here it's just printing out
[934.98s -> 940.42s]  that i value. So, if I want to, for example, loop over the length of a list of size 10,
[940.42s -> 945.78s]  I just have to do for i and range 10 and then index that corresponding part of the list.
[945.78s -> 949.46s]  You technically don't even have to do that because in Python you can just directly get the
[949.46s -> 956.10s]  element of the list. So, here I have a list of names where I have Zach, Jay, and Richard.
[956.10s -> 960.66s]  Instead of saying first the length of the list and then doing this range operation,
[960.66s -> 964.98s]  I can just directly say for name in names and then print out the names and they will just
[964.98s -> 971.22s]  directly get the element in each list. But sometimes you might want both. You might both want
[971.22s -> 976.50s]  this element Zach as well as its position in the array, and for that you can actually use this
[976.50s -> 981.70s]  really helpful function called enumerate. And so, enumerate will basically pair those two values
[981.70s -> 986.74s]  and it'll give you both the value, which is here a name for example, and its corresponding index
[986.74s -> 991.70s]  within the array, both together. So, that's really, really convenient. Versus, for example,
[991.70s -> 995.22s]  having to do this like a little bit more complicated range operation where you first
[995.22s -> 1000.10s]  take the range and then you index the list. How do you iterate over a dictionary? So,
[1000.10s -> 1005.86s]  for dictionaries, if you want to iterate over what's called the keys, so all of these
[1005.86s -> 1010.26s]  first items that you first, you know, put into the dictionary, you can just iterate the same
[1010.26s -> 1014.98s]  way you would a list. You just say for name in, for example, phone book and you can output the keys.
[1014.98s -> 1019.94s]  If you want to iterate over what is stored in the list, which is called a value, you'd have to
[1019.94s -> 1025.94s]  do the dictionary dot values. And if you want both, you use the dot items function. And so,
[1025.94s -> 1035.14s]  that will print out both of these. All right. So, this is sort of covering the overarching,
[1035.14s -> 1040.02s]  most commonly used sort of structures, lists, dictionaries, and then loops,
[1040.02s -> 1045.46s]  and how to sort of efficiently use them within your code. We'll quickly be moving to the sort
[1045.46s -> 1049.54s]  of meat of what is really, really strong about Python and what you'll be using a lot
[1049.54s -> 1055.54s]  for your coming homework, especially homework two, which is NumPy. Okay. So, for NumPy, also,
[1055.54s -> 1061.22s]  I'm going to be going to the Colab. I just quickly wanted to mention what NumPy is. So,
[1061.22s -> 1066.18s]  NumPy is basically an optimized library for mathematical operations. You know,
[1066.18s -> 1069.62s]  people tend to like MathLab because it's very, very useful for these mathematical operations,
[1069.62s -> 1074.82s]  which people use in their research. Python's sort of solution to that is to have a separate
[1074.82s -> 1080.58s]  library entirely, where they make use of subroutines, which are sort of like sub languages,
[1081.14s -> 1084.18s]  sorry, sub scripts that are written in a different language called C or C++
[1085.22s -> 1091.14s]  that are highly optimized for efficiency. So, the reason C and C++ are much faster than Python
[1091.62s -> 1094.42s]  is because they're closer to what's called machine language, which is what the computer
[1094.42s -> 1098.58s]  will read. I mentioned earlier, one of the nice things about Python is it's kind of high level.
[1098.58s -> 1101.46s]  It looks like English, right? Because I'm excited. You know, we say it literally like is,
[1101.46s -> 1106.82s]  you know, if X is equal to one or X is equal to two, right? But that also means that
[1106.82s -> 1110.74s]  there's a lot more translation required on the computer's part before it understands what you
[1110.74s -> 1114.58s]  mean. And that's useful when, you know, we're writing out code where we want to
[1114.58s -> 1118.82s]  understand it, but it's a little bit less useful when you're sort of running a lot of operations
[1118.82s -> 1123.78s]  on a lot of data. So, the real benefit of something like NumPy is that if you have sort of your
[1123.78s -> 1128.74s]  memory and your data in a particular format, it'll call these, we see scripts or what are called
[1128.74s -> 1132.58s]  subroutines in a different language and make them very, very fast. And so, that's the real
[1132.58s -> 1138.10s]  benefit of using NumPy. And almost everyone in sort of NLP is very, very familiar with this
[1138.10s -> 1142.02s]  because you'll be running a lot of operations on, for example, like co-occurrence matrices,
[1142.02s -> 1146.18s]  which are really, really big and it's very useful to have them optimized for time. So,
[1146.18s -> 1151.30s]  that's really the benefit of using NumPy. And NumPy, basically, it's involved for all these
[1151.30s -> 1155.62s]  like math and matrix and vector calculations. And it's different than a list, although you
[1155.62s -> 1160.02s]  can easily translate between the list and a NumPy array. NumPy arrays are specifically,
[1160.02s -> 1164.34s]  as I mentioned, designed to be used in these subroutines. So, they have a specific format,
[1164.34s -> 1169.22s]  they're instantiated differently, and you can translate between this and such your standard list
[1169.22s -> 1173.06s]  easily, but to know that you can only do NumPy operations on NumPy arrays. You can't
[1173.06s -> 1177.38s]  do operations on lists directly. You just have to like convert them, which is really simple. You
[1177.38s -> 1182.02s]  just use this NumPy dot array function, but just know that they operate only on NumPy arrays.
[1183.06s -> 1185.78s]  Okay, so for NumPy, we're going to be going back to the Colab.
[1187.78s -> 1191.14s]  And then, as I mentioned earlier, the real strength of NumPy is, you know, it supports
[1191.14s -> 1196.10s]  these large multidimensional arrays and matrices for very, very optimized high-level
[1196.10s -> 1201.78s]  mathematical functions. And just to go about, step back for a quick second, what is a matrix?
[1201.86s -> 1208.34s]  Matrices are basically like rectangular structures of numbers that are used, and you can treat them
[1208.34s -> 1213.30s]  with specific rules for operations between different kinds of things. So, if you have
[1213.30s -> 1217.22s]  like a lot of data, instead of, you know, individually potentially multiplying things,
[1217.22s -> 1221.70s]  if you can store them in this rectangular format, you have specific rules about how
[1221.70s -> 1225.30s]  this matrix, for example, will interact with a different one. And by doing that, which is
[1225.30s -> 1231.22s]  matrix multiplication or matrix math, you can do a wide variety of mathematical operations.
[1232.74s -> 1236.42s]  Generally, this is conventional. None of these are like hard and fast rules, but conventionally,
[1236.42s -> 1242.58s]  a vector is a matrix in one dimension. So, it's usually like a row vector or a column vector,
[1242.58s -> 1247.78s]  which usually just means that it's a list of values in only one dimension. So, it's like,
[1247.78s -> 1253.30s]  for example, here, when I come down to x is equal to NumPy array of one, two, three,
[1253.30s -> 1259.22s]  that's a list in only one dimension. Versus, for example, z, this is z down here,
[1259.86s -> 1264.98s]  that is what's called like a two-dimensional array, because you have both rows, for example,
[1264.98s -> 1270.98s]  like six comma seven, and then you have eight comma nine, versus in this first one,
[1270.98s -> 1275.70s]  you only have three values in one dimension. So, that's sort of the conventional difference
[1275.70s -> 1279.78s]  between the two. Another convention is matrices generally refer to two-dimensional objects. So,
[1279.78s -> 1283.94s]  this, as I mentioned, is like z, this is two-dimensional. You might have heard the word
[1283.94s -> 1288.82s]  tensor also. Tensors, by convention, usually are like higher dimensional objects. So,
[1288.90s -> 1293.30s]  instead of having two dimensions, you know, two comma two, you can have like n dimensions. You
[1293.30s -> 1297.70s]  can have two comma two comma two comma two comma two for like five or six dimensions.
[1298.34s -> 1303.30s]  And those are very valid to do mathematical operations on, and those are often colloquially
[1303.30s -> 1308.10s]  sort of called tensors. In addition, and this will be covered in the next tutorial,
[1308.10s -> 1315.94s]  in PyTorch, those larger sort of tensors are also optimized for efficiency to be used on GPUs,
[1315.94s -> 1320.26s]  and so they're called tensor in a more concrete way, because you're using these tensors with
[1320.26s -> 1325.06s]  PyTorch and other sort of packages to directly do those quicker GPU operations on for deep
[1325.06s -> 1329.38s]  learning. So, this is sort of, this is a quick sort of terminology difference between the three.
[1330.82s -> 1335.46s]  Okay, so now let's start off with just some quick sort of representations of how are these
[1335.46s -> 1340.50s]  matrices and vectors represented in NumPy. This sort of goes back to your question about
[1340.50s -> 1344.90s]  like what is the difference between like three comma versus like one comma three.
[1345.78s -> 1352.26s]  So, usually three comma in NumPy arrays usually just means that you have one list of like one,
[1352.26s -> 1357.14s]  two, three, for example, of like three values versus if you add another list on top of that,
[1357.78s -> 1362.26s]  this one comma three essentially refers to the fact that there's a list of lists. So,
[1362.26s -> 1367.86s]  anytime you have two dimensions, it always means that there's a list of lists, and that being
[1367.86s -> 1372.34s]  like a list of lists, for example, like a row. So, here one comma three means that there's one
[1372.34s -> 1377.70s]  row and then three columns. So, it's saying there's one row of three comma four comma five
[1377.70s -> 1383.14s]  essentially, and then each of those is like a column separately. You can easily reshape them.
[1383.14s -> 1387.86s]  So, these are basically the same format, but from NumPy's perspective, you'll see a little bit
[1387.86s -> 1392.42s]  later for operations such as broadcasting, you need to have it, for example, sometimes in this
[1392.42s -> 1398.02s]  one comma three format or three comma one format. Um, and also like what like as I said
[1398.02s -> 1402.42s]  three is just like it represents three numbers. One comma three means like one row of
[1402.42s -> 1407.62s]  three elements. Three comma one will mean you have essentially in each column you'll have a
[1407.62s -> 1411.94s]  separate array. So, you'll see sort of boxes around each of them. There's an example that
[1411.94s -> 1414.98s]  comes a little bit later in this collab which will make it a little bit more clearer.
[1414.98s -> 1419.14s]  So, here if you can see the difference between like x and y, one of them has only one
[1419.14s -> 1425.30s]  bracket which just says it's one list, only one list of one comma two comma three. The second one
[1425.30s -> 1431.06s]  is two brackets which says it's a list with only one list in it. It's a list of a list. That's
[1431.06s -> 1435.70s]  really the main difference between like these sort of two representations. So, I could have like
[1435.70s -> 1445.14s]  let's say like a separate one. I'm going to call this a and I just do this. So, it's the
[1445.14s -> 1450.82s]  same sort of elements but this will be one comma three because it's showing that there's one outer
[1450.82s -> 1455.38s]  list which shows the rows and then one inner list which we like to have each of those values.
[1456.42s -> 1460.18s]  So, the benefit will come when I'm coming to what a little bit later which is broadcasting
[1460.18s -> 1464.66s]  and so it essentially will help you determine what dimensions you want to match against because
[1464.66s -> 1470.90s]  sometimes you want to have one comma three like one comma two comma three applied only two
[1470.90s -> 1475.14s]  rows in some other matrix. We'll come to that a little bit later but sometimes you might want
[1475.14s -> 1480.10s]  to have it only applied to columns and so like if I have a separate matrix for example of zero
[1480.10s -> 1484.82s]  zero zero zero zero zero zero zero and I want the resulting matrix to be for example
[1484.82s -> 1488.02s]  one two three one two three one two three along the rows. Let me actually draw this out,
[1488.02s -> 1495.94s]  it might be easier. So, let's say I have like the zero zero zero zero zero zero zero zero
[1496.74s -> 1504.58s]  and if I want to have a matrix that does one two three one two three one two three versus
[1505.62s -> 1512.82s]  one two three one two three one two three the difference in how to generate these two
[1513.78s -> 1517.30s]  will be the difference in the shape like how you represent their shape. It's the same
[1517.30s -> 1522.42s]  one two three but the resulting array you're generating by repeating the one two three values
[1523.22s -> 1526.50s]  requires a difference in shape and so we'll come to that a little bit later because this process
[1526.50s -> 1529.94s]  of how do you generate these arrays is called broadcasting but that's the real benefit of
[1529.94s -> 1533.22s]  having an understanding of the shapes. The same one two three values are the same,
[1533.22s -> 1535.86s]  it's just how they're sort of used with regards to other arrays.
[1536.82s -> 1540.50s]  All right so yeah vectors can be easily represented as sort of and this is what I talked
[1540.50s -> 1544.66s]  about earlier as like n dimensions n by one or one by n dimensions and they can
[1544.66s -> 1547.54s]  resolve in this different behavior kind of what like this that I talked about.
[1548.26s -> 1552.42s]  Matrices are usually in two dimensions represented as m by n. These are just two
[1552.42s -> 1555.62s]  examples that for example I generate let's say and then you can also reshape so
[1555.62s -> 1561.14s]  I start with for example this array which is a list of ten oh sorry I need to import them by
[1561.14s -> 1568.66s]  quickly. So I started off with this matrix a which is basically a one-dimensional list of
[1568.66s -> 1573.22s]  ten values. I can reshape it into a five by two matrix so you just have to make sure that
[1573.22s -> 1577.94s]  your dimensions match which means that like you can multiply them together and get the original
[1578.50s -> 1582.34s]  size. So if I start off with the ten matrix I can make a two by five matrix, I can make a
[1582.34s -> 1586.82s]  five by two matrix, I can make a ten by one, one by ten. I can't make a for example three
[1586.82s -> 1591.22s]  and five because that it wouldn't fit into the original size. And for that this operation
[1591.22s -> 1595.86s]  called reshape is really useful. You might be wondering why is there two parentheses.
[1595.86s -> 1600.26s]  The way that reshape works is essentially it'll take in a tuple. So remember that what I
[1600.26s -> 1603.30s]  was talking about earlier with tuples is that these they're immutable objects and they're
[1603.30s -> 1607.86s]  defined by parentheses. So the outer parentheses is representing what you're inputting to the
[1607.86s -> 1612.02s]  function and what you're inputting is a tuple so it uses the second set of parentheses.
[1612.98s -> 1618.42s]  So now let's go to some array operations. So I started off with you know this array x.
[1619.54s -> 1624.26s]  When you apply simple operations for example a max operation sometimes you might want the max of
[1624.26s -> 1628.02s]  the entire array. So if I do the max of in the entire array what's the max value of the
[1628.02s -> 1634.26s]  entire array by the way? Just the entire thing. Yeah six right. So if I just do np.max of x
[1634.26s -> 1639.46s]  it'll return one value it'll return six. Well let's say I want the max of every row right like
[1639.46s -> 1643.54s]  in every in each of these rows I say I want let's say the max of each row I want two and
[1643.54s -> 1648.90s]  then four and then six. How do you do that? And so NumPy always has like usually in most
[1648.90s -> 1653.70s]  of their functions an axis variable. And what the axis variable will do is it'll tell you
[1653.70s -> 1658.50s]  which of these dimensions do you want to take the max over. And the way to sort of think about
[1658.50s -> 1663.46s]  it is this is going to be a little bit tricky but the way people describe it is the axis is
[1663.46s -> 1669.22s]  what you want to apply your function over what you want to reduce over. And what that means is
[1669.22s -> 1674.74s]  I print out the shape of the original array it's three by two. I want to apply axis one
[1674.74s -> 1678.98s]  where as I remember you know NumPy is zero index it'll be zero one so I want to apply the
[1678.98s -> 1685.14s]  max over the second dimension. The second dimension means that for each of these essentially
[1685.70s -> 1690.26s]  you know that like for like the row dimension is the first dimension so it's not around
[1690.26s -> 1694.82s]  along the rows I'm going to be comparing columns. And so compare this entire column to
[1694.82s -> 1701.94s]  this entire column. And so just remember for axes usually the axis zero refers to the row axis
[1701.94s -> 1706.02s]  and the axis one refers to the column axis. If you don't even want to remember that you
[1706.02s -> 1709.78s]  can just remember that from the original dimension which of these it's referring to.
[1711.14s -> 1716.34s]  And that's the dimension you want to compare over or reduce over. So it can be a little bit
[1716.34s -> 1720.90s]  harder to grasp around it usually the best way to sort of get around it's like just play with
[1720.90s -> 1725.70s]  a bunch of sort of operations of min max and things like that. But just remember like the
[1725.70s -> 1731.14s]  axis is what you want to compare over not the resulting thing. So axis one means your column
[1731.14s -> 1735.54s]  I want to compare between the columns. I want to get for example compare one to two, three to four,
[1735.54s -> 1745.38s]  five to six. Does that make sense? Okay. And what this will do is if I just do numpy.axis it'll
[1745.38s -> 1749.54s]  just return basically since I'm comparing these columns it'll just return a resultant column.
[1750.18s -> 1754.82s]  And so as I mentioned you know for over the axis one you get three values because you're
[1754.82s -> 1758.98s]  comparing over these columns and each column has three values. I'm comparing over rows as you
[1758.98s -> 1764.02s]  mentioned I get two values right. And so this will just be the tuple comma which is just
[1764.02s -> 1768.18s]  indicating that it's just a list it's not a list of lists it's just a list. But let's say I want a
[1768.18s -> 1772.10s]  list of lists you know maybe I want to do those operations I talked about earlier. Instead
[1772.10s -> 1776.90s]  of reshaping which is always there it's always an option you can also use this feature
[1776.90s -> 1782.18s]  called keep dims. And what that'll do is it'll take the original dimensions which is two
[1782.18s -> 1786.26s]  dimensions right because you have three comma two there's two of them and it'll keep that
[1786.26s -> 1792.50s]  consistent. So it'll be three comma one. But it just means that instead of returning just the
[1792.50s -> 1797.86s]  extracted column which is just a list it'll basically keep the column in the context
[1797.86s -> 1802.18s]  of the original sort of x and it'll be it'll keep it as like a two-dimensional value.
[1804.42s -> 1811.86s]  All right now these are just some operations so in numpy um you can use an asterisk as
[1811.86s -> 1816.42s]  uh an element wise multiplication. So an asterisk means that I'm going to be comparing every single
[1816.42s -> 1821.38s]  value um to every single corresponding value in another matrix. And it's you need your
[1821.38s -> 1825.46s]  matrices to also be the same size for this one. So this one it's basically an element wise matrix
[1825.46s -> 1828.90s]  it's not a matrix multiplication so you need to have them be the exact same size. So this
[1828.90s -> 1832.82s]  will compare for example one into three, two into three, three into three, and four into three.
[1834.10s -> 1839.38s]  All right um you can also do matrix multiplication which is a different operation entirely.
[1839.38s -> 1844.74s]  Um for those of you unfamiliar with matrix multiplication um you would basically be
[1845.46s -> 1850.74s]  multiplying a row of one matrix with a column of another matrix. And for that to be necessary
[1850.74s -> 1855.14s]  you need to have the second dimension of the first array be equal to the first dimension of
[1855.14s -> 1866.98s]  the second array. So for matrix multiplication if I have an a into b comma b into c um shaped
[1866.98s -> 1871.22s]  matrices these two have to be equal for matrix multiplication. Just something to keep in mind
[1872.02s -> 1876.74s]  because oftentimes if you're doing matrix multiplication um you need you have to make
[1876.74s -> 1879.38s]  sure these dimensions are the same. Which means that for example
[1884.42s -> 1888.82s]  this is a valid operation um but this can sometimes throw an error.
[1891.54s -> 1895.14s]  Sometimes. So it's just important to make sure that sometimes you you want to make sure
[1895.14s -> 1898.18s]  these are exactly equal. You can actually just print out the shapes and make sure
[1898.18s -> 1902.02s]  that these are equal to be doing matrix multiplication. And then for matrix multiplication
[1902.98s -> 1909.70s]  there's a couple of functions you can use. The first one is just np.matmul which is np.matrix
[1909.70s -> 1914.90s]  multiplication. You can also just use the um the at operation and that one both of those
[1914.90s -> 1918.90s]  are overloaded you can choose whichever one they'll result in the same exact operation.
[1918.90s -> 1924.26s]  And just a quick session show you can to show what this will do is it'll multiply one into two
[1924.26s -> 1929.54s]  so it'll come like one two versus three four so it'll do one into three two into three
[1929.54s -> 1932.66s]  and add those two values. So that's what matrix multiplication will do.
[1935.14s -> 1940.58s]  Okay um and then dot products will what what a dot product is that it takes two vectors so
[1940.58s -> 1945.54s]  usually it operates on vectors. And a vector as I mentioned is just like a one dimensional
[1945.54s -> 1948.66s]  matrix. So it's just basically three cross one for example four cross one.
[1949.22s -> 1953.54s]  It'll element wise multiply between two different vectors and will sum up those values.
[1953.54s -> 1957.70s]  And so here what a dot product would do would be like one into one plus two into ten plus
[1957.70s -> 1962.98s]  three into a hundred. And for a numpy you can just do np dot and then both of those vectors.
[1965.38s -> 1969.94s]  This one is just a side on how you would want the structure of the dot product to be.
[1971.30s -> 1977.94s]  For arrays that are more so okay so the phrase is the best way. For single dimensional
[1978.58s -> 1984.18s]  vectors this operation works directly. Anytime it's a multiple dimensional matrix
[1984.66s -> 1990.42s]  then it treats it as a matrix multiplication the np dot dot function. So for two by two matrix
[1990.42s -> 1994.90s]  versus a two by two matrix dot product it's not going to return the sum it's going to return
[1995.86s -> 1999.86s]  the matrix multiplication. Now that's just something to keep in mind. If you want to make sure
[1999.86s -> 2006.02s]  that your your dot product is happening in the correct way you would want to make sure
[2006.02s -> 2013.46s]  that sort of similar to what I was talking about earlier that here I think this way
[2014.02s -> 2022.50s]  to show it. Okay so you would want the second like the what I mentioned like the last dimension
[2022.50s -> 2025.70s]  of the first one to match with the first dimension of the next one because it's treating
[2025.70s -> 2031.86s]  it as like a matrix multiplication. Here the error that it's throwing is it's three comma two
[2031.86s -> 2037.94s]  combined with three and so the way to sort of like fix that would be to have this be like
[2037.94s -> 2044.50s]  for example like switch the two so you'd have two comma three and then three comma. It's really
[2044.50s -> 2049.86s]  a dimension matching thing at this point so it's it can be a little bit confusing but when you
[2049.86s -> 2053.46s]  sort of the main thing to keep in mind is like for single dimensional vectors you can just
[2053.46s -> 2057.14s]  do np dot dot directly and it'll give you the dot product value. For higher dimensional
[2057.14s -> 2063.22s]  matrices it treats it as a matrix multiplication and so for if you still want to like for those
[2063.22s -> 2067.14s]  higher dimensional values to ensure that you're getting a dot product you would have to make
[2067.22s -> 2073.22s]  sure that the dimensions are aligned similar to these. So anything that's two by two plus for
[2073.22s -> 2078.18s]  both um any any any matrix who doesn't have a single dimension in any of them yes it would
[2078.18s -> 2087.06s]  treat it as a matrix on uh matineal the same thing. Okay all right um okay I'm going to move
[2087.06s -> 2091.86s]  to indexing so similar to what I was talking about earlier remember with lists I was saying if
[2091.86s -> 2096.82s]  you just do the semicolon it'll create like the same array same deal here the semicolon just
[2096.82s -> 2101.14s]  means you take everything from the original array in fact it returns a copy so it returns
[2101.14s -> 2106.18s]  a deep copy means that you have a complete separate copy in memory. Okay now I'm going
[2106.18s -> 2111.38s]  into sort of more details about how do you want to index quickly so if I for example have
[2111.38s -> 2116.58s]  let's say this three by four matrix and I only want to select the zero and the second rows how
[2116.58s -> 2121.38s]  would I do that? So what's useful is that you can sort of treat in numpy you can treat
[2121.38s -> 2126.58s]  different dimensions differently for indexing so a semicolon means you select everything in that
[2126.58s -> 2130.26s]  dimension which for example here there's a semicolon in the second dimension which means
[2130.26s -> 2136.18s]  I'm taking all of the column values versus what's in the first dimension here it's saying
[2136.18s -> 2141.30s]  a numpy array of zero and two so it's saying only the zero index and only the two index which
[2141.30s -> 2147.30s]  means only the zeroth row and only the second row so what this would look like would be
[2147.30s -> 2151.06s]  something like I have a matrix
[2155.38s -> 2160.26s]  okay I have a matrix and I only want to select the zeroth row and I only want to select the
[2160.26s -> 2169.70s]  column the second row zero and second and everything in the columns all right and then
[2169.70s -> 2174.66s]  similarly for example if I want to select in the column dimension I want to select the first
[2174.66s -> 2178.98s]  and second rows and only the first row I can do that so you can basically treat them separately
[2178.98s -> 2182.82s]  you can think how many columns do I want how many rows do I want and then index those
[2182.82s -> 2186.50s]  separately and that goes for as many dimensions as you want in your entire tensor
[2187.70s -> 2192.98s]  um so nice things also if I want to for example take it I have this like let me print
[2192.98s -> 2199.70s]  out actually x here I'll just generate the x okay so this is x right so if I want to take
[2199.70s -> 2205.46s]  all the values of x that are above 0.5 for example I can do that by using what's called
[2205.46s -> 2212.50s]  boolean indexing so I just basically will say x indexed by everything in x that's bigger than
[2212.50s -> 2216.58s]  0.5 so it's pretty direct and it'll just output all the values in this entire array
[2216.58s -> 2224.90s]  that are bigger than 0.5 all right um this one is also another way to do reshaping so I
[2224.90s -> 2228.58s]  kind of mentioned earlier you know sometimes you want have this like list of three elements
[2228.58s -> 2233.94s]  and you want to reshape it to a three by one array for example you can also use what's called
[2233.94s -> 2240.26s]  numpy dot new access this will essentially add another access in whatever dimension you want
[2240.26s -> 2245.78s]  so if I want to change go from like this three by four array to a three by three by four
[2246.66s -> 2251.86s]  two three by four by one then I can just add a numpy dot new access there
[2251.94s -> 2258.74s]  an even simpler way to think about it would be like a two comma to a two comma one and so
[2258.74s -> 2262.82s]  it's just it's another way to do what essentially would be the reshaping reshaping operation
[2265.06s -> 2268.50s]  does that make sense also what this would look like for example let me just
[2268.50s -> 2269.62s]  do a little bit more concrete
[2269.62s -> 2276.82s]  so it's basically I have this list right I have like a singular list and each in in that list
[2276.82s -> 2280.98s]  I have a list of lists so I have a list with element one and list of element two so this is
[2280.98s -> 2290.10s]  what that reshape operation will do and what numpy dot new access will enable you to do as well
[2290.74s -> 2293.30s]  and what numpy dot new access will enable you to do as well
[2295.46s -> 2302.34s]  all right um I think we're good time um so the last main topic we'll be covering
[2302.34s -> 2309.38s]  is broadcasting um and what's really great about broadcasting is it'll allow you to operate with
[2309.38s -> 2314.98s]  numpy arrays that are of different shapes but can be sort of if many operations in them can
[2314.98s -> 2318.58s]  be repeated it allows for that in a very efficient manner and this is actually one of
[2318.58s -> 2322.10s]  the most I would say useful things about numpy and one of its defining features
[2322.10s -> 2327.22s]  and what that means is um if for example in this case right if we go back to this example
[2327.22s -> 2333.94s]  that I had with I start off with the zero zero zero array how do I generate this array
[2334.74s -> 2342.34s]  versus how do I generate this array right instead of me saying okay element zero zero plus one
[2342.90s -> 2347.22s]  element zero one plus two all that stuff right instead of doing that one by one
[2347.94s -> 2355.78s]  what broadcasting allows me to do is I can have only one vector of size one two three and it'll
[2355.78s -> 2360.50s]  depending on how I do the broadcasting which I'll come to in a second I can duplicate it along
[2360.50s -> 2365.30s]  the row dimension or I can duplicate it along the column dimension and numpy allows for that
[2365.30s -> 2369.86s]  it'll do that on its own in the back end and so that's really what broadcasting means is
[2369.86s -> 2375.30s]  I don't need to for example create a new array saying I want to like create a new array to
[2375.30s -> 2379.78s]  begin with which is already like this and then add those two together I can just duplicate this
[2379.78s -> 2384.74s]  and get this all right so now some rules for broadcasting and let me just be visually also
[2384.74s -> 2392.66s]  just show what broadcasting will do oh sorry so broadcasting this is a pretty good visual
[2392.66s -> 2399.38s]  analogy um I have this one by one comma one comma two comma three vector right um and I
[2399.38s -> 2406.34s]  want to basically add let's say only the columns with this one comma two comma three vector
[2406.34s -> 2410.34s]  so what broadcasting allows you to do is you'll you only pass these two values in
[2410.34s -> 2414.34s]  and on the back end it'll duplicate this along the column dimension so let's say
[2414.34s -> 2417.62s]  I have one two three one two three one two three one two three and then it'll do the addition
[2418.34s -> 2423.06s]  similarly if I pass it a vector one comma two comma three comma four
[2423.06s -> 2426.82s]  and I want it to be added to each of the rows instead of each of the columns
[2426.82s -> 2430.18s]  it'll be able to do that by sort of duplicating it on the back end so this is visually what's
[2430.18s -> 2437.46s]  happening with broadcasting all right now some rules so how does numpy know
[2438.10s -> 2442.74s]  when and how to do broadcasting so the main two rules to keep in mind with for broadcasting
[2442.74s -> 2448.18s]  is one um it can only happen if all of the dimensions every single dimension between two
[2448.18s -> 2453.86s]  arrays are compatible and when they say what is compatible either the dimension values are equal
[2454.50s -> 2460.50s]  or one of them is equal to one and that is the only rule required so for example I start off with
[2460.50s -> 2467.46s]  this x array right I have this like three by four x array um will y is equal to three comma
[2467.46s -> 2472.90s]  one be compatible yes it will be why because you have three in the first dimension between
[2472.90s -> 2477.22s]  the two which is the same and in the second dimension you have four and you have one so those
[2477.22s -> 2481.78s]  are compatible values and so what this tells numpy on the back end is I'm doing for example
[2481.78s -> 2486.26s]  an addition operation x plus y it knows that okay three and three are the same
[2486.90s -> 2492.10s]  but four and one are not the same you know one of them has one dimension so I need to duplicate
[2492.10s -> 2497.38s]  this y along the second dimension which means I need to duplicate it along the column dimension
[2497.38s -> 2501.62s]  and once it does that it duplicates it it'll get four three comma four an array and then
[2501.62s -> 2505.70s]  it can do the addition and it does that really fast so it's better to use broadcasting in this
[2505.70s -> 2509.86s]  way but then for you to create a separate array already duplicated and then add them
[2511.78s -> 2518.90s]  similarly I have this z array which is one comma four what x into z will do is first of all check
[2518.90s -> 2523.38s]  okay three comma one okay is that compatible yes because you have three in one dimension you
[2523.38s -> 2527.62s]  have one in the second and four and four are compatible okay so say I know that these
[2527.62s -> 2531.46s]  are compatible in the second dimension I need to change anything in the first dimension it'll
[2531.46s -> 2537.70s]  know to duplicate them basically so you don't have to duplicate z and so add it three times
[2537.70s -> 2543.14s]  in the row dimension create a separate array and then multiply those two so this is giving
[2543.14s -> 2547.62s]  you an example of saying I started off with x I have y then the final shape will be three
[2547.62s -> 2554.18s]  comma four so a lot of times in deep learning you will have the same basically you'll have
[2554.18s -> 2559.54s]  different batches of different images coming in but you want to apply let's say the same
[2559.54s -> 2564.74s]  weight matrix to all of them and instead of duplicating that weight matrix 100 or
[2564.74s -> 2567.94s]  even like potentially depending on the size of your batch size like a thousand times
[2568.50s -> 2573.06s]  and then adding those together you use the same matrix and it'll know okay if I'm gonna be
[2573.06s -> 2577.30s]  duplicating over the batch dimension it'll do that for you on the back end so it's used a
[2577.30s -> 2580.98s]  lot of times in deep learning because of this and basically in your second homework that's
[2580.98s -> 2584.98s]  basically what you'll be doing we'll be implementing a feed for all network in numpy
[2585.54s -> 2590.02s]  and it'll say you have like this w matrix you have this like b matrix which is a by
[2590.02s -> 2594.02s]  we'll come to those in class and it'll ask you to implement them in numpy because that's
[2594.02s -> 2597.54s]  basically what you're doing is that you have this input image you have a weight matrix which
[2597.54s -> 2602.34s]  will somehow scale it to an output and that weight matrix will be applied to multiple
[2602.34s -> 2606.02s]  images in your batch and those images can be different but their sizes will be the same and
[2606.02s -> 2613.22s]  it's optimized for that okay so this is just more examples of sort of the same thing your
[2613.22s -> 2619.30s]  final thing that you'll be coming to is the size of three comma four let's see this one's
[2619.30s -> 2623.46s]  sort of the example that I showed right here right which is that I have this array of
[2623.46s -> 2628.42s]  like say zeros I have this numpy like this b array of size what size would this be
[2628.98s -> 2633.94s]  yes good because you have one outer list and inside this you have one inner list so it's
[2633.94s -> 2639.86s]  just basically one row and then three values inside so yes and so would this be compatible
[2639.86s -> 2644.10s]  yes and so no basically to duplicate um over the row dimension and so you're going to get
[2644.10s -> 2647.38s]  duplicates in the row dimensions you're going to get one two three one two three one two
[2647.38s -> 2652.10s]  three and that's what's happening here um so these are for example a little bit sometimes
[2652.10s -> 2656.90s]  when it says more complex um behavior what this basically just means is that like
[2656.90s -> 2663.62s]  if I have this b vector which is three comma one um if I'm doing this b plus b dot transpose
[2663.62s -> 2666.74s]  by the way transpose is just changing the dimensions it's switching them so if I have
[2666.74s -> 2671.78s]  a two by three matrix uh transpose will be a three by two matrix um what that means visually
[2671.78s -> 2677.22s]  is something like your row and rows and like column dimensions will get switched
[2677.22s -> 2686.10s]  six goes to I believe it's like one two three and four five six so like three
[2686.10s -> 2692.82s]  rows versus like three columns um and what this is just saying is that oh a three by one
[2692.82s -> 2697.06s]  and a one by three um both of those vectors will be compatible because remember in each
[2697.06s -> 2702.98s]  dimension it's either the same or one and so it knows to duplicate uh over both of those
[2702.98s -> 2710.02s]  dimensions and that's what's happening here uh okay so I think we are right at time um
[2710.02s -> 2714.58s]  and what I would recommend is basically playing with variations of this for broadcasting and see
[2714.58s -> 2719.30s]  just remember the two rules for broadcasting is just if it's compatible it's either the same
[2719.30s -> 2723.30s]  value or it's one and whatever is the one dimension is what's going to be duplicated over
[2723.30s -> 2727.06s]  on the back end so yeah it's not going to be compatible if they're divisible for example
[2727.06s -> 2732.74s]  right so if you have like let's say six and three that's not compatible um you can reshape it
[2732.74s -> 2737.46s]  and then see if you'd like to have one there's tricks you can use um where you're sort of
[2737.46s -> 2741.22s]  thinking like on the back end how do I want this data to be multiplied you can maybe reshape
[2741.22s -> 2745.38s]  everything into like an eight one like one by 18 matrix and then multiply everything and then
[2745.38s -> 2749.38s]  reshape it back that's what you can do but you can never just directly for example six by
[2749.38s -> 2755.54s]  three make that compatible okay um so I think let's wrap up this one's just a quick example
[2755.54s -> 2762.34s]  of another use of efficient numpy code um quick note never preferably don't use uh loops
[2762.34s -> 2767.78s]  whenever you're dealing with large data matrices mostly because loops are almost always about a
[2767.78s -> 2772.98s]  hundred times slower um numpy is usually very very efficient as this is just an example of
[2772.98s -> 2777.62s]  what you can accomplish um with numpy and the same thing using loops so what this is saying
[2777.62s -> 2782.98s]  is that I have an x matrix of size thousand by thousand and I want to apply you know let's say
[2782.98s -> 2789.06s]  I want to add everything from row hundred onwards um with plus five so visually what that will
[2789.06s -> 2797.62s]  look like is something like I have this full matrix and I want everything here basically
[2797.62s -> 2803.94s]  to be add with plus added with plus five um then in in the loop format I can basically loop over
[2803.94s -> 2808.66s]  the first dimension of hundred plus and do that or in numpy I can basically do what's called
[2808.66s -> 2813.46s]  numpy dot a range which will generate um integers in like basically one two three four five six all
[2813.46s -> 2817.30s]  the way up to that hundred value in this case it's between hundred and thousand so start with
[2817.30s -> 2820.98s]  hundred hundred one hundred two all the way to thousand in the first dimension and then just
[2820.98s -> 2826.10s]  add that with five so this is just an example of how you would switch from using loops to using
[2826.10s -> 2828.18s]  numpy and it's a lot less faster
