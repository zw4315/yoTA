# Detected language: en (p=1.00)

[0.00s -> 6.00s]  And can everybody see my screen or the whiteboard that I shared?
[6.00s -> 7.00s]  Yeah.
[7.00s -> 8.00s]  Okay, good.
[9.00s -> 12.00s]  How are people doing with the log lab?
[12.00s -> 21.00s]  Let me start there and just ask how progress is and whether it's more difficult or it's looking okay.
[21.00s -> 25.00s]  Anybody want to sort of report in their experience so far?
[31.00s -> 33.00s]  I hope lots of people have started.
[39.00s -> 40.00s]  Yeah, go ahead.
[40.00s -> 42.00s]  Oh, sorry, go ahead.
[42.00s -> 44.00s]  Okay, cool.
[45.00s -> 47.00s]  I'll go, I'll go.
[47.00s -> 58.00s]  The log lab, I think the first part, the K-log was not as bad.
[58.00s -> 62.00s]  And then the second part was a bit harder.
[62.00s -> 64.00s]  Well, it's a lot harder in my opinion.
[66.00s -> 79.00s]  You just have to figure out a, I guess the hard part was thinking of a solution that it's like, hey, this doesn't cause deadlock.
[79.00s -> 90.00s]  But then you think there are cases where like deadlock could happen if you acquire a buckets lock again and all that stuff.
[90.00s -> 97.00s]  But yeah, I just have to think, you have to think like about extra cases and all that stuff.
[97.00s -> 99.00s]  And after that, it shouldn't be that bad.
[100.00s -> 104.00s]  Anybody else who want to share their experience so far?
[104.00s -> 109.00s]  I wanted to ask, are we allowed to do any part of the lab like lock-free?
[109.00s -> 117.00s]  Because I know like their first part, for example, is pretty, the instructions said pretty clearly like make apparel memory allocator.
[117.00s -> 123.00s]  But can we do it just lock-free and sync, you know, leave it as it is?
[123.00s -> 129.00s]  You're free to do any solution that passes make great is fine.
[130.00s -> 134.00s]  Lock-free, I would be, you could certainly be free to do it.
[134.00s -> 136.00s]  I'd be hesitant to start there.
[136.00s -> 143.00s]  If I were you, I would start first with a more fine grained lock implementation and then move to a lock-free implementation.
[145.00s -> 151.00s]  The reason I started with a lock-free is because if you go to a fine grained, you need to do all of the parallel stuff.
[151.00s -> 156.00s]  But if you just go directly to a lock-free one, then you can keep it on a single free list.
[156.00s -> 163.00s]  And you just need to, you just need to automatize the free and allocate operations.
[163.00s -> 165.00s]  So it actually isn't that bad.
[165.00s -> 170.00s]  Yeah, I think there may be in, if there's a single list in the case of the K-alloc, that might be the case.
[170.00s -> 174.00s]  I think, you know, the lock-free B-alloc is going to be a little bit more complicated.
[174.00s -> 177.00s]  Yeah, that I'm scared to do.
[177.00s -> 179.00s]  That's the right reaction to have.
[181.00s -> 183.00s]  Anybody else?
[184.00s -> 190.00s]  I found it a bit hard to debug those problems because it's not immediately clear what is happening.
[190.00s -> 196.00s]  So we have to go and sit with GDB and break, break, break.
[196.00s -> 198.00s]  And yeah.
[198.00s -> 205.00s]  Yeah, I think the one reason I'm always scared to get these lock lapses, you know, they're harder to debug.
[205.00s -> 210.00s]  And, you know, the bug might not show up in every run.
[210.00s -> 219.00s]  And, but hopefully it is very educational because like learning or programming locks inside of a kernel is a real thing.
[219.00s -> 223.00s]  But it is definitely a core challenge.
[223.00s -> 233.00s]  One thing about the, maybe this is a node for the, encouraging node, the NextLab actually doesn't involve basically any concurrency.
[233.00s -> 237.00s]  And so hopefully that will be much, much, much more straightforward.
[238.00s -> 240.00s]  Okay.
[240.00s -> 250.00s]  I guess, how do you, how do you efficiently or effectively debug concurrent programs like with all those multiple threads using GDB?
[250.00s -> 253.00s]  I use very basic stuff.
[253.00s -> 256.00s]  I have, I use print statements.
[256.00s -> 265.00s]  But the main thing I rely on is I sort of try to write down or assertions for invariants that I think should be true at every point.
[265.00s -> 272.00s]  And if the assertion goes off, then I know that, you know, there was something wrong in my thinking or the assertion was wrong.
[272.00s -> 279.00s]  And then I think for a while and try to decide what it is and then go from there.
[279.00s -> 289.00s]  The normal, for many other settings, there are race detectors that can help you.
[289.00s -> 299.00s]  And again, basically flag code that looks like it might be having problems or is prone to race conditions.
[299.00s -> 304.00s]  But that's a whole set of other tools that we're not using.
[304.00s -> 311.00s]  And it's not that good, but there's a little bit of a big step to actually get that all up and going and running.
[311.00s -> 317.00s]  So that's the other mechanism that people use, race detectors.
[317.00s -> 324.00s]  And basically flag any any shared variable that is updated or read without actually holding a lock.
[324.00s -> 331.00s]  That doesn't help you with deadlocks, for example, in this lab, in the block, you know, you get deadlocks.
[331.00s -> 344.00s]  Deadlocks tend to be easier to debug, correct? Because you can you get the panic and then you can look at the backtrace and see actually what was involved in the deadlock.
[344.00s -> 350.00s]  Does that make sense? Thank you.
[350.00s -> 359.00s]  OK, another suggestion, actually, somebody posted on the feedback is, you know, the class attendance is getting a little bit lower than in the beginning of the semester.
[359.00s -> 366.00s]  And I think we might be small enough for the size that it may be perfectly fine to actually have cameras on.
[366.00s -> 372.00s]  And so maybe I want to encourage you to ask a question, to turn on your camera and, you know,
[372.00s -> 380.00s]  hopefully improve our experience as if it's in the classroom as opposed to in a virtual meeting.
[380.00s -> 385.00s]  And you don't have to look at me. OK.
[385.00s -> 393.00s]  So, OK, today's lecture. So today's lecture is going to be about crash safety, crash safety in file systems.
[393.00s -> 402.00s]  And this is not crash safety in more general form. I'm actually really focusing on a particular problem.
[402.00s -> 412.00s]  Or a specific problem, namely a crash or a power failure can meet.
[412.00s -> 424.00s]  On this cloud system. To be in an inconsistent state for an incorrect state.
[424.00s -> 435.00s]  And what I mean with an incorrect state is, for example, a data block belongs to two files or an iNote is allocated to two different files.
[435.00s -> 444.00s]  And so the scenario where this problem might appear is, let's say, you know, you're running make, make a pretty file system,
[444.00s -> 454.00s]  interacts with the file system, reads and writes files. And somewhere during that thing, a power failure happens.
[454.00s -> 465.00s]  You know, your laptop run out of battery, you know, maybe the power just dropped or to your house and you reboot.
[465.00s -> 471.00s]  The power comes back on at some point, you reboot the machine or the machine comes back up.
[471.00s -> 479.00s]  And then, you know, you get a prompt again, you run LS and you hope basically that your file system is in a good state.
[479.00s -> 488.00s]  In a state that actually can still use it. And so the particular failures or crashes that we're concerned about are basically power failures during file system operations.
[488.00s -> 494.00s]  Or the kernel panics, you know, while running some file system operation.
[494.00s -> 502.00s]  Xv6 is panics, most kernels are panics. You know, maybe there's some kernel bug that causes a panic and suddenly your system just fails.
[502.00s -> 506.00s]  What you'd like to be the case is that after reboot, you know, you can actually do something.
[506.00s -> 511.00s]  Or you can still use the file system. And this might be something where you're thinking, well, how could that not be?
[511.00s -> 515.00s]  Right, because the file system is stored on a persistent storage medium.
[515.00s -> 519.00s]  And so if the power fails, you know, the medium should be good.
[519.00s -> 523.00s]  And then so one machine comes back up, you know, all the blocks that you've written should be there.
[523.00s -> 531.00s]  And we'll see that the tricky case is that many file system operations have multi-step operations.
[531.00s -> 544.00s]  And really what is important in those multi, and if we crash just in the wrong place in these multi-step operations, the file system actually may end up being on disk inconsistent for that short period of time.
[544.00s -> 548.00s]  And if the power failure just happened there, you know, something bad could happen.
[548.00s -> 553.00s]  And so that is sort of the problem that we're focusing on today.
[553.00s -> 560.00s]  And so this is different from the problem that, for example, whatever, you know, there's a power failure and your disk caught fire.
[560.00s -> 568.00s]  And so there is nothing there anymore. And so you need to, in that case, you know, you need to, you need to, there's a completely different problem that has different solutions.
[568.00s -> 575.00s]  You know, for example, you have to go back to a backup of your file system or reinstall your file system, et cetera, et cetera.
[575.00s -> 586.00s]  So that's the problem we're not worried about. We're really worried about the specific problem of a failure happening right during a multi-step operation.
[586.00s -> 593.00s]  OK, and the solution for that specific problem that we're going to be exploring is something that is called logging.
[593.00s -> 606.00s]  This is a very popular solution originally coming out of the database world, but a lot of file systems use logging these days.
[606.00s -> 612.00s]  We're going to, it's a very, one reason it's popular is because it's a very principled solution.
[612.00s -> 616.00s]  And we're going to see the instantiation of logging in xv6.
[616.00s -> 626.00s]  And of course, xv6 has a very simple implementation, like a bare minimal implementation of logging, just to demonstrate the key ideas.
[626.00s -> 633.00s]  And even that very bare bone log implementation actually has some subtle issues that we're going to be talking about.
[633.00s -> 636.00s]  And that's why it's worth studying it.
[636.00s -> 646.00s]  One downside is we'll see if the xv6 solution is because of its simplicity, its performance is also not so great, even though logging systems in principle can get good performance.
[646.00s -> 660.00s]  And so what we'll do next week is actually look how to implement a high performance logging system by studying the logging system that the Linux ext3 file system uses.
[660.00s -> 662.00s]  But that's next week.
[662.00s -> 669.00s]  Another maybe small point I want to make today is that this is our last xv6 lecture.
[669.00s -> 685.00s]  And from now on, we're going to be switching to papers, because in some ways, what we've done is we sort of covered the basic concepts, and we can start looking at more advanced operating system ideas by reading papers.
[685.00s -> 687.00s]  Okay.
[687.00s -> 694.00s]  Any questions so far?
[694.00s -> 698.00s]  We're all good?
[698.00s -> 699.00s]  Okay.
[699.00s -> 707.00s]  So let me go back a little bit about the scenario that we're focusing about in this lecture.
[707.00s -> 727.00s]  So file systems or file system operations, like creating a file, writing a file, are multi-step disk operations.
[727.00s -> 744.00s]  And, you know, we saw that last week, or Monday, we talked about how create is implemented, like creating a file or writing to a file, we often see that, you know, the sequence of events is something of the sequence of steps are, you know, allocate an inode or mark the inode allocated on disk, then, you know, write the directory block that contains that inode.
[744.00s -> 747.00s]  So those are the multi-steps that I'm talking about.
[747.00s -> 765.00s]  And if we get a crash between two of these steps, that crash can leave, may leave the file system invariance violated.
[765.00s -> 777.00s]  And the invariance I'm talking about are invariance of the form, you know, every block is either free or allocated to one file and not to two files.
[777.00s -> 787.00s]  And, you know, we want to make sure that this happens despite, you know, these failures right between these operations.
[787.00s -> 798.00s]  And the risk is, if these invariance are violated, then, you know, bad things can happen after reboot.
[798.00s -> 813.00s]  You know, you might crash again immediately, because, you know, there's some data structure that the file system is now in a state that the file system actually can't really deal with, you know, on this data structure in such a shape that the file system really can't process them anymore.
[813.00s -> 821.00s]  Or more likely, you're not crash, no crash, but, you know, data may get lost.
[821.00s -> 833.00s]  Or you read or write incorrect data.
[833.00s -> 836.00s]  And we'll see a couple of examples to make it more clear.
[836.00s -> 842.00s]  But so this is sort of the risk that we're worried about.
[842.00s -> 858.00s]  I don't know of anybody actually ever in personal life or like in your daily life using computers actually has experienced this problem where basically you had a failure in the file system or you had a failure, you had a power failure, you know, your machine rebooted or your phone restarted.
[858.00s -> 862.00s]  And that basically was unusable afterwards.
[862.00s -> 877.00s]  And one reason that might be unusual because the file system just didn't recover correctly.
[877.00s -> 883.00s]  Okay, so to make it more clear, let's look at an example in the context of XV.
[883.00s -> 892.00s]  To make this risk a little bit more concrete, let's look at an example in the context of XV6 and to see what actually could go wrong.
[892.00s -> 901.00s]  So remember, from Monday the XV6 file system, very simple file system, has a simple disk layout.
[901.00s -> 908.00s]  You know, the super block, there's the log that we're going to be talking about a lot today that we didn't talk about on Monday.
[908.00s -> 914.00s]  There are inodes, you know, a set of blocks that actually contain each and each block may contain multiple inodes.
[914.00s -> 918.00s]  Bitmap block to record which blocks are free and which are not free.
[918.00s -> 924.00s]  And then the data blocks that actually contain the actual data of the file system.
[924.00s -> 931.00s]  And remember from Monday's lecture, I reproduced the trace here, you know, we looked at actually how a file is created.
[931.00s -> 946.00s]  And, you know, we see that the creation of a single file, the creation of a single file consists of multiple operations.
[946.00s -> 958.00s]  So for example, like in this particular scenario that I have here on the slide, we see that, you know, an inode is allocated.
[958.00s -> 962.00s]  And, you know, we know this because this block 33 is being written.
[962.00s -> 967.00s]  We see that the inode is being initialized and then written again to block 33.
[967.00s -> 970.00s]  Then we see the block 46 is written.
[970.00s -> 979.00s]  And the reason it's written is presumably because, you know, the directory block that actually contains X and the inode number for X is written to the disk.
[979.00s -> 988.00s]  Then the root inode is updated to reflect that the directory has grown in size to contain this particular file X.
[988.00s -> 991.00s]  And then, you know, the inode is updated.
[991.00s -> 998.00s]  And so what we want to now understand is like what happens, like what could possibly go wrong?
[998.00s -> 1005.00s]  And so let's say, you know, we have a power failure like right here.
[1005.00s -> 1010.00s]  So here is a power failure or kernel crash.
[1010.00s -> 1014.00s]  And so what happens after the power failure?
[1014.00s -> 1024.00s]  All the in-memory state is lost because that in-memory state, the data that's actually in RAM, like all the processes, all the file descriptors,
[1024.00s -> 1029.00s]  all the in-memory caches are gone because, you know, memory is not persistent.
[1029.00s -> 1033.00s]  And the only thing that we have left is what actually is on the disk.
[1033.00s -> 1046.00s]  So only the data structures and the bits and bytes that are actually sitting on the disk survive the power failure because that actually medium is, you know, persistence.
[1046.00s -> 1048.00s]  It has durability.
[1048.00s -> 1050.00s]  And so we want to know, like, we understand.
[1050.00s -> 1060.00s]  So if we crash here and we have no additional mechanisms or we have no logging, as I've said, that we're going to be talking about, but we have no additional mechanisms.
[1060.00s -> 1063.00s]  How bad is it?
[1063.00s -> 1073.00s]  What risk are we running here?
[1073.00s -> 1077.00s]  Anybody?
[1077.00s -> 1083.00s]  So basically, you know, we've written block 33 to record that the inode has been allocated.
[1083.00s -> 1092.00s]  Then we had a power failure and then we come back up.
[1092.00s -> 1093.00s]  Go ahead, Brandon.
[1093.00s -> 1098.00s]  Does that mean we lose the lose this block?
[1098.00s -> 1102.00s]  It's like it seems like it's populated, but it's actually not.
[1102.00s -> 1114.00s]  Yeah, I think we're losing the whole block, but we use the inode X, the inode X or the inode for X that was allocated or the mark was allocated is allocated on disk.
[1114.00s -> 1121.00s]  But we have not put it in any we've not succeeded in putting it in any directory.
[1121.00s -> 1126.00s]  So basically on the disk, you know, there's an inode allocated, but it doesn't appear in any directory.
[1126.00s -> 1128.00s]  So we can't even remove it.
[1128.00s -> 1137.00s]  And so basically what will this cause us to happen is we lose an inode.
[1137.00s -> 1141.00s]  Does that make sense?
[1141.00s -> 1145.00s]  So you might think, well, maybe what I should do is like maybe I should reorder the writes.
[1145.00s -> 1149.00s]  And in a way, you know, then hopefully, you know, this, you know, we don't lose the inode.
[1149.00s -> 1158.00s]  So for example, another thing we could try doing is say, well, what we'll do is we'll write 46 first.
[1158.00s -> 1176.00s]  If we update the inode, update the directory, write the directory inode, write 32, and then we'll actually mark the inode as allocated on disk to mark it as allocated.
[1176.00s -> 1185.00s]  So we do the same set of operations in a slightly different order in the hope that we should avoid this losing of the inode problem.
[1185.00s -> 1191.00s]  And would this work?
[1191.00s -> 1195.00s]  Well, the thing that we should do to ask ourselves, like, you know, let's think about this point in time.
[1195.00s -> 1202.00s]  Let's say a crash happens like right here or our failure happens right between updating the directory, basically.
[1202.00s -> 1210.00s]  But before we allocated the inode on disk. And now, you know, power fails, machine comes back up, and we look at the file system.
[1210.00s -> 1215.00s]  You know, what state will the file system be in?
[1215.00s -> 1219.00s]  It'll still think it's a free inode.
[1219.00s -> 1230.00s]  Yeah, but what would happen if, for example, we read the file X in the directory, in the root directory, because it is in there now, correcting the data block.
[1230.00s -> 1235.00s]  We're going to be reading the inode that actually is not even allocated, correct, it's marked unallocated.
[1235.00s -> 1242.00s]  And worse, what could happen is, correct, that inode might be allocated again, or it might actually really be allocated,
[1242.00s -> 1247.00s]  because the mark is unallocated to actually, in fact, a different file.
[1247.00s -> 1255.00s]  And so now we have two files that might actually, two files that actually share, even though they're completely different, they share the same inode.
[1255.00s -> 1263.00s]  And so, for example, if one file would be owned by user 1 and one by user 2, then basically user 2 could read user 1's data, correct?
[1263.00s -> 1271.00s]  So that's no good either, correct?
[1271.00s -> 1274.00s]  Does that make sense?
[1274.00s -> 1279.00s]  So basically, switching the order is not really going to solve our problem.
[1279.00s -> 1283.00s]  You would just basically get a different problem than we had before.
[1283.00s -> 1286.00s]  Okay, let's look at one more example.
[1286.00s -> 1295.00s]  Here's the example of writing through the file X.
[1295.00s -> 1300.00s]  So once we have the files allocated, let's say that all succeeded, and now we're executing the write system call.
[1300.00s -> 1305.00s]  And the write system call also does multiple writes operations, as we saw on Monday.
[1305.00s -> 1309.00s]  For example, it will allocate a block, in this case, block 45.
[1309.00s -> 1312.00s]  So it sets a bit in the pre-map.
[1312.00s -> 1318.00s]  The block 45 is the bitmap block, so it allocates a block in the bitmap.
[1318.00s -> 1324.00s]  It allocates a bit in the bitmap block to indicate that block has now been allocated.
[1324.00s -> 1327.00s]  That block turns out to be, I guess, 595.
[1327.00s -> 1334.00s]  And then we write the character H to 595, and then the character I, and then we update the inode.
[1334.00s -> 1342.00s]  And then we can ask ourselves the same question, like what will happen if we crash?
[1342.00s -> 1349.00s]  So for example, let's say we allocate a crash like right here between writing the bitmap block
[1349.00s -> 1354.00s]  before we actually write the inode.
[1354.00s -> 1360.00s]  So crash here.
[1360.00s -> 1370.00s]  And so we reboot, we come back up, and the disk is in a particular state, and what is the risk?
[1370.00s -> 1374.00s]  We use a data block, but we lose it.
[1374.00s -> 1379.00s]  Yeah, we lose it again, correct? Because the block is allocated, but it doesn't show up in any file.
[1379.00s -> 1388.00s]  Because it hasn't been written into any inode, so we lose a data block.
[1388.00s -> 1392.00s]  So you might think, okay, well, maybe just because we wrote them in the wrong order,
[1392.00s -> 1397.00s]  what we should have done is, what we should have done is first write it in the inode.
[1397.00s -> 1407.00s]  So first write 33 with 595 as either an indirect block or a direct block.
[1407.00s -> 1412.00s]  And then actually we will mark the inode, the block is allocated.
[1412.00s -> 1417.00s]  So then we'll write 45.
[1417.00s -> 1423.00s]  So we change the order because we want to avoid these lost data blocks, and we change the order in this way.
[1423.00s -> 1430.00s]  And now let's consider the case if there's a failure right here.
[1430.00s -> 1437.00s]  What is the risk?
[1437.00s -> 1444.00s]  The size of the file is not compatible with actually how many data blocks are allocated?
[1444.00s -> 1451.00s]  That might be, although I think in the right of 33, you actually update both the size and the block number, correct?
[1451.00s -> 1453.00s]  Oh, yeah.
[1453.00s -> 1456.00s]  So that might work out okay.
[1456.00s -> 1460.00s]  If there were two separate writes in the inode, that would be a problem.
[1460.00s -> 1467.00s]  But there's some bigger problem here.
[1467.00s -> 1485.00s]  It's that the file has the data block, but the data block is marked as unallocated, and other files can also use it.
[1485.00s -> 1486.00s]  Yeah, correct.
[1486.00s -> 1494.00s]  That's the real big problem here is that the inode thinks the block 595 belongs to that file.
[1494.00s -> 1498.00s]  But actually on disk, it's still marked as unallocated.
[1498.00s -> 1505.00s]  And so when later another file was created, that block actually might be used for that other file.
[1505.00s -> 1510.00s]  And so now certainly one file thinks it owns 595, but actually another file does.
[1510.00s -> 1517.00s]  And in fact, both files will have 595 in their block numbers for their inode.
[1517.00s -> 1525.00s]  And basically, you know, if one user owns that file and the other user owns the other file, the connection reader writes each other's data.
[1525.00s -> 1528.00s]  It's clearly not what we want.
[1528.00s -> 1537.00s]  You know, the file system should guarantee that every block only belongs in one file and no other file or is free.
[1537.00s -> 1549.00s]  OK, so this could lead to security problems, but basically block is shared among multiple files.
[1549.00s -> 1555.00s]  And that's definitely wrong.
[1555.00s -> 1564.00s]  Does that make sense in terms of the problems that can appear? And again, you know, the real issue here is not to watch the ordering of the writes,
[1564.00s -> 1579.00s]  but the real underlying problem here is that we're just doing multiple writes and then basically have to sort of show up on disk as an atomic operation.
[1579.00s -> 1588.00s]  OK, so the solution that we're going to explore in this lecture is logging.
[1588.00s -> 1597.00s]  And as I said before, this is a common solution used in file systems and originating actually out of the database literature.
[1597.00s -> 1607.00s]  And it actually has a couple of good properties. One, it's going to make basically system calls or file system calls atomic.
[1607.00s -> 1618.00s]  With that I mean, so if a create file or you call create or you call write, basically all the effects of that system call all appear all together or none of them.
[1618.00s -> 1627.00s]  So that avoids this problem of only some subset of the writes actually showing up on disk.
[1627.00s -> 1632.00s]  The second good property it has, it allows for fast recovery.
[1633.00s -> 1641.00s]  So after reboot, it turns out we don't actually have to do a lot of work to repair the file system, a very minimal amount of work.
[1641.00s -> 1648.00s]  And this is in contrast to some other solution that I'm not talking about, which is basically you go and inspect the file system.
[1648.00s -> 1653.00s]  Maybe you read all the blocks of the file system or read all the Inode blocks, read all the bitmap blocks.
[1653.00s -> 1659.00s]  And so check out whether the file system is still in the correct shape and maybe repair things.
[1659.00s -> 1667.00s]  Logging has this nice property that actually the recovery is fast. And then finally, in principle, it can be actually very high performance.
[1667.00s -> 1673.00s]  Although the one we're going to be looking in the context of XP6 is not high performance.
[1673.00s -> 1681.00s]  So we're going to look at that next week. We'll see actually how to build logging system that has atomic file system calls, fast recovery and high performance.
[1681.00s -> 1685.00s]  Today, we're going to be just focusing on the first two.
[1685.00s -> 1692.00s]  OK, the basic idea of logging is actually straightforward.
[1692.00s -> 1696.00s]  And so basically what you do is you divide the disk into two pieces.
[1696.00s -> 1700.00s]  One is the log, one is the file system.
[1700.00s -> 1704.00s]  And the file system might be a bunch bigger than the log.
[1704.00s -> 1717.00s]  And when you need to update the file system, so update, let's say, block 33 or update the bitmap block, we're actually not going to update the file system blocks.
[1717.00s -> 1719.00s]  We're not going to update the bitmap block directly.
[1719.00s -> 1724.00s]  Instead, the only thing we're going to do on the right is, so here's our memory.
[1724.00s -> 1728.00s]  We have a block in memory, let's say the bitmap block.
[1728.00s -> 1735.00s]  That's 45. And instead of writing it to 45, what we normally would have done, what we're going to do is actually we're going to write it into the log.
[1735.00s -> 1741.00s]  So we're going to stick it here. And remember that actually should go to 45.
[1741.00s -> 1744.00s]  We're going to put it there. And we do that with all the other writes too.
[1744.00s -> 1748.00s]  So, for example, we'll put our inode block there.
[1748.00s -> 1752.00s]  You know, that was like maybe 33, I think, if I remember correctly.
[1752.00s -> 1758.00s]  And we'll stick it in there. And, you know, remember that it actually has to go to 33.
[1758.00s -> 1764.00s]  So basically what we do, any write is first logged.
[1764.00s -> 1770.00s]  And so we don't write directly to the home location of the block, but we just put it always in the log.
[1770.00s -> 1781.00s]  Then at some point, you know, when the file system operation is done, you know, for example, it has these four or five writes that we saw in the previous slides are in the log, we commit the operation.
[1782.00s -> 1795.00s]  And basically what it means is somewhere in the log, we just record a record, you know, in the fixed location that basically says, OK, well, you know, there are like five blocks in the log.
[1795.00s -> 1801.00s]  And that is, you know, the log set of log writes.
[1801.00s -> 1807.00s]  And then, you know, when we have all the writes stably on disk, we're going to actually install them.
[1807.00s -> 1815.00s]  It's called the installation phase. And really what that means is we're going to move these logs from the log to their home location.
[1815.00s -> 1823.00s]  So we know this one has to go to 45. So we put it at 45. This one has to go to 33, you know, report it to 33, et cetera, et cetera.
[1823.00s -> 1834.00s]  And once we're done, you know, basically we can clean the log. And cleaning the log is basically you're rewriting, you know, basically setting this five to zero.
[1834.00s -> 1846.00s]  And that is the basic plan. And why is this plan good? Well, let's think about it. Let's say we crash before here.
[1846.00s -> 1857.00s]  What would happen? So let me hold that question. Let me actually talk about one thing before asking the question.
[1857.00s -> 1867.00s]  Let's say we crash. And so we reboot. And on the reboot, there's basically what the file system does.
[1867.00s -> 1878.00s]  It looks at the commit record, sees what the value of the commit record is. If it is zero, you know, do nothing in our simple scheme.
[1878.00s -> 1884.00s]  And if it's bigger than zero, we know that there are basically blocks in the log that need to be actually installed.
[1884.00s -> 1890.00s]  And we apparently didn't finish the installation. We crashed after the commit, but before cleaning the log.
[1890.00s -> 1904.00s]  So basically we reinstall. And after we reinstall, we clean the log.
[1904.00s -> 1916.00s]  OK. And this scheme is good because it actually ensures that no matter where a crash happens, we either install all the blocks of the rights or reinstall none of them.
[1916.00s -> 1923.00s]  We were never in a situation where we installed some of the rights, but not all of them.
[1923.00s -> 1928.00s]  And just to see why this is true, let's consider a couple of cases where things could crash.
[1928.00s -> 1937.00s]  So things could crash between one and two. What will happen?
[1937.00s -> 1943.00s]  What situation do we end up?
[1943.00s -> 1952.00s]  The situation in which on recovery we do nothing. And that's OK, because nothing has been written to the file system yet.
[1952.00s -> 1956.00s]  Exactly. So this is the case where basically we just do nothing.
[1956.00s -> 1964.00s]  You know, as if the system basically never executed. As if the failure happened slightly earlier, right before the file system call started.
[1964.00s -> 1978.00s]  And so that's perfectly OK. That's acceptable. OK, what happens if we crash between after committing before reinstalling?
[1978.00s -> 1984.00s]  Then you'll just redo all the installs. So you'll kind of restore the correct state. Yeah, so exactly.
[1984.00s -> 1989.00s]  So at that point, all we have, we know there are all the blocks are in the log.
[1989.00s -> 1994.00s]  They're all written because we committed. So it must be the case that the whole file system operation finished.
[1994.00s -> 2000.00s]  And so we can basically put them in their location where they should be. And then we're all in good shape.
[2000.00s -> 2010.00s]  And so in this case, you know, all the files, you know, in this case, what we end up is as if the file system call actually complete just before the crash.
[2010.00s -> 2021.00s]  There's like no difference. OK, so what happens if we crash during reinstall or like in install or during install before we're cleaning the crash here?
[2021.00s -> 2031.00s]  In this case, in this case, and I will do the third case, we'll install during installation or before install after installing, but before cleaning.
[2031.00s -> 2038.00s]  What what what will happen then? On the.
[2038.00s -> 2045.00s]  Oh, sorry. On the next restart, nothing has really changed in terms of the recovery process.
[2045.00s -> 2054.00s]  And so we're just going to redo the log. Yeah, we're going to redo the log again and we can copy basically the content again to the locations where it may be.
[2054.00s -> 2064.00s]  In fact, we might do it multiple times. Is that OK?
[2064.00s -> 2078.00s]  Yes, because those are just writes and it's there to a specific location that we don't change, like it's written in the log, so we know where we should write every time.
[2078.00s -> 2088.00s]  Yeah, basically every time we'll do the same right. Correct. So let's say in block 45, you know, there's the value 10 and we're going to write 10 to location 45 every time.
[2088.00s -> 2094.00s]  And that's exactly what it should be. And like and repeating that right multiple times doesn't really do any harm.
[2094.00s -> 2103.00s]  Because we're writing the same value that actually should be there anyway. And so it's perfectly fine for us to do reinstallation multiple times.
[2103.00s -> 2109.00s]  Of course, we shouldn't serve any other files and calls at this particular point in time. We should do this before we restart the file system.
[2109.00s -> 2116.00s]  But while, you know, during reboot or during recovery, you know, we can just do this.
[2116.00s -> 2125.00s]  Another way of saying that is that installation is basically idempotent. You can just execute it many, many, many times and we'll have the same effect at the end.
[2125.00s -> 2129.00s]  A question about that. Yeah.
[2129.00s -> 2136.00s]  Because the interface is just read and write, if we had an append, this would not be safe, right?
[2136.00s -> 2146.00s]  Yeah. You can make append safe to more fancy logging schemes. But for this particular logging scheme, you know, we don't have to worry about that.
[2146.00s -> 2158.00s]  In fact, like in some sense, append is a file system level operation. And at that level, we can make it atomic using the logging scheme that we have here.
[2158.00s -> 2159.00s]  I see. Thank you.
[2160.00s -> 2161.00s]  I also have a question.
[2161.00s -> 2162.00s]  Yep. Go ahead.
[2162.00s -> 2171.00s]  What would happen if the file system crashed while you were committing? So you want to like execute multiple writes, and then you only commit like half of them.
[2171.00s -> 2174.00s]  Yeah. Okay. So can you speak up a little bit more? Because your volume is low.
[2174.00s -> 2191.00s]  Oh, yes. Sorry. So if you wanted to like commit multiple writes at once, like in an atomic way, but your system crashes in the middle of committing, so you are only able to commit like half of the writes, what would happen in that instance?
[2191.00s -> 2208.00s]  Okay. So this is a very important point. I'm glad you asked the question. So first of all, you commit, you know, writing this commit operation here, correct? This step two, you only execute that commit operation after you already logged all the writes that you were planning to execute, right?
[2208.00s -> 2213.00s]  So at the point you do to commit, all the writes are in the log.
[2213.00s -> 2218.00s]  And so the commit operation itself is an interesting question, like what happens there?
[2218.00s -> 2227.00s]  So the way I sort of indicated this on the slide, the commit operation writes a single block, like a single sector on the disk.
[2227.00s -> 2237.00s]  And the standard assumption that file systems make is that a single block write or single sector write is an atomic operation.
[2237.00s -> 2242.00s]  Meaning that if you write it, the whole sector will be written where none of the sector will be written.
[2242.00s -> 2249.00s]  So the sector will never be written partially. And so there's always, you know, clearly valid data in that particular sector.
[2249.00s -> 2257.00s]  And so basically this operation, that commit operation, writing the log header is, or writing the commit record is the real commit operation.
[2257.00s -> 2268.00s]  Like if that succeeds and there's basically say a five in commit header, you know, we know that there are five blocks in the log and we have to reinstall those five blocks.
[2268.00s -> 2278.00s]  If the commit header didn't make it to disk, then the value would still be zero and we'll just treat it as if the transaction never happened.
[2278.00s -> 2280.00s]  Thank you.
[2280.00s -> 2288.00s]  The key rule that you're sort of hinting at that has to be true is something that's called the write ahead rule,
[2288.00s -> 2300.00s]  which means that a logging system cannot install writes until all the writes are in the log.
[2300.00s -> 2309.00s]  Any more questions about this sort of basic plan?
[2309.00s -> 2312.00s]  OK.
[2312.00s -> 2322.00s]  Good.
[2322.00s -> 2328.00s]  So what I want to get there are many, many different versions of logging schemes.
[2328.00s -> 2332.00s]  And I sketched out here a very simple one. You know, it's perfectly fine.
[2332.00s -> 2339.00s]  You know, there are schemes where basically the cleaning of the log is postponed, installation is postponed until later.
[2339.00s -> 2347.00s]  But I'm just going to run sort of with this very simple scheme. And then next week we'll see more sophisticated logging protocols.
[2347.00s -> 2358.00s]  But all those logging protocols follow this write ahead rule that, you know, before you write the commit record, you have to make sure that all the writes are in the log.
[2358.00s -> 2367.00s]  But then there's a lot of within that still there's a ton of flexibility in designing a particular logging protocol as they're typically called.
[2367.00s -> 2380.00s]  OK, I'm going to look a little bit how this then is manifest itself in XV6 as a sort of a case study and to make things really concrete.
[2380.00s -> 2392.00s]  OK, so in XV6, we're going to look at two sort of pieces of state, if you will, the stuff that is actually on disk and things that are in memory.
[2392.00s -> 2404.00s]  And in memory contents will disappear on or the way we should think about it is that in memory contents will disappear on a crash or a power failure.
[2404.00s -> 2413.00s]  And the structure of the XV siglog, as always, is extremely simple.
[2413.00s -> 2419.00s]  There's actually we have one block at the beginning, the header block, and that is basically our commit record.
[2420.00s -> 2424.00s]  It contains the number N, which is like the number of blocks in the log.
[2424.00s -> 2433.00s]  And then for each block, the block number, the home location of that block.
[2433.00s -> 2438.00s]  So there's going to be N of those.
[2438.00s -> 2443.00s]  And so then in the log itself, R basically is the data that belongs to that.
[2443.00s -> 2454.00s]  Here's the data of BN0, here's the data of BN1, et cetera, to BN minus one.
[2454.00s -> 2460.00s]  So that's what's in the log. And that's the only thing that's sort of in the log. There's nothing more to it.
[2460.00s -> 2469.00s]  Then in memory, when one of the files is running, there's an in copy version or in memory version of the header.
[2469.00s -> 2477.00s]  And it basically has the N and it has an array of block numbers.
[2477.00s -> 2491.00s]  Et cetera. And then these block numbers refer to blocks that are sitting in the data that actually corresponds to the block numbers that are sort of sitting in this in-memory data structure.
[2491.00s -> 2496.00s]  They live in the block cache, which by now you're well familiar with.
[2496.00s -> 2502.00s]  And so maybe this is like block 10 is the first block in the log.
[2502.00s -> 2509.00s]  Or let me take a more concrete example from the lines up with our previous thing. So maybe this is like 45.
[2509.00s -> 2515.00s]  And basically, you know, somewhere in the cache, the block has there, of course, you know, whatever block for 45.
[2515.00s -> 2528.00s]  And here's its data. OK, that's sort of the structures that the in-memory file system has and on this file system has.
[2528.00s -> 2537.00s]  So the on this file system just has the log and the in-memory has these data structures to orchestrate these multi-write operations that we're going to be doing.
[2537.00s -> 2553.00s]  OK. So to make this a little more concrete, let's look at some code that will help us understand how everything works.
[2553.00s -> 2561.00s]  Let me pull up some code next to it.
[2561.00s -> 2568.00s]  We keep that picture so that we can look at it if we want to or I can point to it.
[2568.00s -> 2574.00s]  Can everybody see my code?
[2574.00s -> 2580.00s]  Somebody confirmed that they think the index window. Yeah, we can see it.
[2580.00s -> 2585.00s]  Is it big enough? I think it's good.
[2585.00s -> 2594.00s]  OK. Looks good. Thank you. OK, so let's start with the you know, I talked about transactions, right?
[2594.00s -> 2602.00s]  You know, the fact that, you know, the we should not commit until we should not write a commit writer until all the writes have done.
[2602.00s -> 2611.00s]  And so this means that the sort of file system operations must indicate sort of what the beginning of transaction is and particularly what the end of a transaction is.
[2611.00s -> 2616.00s]  And the way that happens in xv6 is that every file system call.
[2616.00s -> 2628.00s]  Here's open corresponds to create basically start with begin up and begin up basically indicates like, OK, I want to start a transaction and I want all the block rights that I've been doing between begin up and end up,
[2628.00s -> 2635.00s]  which is basically at the end of the transaction to be atomic, meaning they should be all applied or none of them should be applied.
[2635.00s -> 2647.00s]  OK. And so every file system call in xv6 has that structure that basically has begin up, then the code and implements the file system call and then end up.
[2647.00s -> 2651.00s]  And that end up is basically where the commit operation happens.
[2651.00s -> 2659.00s]  So basically between begin and end up, the on disk or the in-memory data structure should be updated, you know, whatever the in-memory log may be updated.
[2659.00s -> 2664.00s]  The bar cache might be updated, but nothing really happens until end up.
[2664.00s -> 2668.00s]  And at end up time, we're basically going to put things into the log.
[2668.00s -> 2676.00s]  And then we are done with putting everything in the log will actually write the commit record or the log header.
[2676.00s -> 2679.00s]  OK, so let's.
[2679.00s -> 2687.00s]  So what is interesting, of course, then what happens is every write correctly, whenever one of these file system calls does a disk write,
[2687.00s -> 2695.00s]  you know, something must happen. So if we go back, for example, to FSC, you know, look at Ialloc.
[2695.00s -> 2704.00s]  Ialloc basically what it calls, it doesn't call B write directly, but it actually calls log write.
[2704.00s -> 2710.00s]  And so we're going to see what log write does. Log write is basically the function implemented by the logging system.
[2710.00s -> 2723.00s]  And every write that basically a file system called does between begin up and end up always goes to log write.
[2723.00s -> 2730.00s]  So here's log write and log write actually is reasonable, you know, straightforward.
[2730.00s -> 2738.00s]  You know, we've written the block in the block cache, so somewhere basically 45, maybe this is like the right to 45.
[2738.00s -> 2742.00s]  We've updated, you know, 45 in the block cache.
[2742.00s -> 2748.00s]  And now we basically record in the in-memory data structures that to some point later at commit point,
[2748.00s -> 2755.00s]  we need to write this block into the log. And so, you know, basically, you know, the code is,
[2755.00s -> 2764.00s]  the code is reasonable straightforward, acquires a lock on the header and basically updates the header.
[2764.00s -> 2770.00s]  And in particular, what it does, you know, it goes through, you know, the, it updates N.
[2770.00s -> 2776.00s]  Well, actually, the first thing it does, it actually sees if there's already a copy of 45 in the,
[2776.00s -> 2780.00s]  if 45 is already recorded as being having to written to.
[2780.00s -> 2785.00s]  And if that's the case, nothing has to be done because 45 will be written to.
[2785.00s -> 2790.00s]  And so we're done. And sometimes it's called lock absorption.
[2790.00s -> 2795.00s]  If, you know, block 45 is not in the array yet,
[2795.00s -> 2800.00s]  we're not in the list of blocks or the array of blocks that needs to be written to disk,
[2800.00s -> 2806.00s]  then basically, you know, the only thing this piece of code does is basically bump up and stick,
[2806.00s -> 2813.00s]  you know, that block number that needs to be written into the next entry or into that entry.
[2813.00s -> 2816.00s]  Then the only other thing it does, you know, we'll talk about this later,
[2816.00s -> 2820.00s]  it will pin the block in the buffer cache.
[2820.00s -> 2826.00s]  And let me postpone why for a little while, but I will come back to that later.
[2826.00s -> 2828.00s]  And that's actually all the log right there is doing.
[2828.00s -> 2832.00s]  So every file system call that needs to update a block, you know,
[2832.00s -> 2838.00s]  updates the block in the block cache, and then basically it pins it to this in-memory data structure,
[2838.00s -> 2844.00s]  unless, you know, it's already there, in which case, you know, it just absorbs it.
[2844.00s -> 2849.00s]  Does that make sense?
[2849.00s -> 2854.00s]  So does that mean that bwrite shouldn't be used by itself at all?
[2854.00s -> 2856.00s]  So say again?
[2856.00s -> 2860.00s]  bwrite shouldn't be used by itself only as...
[2860.00s -> 2862.00s]  Yes, that's correct.
[2862.00s -> 2874.00s]  Basically, one way to think about it is that every bwrite in the file system is replaced by log write.
[2874.00s -> 2878.00s]  Okay, so now let's see what actually happens at end-opt,
[2878.00s -> 2883.00s]  because that's where the exciting part happens.
[2883.00s -> 2889.00s]  And there's a couple of cases that I just want to avoid talking about a little bit later,
[2889.00s -> 2894.00s]  because they, you know, even this simple logging system actually has some subtle complexities,
[2894.00s -> 2898.00s]  and most of the beginning of this code deals with these subtle complexities.
[2898.00s -> 2901.00s]  But as you want to really get the normal case, you know,
[2901.00s -> 2906.00s]  there's a simple case where no other file system operations are in progress.
[2906.00s -> 2912.00s]  We re-execute, you know, create file, and basically we're getting to the point where we want to commit.
[2912.00s -> 2917.00s]  And so the code is pretty straightforward and calls commit.
[2917.00s -> 2921.00s]  And so let's look at commit.
[2921.00s -> 2923.00s]  So here's commit.
[2923.00s -> 2928.00s]  And basically commit does two basically steps, and basically it writes the log,
[2928.00s -> 2936.00s]  and that's basically writing all these block numbers that are sitting, you know, in the in-memory header,
[2936.00s -> 2942.00s]  and writes them basically all to the header on disk, including, you know, this number n.
[2943.00s -> 2948.00s]  And so let's see, that's what write head does, sorry.
[2948.00s -> 2956.00s]  Write log basically writes, you know, the blocks from the buffer cache into their respective, into the log itself.
[2956.00s -> 2960.00s]  So let's see what write log is right above here.
[2960.00s -> 2962.00s]  And you can see what it does.
[2962.00s -> 2965.00s]  It goes through, you know, this array, you know, one at a time,
[2965.00s -> 2971.00s]  and basically writes that to the log position in the log.
[2971.00s -> 2977.00s]  Okay, so it reads, you know, the log block, then sticks it in there by copying it,
[2977.00s -> 2980.00s]  and then writing it actually out to the disk.
[2980.00s -> 2984.00s]  So this basically ensures that like block 45 will end up here, you know,
[2984.00s -> 2988.00s]  let's say this is 32, that will end up there, et cetera, et cetera.
[2988.00s -> 2992.00s]  Then in the end, so at this point, we have not committed yet, correct?
[2992.00s -> 2995.00s]  The only thing we've done is basically putting blocks into the log.
[2995.00s -> 3000.00s]  And if we were crash at this particular point in time, you know, before, you know, calling write head,
[3000.00s -> 3007.00s]  before write hex, you see that, and basically at as if the transaction didn't execute at all.
[3007.00s -> 3009.00s]  So let's look at write head.
[3009.00s -> 3013.00s]  So that write head is, you know, what I called earlier, basically the commit point.
[3013.00s -> 3017.00s]  And the commit point basically, you know, basically it's straightforward
[3017.00s -> 3024.00s]  and reach the header block from disk, which is probably sitting in the buffer cache.
[3024.00s -> 3031.00s]  It, you know, puts the, copies the N, you know, this N into that block,
[3031.00s -> 3034.00s]  puts all the block numbers into that array, into that block,
[3034.00s -> 3037.00s]  and then basically writes that particular block.
[3037.00s -> 3042.00s]  So this is the, this B write, what is that? Is that the commit point?
[3045.00s -> 3049.00s]  If a crash happens before this B write, what happens then?
[3054.00s -> 3058.00s]  Anybody?
[3058.00s -> 3068.00s]  If the crash happens before B write, isn't the only modification that we've made to the in-memory HP data structure,
[3068.00s -> 3070.00s]  so it's not, it's going to be fine?
[3070.00s -> 3072.00s]  Yeah, it's going to be fine, right?
[3072.00s -> 3076.00s]  Because basically we may have written db1, zero, dbN, or whatever to the log,
[3076.00s -> 3078.00s]  but we have not succeeded in writing the log header.
[3078.00s -> 3082.00s]  And so we'll do, on recovery, nothing will happen.
[3083.00s -> 3087.00s]  And what happens if there's a crash right after the B write, so like a crash here?
[3092.00s -> 3097.00s]  And it's no longer zero, so the log header is correctly read and it's recovered?
[3097.00s -> 3098.00s]  Yeah, it will be recovered, correct?
[3098.00s -> 3101.00s]  Well, at some point, hopefully during recovery, as we inspect that, you know,
[3101.00s -> 3107.00s]  we expect that recovery will actually read the log header, see that there is a five in there, for example,
[3107.00s -> 3110.00s]  and then copy the first five blocks to their home location.
[3110.00s -> 3118.00s]  So this is really, this one line, this one disk write, this one sector write is really the commit point.
[3118.00s -> 3120.00s]  Correct?
[3123.00s -> 3127.00s]  Before the commitment point, the transaction is as it is, the transaction didn't happen,
[3127.00s -> 3131.00s]  and after the commit point, the transaction will definitely be finished,
[3131.00s -> 3134.00s]  assuming your recovery is correct.
[3135.00s -> 3142.00s]  Okay, so let's, you know, go back to commit.
[3144.00s -> 3148.00s]  So commit, after it's committed, it actually installs the transactions,
[3148.00s -> 3150.00s]  and, you know, that's pretty straightforward.
[3150.00s -> 3154.00s]  Basically, you know, it takes the blocks, looks at the header, where the blocks belongs,
[3154.00s -> 3156.00s]  and then basically writes it to that particular location.
[3158.00s -> 3161.00s]  And so we can actually look at the install trans,
[3162.00s -> 3164.00s]  and see that actually that's what it does.
[3165.00s -> 3170.00s]  You know, it has a copy of the log header, and it just reads the log header,
[3170.00s -> 3174.00s]  it reads the destination block, the home location,
[3174.00s -> 3179.00s]  copies the data from the log block into the destination,
[3179.00s -> 3182.00s]  and then writes the buffer to the destination.
[3183.00s -> 3184.00s]  Okay?
[3185.00s -> 3187.00s]  So basically, effectively, what this does is basically, you know,
[3187.00s -> 3190.00s]  if you go back to this previous slide here, it copies, you know,
[3190.00s -> 3193.00s]  it just does these copies from the log into the home location,
[3193.00s -> 3195.00s]  or actually in the file system.
[3197.00s -> 3200.00s]  And of course, you know, we might get a failure somewhere in, you know, this code,
[3200.00s -> 3203.00s]  or while we're doing this, but, you know, that should be okay,
[3203.00s -> 3206.00s]  because hopefully in recovery, we'll just start over from the beginning.
[3209.00s -> 3212.00s]  So let's look at, so that was install.
[3213.00s -> 3215.00s]  So once install is done,
[3215.00s -> 3219.00s]  then basically it sets, you know,
[3219.00s -> 3223.00s]  the in memory header and back to zero,
[3223.00s -> 3225.00s]  and then writes that log header.
[3225.00s -> 3228.00s]  And effectively that causes to,
[3230.00s -> 3233.00s]  cleans the log, because basically there's now zero in it.
[3234.00s -> 3235.00s]  Question?
[3236.00s -> 3242.00s]  So you, the function you're in just before,
[3242.00s -> 3247.00s]  like where's, does the from to, or to, from getting,
[3247.00s -> 3252.00s]  so that puts the block that you're going to like update,
[3253.00s -> 3257.00s]  the log block that you're going to update into the buffer cache.
[3258.00s -> 3262.00s]  Could you make it faster by not putting it into the buffer cache
[3262.00s -> 3266.00s]  and just directly writing it to the device instead?
[3267.00s -> 3270.00s]  Let me, which function we're talking about?
[3271.00s -> 3273.00s]  I forget its name.
[3274.00s -> 3278.00s]  It's the one where you copy, you know, everything into the log.
[3279.00s -> 3281.00s]  Okay. Install, install trans.
[3282.00s -> 3283.00s]  I think so.
[3284.00s -> 3285.00s]  No, no, no, no.
[3287.00s -> 3288.00s]  Maybe it was this one.
[3290.00s -> 3293.00s]  I was thinking probably of right head, but it's the same thing.
[3294.00s -> 3295.00s]  Okay.
[3295.00s -> 3300.00s]  The only reason, yeah, the only reason to this,
[3301.00s -> 3303.00s]  basically our interface is not particularly good.
[3303.00s -> 3305.00s]  You could just write straight, you know,
[3305.00s -> 3307.00s]  you're wondering why you are doing the read.
[3308.00s -> 3309.00s]  There's no reason to do the read
[3309.00s -> 3311.00s]  because we're going to write anyway.
[3312.00s -> 3313.00s]  Is that the question?
[3315.00s -> 3319.00s]  Yeah, that and you're also doing the men move, right?
[3319.00s -> 3320.00s]  And you're doing the men move, yeah.
[3320.00s -> 3322.00s]  So this actually a sequence of code
[3322.00s -> 3323.00s]  can definitely be optimized.
[3323.00s -> 3326.00s]  You can save, you know, one or two disk writes.
[3326.00s -> 3329.00s]  Just for simplicity, we don't do any of that.
[3330.00s -> 3331.00s]  Okay. Thank you.
[3335.00s -> 3336.00s]  Okay.
[3337.00s -> 3339.00s]  So I think we're in over commit.
[3340.00s -> 3343.00s]  Just like you just go back and double check.
[3344.00s -> 3345.00s]  So we did the right log.
[3346.00s -> 3347.00s]  We did the right head.
[3347.00s -> 3349.00s]  And basically this is the cleaning operation.
[3350.00s -> 3353.00s]  We erased, you know, the transaction by sending it to zero.
[3353.00s -> 3354.00s]  Okay.
[3355.00s -> 3357.00s]  So then the only thing to sort of further inspect
[3358.00s -> 3360.00s]  is like how does recovery work?
[3360.00s -> 3364.00s]  And so recovery happens when, you know,
[3364.00s -> 3366.00s]  when XP6 starts.
[3366.00s -> 3368.00s]  So we had a crash, correct?
[3368.00s -> 3369.00s]  So the system failed.
[3370.00s -> 3371.00s]  We rebooted.
[3374.00s -> 3378.00s]  And one of the first things that XP6 does
[3379.00s -> 3382.00s]  during initialization, it actually calls init log.
[3383.00s -> 3386.00s]  And init log basically calls its function
[3386.00s -> 3387.00s]  recover from log.
[3387.00s -> 3389.00s]  And so let's see what that does.
[3390.00s -> 3392.00s]  And basically recover from log, you know,
[3392.00s -> 3397.00s]  calls read head to basically extract or read the,
[3399.00s -> 3402.00s]  let me see if I can scroll down here a little bit.
[3405.00s -> 3407.00s]  Yeah, basically reads the header from disk.
[3408.00s -> 3412.00s]  And sees if N, well, it doesn't really see if N is zero
[3412.00s -> 3414.00s]  or not, but it just calls install trans.
[3414.00s -> 3417.00s]  And, you know, this is exactly the same install trans
[3417.00s -> 3420.00s]  that we just looked at a little while ago.
[3420.00s -> 3422.00s]  And basically, you know, it looks at this N
[3422.00s -> 3425.00s]  and installs all the blocks from zero to N
[3425.00s -> 3427.00s]  out of the log into their home location.
[3428.00s -> 3430.00s]  And if it's done once it succeeds, you know,
[3430.00s -> 3434.00s]  then actually it calls clear log as before.
[3435.00s -> 3437.00s]  And so that's actually all what recovery does.
[3437.00s -> 3439.00s]  You know, recovery just basically always call
[3439.00s -> 3441.00s]  and does the installation.
[3441.00s -> 3444.00s]  And if we crash during installation here,
[3444.00s -> 3446.00s]  no particular problem again, correct?
[3446.00s -> 3448.00s]  Because we'll crash, we'll boot.
[3448.00s -> 3452.00s]  XP6 during booting will call log init,
[3452.00s -> 3453.00s]  which we'll call recover from log.
[3453.00s -> 3456.00s]  And it will basically reinstall or replay the log
[3456.00s -> 3457.00s]  as it's sometimes called.
[3457.00s -> 3460.00s]  Again, and this might have, this might end,
[3460.00s -> 3464.00s]  we crash every time or, you know, many, many times,
[3464.00s -> 3466.00s]  you know, it will reinstall or replay the log
[3466.00s -> 3467.00s]  many, many, many times,
[3467.00s -> 3469.00s]  but until hopefully at some point it succeeds
[3469.00s -> 3472.00s]  and actually, you know, gets the whole log written
[3472.00s -> 3475.00s]  or gets the whole log installed, you know,
[3475.00s -> 3477.00s]  to the home locations.
[3479.00s -> 3480.00s]  Does that make sense?
[3483.00s -> 3485.00s]  I had a question about,
[3485.00s -> 3488.00s]  so if a process just runs normally,
[3488.00s -> 3491.00s]  it writes some data to disk
[3491.00s -> 3493.00s]  and then at some point after that,
[3493.00s -> 3497.00s]  before it commits and installs the changes,
[3497.00s -> 3499.00s]  there's a failure.
[3499.00s -> 3503.00s]  The process, from the process point of view,
[3503.00s -> 3506.00s]  nothing happened, but something like,
[3506.00s -> 3510.00s]  I guess the failure happened after the process ended,
[3510.00s -> 3512.00s]  what it was doing.
[3512.00s -> 3515.00s]  So is there anything bad about that?
[3515.00s -> 3517.00s]  I'm not 100% sure where you're getting it,
[3517.00s -> 3521.00s]  but the short answer is there's nothing bad, right?
[3521.00s -> 3523.00s]  Because the disk won't be updated at all.
[3523.00s -> 3525.00s]  So just as if, you know,
[3525.00s -> 3527.00s]  the file system operation didn't happen.
[3528.00s -> 3529.00s]  Right.
[3530.00s -> 3531.00s]  I guess I'm seeing...
[3531.00s -> 3532.00s]  The process disappears too,
[3532.00s -> 3535.00s]  but you know, we don't expect the process
[3535.00s -> 3536.00s]  to survive failures anyway.
[3538.00s -> 3539.00s]  Right.
[3539.00s -> 3543.00s]  I guess, okay, I think that answered my question.
[3543.00s -> 3544.00s]  Thank you.
[3545.00s -> 3548.00s]  Yeah, it's important to remember that basically
[3549.00s -> 3551.00s]  the only thing that really survives failures
[3551.00s -> 3553.00s]  or that's persistence across failures
[3553.00s -> 3555.00s]  is the disk or the state on the disk,
[3555.00s -> 3556.00s]  nothing else, right?
[3559.00s -> 3560.00s]  Okay.
[3560.00s -> 3562.00s]  So just to make this all concrete
[3562.00s -> 3565.00s]  and one little bit more too, let's...
[3565.00s -> 3569.00s]  I put a statement in be right.
[3569.00s -> 3572.00s]  So the thing that actually does write to disk,
[3572.00s -> 3574.00s]  like in the block cache
[3574.00s -> 3575.00s]  and we're just gonna see
[3575.00s -> 3578.00s]  what the trace of actual disk rights are
[3578.00s -> 3581.00s]  because basically on Monday, I sort of...
[3584.00s -> 3585.00s]  I didn't tell the full truth
[3585.00s -> 3587.00s]  because basically I put the print statement
[3587.00s -> 3589.00s]  in log right and not in be right.
[3589.00s -> 3591.00s]  And so now I put it in the be right
[3591.00s -> 3592.00s]  and so we can actually see
[3592.00s -> 3594.00s]  all the blocks that are being written.
[3594.00s -> 3596.00s]  So we'll do the same thing as before,
[3596.00s -> 3597.00s]  echo hi X
[3597.00s -> 3600.00s]  and just look at actually the actual disk rights
[3601.00s -> 3602.00s]  and see if they make sense.
[3602.00s -> 3603.00s]  So the first thing to note, correct,
[3603.00s -> 3605.00s]  is that this trace is way longer
[3605.00s -> 3607.00s]  than the trace that we looked at last time.
[3607.00s -> 3609.00s]  In fact, that we looked at slides
[3609.00s -> 3611.00s]  a couple of slides ago, right?
[3611.00s -> 3612.00s]  Because if you look in there,
[3612.00s -> 3614.00s]  in fact, just to demonstrate this,
[3616.00s -> 3620.00s]  here was that same echo hi, correct?
[3620.00s -> 3622.00s]  And when we see there,
[3622.00s -> 3626.00s]  it's like only it's five log right operations,
[3626.00s -> 3631.00s]  but it turns into many disk operations, correct?
[3632.00s -> 3633.00s]  So let's look at it.
[3635.00s -> 3638.00s]  So what we think be right three, four and five are
[3638.00s -> 3640.00s]  and what is be right two?
[3648.00s -> 3649.00s]  Anybody?
[3649.00s -> 3653.00s]  So writing to the log and then the super block?
[3654.00s -> 3655.00s]  Not the super block.
[3655.00s -> 3657.00s]  No, that's the log head.
[3657.00s -> 3659.00s]  Yeah, so just to look at the...
[3659.00s -> 3660.00s]  You got it right.
[3660.00s -> 3662.00s]  There's looking at this picture again, correct?
[3662.00s -> 3663.00s]  The logs, that's a two.
[3663.00s -> 3666.00s]  So that's probably the header block,
[3666.00s -> 3668.00s]  the commit record, if you will.
[3668.00s -> 3670.00s]  And then three is the first data block,
[3670.00s -> 3671.00s]  four is the second data block,
[3671.00s -> 3673.00s]  five is the third data block, right?
[3673.00s -> 3677.00s]  So going back, this is the first right,
[3677.00s -> 3680.00s]  the second right, the third right,
[3680.00s -> 3682.00s]  they're all going into the log
[3682.00s -> 3687.00s]  and they're written to disk in the log part of the disk.
[3687.00s -> 3689.00s]  And then this is the commit record,
[3689.00s -> 3692.00s]  the header and then presumably, what is this face?
[3701.00s -> 3702.00s]  What is this part?
[3703.00s -> 3705.00s]  Is that the bitmap setting?
[3705.00s -> 3706.00s]  No.
[3706.00s -> 3708.00s]  So what do we think actually is stored
[3708.00s -> 3709.00s]  in this be right three?
[3712.00s -> 3715.00s]  Here, aren't you creating the file
[3716.00s -> 3720.00s]  that the inode for X updating the directory
[3720.00s -> 3723.00s]  and then also actually making the file itself?
[3723.00s -> 3724.00s]  Yeah.
[3724.00s -> 3726.00s]  And we didn't do it here, correct?
[3726.00s -> 3729.00s]  Because in these be rights that didn't happen
[3729.00s -> 3730.00s]  and now we're doing it.
[3731.00s -> 3734.00s]  So what phase is this of the transaction?
[3736.00s -> 3738.00s]  Installing the changes?
[3738.00s -> 3739.00s]  Yeah, it's installing the changes, correct?
[3739.00s -> 3744.00s]  What we did here is we log the rights,
[3744.00s -> 3747.00s]  then we committed the file system operation
[3747.00s -> 3750.00s]  to create operation and now we're installing it.
[3750.00s -> 3753.00s]  So now we're putting the blocks in their home location.
[3754.00s -> 3757.00s]  And now, and what does this be right two then?
[3764.00s -> 3765.00s]  It's clearing the logs?
[3765.00s -> 3767.00s]  Yeah, it's clearing the log, exactly.
[3767.00s -> 3773.00s]  So basically this, the system call was writing 33, 46 or 32
[3774.00s -> 3776.00s]  and to actually do that using the logging system
[3776.00s -> 3781.00s]  that basically turns into this set of disk rights, right?
[3782.00s -> 3784.00s]  Where the first party is installing the log,
[3784.00s -> 3786.00s]  if the first party is actually logging the rights
[3786.00s -> 3788.00s]  and the second party is installing the log.
[3790.00s -> 3792.00s]  And these are the two rights to the commit records.
[3795.00s -> 3796.00s]  Does that make sense?
[3796.00s -> 3799.00s]  Is it possible to infer where begin op and end op
[3799.00s -> 3801.00s]  would run from this trace?
[3802.00s -> 3804.00s]  Well, so we sort of know, correct?
[3804.00s -> 3807.00s]  So where did, we don't really know where begin op start,
[3807.00s -> 3808.00s]  but this is at the beginning.
[3808.00s -> 3810.00s]  Any file system call starts with the begin op
[3811.00s -> 3815.00s]  and it must be the case that the commit record, correct?
[3815.00s -> 3817.00s]  Is written in end op.
[3818.00s -> 3822.00s]  So we know that this is the end op
[3822.00s -> 3824.00s]  of some file system operation.
[3828.00s -> 3829.00s]  Does that make sense?
[3832.00s -> 3836.00s]  Okay, so that was basically X3.6 logging
[3836.00s -> 3837.00s]  and logging in action.
[3838.00s -> 3841.00s]  And I wanna talk about a couple of complications
[3842.00s -> 3845.00s]  and even this dirt simple,
[3845.00s -> 3849.00s]  naive logging scheme actually has complications.
[3850.00s -> 3852.00s]  One thing to immediately note of course is,
[3855.00s -> 3857.00s]  is this a very performant implementation
[3858.00s -> 3860.00s]  just by looking at this trace?
[3861.00s -> 3862.00s]  Yeah.
[3867.00s -> 3868.00s]  No.
[3868.00s -> 3869.00s]  Yeah, why not?
[3870.00s -> 3872.00s]  I know this is a basically too simple question,
[3873.00s -> 3875.00s]  but it's important to ask.
[3876.00s -> 3881.00s]  Like you're writing the stuff twice, right?
[3881.00s -> 3882.00s]  Yeah, you're writing your stuff twice.
[3883.00s -> 3884.00s]  So if I write a file F or a big file F,
[3885.00s -> 3887.00s]  I'm gonna write that big file F twice.
[3888.00s -> 3890.00s]  And so certainly not particularly high performance.
[3891.00s -> 3892.00s]  I mean, basically we're cutting the performance
[3893.00s -> 3894.00s]  immediately by a factor of two,
[3895.00s -> 3897.00s]  just to get crash safety.
[3898.00s -> 3899.00s]  And so we'll see you on,
[3900.00s -> 3905.00s]  when you're reading the X3 paper for a Monday,
[3906.00s -> 3907.00s]  one thing you should keep in your head
[3908.00s -> 3910.00s]  while reading is how do I get around
[3911.00s -> 3912.00s]  sort of this factor of two?
[3915.00s -> 3916.00s]  Okay?
[3917.00s -> 3918.00s]  Sorry, is it the case that you write
[3919.00s -> 3920.00s]  the H and the I separately?
[3921.00s -> 3922.00s]  Yeah, I think so.
[3923.00s -> 3924.00s]  Okay.
[3925.00s -> 3927.00s]  I'll show you in a second why,
[3928.00s -> 3929.00s]  what is happening there.
[3931.00s -> 3932.00s]  Or maybe.
[3934.00s -> 3936.00s]  Well, let me not commit too much for that answer,
[3937.00s -> 3939.00s]  but I'll come back to it.
[3940.00s -> 3941.00s]  I'm sorry, am I having the empty line,
[3942.00s -> 3943.00s]  not the H and the I, but yeah.
[3944.00s -> 3945.00s]  The new line is a separate right.
[3946.00s -> 3947.00s]  The H and I is one right
[3948.00s -> 3949.00s]  and the new line is a separate right.
[3949.00s -> 3950.00s]  Okay, thank you.
[3951.00s -> 3952.00s]  You're welcome.
[3953.00s -> 3954.00s]  Okay, there's complications
[3955.00s -> 3956.00s]  and I want to talk a little bit
[3957.00s -> 3958.00s]  about these complications.
[3964.00s -> 3965.00s]  So here's our basic scheme
[3966.00s -> 3967.00s]  and basic data structures
[3968.00s -> 3969.00s]  and there are three complications
[3970.00s -> 3971.00s]  that I want to talk about.
[3974.00s -> 3975.00s]  Maybe I'll call them challenges,
[3976.00s -> 3977.00s]  whatever you want to call them.
[3977.00s -> 3978.00s]  The first is eviction.
[3988.00s -> 3989.00s]  And the issue is as follows.
[3990.00s -> 3991.00s]  Let's say we go back to this picture here
[3993.00s -> 3994.00s]  and the whole B cache is full.
[3997.00s -> 3998.00s]  And so the transaction is in progress.
[4001.00s -> 4002.00s]  Let's say we just updated 45.
[4004.00s -> 4005.00s]  It's now done with block 45
[4005.00s -> 4006.00s]  so it's going to write the next block
[4007.00s -> 4008.00s]  and the cache is full.
[4013.00s -> 4015.00s]  And let's say we don't have a solution for this yet,
[4019.00s -> 4020.00s]  but the cache decides it wants to evict 45.
[4024.00s -> 4025.00s]  And if it wants to evict 45,
[4026.00s -> 4027.00s]  that will mean we have to write it
[4028.00s -> 4029.00s]  through its home location.
[4031.00s -> 4032.00s]  How bad would it be
[4032.00s -> 4033.00s]  to write the block evict 45
[4037.00s -> 4038.00s]  and write 45 to home location?
[4045.00s -> 4046.00s]  Is that good or bad?
[4046.00s -> 4047.00s]  Would any rule be broken if we did that?
[4049.00s -> 4050.00s]  I guess that is if a crash happens
[4051.00s -> 4052.00s]  before the other writes
[4053.00s -> 4054.00s]  in the same transaction occurs.
[4056.00s -> 4057.00s]  I don't know.
[4058.00s -> 4059.00s]  I don't know.
[4060.00s -> 4061.00s]  I don't know.
[4062.00s -> 4063.00s]  I don't know.
[4064.00s -> 4065.00s]  I don't know.
[4066.00s -> 4067.00s]  I don't know.
[4068.00s -> 4069.00s]  I don't know.
[4070.00s -> 4071.00s]  I don't know.
[4072.00s -> 4073.00s]  I don't know.
[4074.00s -> 4075.00s]  I don't know.
[4076.00s -> 4077.00s]  If the crash occurs,
[4078.00s -> 4079.00s]  then basically atomicity is broken.
[4080.00s -> 4081.00s]  Yeah.
[4082.00s -> 4083.00s]  So this is BAT, correct?
[4084.00s -> 4085.00s]  BAT is basically violates this write-ahead rule
[4086.00s -> 4087.00s]  that I talked about.
[4088.00s -> 4089.00s]  You have to write all the blocks to the lock
[4090.00s -> 4091.00s]  before you write any block
[4092.00s -> 4093.00s]  to its home location.
[4106.00s -> 4107.00s]  So it has to be the case, correct?
[4108.00s -> 4109.00s]  That the cache does not evict
[4110.00s -> 4111.00s]  any block that sits in the lock.
[4112.00s -> 4113.00s]  Does that make sense?
[4115.00s -> 4116.00s]  So the solution is
[4117.00s -> 4118.00s]  don't evict
[4121.00s -> 4123.00s]  blocks that are in the lock.
[4129.00s -> 4130.00s]  And this is exactly
[4131.00s -> 4132.00s]  what I was showing a little bit earlier
[4133.00s -> 4134.00s]  and said I didn't want to talk about.
[4134.00s -> 4135.00s]  So if you go to log write,
[4136.00s -> 4137.00s]  again, just to see for a second there,
[4140.00s -> 4141.00s]  log write, here's log write again.
[4143.00s -> 4144.00s]  And here we see this call to BPIN.
[4146.00s -> 4147.00s]  And what do you think BPIN does?
[4150.00s -> 4151.00s]  The name sort of indicates it.
[4155.00s -> 4156.00s]  It bins the block in the cache?
[4161.00s -> 4162.00s]  Yeah, and how does it do it?
[4162.00s -> 4163.00s]  Since you've been looking at this
[4164.00s -> 4165.00s]  for your current lab extensively,
[4167.00s -> 4168.00s]  what do you think it does?
[4169.00s -> 4170.00s]  So we've had, you know,
[4171.00s -> 4172.00s]  we can look up the implementation with BPIN,
[4173.00s -> 4174.00s]  but we can also guess what it does.
[4179.00s -> 4180.00s]  Doesn't it essentially just make it
[4181.00s -> 4182.00s]  so that it doesn't get evicted
[4183.00s -> 4184.00s]  by increasing the ref count?
[4185.00s -> 4186.00s]  Yeah, exactly.
[4187.00s -> 4188.00s]  This is the only thing it does.
[4189.00s -> 4190.00s]  BPIN just increases the ref count
[4190.00s -> 4191.00s]  so that it won't evict any blocks
[4193.00s -> 4194.00s]  we have a ref count higher than zero.
[4196.00s -> 4197.00s]  And so presumably somewhere later
[4198.00s -> 4199.00s]  in the logging code,
[4200.00s -> 4201.00s]  when once actually everything is logged,
[4202.00s -> 4203.00s]  we can actually unpin the block.
[4206.00s -> 4207.00s]  Okay, so that's one complication.
[4208.00s -> 4209.00s]  So we have this pinning and unpinning going on.
[4212.00s -> 4213.00s]  Let's look at the other complication.
[4220.00s -> 4221.00s]  The file system operations must fit in log.
[4241.00s -> 4242.00s]  You know, as you see,
[4243.00s -> 4244.00s]  if we go back to our picture here,
[4245.00s -> 4246.00s]  or actually maybe this is the better picture,
[4247.00s -> 4248.00s]  how big is the log in xv6?
[4250.00s -> 4251.00s]  30 blocks.
[4254.00s -> 4255.00s]  Yeah, 30 blocks.
[4256.00s -> 4257.00s]  Yeah, 32 minus two.
[4258.00s -> 4259.00s]  So, you know, the max size,
[4260.00s -> 4261.00s]  max log size is 30.
[4264.00s -> 4265.00s]  Of course we could bump it up
[4266.00s -> 4267.00s]  and, you know, real file system
[4268.00s -> 4269.00s]  runs with a much bigger log,
[4270.00s -> 4271.00s]  but it doesn't really matter.
[4272.00s -> 4273.00s]  No matter what, it has to be the case, Greg,
[4274.00s -> 4275.00s]  that the file system operation
[4276.00s -> 4277.00s]  must fit in 30 blocks.
[4278.00s -> 4279.00s]  Because if a file system operation
[4280.00s -> 4281.00s]  we would have to spill something
[4282.00s -> 4283.00s]  to the on-disk location,
[4284.00s -> 4285.00s]  and we're not allowed to do that, right?
[4286.00s -> 4287.00s]  Because that would violate
[4288.00s -> 4289.00s]  the write-ahead rule again.
[4290.00s -> 4291.00s]  So it has to be the case
[4292.00s -> 4293.00s]  that every file system operation
[4294.00s -> 4295.00s]  fits into the log.
[4296.00s -> 4297.00s]  Does that make sense?
[4298.00s -> 4299.00s]  And in fact, you know,
[4300.00s -> 4301.00s]  how do you think we got to 32, or 30?
[4310.00s -> 4311.00s]  Does it have to do anything
[4312.00s -> 4313.00s]  with how many blocks actually fit?
[4314.00s -> 4315.00s]  You know, we're not allowed to find
[4316.00s -> 4317.00s]  because basically what we,
[4318.00s -> 4319.00s]  how many blocks does,
[4320.00s -> 4321.00s]  what is the maximum number of blocks, Greg,
[4322.00s -> 4323.00s]  that the file system operation could write?
[4324.00s -> 4325.00s]  And that is really what the,
[4326.00s -> 4327.00s]  this number 30 has to be
[4328.00s -> 4329.00s]  definitely bigger than any,
[4330.00s -> 4331.00s]  you know, the max number of blocks
[4334.00s -> 4336.00s]  the file system operation
[4340.00s -> 4341.00s]  writes.
[4346.00s -> 4347.00s]  And so in fact,
[4348.00s -> 4349.00s]  you know, what Robert and I did is
[4350.00s -> 4351.00s]  we went through all the file system operations,
[4352.00s -> 4353.00s]  looked at them and, you know,
[4354.00s -> 4355.00s]  decided what sort of the maximum number is.
[4356.00s -> 4357.00s]  And it turns out the maximum number
[4358.00s -> 4359.00s]  is much lower than the 30.
[4360.00s -> 4361.00s]  But, you know, we'll see in a second
[4362.00s -> 4363.00s]  there's a couple interesting complications.
[4364.00s -> 4365.00s]  Like for example, the operation
[4366.00s -> 4367.00s]  that we looked so far,
[4368.00s -> 4369.00s]  like creating a file, correct,
[4370.00s -> 4371.00s]  in fact, most operations are,
[4372.00s -> 4373.00s]  you know, a handful of blocks,
[4374.00s -> 4375.00s]  not that many.
[4376.00s -> 4377.00s]  Can you think of any operations
[4378.00s -> 4379.00s]  that might write many, many, many blocks?
[4394.00s -> 4395.00s]  You mean write on a huge file?
[4396.00s -> 4397.00s]  Yeah, write a huge file, right?
[4398.00s -> 4399.00s]  So what if we, you know,
[4400.00s -> 4401.00s]  called the write system call
[4402.00s -> 4403.00s]  and we pass it to buffer
[4404.00s -> 4405.00s]  and we have like a megabyte of data,
[4406.00s -> 4407.00s]  right, like a thousand blocks?
[4408.00s -> 4409.00s]  It seems like we would be in serious trouble, right?
[4410.00s -> 4411.00s]  It would violate, you know,
[4412.00s -> 4413.00s]  these maximum rules.
[4414.00s -> 4415.00s]  And so let's look at write.
[4428.00s -> 4429.00s]  It says write,
[4430.00s -> 4431.00s]  so let's see if it's file write.
[4432.00s -> 4433.00s]  So here's file write.
[4434.00s -> 4435.00s]  Okay, so here's an inode,
[4436.00s -> 4437.00s]  a file descriptor inode.
[4438.00s -> 4439.00s]  Everybody can see my code,
[4440.00s -> 4441.00s]  the code that I have on the display.
[4442.00s -> 4443.00s]  And notice that what does this code do?
[4449.00s -> 4450.00s]  You can read the comment right on top,
[4451.00s -> 4452.00s]  you know, here, and it basically explains it.
[4453.00s -> 4454.00s]  But basically what happens, correct,
[4455.00s -> 4456.00s]  the write is split in many,
[4457.00s -> 4458.00s]  no more smaller writes.
[4458.00s -> 4460.00s]  So what really was going on here, correct,
[4461.00s -> 4464.00s]  is we're ensuring that the whole write
[4465.00s -> 4467.00s]  as a whole is not atomic,
[4468.00s -> 4469.00s]  but that's okay.
[4470.00s -> 4471.00s]  The write Unix system called semantics
[4472.00s -> 4473.00s]  don't require that actually all the
[4474.00s -> 4475.00s]  thousand blocks, you know, of our megabyte
[4476.00s -> 4477.00s]  are actually written atomically.
[4478.00s -> 4479.00s]  It just requires that we don't corrupt
[4480.00s -> 4481.00s]  the file system, you know, between,
[4482.00s -> 4483.00s]  don't corrupt the file system while doing it.
[4484.00s -> 4485.00s]  And so basically we, you know,
[4485.00s -> 4488.00s]  actually six splits a big write
[4489.00s -> 4490.00s]  in a number of smaller writes
[4491.00s -> 4492.00s]  and writes them as individual transactions.
[4493.00s -> 4494.00s]  And this one basically ensures
[4495.00s -> 4496.00s]  that in our example,
[4497.00s -> 4498.00s]  if a transaction allocates a block number
[4499.00s -> 4500.00s]  because we need a new block
[4501.00s -> 4502.00s]  as an intermediate block,
[4503.00s -> 4504.00s]  or because we need a new block
[4505.00s -> 4506.00s]  because we're gonna write to it,
[4507.00s -> 4508.00s]  at least that part is completely atomic
[4509.00s -> 4510.00s]  and the file system will be never left
[4511.00s -> 4512.00s]  in an incorrect state violating
[4513.00s -> 4514.00s]  any of the file system invariants.
[4515.00s -> 4516.00s]  I mean, in many smaller writes
[4517.00s -> 4518.00s]  or many transactions.
[4519.00s -> 4520.00s]  Okay.
[4521.00s -> 4522.00s]  In fact, that's the main one
[4523.00s -> 4527.00s]  that actually is write FS split
[4528.00s -> 4530.00s]  in many, many transactions.
[4537.00s -> 4538.00s]  Any questions about this?
[4543.00s -> 4544.00s]  And note, because, you know,
[4545.00s -> 4546.00s]  we're pinned correct in cache,
[4547.00s -> 4548.00s]  that means also that the block cache
[4549.00s -> 4550.00s]  was me bigger than,
[4551.00s -> 4553.00s]  bigger either due to lock size.
[4558.00s -> 4559.00s]  Okay.
[4560.00s -> 4561.00s]  So now the final challenge
[4562.00s -> 4563.00s]  that I wanna talk about
[4564.00s -> 4568.00s]  is concurrent file system calls.
[4576.00s -> 4577.00s]  And the issue is as follows.
[4578.00s -> 4579.00s]  It lets me first try to explain
[4580.00s -> 4581.00s]  what the problem is
[4582.00s -> 4583.00s]  and then we'll see what the solution is.
[4584.00s -> 4585.00s]  So let's say we have our log
[4587.00s -> 4588.00s]  and we're writing
[4591.00s -> 4592.00s]  and maybe there are two transactions
[4593.00s -> 4594.00s]  executing concurrently.
[4595.00s -> 4596.00s]  And just imagine for a second
[4597.00s -> 4598.00s]  that, you know,
[4599.00s -> 4600.00s]  they write a lot of blocks.
[4601.00s -> 4602.00s]  So basically T zero is executing
[4602.00s -> 4603.00s]  T zero is executing
[4604.00s -> 4605.00s]  and they're all full.
[4606.00s -> 4607.00s]  So here's the beginning of the log.
[4608.00s -> 4609.00s]  Here's the end of the log
[4610.00s -> 4611.00s]  and, you know, T one executes
[4612.00s -> 4613.00s]  you know, some blocks
[4614.00s -> 4615.00s]  and et cetera, et cetera.
[4616.00s -> 4617.00s]  And by the time we run
[4618.00s -> 4619.00s]  to the end of the log,
[4620.00s -> 4621.00s]  neither one is complete yet.
[4622.00s -> 4623.00s]  You know, so they both have still
[4624.00s -> 4625.00s]  more rights to do.
[4626.00s -> 4627.00s]  And at this point,
[4628.00s -> 4629.00s]  can we commit
[4630.00s -> 4631.00s]  any of the two transactions?
[4633.00s -> 4634.00s]  No, we can't.
[4635.00s -> 4636.00s]  Correct?
[4637.00s -> 4638.00s]  Because if we would commit
[4639.00s -> 4640.00s]  a transaction that is partially done,
[4641.00s -> 4642.00s]  then we violate
[4643.00s -> 4644.00s]  the right ahead rule again
[4645.00s -> 4646.00s]  and, you know, the whole purpose
[4647.00s -> 4648.00s]  of actually logging doesn't work out.
[4649.00s -> 4650.00s]  So it has to be the case
[4651.00s -> 4652.00s]  that basically a number
[4653.00s -> 4654.00s]  of concurrent transactions
[4655.00s -> 4656.00s]  must fit in the log.
[4657.00s -> 4658.00s]  In fact, all concurrent operations
[4663.00s -> 4664.00s]  current, so oops,
[4675.00s -> 4676.00s]  must fit.
[4677.00s -> 4678.00s]  And so in the way,
[4680.00s -> 4681.00s]  so this is sort of a challenge, correct?
[4682.00s -> 4683.00s]  We have, you know, a file system
[4684.00s -> 4685.00s]  call starting and, you know,
[4686.00s -> 4687.00s]  we got to sort of arrange
[4688.00s -> 4689.00s]  that basically the, that we,
[4690.00s -> 4691.00s]  that we basically do a sort of
[4692.00s -> 4693.00s]  an entrance, you know, check.
[4694.00s -> 4695.00s]  You know, before we actually
[4696.00s -> 4697.00s]  left the file system operation go,
[4698.00s -> 4699.00s]  we must check whether there
[4700.00s -> 4701.00s]  actually is enough blocks still,
[4702.00s -> 4703.00s]  you know, if we have like n file
[4704.00s -> 4705.00s]  system operations or any in progress,
[4706.00s -> 4707.00s]  we have to make sure that if we
[4708.00s -> 4709.00s]  allow one more guy to start,
[4710.00s -> 4711.00s]  that actually the total number of
[4712.00s -> 4713.00s]  blocks they could write together
[4714.00s -> 4715.00s]  actually fits in the log.
[4716.00s -> 4717.00s]  And the way, you know,
[4718.00s -> 4719.00s]  basically xv6 sort of gets around
[4720.00s -> 4721.00s]  this is basically limits the
[4722.00s -> 4723.00s]  operation.
[4729.00s -> 4730.00s]  And the way it basically works
[4731.00s -> 4732.00s]  is that,
[4735.00s -> 4736.00s]  in begin op, you know,
[4737.00s -> 4738.00s]  we just see how many outstanding
[4739.00s -> 4740.00s]  concurrent file system operations
[4741.00s -> 4742.00s]  are in progress.
[4743.00s -> 4744.00s]  If there are too many in progress,
[4745.00s -> 4746.00s]  we just stop the current file
[4747.00s -> 4748.00s]  system operation and it goes to
[4749.00s -> 4750.00s]  sleep and it will wait until
[4750.00s -> 4751.00s]  it's done.
[4751.00s -> 4752.00s]  And all the other guys will commit
[4753.00s -> 4754.00s]  together. In fact, like, you know,
[4755.00s -> 4756.00s]  at some point, you know, t1,
[4757.00s -> 4758.00s]  t2, they're basically done,
[4759.00s -> 4760.00s]  you know, maybe t3 is in a 2,
[4761.00s -> 4762.00s]  they finish and then basically in
[4763.00s -> 4764.00s]  all these transactions in a single
[4765.00s -> 4766.00s]  time, in a single, basically
[4767.00s -> 4768.00s]  committed together.
[4769.00s -> 4770.00s]  This is sometimes called group
[4771.00s -> 4772.00s]  commit because you're committing
[4773.00s -> 4774.00s]  multiple system calls, you know,
[4775.00s -> 4776.00s]  all the ones that were concurrent
[4777.00s -> 4778.00s]  in action, you committed
[4778.00s -> 4779.00s]  multiple transactions so that all
[4780.00s -> 4781.00s]  their updates are visible.
[4782.00s -> 4783.00s]  So that all their updates all
[4784.00s -> 4785.00s]  take place or none of them take
[4786.00s -> 4787.00s]  place.
[4791.00s -> 4792.00s]  Okay.
[4794.00s -> 4795.00s]  And we can see that, you know,
[4796.00s -> 4797.00s]  if we go to...
[4798.00s -> 4799.00s]  A quick question.
[4800.00s -> 4801.00s]  Is the group commit,
[4802.00s -> 4804.00s]  is grouping the commits necessary?
[4805.00s -> 4806.00s]  Like, could you
[4807.00s -> 4808.00s]  say if one system calls finish
[4809.00s -> 4810.00s]  first, just commit its
[4811.00s -> 4812.00s]  transaction and then commit
[4813.00s -> 4814.00s]  that once later or is it like a
[4815.00s -> 4816.00s]  necessary property?
[4817.00s -> 4818.00s]  You got to be very, very careful
[4819.00s -> 4820.00s]  because you remember one thing I
[4821.00s -> 4822.00s]  didn't really state as explicitly as
[4823.00s -> 4824.00s]  a goal early on is that we
[4825.00s -> 4826.00s]  basically execute the system calls
[4827.00s -> 4828.00s]  still in the right order, right?
[4829.00s -> 4830.00s]  If a write or if a read observes
[4831.00s -> 4832.00s]  a write and then does a write,
[4833.00s -> 4834.00s]  then it has to be the case that
[4834.00s -> 4835.00s]  that second write happens later
[4836.00s -> 4837.00s]  than the first write.
[4838.00s -> 4839.00s]  And the reason that this is a log,
[4840.00s -> 4841.00s]  correct, is because that basically
[4842.00s -> 4843.00s]  reflects the order in which the
[4844.00s -> 4845.00s]  writes have happened.
[4846.00s -> 4847.00s]  And so you can't really,
[4848.00s -> 4849.00s]  really nearly change the order of
[4850.00s -> 4851.00s]  the writes in the log because
[4852.00s -> 4853.00s]  that may actually result into
[4854.00s -> 4855.00s]  bizarre behavior, observable by
[4856.00s -> 4857.00s]  user programs.
[4858.00s -> 4859.00s]  And so that has to be the case
[4860.00s -> 4861.00s]  that basically you commit, you
[4862.00s -> 4863.00s]  know, the operations and
[4864.00s -> 4865.00s]  also perform the writes in the
[4866.00s -> 4867.00s]  order they happened.
[4868.00s -> 4869.00s]  And so in general, you know,
[4870.00s -> 4871.00s]  it's safe, you know, it's safe
[4872.00s -> 4873.00s]  to basically commit them all
[4874.00s -> 4875.00s]  together. You're always in a good
[4876.00s -> 4877.00s]  shape.
[4878.00s -> 4879.00s]  OK.
[4879.00s -> 4880.00s]  Good question, though.
[4883.00s -> 4884.00s]  OK, I just want to go back to
[4885.00s -> 4886.00s]  one more thing and look at the
[4887.00s -> 4888.00s]  beginning off.
[4889.00s -> 4890.00s]  I talked a little bit of the
[4891.00s -> 4892.00s]  guys said like, oh, nothing.
[4892.00s -> 4893.00s]  I don't want to talk about it
[4893.00s -> 4894.00s]  right now.
[4896.00s -> 4897.00s]  But.
[4898.00s -> 4899.00s]  There we can see.
[4901.00s -> 4902.00s]  So here's the game up.
[4903.00s -> 4904.00s]  First of all, if
[4905.00s -> 4906.00s]  we're ready and committing the
[4907.00s -> 4908.00s]  log, we're just going to wait
[4908.00s -> 4909.00s]  until the log has committed
[4910.00s -> 4911.00s]  because, you know, we can't
[4912.00s -> 4913.00s]  write to the log while the log
[4914.00s -> 4915.00s]  actually being installed.
[4916.00s -> 4917.00s]  If we're the
[4918.00s -> 4919.00s]  nth concurrent operation that
[4920.00s -> 4921.00s]  basically makes us go across
[4922.00s -> 4923.00s]  size, we could just go to sleep.
[4925.00s -> 4926.00s]  And wait until basically
[4927.00s -> 4928.00s]  all the preceding concurrent
[4928.00s -> 4929.00s]  transactions are done.
[4930.00s -> 4931.00s]  And if we're allowed to
[4932.00s -> 4933.00s]  proceed, you know, basically our
[4933.00s -> 4934.00s]  entrance is allowed.
[4935.00s -> 4936.00s]  You know, we increase lock
[4936.00s -> 4937.00s]  outstanding by one because
[4938.00s -> 4939.00s]  reflect our thing and then we
[4939.00s -> 4940.00s]  basically proceed and start
[4940.00s -> 4941.00s]  doing file system operations.
[4942.00s -> 4943.00s]  And if you don't look at
[4944.00s -> 4945.00s]  and up again, just to
[4946.00s -> 4947.00s]  see, you see the end up
[4947.00s -> 4948.00s]  basically decreases lock
[4949.00s -> 4950.00s]  outstanding by one because one
[4950.00s -> 4951.00s]  transaction has finished.
[4953.00s -> 4954.00s]  It certainly would be an error.
[4955.00s -> 4956.00s]  We were in creating states and
[4956.00s -> 4957.00s]  we panic in that case.
[4957.00s -> 4959.00s]  And we actually are the last
[4959.00s -> 4960.00s]  one from that set of
[4960.00s -> 4961.00s]  concurrent transactions.
[4962.00s -> 4963.00s]  Then actually and lock
[4963.00s -> 4964.00s]  outstanding goes to zero.
[4964.00s -> 4965.00s]  We immediately start committing.
[4966.00s -> 4967.00s]  And then when we're done
[4969.00s -> 4970.00s]  or when actually
[4971.00s -> 4972.00s]  if we're not the
[4973.00s -> 4974.00s]  yeah.
[4976.00s -> 4977.00s]  Yeah, we commit.
[4979.00s -> 4980.00s]  And if there's space, you
[4980.00s -> 4981.00s]  know, left, you know, we wake
[4982.00s -> 4983.00s]  up a guy so that they can
[4984.00s -> 4985.00s]  actually start running.
[4986.00s -> 4987.00s]  OK, so even this
[4988.00s -> 4989.00s]  dirt simple file system that
[4990.00s -> 4991.00s]  or just dirt simple logging
[4991.00s -> 4992.00s]  system that actually six
[4993.00s -> 4994.00s]  actually has a bunch of
[4994.00s -> 4995.00s]  complications.
[4998.00s -> 4999.00s]  So I'm starting to run out of
[4999.00s -> 5001.00s]  time, so let me wrap up here.
[5002.00s -> 5003.00s]  So in summary.
[5005.00s -> 5006.00s]  You know, what do we
[5007.00s -> 5008.00s]  what we talked about is
[5008.00s -> 5009.00s]  basically logging
[5010.00s -> 5011.00s]  as a solution for
[5013.00s -> 5014.00s]  for crash safety
[5015.00s -> 5017.00s]  or really for multi step
[5019.00s -> 5020.00s]  file system operations.
[5023.00s -> 5024.00s]  And, you know, what we've
[5025.00s -> 5026.00s]  seen so far, you know,
[5026.00s -> 5027.00s]  it works great for crash
[5027.00s -> 5028.00s]  safety, but, you know,
[5028.00s -> 5030.00s]  performance and
[5031.00s -> 5032.00s]  that's going to be the topic
[5032.00s -> 5033.00s]  for Monday. And
[5034.00s -> 5035.00s]  as you read that
[5036.00s -> 5037.00s]  free file system paper for
[5037.00s -> 5038.00s]  Monday, you know, that's the
[5038.00s -> 5039.00s]  thing you should be thinking
[5039.00s -> 5040.00s]  about.
[5041.00s -> 5042.00s]  OK, any more final
[5043.00s -> 5044.00s]  questions? And in fact,
[5044.00s -> 5045.00s]  anybody who has to leave,
[5045.00s -> 5046.00s]  please feel free to leave.
[5047.00s -> 5048.00s]  But if you want to hang
[5048.00s -> 5049.00s]  around and ask more
[5049.00s -> 5050.00s]  questions, you know, please
[5050.00s -> 5051.00s]  do so.
[5054.00s -> 5055.00s]  I have a question regarding
[5057.00s -> 5058.00s]  cache size and the log
[5058.00s -> 5059.00s]  size.
[5059.00s -> 5060.00s]  So you said that the cache
[5061.00s -> 5062.00s]  size has to be at least as
[5062.00s -> 5063.00s]  big as the log size,
[5064.00s -> 5065.00s]  but they seem to be the
[5065.00s -> 5066.00s]  same size for
[5067.00s -> 5068.00s]  this case.
[5068.00s -> 5069.00s]  So would that mean that
[5069.00s -> 5071.00s]  if the log pins
[5072.00s -> 5073.00s]  30
[5074.00s -> 5075.00s]  buffers
[5076.00s -> 5077.00s]  and then some other
[5077.00s -> 5078.00s]  operation tries to do
[5078.00s -> 5079.00s]  something,
[5079.00s -> 5080.00s]  it just fails because
[5081.00s -> 5082.00s]  it runs out of
[5083.00s -> 5084.00s]  free
[5086.00s -> 5087.00s]  spots in the buffer?
[5087.00s -> 5088.00s]  No.
[5089.00s -> 5090.00s]  Maybe let's
[5090.00s -> 5091.00s]  let's look at the
[5093.00s -> 5094.00s]  cache.
[5094.00s -> 5095.00s]  So.
[5096.00s -> 5097.00s]  Let me first actually
[5097.00s -> 5098.00s]  check one thing.
[5102.00s -> 5104.00s]  OK, let's go through bio.
[5107.00s -> 5108.00s]  OK.
[5110.00s -> 5111.00s]  Let's actually first check
[5111.00s -> 5112.00s]  if involved is bigger than.
[5115.00s -> 5116.00s]  OK, sets of
[5116.00s -> 5117.00s]  lots of sizes in the
[5117.00s -> 5118.00s]  block cache.
[5118.00s -> 5119.00s]  OK, so it's set up to
[5119.00s -> 5120.00s]  something big.
[5121.00s -> 5122.00s]  So what happens actually
[5122.00s -> 5123.00s]  if we can't find
[5123.00s -> 5124.00s]  we can't find a buffer
[5125.00s -> 5126.00s]  and actually there's
[5126.00s -> 5127.00s]  panics.
[5128.00s -> 5129.00s]  And.
[5131.00s -> 5132.00s]  So we're
[5133.00s -> 5134.00s]  there's no free slot
[5134.00s -> 5135.00s]  in the buffer cache,
[5135.00s -> 5136.00s]  actually six panics,
[5136.00s -> 5137.00s]  so it's not particularly
[5137.00s -> 5138.00s]  ideal. In fact,
[5138.00s -> 5139.00s]  it's terrible.
[5140.00s -> 5141.00s]  And so you hope never
[5141.00s -> 5142.00s]  to be in this situation
[5142.00s -> 5143.00s]  and hopefully we picked our
[5143.00s -> 5144.00s]  numbers correctly that
[5144.00s -> 5145.00s]  basically this is unlikely
[5145.00s -> 5146.00s]  to happen.
[5146.00s -> 5147.00s]  But why can't we return
[5147.00s -> 5148.00s]  an error?
[5149.00s -> 5150.00s]  Because that seems like
[5150.00s -> 5151.00s]  the obvious thing to do
[5151.00s -> 5152.00s]  like, you know.
[5153.00s -> 5154.00s]  You
[5165.00s -> 5166.00s]  just return an error
[5166.00s -> 5167.00s]  to the caller
[5167.00s -> 5168.00s]  and then the caller
[5168.00s -> 5169.00s]  maybe returns
[5169.00s -> 5170.00s]  back up to the
[5170.00s -> 5171.00s]  file system interface
[5171.00s -> 5172.00s]  and just return
[5172.00s -> 5173.00s]  minus one saying like,
[5173.00s -> 5174.00s]  oh, this operation failed.
[5175.00s -> 5176.00s]  Why is that a
[5176.00s -> 5177.00s]  problem?
[5180.00s -> 5181.00s]  So ready to think
[5181.00s -> 5182.00s]  about this is that
[5182.00s -> 5183.00s]  many file system
[5183.00s -> 5184.00s]  operations are multi-step
[5184.00s -> 5185.00s]  operations, right?
[5186.00s -> 5187.00s]  As we have seen
[5187.00s -> 5188.00s]  now in this lecture
[5189.00s -> 5190.00s]  and in the previous
[5190.00s -> 5191.00s]  lecture.
[5191.00s -> 5192.00s]  And let's say
[5193.00s -> 5194.00s]  we did two writes
[5194.00s -> 5195.00s]  and then the
[5195.00s -> 5196.00s]  third write
[5196.00s -> 5197.00s]  we run into this case
[5198.00s -> 5199.00s]  where we can't
[5199.00s -> 5200.00s]  actually do the write
[5200.00s -> 5201.00s]  because, you know,
[5201.00s -> 5202.00s]  there's no place in
[5202.00s -> 5203.00s]  the block cache.
[5203.00s -> 5204.00s]  We have done
[5204.00s -> 5205.00s]  two writes, right?
[5206.00s -> 5207.00s]  Can we just
[5207.00s -> 5208.00s]  bail out of the
[5208.00s -> 5209.00s]  file system call?
[5210.00s -> 5211.00s]  Okay, I see.
[5211.00s -> 5212.00s]  Right.
[5212.00s -> 5213.00s]  We cannot, right?
[5213.00s -> 5214.00s]  Because we might
[5214.00s -> 5215.00s]  have updated
[5215.00s -> 5216.00s]  in the directory,
[5216.00s -> 5217.00s]  you know, a
[5217.00s -> 5218.00s]  directory block of
[5218.00s -> 5219.00s]  some file.
[5219.00s -> 5220.00s]  We might have
[5220.00s -> 5221.00s]  to update a
[5221.00s -> 5222.00s]  directory block
[5222.00s -> 5223.00s]  of some directory.
[5223.00s -> 5224.00s]  And if we
[5224.00s -> 5225.00s]  wanted to make
[5225.00s -> 5226.00s]  this work,
[5226.00s -> 5227.00s]  you know,
[5227.00s -> 5228.00s]  what we would
[5228.00s -> 5229.00s]  have to do is
[5229.00s -> 5230.00s]  basically undo
[5230.00s -> 5231.00s]  those changes, right?
[5231.00s -> 5232.00s]  Like any
[5232.00s -> 5233.00s]  writes that we
[5233.00s -> 5234.00s]  did before as
[5234.00s -> 5235.00s]  part of that
[5235.00s -> 5236.00s]  system call,
[5236.00s -> 5237.00s]  we have to undo.
[5238.00s -> 5239.00s]  Right, okay.
[5239.00s -> 5240.00s]  No, that is
[5240.00s -> 5241.00s]  painful.
[5241.00s -> 5242.00s]  Right.
[5242.00s -> 5243.00s]  So we don't
[5243.00s -> 5244.00s]  do it.
[5244.00s -> 5245.00s]  Does that make
[5245.00s -> 5246.00s]  sense?
[5246.00s -> 5247.00s]  Okay, so it's
[5247.00s -> 5248.00s]  not a problem
[5248.00s -> 5249.00s]  if the
[5249.00s -> 5250.00s]  log,
[5250.00s -> 5251.00s]  the log
[5251.00s -> 5252.00s]  pins everything
[5252.00s -> 5253.00s]  and there's
[5253.00s -> 5254.00s]  no more space
[5254.00s -> 5255.00s]  for cache,
[5255.00s -> 5256.00s]  but it will
[5256.00s -> 5257.00s]  just panic.
[5257.00s -> 5258.00s]  Okay.
[5258.00s -> 5259.00s]  Yeah.
[5259.00s -> 5260.00s]  Yeah, of course
[5260.00s -> 5261.00s]  this panic
[5261.00s -> 5262.00s]  should never
[5262.00s -> 5263.00s]  really happen,
[5263.00s -> 5264.00s]  right?
[5264.00s -> 5265.00s]  Like there's
[5265.00s -> 5266.00s]  only odd
[5266.00s -> 5267.00s]  things.
[5267.00s -> 5268.00s]  Okay.
[5268.00s -> 5269.00s]  Yeah, that
[5269.00s -> 5270.00s]  makes sense.
[5270.00s -> 5271.00s]  Okay.
[5271.00s -> 5272.00s]  Thank you.
[5272.00s -> 5273.00s]  You're
[5273.00s -> 5274.00s]  welcome.
[5274.00s -> 5275.00s]  Any more
[5275.00s -> 5276.00s]  questions?
[5276.00s -> 5277.00s]  I had a
[5277.00s -> 5278.00s]  question about
[5278.00s -> 5279.00s]  I guess
[5279.00s -> 5280.00s]  following off
[5280.00s -> 5281.00s]  on my
[5281.00s -> 5282.00s]  earlier one
[5282.00s -> 5283.00s]  about the
[5283.00s -> 5284.00s]  group commits.
[5284.00s -> 5285.00s]  Yeah.
[5285.00s -> 5286.00s]  I was trying
[5286.00s -> 5287.00s]  to think of,
[5287.00s -> 5288.00s]  like I think
[5288.00s -> 5289.00s]  I kind of
[5289.00s -> 5290.00s]  understand it
[5290.00s -> 5291.00s]  a halo what
[5291.00s -> 5292.00s]  I was trying
[5292.00s -> 5293.00s]  to make sure
[5293.00s -> 5294.00s]  like I
[5294.00s -> 5295.00s]  understand a
[5295.00s -> 5296.00s]  little bit
[5296.00s -> 5297.00s]  about how
[5297.00s -> 5298.00s]  the group
[5298.00s -> 5299.00s]  demonstrates it.
[5299.00s -> 5300.00s]  It's like,
[5300.00s -> 5301.00s]  I guess I
[5301.00s -> 5302.00s]  was thinking
[5302.00s -> 5303.00s]  of like a
[5303.00s -> 5304.00s]  situation where
[5304.00s -> 5305.00s]  you have
[5305.00s -> 5306.00s]  say like
[5306.00s -> 5307.00s]  this might be
[5307.00s -> 5308.00s]  convoluted like
[5308.00s -> 5309.00s]  one process
[5309.00s -> 5310.00s]  generating a
[5310.00s -> 5311.00s]  stream of
[5311.00s -> 5312.00s]  like numbers
[5312.00s -> 5313.00s]  like one
[5313.00s -> 5314.00s]  through n and
[5314.00s -> 5315.00s]  then two
[5315.00s -> 5316.00s]  processes
[5316.00s -> 5317.00s]  consuming
[5317.00s -> 5318.00s]  that maybe
[5318.00s -> 5319.00s]  they're
[5319.00s -> 5320.00s]  listening on
[5320.00s -> 5321.00s]  the same pipe
[5321.00s -> 5322.00s]  and say
[5322.00s -> 5323.00s]  like n
[5323.00s -> 5324.00s]  like stops
[5324.00s -> 5325.00s]  the even
[5325.00s -> 5326.00s]  numbers and
[5326.00s -> 5327.00s]  if you didn't
[5327.00s -> 5328.00s]  have group
[5328.00s -> 5329.00s]  commits so
[5329.00s -> 5330.00s]  like the
[5330.00s -> 5331.00s]  correct
[5331.00s -> 5332.00s]  behavior is
[5332.00s -> 5333.00s]  and say
[5333.00s -> 5334.00s]  they're
[5334.00s -> 5335.00s]  printing out
[5335.00s -> 5336.00s]  or like
[5336.00s -> 5337.00s]  they're
[5337.00s -> 5338.00s]  writing these
[5338.00s -> 5339.00s]  to the
[5339.00s -> 5340.00s]  same file
[5340.00s -> 5341.00s]  and so the
[5341.00s -> 5342.00s]  correct
[5342.00s -> 5343.00s]  behavior would
[5343.00s -> 5344.00s]  be at the
[5344.00s -> 5345.00s]  end of at
[5345.00s -> 5346.00s]  the end of
[5346.00s -> 5347.00s]  all this you
[5347.00s -> 5348.00s]  would expect
[5348.00s -> 5349.00s]  the file to
[5349.00s -> 5350.00s]  have like
[5350.00s -> 5351.00s]  an even
[5351.00s -> 5352.00s]  number like
[5352.00s -> 5353.00s]  the last
[5353.00s -> 5354.00s]  one and
[5354.00s -> 5355.00s]  so you actually
[5355.00s -> 5356.00s]  see nine is
[5356.00s -> 5357.00s]  this like a
[5357.00s -> 5358.00s]  correct example
[5358.00s -> 5359.00s]  of why this
[5359.00s -> 5360.00s]  is important
[5360.00s -> 5361.00s]  I think I
[5361.00s -> 5362.00s]  have to think
[5362.00s -> 5363.00s]  a little bit
[5363.00s -> 5364.00s]  more carefully
[5364.00s -> 5365.00s]  about it
[5365.00s -> 5366.00s]  but that is
[5366.00s -> 5367.00s]  definitely the
[5367.00s -> 5368.00s]  flavor of
[5368.00s -> 5369.00s]  the problem
[5369.00s -> 5370.00s]  that you might
[5370.00s -> 5371.00s]  run into if
[5371.00s -> 5372.00s]  you reorder
[5372.00s -> 5373.00s]  system calls
[5373.00s -> 5374.00s]  okay okay
[5374.00s -> 5375.00s]  I think I
[5375.00s -> 5376.00s]  have a
[5376.00s -> 5377.00s]  concrete example
[5377.00s -> 5378.00s]  in the lecture
[5378.00s -> 5379.00s]  notes okay
[5379.00s -> 5380.00s]  in the lecture
[5380.00s -> 5381.00s]  notes you
[5381.00s -> 5382.00s]  know the shell
[5382.00s -> 5383.00s]  is really an
[5383.00s -> 5384.00s]  issue that
[5384.00s -> 5385.00s]  transactions need
[5385.00s -> 5386.00s]  to be committed
[5386.00s -> 5387.00s]  in order
[5387.00s -> 5388.00s]  I see and
[5388.00s -> 5389.00s]  if you didn't
[5389.00s -> 5390.00s]  have group
[5390.00s -> 5391.00s]  commit then
[5391.00s -> 5392.00s]  yeah
[5392.00s -> 5393.00s]  people might
[5393.00s -> 5394.00s]  think like
[5394.00s -> 5395.00s]  well what
[5395.00s -> 5396.00s]  I should do
[5396.00s -> 5397.00s]  if you didn't
[5397.00s -> 5398.00s]  have group
[5398.00s -> 5399.00s]  commit then
[5399.00s -> 5400.00s]  there's a
[5400.00s -> 5401.00s]  temptation to
[5401.00s -> 5402.00s]  basically you
[5402.00s -> 5403.00s]  know commit
[5403.00s -> 5404.00s]  some later
[5404.00s -> 5405.00s]  transaction because
[5405.00s -> 5406.00s]  it's already
[5406.00s -> 5407.00s]  finished but
[5407.00s -> 5408.00s]  the first one
[5408.00s -> 5409.00s]  isn't finished
[5409.00s -> 5410.00s]  yet and to
[5410.00s -> 5411.00s]  create space
[5411.00s -> 5412.00s]  let's let's
[5412.00s -> 5413.00s]  just example
[5413.00s -> 5414.00s]  I think you
[5414.00s -> 5415.00s]  know shell
[5415.00s -> 5416.00s]  command where
[5416.00s -> 5417.00s]  sort of illustrates
[5417.00s -> 5418.00s]  that like ordering
[5418.00s -> 5419.00s]  is important
[5419.00s -> 5420.00s]  okay
[5420.00s -> 5421.00s]  it doesn't
[5421.00s -> 5422.00s]  tie it directly
[5422.00s -> 5423.00s]  to group
[5423.00s -> 5424.00s]  commit but
[5424.00s -> 5425.00s]  it usually
[5425.00s -> 5426.00s]  basically makes
[5426.00s -> 5427.00s]  the point that
[5427.00s -> 5428.00s]  ordering the
[5428.00s -> 5429.00s]  system calls
[5429.00s -> 5430.00s]  is important
[5430.00s -> 5431.00s]  I see is
[5431.00s -> 5432.00s]  this in the
[5432.00s -> 5433.00s]  the like
[5433.00s -> 5434.00s]  the text
