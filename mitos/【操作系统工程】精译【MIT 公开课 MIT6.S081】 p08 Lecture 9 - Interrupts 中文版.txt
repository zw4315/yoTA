# Detected language: en (p=1.00)

[0.00s -> 13.96s]  For folks who already signed in, I was curious to see how you experienced being with the
[13.96s -> 14.96s]  traps lab.
[14.96s -> 21.68s]  And if you already started on the lazy allocation lab, how was that going?
[21.68s -> 26.56s]  Here's the year when it was less painful than the page table lab.
[26.56s -> 39.76s]  Andrew, do you want to say something about that?
[39.76s -> 41.96s]  I thought the traps lab was okay.
[41.96s -> 50.52s]  It was just making sure that I actually used the trampoline page properly was a little
[50.52s -> 51.52s]  annoying.
[51.52s -> 56.64s]  But once I figured that out, then it just kind of worked.
[56.64s -> 65.40s]  The whole goal of the lab was to really expose you to the trap handling entry and exit.
[65.40s -> 68.28s]  How about Amir?
[68.28s -> 77.32s]  How was your experience with the traps lab?
[77.32s -> 80.36s]  I thought the traps lab was good.
[80.36s -> 85.32s]  Very much more manageable than the page table lab.
[85.32s -> 90.32s]  I noticed that there were opportunities to be clever about some aspects of the implementation,
[90.32s -> 91.96s]  which was nice.
[91.96s -> 99.32s]  And the lazy lab is good so far, debugging, but both better than the page table lab,
[99.32s -> 100.32s]  in my opinion.
[100.32s -> 101.32s]  Glad to hear that.
[101.32s -> 108.28s]  I'm sure you were glad to hear that, but I'm glad to hear it too.
[108.28s -> 113.08s]  How about Timmy?
[113.08s -> 119.68s]  These two previous labs have been a lot better than the page table one.
[119.68s -> 128.16s]  I guess the hardest part for the latest lab, the lazy one, was the read and write
[128.16s -> 129.80s]  and all that stuff.
[129.80s -> 133.72s]  And it's not that bad, in my opinion.
[133.72s -> 144.76s]  How about you, Catherine, with the traps lab and the lazy lab for you in comparison
[144.76s -> 148.28s]  to the page table lab?
[148.28s -> 153.24s]  Are you there, Catherine?
[153.24s -> 157.56s]  I guess Catherine weeks.
[157.56s -> 161.80s]  Hello, I'm doing well.
[161.80s -> 167.88s]  Sorry, I didn't know which Catherine you're talking to.
[167.88s -> 173.12s]  I guess there's only 20 people, so probably not likely that there's another one.
[173.12s -> 174.12s]  I'm doing quite well.
[174.52s -> 175.52s]  Good, good.
[175.52s -> 178.76s]  So this lab is less painful than the page table lab?
[178.76s -> 181.32s]  Yes, it is definitely less painful.
[181.32s -> 182.32s]  Excellent.
[182.32s -> 194.12s]  Yeah, the one after page tables, what was that traps, that was definitely much simpler.
[194.12s -> 195.12s]  Good.
[195.12s -> 196.12s]  Okay, great.
[196.12s -> 203.28s]  We're glad to hear that, I just wanted to get an informal poll, see the page table
[203.28s -> 208.84s]  turned out harder than we thought it would, and so glad to hear that these ones are
[208.84s -> 209.84s]  better.
[209.84s -> 216.88s]  Okay, so why don't we get going, and welcome to the next lecture in 6.081, wherever you
[216.88s -> 217.88s]  are.
[217.88s -> 222.88s]  So the topic of today is about interrupts, but before jumping into sort of talking
[222.88s -> 227.20s]  about interrupts, I wanted to share a little bit one thing that I wanted to talk about
[227.20s -> 232.00s]  last week, which I tend to get around doing here, and you know, which you might find
[232.00s -> 233.00s]  interesting.
[233.00s -> 238.40s]  Let me see if I can get my right screen here up.
[238.40s -> 243.92s]  So here, you know, you see my screens here on the bottom left, I'm actually logged
[243.92s -> 251.40s]  into Athena through the dialog machines, and there's a couple things I wanted to talk
[251.40s -> 257.12s]  about in terms of how memory is being used by a real operating system.
[257.12s -> 259.76s]  Since we talked a lot about that last week, and particularly in the end of the lecture
[259.76s -> 264.48s]  were a lot of questions about, you know, page out, finding free memory, and all that kind
[264.48s -> 265.48s]  of stuff.
[265.48s -> 271.16s]  So this is one of the Athena machines, you know, one thing to note if you look at the
[271.16s -> 276.40s]  memory line, it actually tells you how much, okay, the program I'm running is called
[276.40s -> 282.08s]  Top, apart from any of you who have used it, you see how much memory is in a machine,
[282.08s -> 288.52s]  and as you can see, there's quite a bit of memory in this machine, and if you look a
[288.52s -> 296.00s]  little bit carefully, actually most of it is used, right, you know, a large part of
[296.00s -> 298.56s]  the memory is actually not being used by applications, but it's actually used by
[298.56s -> 303.08s]  the buffer cache, and so this is quite common in an operating system, you don't really
[303.08s -> 307.24s]  want to leave your, you know, physical memory sitting idle and do nothing, you might
[307.24s -> 311.24s]  as well use it for something useful, and so in this case, you know, the good chunk
[311.28s -> 314.28s]  of it is actually used for the buffer cache.
[314.28s -> 321.28s]  There's a little bit of memory free, not much, you know, fraction of like from the total
[321.28s -> 324.76s]  memory that actually is in the machine, and so this is a very common case, like most
[324.76s -> 329.08s]  operating systems sort of run with basically almost no memory free at any
[329.08s -> 333.72s]  particular instance in time, and so what that means, for example, if an
[333.72s -> 337.44s]  application or the kernel needs some memory, it will have to throw out
[337.44s -> 342.52s]  something, you know, maybe it has enough for a few pages or a handful of pages, but
[342.52s -> 345.64s]  at some point if it needs a lot of free memory, it will ask to evict something,
[345.64s -> 350.04s]  either from the applications or from the buffer cache, and so, you know, the sort
[350.04s -> 353.00s]  of a, and so the main point here basically is that here when the kernel
[353.00s -> 356.04s]  needs allocate memory, it's actually not generally not a cheap operation,
[356.04s -> 359.28s]  because, you know, the memory is not, there's not a ton of memory free
[359.28s -> 363.40s]  available. The other thing that's sort of interesting to look at is I sorted the
[363.40s -> 371.60s]  output of top by the amount of resident memory, so you look at every line for
[371.60s -> 376.28s]  every process, you know, you see that this is the size of the address space, and then
[376.28s -> 378.96s]  the next line actually tells you how much memory is actually being used,
[378.96s -> 382.84s]  like the amount of physical memory, you know, how the fraction of the address
[382.84s -> 386.08s]  beta actually is in physical memory, and as you can see it actually, you know,
[386.08s -> 390.72s]  it's typically way smaller than the address space, and so the tricks that we
[390.72s -> 396.28s]  talked about last where the cool ideas virtual memory provides are being used
[396.28s -> 401.56s]  here, like this demand paging, the shared columnists, shared pages, you know,
[401.56s -> 407.20s]  from the shared libraries, and you see in general that basically the resident
[407.20s -> 411.84s]  memory is much, much, much smaller than the virtual address space. Maybe in a
[411.84s -> 415.16s]  couple other interesting things to sort of note, just like looking at this
[415.16s -> 419.84s]  machine, the load is very low, even though there are 120 users, 101, 102
[419.88s -> 425.36s]  users logged in, and you're gonna see there's a lot of processes, you know,
[425.36s -> 430.84s]  950 or roughly. Another thing to note is actually how long the machine has been up,
[430.84s -> 436.24s]  like 249 days. You know, your xv6 kernel is probably not up that long at
[436.24s -> 444.48s]  all ever. Okay, so that's, you know, any questions about this, just sort of, you
[444.48s -> 447.80s]  know, the main point being that like most memories in use and the resident
[447.80s -> 455.52s]  memory is typically much smaller than the virtual address space. You can, of
[455.52s -> 461.24s]  course, run this yourself if you want to, and see what actually what's up. Any
[461.24s -> 467.40s]  questions? You see some of the 6S081 students being logged in, and if you
[467.40s -> 474.28s]  look around, you see a whole bunch of QMUs running. Okay, no questions. Let
[474.28s -> 482.24s]  me go back to the topic for today, which is interrupts. And the basic, you know,
[482.24s -> 486.28s]  the basic idea is very straightforward, or what we want to enable is that
[487.72s -> 490.96s]  there's going to be cases where the hardware wants attention,
[494.56s -> 500.96s]  wants attention now. You know, a packet comes in from the network, and so the
[500.96s -> 507.36s]  network, the network card generates an interrupt, user types a key on the
[507.36s -> 512.24s]  keyboard, and you know, the keyboard generates an interrupt. And, you know,
[512.24s -> 517.72s]  what the shopper has to do is the shopper has to save its work, whatever
[517.72s -> 523.68s]  it was doing right now, put that on the site, you know, process the
[523.68s -> 539.44s]  interrupt, and then resume or restore into the work that it is doing. And,
[540.60s -> 545.48s]  you know, basically that saving and restoring is very, very similar to the
[545.52s -> 548.52s]  you know, mechanisms that we already have seen before, namely for system
[548.52s -> 566.88s]  calls and traps, like page faults, they all use the same mechanism. So in
[566.88s -> 571.04s]  that sense, you know, interrupts are no different whatsoever compared to traps
[571.04s -> 574.88s]  or, you know, system calls, but a couple things that make them a little
[574.88s -> 578.32s]  bit different and why we're actually spending a little lecture on them. So
[578.32s -> 584.44s]  three basically things that make interrupts slightly different from
[584.68s -> 589.20s]  system calls and exceptions. One, for a better word, I'm going to call
[589.20s -> 597.84s]  their asynchronous. And with that, I mean, that the system called the
[597.84s -> 600.36s]  interrupt that happens, you know, when the hardware action generator
[600.36s -> 603.48s]  interrupts, and then the interrupt handler runs, the interrupt handler
[603.48s -> 606.76s]  might actually have nothing to do with the current running process on
[606.76s -> 610.84s]  the CPU. So unlike, for example, when you do a system call, when the
[610.84s -> 614.16s]  system call happens, and then you jump into the kernel, then we're
[614.16s -> 617.56s]  running in the context of the calling process. And this is not
[617.56s -> 620.88s]  true with interrupts, they might have been completely unrelated to
[620.88s -> 624.60s]  actually, you know, the process that, you know, is running in the CPU
[624.60s -> 626.88s]  might actually have nothing to do with the interrupt handler may not
[626.88s -> 633.16s]  even have caused it. So that's the difference. Second of all, there is
[633.84s -> 639.16s]  much more concurrency than we have seen so far. In fact, you know,
[639.16s -> 642.44s]  sort of this is a starting place where we're talking about
[642.44s -> 645.32s]  concurrency. And we'll talk about it in Wednesday lecture a
[645.32s -> 648.88s]  lot more. The basic observation is that basically the CPU
[648.92s -> 651.96s]  and the device that generate interrupt, there's an outbreak
[651.96s -> 654.96s]  in parallel, you know, the UART with a network card, you know,
[654.96s -> 657.56s]  it's just doing its thing, you know, basically picking packets
[657.56s -> 660.40s]  up in the network, and then at some point generating an interrupt.
[660.80s -> 663.32s]  And once same time, the CPU is running, it also is doing its
[663.32s -> 666.32s]  own thing. So we have like true parallelism, you know, going
[666.32s -> 669.60s]  on between the device and the CPU. And we have to manage
[669.60s -> 673.92s]  that parallelism as we'll see in a second. And then finally,
[675.08s -> 677.48s]  you know, I'm going to be focused mostly on external
[677.48s -> 680.40s]  devices like network cards and UART, and those have to be
[680.40s -> 681.00s]  programmed.
[681.00s -> 691.56s]  And basically, you know, every device has sort of its own
[691.56s -> 694.36s]  programming manual in the same way that the sort of RISC-V
[694.36s -> 696.88s]  has a manual with the instructions and you know, which
[696.88s -> 700.68s]  registers do what. Every device actually has a similar
[700.68s -> 704.84s]  sort of type manual with, you know, describing what register
[704.84s -> 708.28s]  it has, what operations you can perform, what the device
[708.28s -> 710.24s]  does, you know, in response to the reading and writing
[710.24s -> 716.00s]  control registers. Unfortunately, often the manuals
[716.00s -> 720.80s]  for the devices are less clear than the RISC-V manual, which
[720.80s -> 725.40s]  makes programming even more complicated. And so what I'm
[725.40s -> 727.08s]  going to do in this lecture is actually pretty
[727.08s -> 733.08s]  straightforward. I just want to talk about how the prompt
[733.36s -> 737.68s]  shows up when, you know, the shell prints the prompt and
[737.72s -> 743.04s]  then if you type LS, you know, how do these characters get
[743.04s -> 745.60s]  read and actually then being displayed in the console. And
[745.60s -> 747.68s]  in fact, so basically the rest of this lecture is about
[747.68s -> 752.88s]  these three characters. But all the mechanisms that's
[752.88s -> 757.64s]  necessary to actually make that happen. Any questions so
[757.64s -> 760.28s]  far before I start diving more a little deeper?
[766.20s -> 772.32s]  Okay, so let's, so the first question maybe to ask is
[772.32s -> 773.56s]  where do the interrupts come from?
[788.00s -> 791.60s]  And since we're gonna be focusing mostly on this lecture
[791.60s -> 794.28s]  on external interrupts, you know, not timer interrupts or
[794.28s -> 797.64s]  software interrupts, you know, the external interrupts come
[797.64s -> 800.56s]  from devices that are sitting on the board. And here's
[800.56s -> 805.88s]  our sci-fi board that QEMU more or less emulates, you
[805.88s -> 809.48s]  know, there's some small modifications. And we see
[809.48s -> 811.40s]  there's actually, you know, if you look around on this
[811.40s -> 814.52s]  board, there's a lot of actually different devices there
[814.52s -> 816.56s]  that, you know, can be connected to this board, you
[816.60s -> 820.76s]  know, here are even at our connector. In fact, here's,
[821.00s -> 824.96s]  here's a micro USB that sits over there. There's a micro
[824.96s -> 829.32s]  SD card, you know, there are reset buttons. And so
[829.32s -> 832.24s]  there's all kinds of lines that must be running from
[832.24s -> 836.20s]  those devices into the CPU. And most of this lecture is
[836.20s -> 838.28s]  basically sort of understanding, you know, what
[838.28s -> 844.08s]  happens at the CPU when the device generates an interrupt
[844.08s -> 846.12s]  and how to read and write the information from the
[846.16s -> 852.52s]  device. I believe like these lower the two pins here at
[852.52s -> 855.36s]  this expansion connector, I think the one of them is
[855.36s -> 860.60s]  UART is the UART sent or transmission and the
[860.60s -> 869.88s]  other one is the UART zero receive line. And I
[869.88s -> 871.56s]  think it's actually connected to both sides to
[871.56s -> 873.84s]  micro USB as well as to this expansion cord. And I
[873.84s -> 876.28s]  think the UART chip itself, you know, might
[876.28s -> 886.28s]  actually be inside of this chip over there. Okay, so,
[887.00s -> 890.20s]  so basically, there's a bunch of lines running on
[890.20s -> 893.24s]  the board, you know, into the CPU. You know, so
[893.24s -> 895.16s]  we go zoom in a little bit more in detail on the
[895.16s -> 900.76s]  CPU. You know, here's a schema from the, you
[900.80s -> 904.52s]  know, the sci-fi documentation for the board, or
[904.52s -> 909.40s]  the processor, the core that we're using. We looked
[909.40s -> 912.12s]  at this a little bit before. And, you know, we
[912.12s -> 914.76s]  see here, basically, here are the devices on the
[915.20s -> 918.44s]  right side, here are UART zero. And, you know, we
[918.44s -> 920.68s]  know that basically, there's UART zero's memory
[920.68s -> 924.04s]  mapped somewhere in the physical address space, like
[924.04s -> 926.48s]  all the DRAM, you know, sits on this side, we
[926.48s -> 930.20s]  know, we know that DRAM sits above 0x000, and
[930.20s -> 934.40s]  below 0x000 are the different devices. And
[934.40s -> 936.44s]  basically, we have loads of storage instructions,
[936.48s -> 940.92s]  you know, to those physical addresses, you know,
[940.92s -> 942.84s]  we can actually program the UART to look at that
[942.84s -> 945.88s]  in much more detail in a second. All the
[945.88s -> 949.20s]  devices can basically come into the processor. And
[949.28s -> 952.12s]  really, what happens is this platform level
[952.12s -> 954.16s]  internet interrupt controller, which is called
[954.16s -> 957.44s]  the Flick for short, is the one that sort of
[957.92s -> 961.04s]  manages the interrupts coming in, you know, from
[961.40s -> 964.52s]  external devices. And so we can zoom in a little
[964.52s -> 971.16s]  bit more. Here's a diagram of the, the Flick in
[971.20s -> 974.60s]  our on chip devices. So here we see there's 53
[974.68s -> 978.04s]  interrupt lines coming in from different devices.
[978.92s -> 980.72s]  Probably every device has its own interrupt line,
[980.76s -> 983.28s]  they come into the Flick, and then the Flick
[983.32s -> 993.20s]  and the route interrupts. So for example, you
[993.20s -> 996.00s]  know, depending, so here are our particular
[996.00s -> 999.80s]  cores, here in our the way we run it, we run it
[999.80s -> 1004.52s]  in a free cores. And basically, you know, the
[1004.52s -> 1007.20s]  Flick can be programmed so that the Flick will
[1007.20s -> 1009.80s]  route interrupts to either one of these cores, or
[1009.80s -> 1013.20s]  to the first core that can take an interrupt. And
[1013.20s -> 1016.00s]  there's a bit of flexibility. And then none of
[1016.00s -> 1018.20s]  the cores can take an interrupt at this point.
[1018.20s -> 1019.68s]  For example, they have disabled interrupts,
[1019.68s -> 1022.28s]  because they're processing another interrupt, and
[1022.28s -> 1025.88s]  the Flick will hold that interrupt until you
[1025.88s -> 1028.04s]  know, a processor is available to take the
[1028.04s -> 1032.04s]  interrupt. So the Flick has some internal state,
[1032.08s -> 1035.56s]  you know, to keep track of that. If you saw
[1035.56s -> 1036.92s]  the documentation a little bit, you know, the
[1036.92s -> 1038.84s]  way you know, real things are happening is the
[1038.84s -> 1041.28s]  Flick indicates that there is an interrupt
[1041.32s -> 1044.36s]  pending. One of the cores, you know, basically
[1044.36s -> 1048.04s]  claims it. So that will tell the Flick not to
[1048.04s -> 1050.72s]  give to any other core. And once the core is
[1050.72s -> 1052.44s]  completely done with it, we'll say like, Okay,
[1052.44s -> 1054.60s]  I'm done with this particular interrupt. And you
[1054.60s -> 1057.44s]  know, the Flick will inform the Flick that
[1057.44s -> 1060.64s]  there's, it can forget about this interrupt.
[1063.44s -> 1066.16s]  Any questions about this? The sort of the
[1066.24s -> 1069.84s]  internal RISC-V interrupt structure?
[1071.76s -> 1075.52s]  Yeah, so when each heart holds the Flick, does
[1075.52s -> 1078.32s]  the Flick have some enforcement mechanism to
[1078.32s -> 1079.28s]  ensure fairness?
[1080.20s -> 1084.48s]  I developed to the kernel to program the
[1084.48s -> 1088.44s]  Flick in whatever way it wants. The Flick
[1088.44s -> 1091.80s]  doesn't really just a service of delivering
[1091.80s -> 1093.32s]  interrupt and writing them. But it is the
[1093.32s -> 1095.92s]  kernel who programs the Flick and tells where
[1095.92s -> 1098.72s]  interrupt should be delivered, etc. In fact, you
[1098.72s -> 1101.20s]  know, interrupts have priorities, the kernel
[1101.20s -> 1102.96s]  can decide which interrupt is more important
[1102.96s -> 1105.28s]  than another interrupt. There's a huge amount of
[1105.28s -> 1106.00s]  flexibility.
[1114.08s -> 1115.92s]  Any other questions about the hardware?
[1121.68s -> 1122.20s]  Okay.
[1123.12s -> 1123.64s]  Um,
[1125.32s -> 1126.80s]  okay, so that's sort of the hardware side of
[1126.80s -> 1129.68s]  it. Let's talk a little bit here at a high
[1129.68s -> 1131.04s]  level about the software side.
[1133.04s -> 1136.48s]  So typically, the code that manages this
[1136.48s -> 1137.84s]  device is called the driver.
[1147.92s -> 1149.28s]  And basically,
[1150.28s -> 1153.80s]  it is just just code. You know, typically, of
[1153.80s -> 1155.56s]  course, in the kernels that we're be looking
[1155.56s -> 1159.20s]  at in C code, and in x06, you know, all the
[1159.20s -> 1164.96s]  drivers are inside of the kernel. And in the
[1164.96s -> 1166.76s]  code, you know, basically managing where the
[1166.76s -> 1170.88s]  drivers are all inside of the kernel. In so
[1170.88s -> 1172.28s]  regard, you know, the one that we're going to
[1172.28s -> 1173.88s]  be looking a little bit today, you know, is
[1173.88s -> 1177.48s]  like UART.C is the driver for the UART chip.
[1178.48s -> 1182.36s]  And if you look at the structure, internal
[1182.36s -> 1186.08s]  structure of the, that code, most drivers
[1186.08s -> 1191.24s]  have the structure, draw this not as an
[1191.24s -> 1192.76s]  address space or not intended to be as an
[1192.76s -> 1194.20s]  address space. But typically, when people
[1194.20s -> 1196.44s]  talk about drivers, there's a bottom part
[1197.76s -> 1198.68s]  and the top part.
[1202.76s -> 1204.36s]  And basically, the bottom part is the
[1204.36s -> 1205.12s]  interrupt handler.
[1207.60s -> 1212.56s]  So when the interrupt handler when an interrupt
[1212.56s -> 1214.68s]  comes in, you know, the processor, the CPU
[1214.68s -> 1218.08s]  has interrupts enabled, the interrupt will
[1218.08s -> 1220.64s]  fire, you know, the processor will, as we
[1220.64s -> 1223.04s]  seen the second will actually call the
[1223.04s -> 1224.88s]  interrupt handler for that the device
[1225.04s -> 1228.12s]  basically calls into the code here. And
[1228.12s -> 1231.96s]  the interrupt handler just runs in doesn't
[1231.96s -> 1233.68s]  doesn't run in any context of any
[1233.68s -> 1235.48s]  specific process, you know, just, you
[1235.48s -> 1238.64s]  know, process the just process the interrupt.
[1240.00s -> 1243.36s]  The top part, if you will, the driver is
[1243.36s -> 1246.00s]  where usual processes or you know, the
[1246.00s -> 1247.32s]  rest of the kernel calls into, for
[1247.32s -> 1248.84s]  example, in the console case, great
[1248.84s -> 1251.08s]  funeral where you are, there's really
[1251.08s -> 1259.32s]  right interface that actually the higher
[1259.32s -> 1261.76s]  level code actually calls into. And so
[1261.76s -> 1263.28s]  in typically cases, actually, there's
[1263.28s -> 1266.04s]  compute often in the driver, and, you
[1266.04s -> 1268.64s]  know, the top level code, you know,
[1268.68s -> 1270.56s]  calls in sticks, you know, characters
[1270.56s -> 1274.00s]  into the into this queue, and the
[1274.00s -> 1275.52s]  interrupt handler either, you know,
[1275.56s -> 1277.40s]  push calls, depending on sending or
[1277.40s -> 1279.84s]  receiving, but if it's receiving, maybe
[1279.84s -> 1281.12s]  the interrupt handler also will stick,
[1281.16s -> 1284.24s]  you know, actually, characters into
[1284.24s -> 1286.24s]  queues. And we'll see that these
[1286.24s -> 1288.20s]  queues are basically used to decouple
[1288.20s -> 1289.44s]  the top and the bottom part from
[1289.44s -> 1292.24s]  each other in allowing the device to
[1292.24s -> 1294.40s]  run in parallel with the rest of the
[1294.40s -> 1299.40s]  code on the CPU. And the interrupt
[1299.40s -> 1300.32s]  handler, typically, there's some
[1300.32s -> 1301.32s]  restrictions on the interrupt
[1301.32s -> 1302.48s]  handler, because it doesn't run in
[1302.48s -> 1305.12s]  any context, you know, any process
[1305.12s -> 1306.36s]  context, for example, you can, you
[1306.36s -> 1308.04s]  know, call copying or copy out,
[1308.92s -> 1311.72s]  because the current page table might
[1311.72s -> 1314.64s]  actually not be reflective of the page
[1314.64s -> 1316.64s]  table that will the process to which
[1316.64s -> 1318.88s]  character should be copied. And so
[1318.88s -> 1320.88s]  it's the upper part of the driver
[1320.92s -> 1322.68s]  generally does the interaction with
[1322.68s -> 1324.68s]  user level processes and maybe calls
[1324.68s -> 1329.52s]  copying and copy out. Any questions
[1329.52s -> 1330.92s]  about this sort of this high level
[1331.84s -> 1336.60s]  picture? We'll look at this in quite
[1336.60s -> 1338.48s]  a bit more detail. But this is sort
[1338.48s -> 1342.36s]  of the main organization of a typical
[1342.36s -> 1344.88s]  driver. And as you realize, there are
[1344.88s -> 1346.52s]  many drivers in an operating system.
[1346.52s -> 1350.40s]  In fact, it's quite common that the
[1350.40s -> 1352.04s]  sum of the driver code is quite
[1352.04s -> 1354.92s]  bigger or larger than the core
[1354.92s -> 1357.48s]  kernel itself. And mostly because
[1357.48s -> 1359.16s]  for every device, you need to
[1359.16s -> 1361.84s]  drive, you need a driver. And
[1361.84s -> 1362.84s]  most computers have a lot of
[1362.84s -> 1371.72s]  devices. Okay, so let's talk a
[1371.72s -> 1372.72s]  little bit about programming
[1372.72s -> 1384.56s]  devices. Typically, programming is
[1384.56s -> 1394.96s]  done using memory mapped IO. So as
[1394.96s -> 1398.00s]  we've seen in the RISC-V or in
[1398.00s -> 1401.64s]  the sci-fi board, the devices
[1401.64s -> 1403.12s]  show up at particular addresses
[1403.16s -> 1406.24s]  in the physical address space.
[1406.52s -> 1408.20s]  This is decided by the device
[1408.20s -> 1409.00s]  manager or the board
[1409.00s -> 1411.64s]  manufacturer. And the operating
[1411.64s -> 1412.84s]  system needs to know what those
[1413.48s -> 1415.28s]  where those devices are located in
[1415.28s -> 1417.88s]  the physical memory space, and
[1417.88s -> 1420.16s]  then basically programs them using
[1420.44s -> 1421.84s]  ordinary load and store
[1421.84s -> 1427.76s]  instructions to those addresses. But
[1427.76s -> 1428.72s]  basically what these load and
[1428.76s -> 1433.52s]  store instructions do is they read
[1433.52s -> 1441.68s]  or write control registers of the
[1441.68s -> 1449.32s]  device. And so typically, when you
[1449.32s -> 1451.16s]  maybe like store something in one
[1451.16s -> 1452.64s]  of the controller registers, that
[1452.64s -> 1454.20s]  causes a packet to be sent. So
[1454.20s -> 1455.16s]  instead of reading or writing
[1455.16s -> 1456.92s]  memory, these load and store
[1456.92s -> 1458.04s]  instructions typically have side
[1458.04s -> 1460.36s]  effects, the cost of the device
[1460.36s -> 1464.04s]  to do something. And, you know,
[1464.04s -> 1465.08s]  you have to look basically in
[1465.08s -> 1466.40s]  the documentation of the device
[1466.40s -> 1467.56s]  to actually figure out what the
[1467.56s -> 1470.56s]  device does. And, you know,
[1470.60s -> 1471.88s]  sometimes this documentation is
[1471.88s -> 1473.24s]  very clear, and sometimes this
[1473.24s -> 1474.56s]  documentation is less clear.
[1475.12s -> 1476.04s]  Let's just give you a little
[1476.04s -> 1480.52s]  bit of a sample, Greg. The two
[1480.52s -> 1481.60s]  things I wanted to show you
[1481.60s -> 1485.08s]  here on the right side of the
[1485.08s -> 1489.76s]  screen, you see the physical
[1489.76s -> 1492.28s]  memory map space for the sci-fi
[1492.60s -> 1494.92s]  board, and you see what the
[1494.92s -> 1496.12s]  addresses are, where particular
[1496.12s -> 1497.76s]  things are mapped, where they
[1497.76s -> 1499.04s]  show up in the physical address
[1499.04s -> 1500.52s]  space. I'm sure you've used the
[1500.52s -> 1501.60s]  word map, where they actually
[1501.60s -> 1502.72s]  show up in the physical address
[1502.72s -> 1504.72s]  space. And so for example, we
[1504.72s -> 1507.32s]  see the claims is there at
[1507.32s -> 1512.44s]  0x200. Let's see, we'll pick
[1512.44s -> 1515.76s]  out another one. The flick was
[1515.76s -> 1516.80s]  somewhere there too. Okay,
[1516.80s -> 1519.80s]  here's the flick at 0xc000.
[1519.84s -> 1523.36s]  That's the platform internet
[1523.36s -> 1527.32s]  controller. And we see actually
[1527.32s -> 1529.12s]  UR0 here at this particular
[1529.12s -> 1531.60s]  address. It turns out that on
[1532.08s -> 1534.24s]  the QEMU that we're using,
[1534.56s -> 1537.96s]  users have the UR actually at a
[1537.96s -> 1540.60s]  different location. That's
[1540.60s -> 1542.84s]  because we use word QEMU, which
[1542.84s -> 1544.04s]  doesn't actually literally
[1544.16s -> 1545.76s]  emulate the sci-fi board, but
[1545.76s -> 1546.84s]  something that's very close to
[1546.84s -> 1549.52s]  the sci-fi board. Okay, so
[1549.52s -> 1551.92s]  that's the memory map, the
[1551.92s -> 1553.84s]  memory map of physical addresses
[1554.60s -> 1561.52s]  to devices. And then on the
[1561.64s -> 1564.16s]  left side is just a piece of
[1564.16s -> 1570.40s]  documentation for the UR. This
[1570.40s -> 1576.00s]  is the 1655, 16550. That's
[1576.00s -> 1578.08s]  actually the UR chip that sits
[1578.08s -> 1580.48s]  on the QEMU emulates and that
[1580.48s -> 1582.80s]  we're using to actually
[1582.80s -> 1586.48s]  interact with the keyboard and
[1587.60s -> 1589.68s]  console. And this is a
[1589.68s -> 1590.88s]  reasonable simple chip. There's
[1590.88s -> 1592.28s]  not actually much going on in
[1592.28s -> 1595.28s]  this device. Even then, there's
[1595.28s -> 1598.04s]  sort of complications. Here on
[1598.04s -> 1602.48s]  this table here, it shows the
[1602.48s -> 1604.16s]  registers that the chip has,
[1605.00s -> 1606.32s]  the controller registers. For
[1606.32s -> 1607.80s]  example, controller register
[1607.80s -> 1610.88s]  0, 0, 0. And when you do a
[1610.88s -> 1614.36s]  loan instruction, it will hold
[1614.36s -> 1616.32s]  the data. If you do a store
[1616.32s -> 1617.52s]  instruction, that's the
[1617.52s -> 1618.92s]  register that will basically the
[1618.92s -> 1620.44s]  data will be copied into to
[1620.44s -> 1621.56s]  be transmitted, you know,
[1621.56s -> 1623.36s]  outside on the wire. The UR
[1623.36s -> 1629.00s]  is basically a device that
[1629.00s -> 1630.84s]  allows you to send bits over a
[1630.84s -> 1633.76s]  serial line. The sent line is
[1633.76s -> 1635.24s]  one line and the received line
[1635.24s -> 1638.44s]  is another line. And basically
[1638.44s -> 1640.76s]  you take a byte and basically
[1640.76s -> 1643.48s]  they're multiplexed or serialized
[1643.48s -> 1645.96s]  on this single line, sent over
[1645.96s -> 1646.96s]  to the other side. There's a
[1646.96s -> 1648.32s]  UR chip sitting on the other
[1648.32s -> 1649.80s]  side and basically assembles the
[1649.80s -> 1653.64s]  bit back into a single byte. And
[1653.64s -> 1654.44s]  a couple other things that you
[1654.44s -> 1656.00s]  can control, you know, on this
[1656.28s -> 1658.68s]  device. You can actually
[1658.92s -> 1662.36s]  control the baud rate of the
[1662.36s -> 1666.44s]  device to some degree. And, you
[1666.44s -> 1667.56s]  know, probably most important for
[1667.56s -> 1674.60s]  us is the register one, which
[1674.60s -> 1675.68s]  you see here, which is the
[1675.68s -> 1677.52s]  interrupt enable register. And
[1677.52s -> 1679.36s]  so we can program it to
[1679.40s -> 1681.80s]  actually cause the UR to
[1681.80s -> 1686.24s]  generate interrupts. So if you
[1686.24s -> 1687.96s]  can scroll down this document,
[1688.88s -> 1691.28s]  you'll see that the, you know,
[1691.28s -> 1692.56s]  I'll scroll down a bit to get
[1692.56s -> 1694.12s]  out the document actually in
[1694.12s -> 1695.52s]  more detail, basically described
[1695.52s -> 1696.56s]  with every bit in every
[1696.56s -> 1699.44s]  register means. And for example,
[1699.44s -> 1702.12s]  in the interrupt enable
[1702.12s -> 1704.48s]  registered IER, the register
[1704.52s -> 1706.12s]  is the acronym for it. You
[1706.12s -> 1707.40s]  know, then basically this is
[1707.40s -> 1708.56s]  the received line status
[1708.56s -> 1711.48s]  interrupt and transmit holding
[1711.48s -> 1713.40s]  register interrupt. So that's
[1713.60s -> 1716.04s]  what the bits mean. And, you
[1716.04s -> 1717.28s]  know, it goes on and on. And
[1717.28s -> 1718.84s]  there's a lot more documentation
[1718.84s -> 1721.36s]  that tells you what the more
[1721.36s -> 1722.64s]  details of the registers are,
[1722.64s -> 1724.44s]  how you can use it in polling
[1724.44s -> 1725.48s]  mode or interrupt mode. We'll
[1725.48s -> 1726.40s]  talk about it a little bit
[1726.40s -> 1728.04s]  more, you know, how, how you
[1728.04s -> 1729.72s]  have to program the interrupt
[1729.72s -> 1731.00s]  enable registers, et cetera,
[1731.00s -> 1732.64s]  et cetera. So it turns out
[1732.64s -> 1734.52s]  to be a short version of the
[1734.52s -> 1735.76s]  real documents, you know, the
[1735.76s -> 1737.28s]  real documents for the chip
[1737.28s -> 1739.88s]  that actually is much more has
[1739.88s -> 1740.96s]  much more stuff in it, much
[1740.96s -> 1742.52s]  more detail, but it's sort of
[1742.52s -> 1743.84s]  sufficient for us to actually
[1743.96s -> 1745.04s]  be able to talk about how the
[1745.04s -> 1747.12s]  program view art. And you can
[1747.12s -> 1748.12s]  see this is like one of the
[1748.12s -> 1749.48s]  most simple devices. And even
[1749.48s -> 1751.12s]  that document, you know, has
[1751.12s -> 1751.92s]  quite a bit to it.
[1757.76s -> 1760.36s]  I'm sorry, I was wondering if
[1760.36s -> 1762.12s]  you're right. So if you
[1763.40s -> 1764.72s]  write something to the
[1764.88s -> 1767.12s]  transmit holding register, and
[1767.12s -> 1769.36s]  then you write again, like
[1769.60s -> 1772.88s]  right after that, it, it makes
[1772.88s -> 1775.24s]  sure that, like, the previous
[1775.24s -> 1778.44s]  number didn't just like, get
[1778.44s -> 1779.52s]  overridden, right?
[1780.92s -> 1783.04s]  Yes, yes, yes. And no, it's
[1783.04s -> 1784.44s]  part of you, actually, this is
[1784.44s -> 1785.80s]  on one of the things that we're
[1785.80s -> 1786.40s]  going to pay a bit of
[1786.40s -> 1789.80s]  attention to the you tell
[1789.80s -> 1790.92s]  basically reload instruction, you
[1790.92s -> 1791.88s]  load some value or store
[1791.88s -> 1792.80s]  instructions, load some value in
[1792.80s -> 1796.08s]  that register. And then the
[1797.52s -> 1799.12s]  viewer chip now goes off, and
[1799.12s -> 1800.76s]  it's going to send off that that
[1800.76s -> 1802.24s]  byte onto the line on the
[1802.24s -> 1804.88s]  serial line, correct. And when
[1804.88s -> 1806.96s]  it's done, it will generate an
[1806.96s -> 1808.04s]  interrupt saying to the
[1808.04s -> 1809.12s]  kernel, okay, I'm done with
[1809.12s -> 1810.12s]  that byte, now you can give
[1810.12s -> 1812.92s]  me the next byte. And so the
[1812.92s -> 1813.92s]  kernel and the device has to
[1813.92s -> 1815.00s]  sort of follow a protocol to
[1815.00s -> 1815.88s]  make sure that actually
[1815.88s -> 1818.36s]  everything works out. This
[1818.36s -> 1819.92s]  particular view art, you know,
[1819.92s -> 1822.56s]  that we're using has a, I
[1822.56s -> 1826.52s]  think 1655 558, actually
[1826.52s -> 1828.28s]  internally has a five Oh, and
[1828.28s -> 1830.12s]  I think it can buffer a bunch
[1830.12s -> 1831.36s]  of characters, like I think up
[1831.36s -> 1834.36s]  to 16. But you still have to
[1834.36s -> 1835.56s]  sort of play this game of like
[1835.56s -> 1837.48s]  you can't stick more than 16
[1837.48s -> 1838.92s]  characters into it until the
[1838.92s -> 1840.44s]  device actually has told you
[1840.44s -> 1842.52s]  well, I've sent one character.
[1845.04s -> 1845.76s]  Does that make sense?
[1846.80s -> 1848.20s]  Okay, yeah, thank you.
[1849.40s -> 1850.76s]  So let's talk a little bit
[1850.76s -> 1852.76s]  more, you know, before we look
[1852.76s -> 1856.48s]  at a little more detail, you
[1856.48s -> 1859.00s]  know, you know, the case study,
[1859.04s -> 1861.28s]  you know, that we are going to
[1861.28s -> 1864.16s]  go through for sort of
[1864.16s -> 1865.64s]  explaining how devices and
[1865.64s -> 1866.72s]  interrupts work is there's
[1866.72s -> 1867.84s]  dollar LS, you know, what
[1867.84s -> 1872.52s]  happens when the, you know,
[1872.52s -> 1874.48s]  how actually how you print.
[1874.56s -> 1875.88s]  And so basically, what happens
[1876.12s -> 1878.04s]  is that the device, as we
[1878.04s -> 1879.48s]  actually sort of discussed in
[1879.48s -> 1881.00s]  a second ago, is basically
[1881.00s -> 1881.92s]  puts the character of the
[1881.92s -> 1885.16s]  dollar in this case, into the
[1885.16s -> 1887.52s]  UART, in fact, in the register
[1887.56s -> 1890.00s]  that we just looked at, and
[1890.04s -> 1893.28s]  then the UART generates an
[1893.28s -> 1894.96s]  interrupt, at least that's the
[1894.96s -> 1896.16s]  way we can set things up,
[1896.36s -> 1900.12s]  generates an interrupt when the
[1900.12s -> 1910.20s]  character has been sent. And
[1910.20s -> 1911.68s]  then on the other side, and
[1911.68s -> 1913.80s]  so basically, the way things
[1913.80s -> 1915.48s]  are set up in Qemu is that
[1915.72s -> 1917.08s]  on the send line, on the other
[1917.08s -> 1919.28s]  side of the send line, it
[1919.28s -> 1920.64s]  basically sits in another
[1920.64s -> 1923.08s]  UART chip, and that actually
[1923.08s -> 1924.68s]  connects to the console to the
[1924.68s -> 1926.76s]  virtual, you know, the virtual
[1926.76s -> 1929.52s]  console. On the other side,
[1929.52s -> 1930.88s]  you know, what happens on LS
[1932.08s -> 1933.80s]  is you need to do the input.
[1933.84s -> 1935.92s]  And so the keyboard actually is
[1935.92s -> 1937.68s]  connected to the receive line.
[1941.68s -> 1949.36s]  And so basically the keyboard,
[1949.36s -> 1950.36s]  you know, you hit a key on the
[1950.36s -> 1952.60s]  keyboard, the virtual
[1952.60s -> 1954.56s]  keyboard, in this case, you
[1954.56s -> 1956.16s]  know, the UART chip on that
[1956.16s -> 1958.32s]  side, you know, will serialize,
[1958.32s -> 1961.28s]  you know, the character L, send
[1961.28s -> 1962.12s]  it to the UART on the other
[1962.12s -> 1964.60s]  side, the other side, you
[1964.60s -> 1965.80s]  know, puts the, you know, the
[1965.80s -> 1966.96s]  bits, you know, together again
[1966.96s -> 1969.52s]  into one byte, and then
[1969.52s -> 1973.20s]  generates an interrupt, generates
[1973.20s -> 1975.08s]  an interrupt to tell the
[1975.08s -> 1976.08s]  processor, hey, there's a
[1976.08s -> 1977.68s]  character available from the
[1978.60s -> 1981.32s]  keyboard. And then the
[1981.32s -> 1982.72s]  interrupt handles, the interrupt
[1982.72s -> 1984.32s]  handle reads the byte from the
[1984.32s -> 1985.48s]  UART, as we'll see in a
[1985.48s -> 1986.68s]  second. And so those are the
[1986.68s -> 1987.56s]  sort of two things that we
[1987.56s -> 1988.64s]  want to sort of understand in
[1988.64s -> 1990.68s]  more detail, actually how they
[1990.68s -> 1995.60s]  work. Okay. Any questions about
[1995.60s -> 2006.28s]  this? Okay. So the RISC-V has a
[2006.28s -> 2012.28s]  bunch of support, support for
[2012.28s -> 2023.20s]  interrupts. And there's a number
[2023.20s -> 2025.48s]  of registers, you know, that
[2025.48s -> 2027.28s]  we'll see in more detail as
[2027.28s -> 2028.20s]  they get used, but it's
[2028.20s -> 2029.20s]  useful to know which ones
[2029.20s -> 2032.20s]  there are. There's the SIE
[2032.20s -> 2035.68s]  supervisor interrupt enable
[2035.68s -> 2037.80s]  register. And that has a bit,
[2038.44s -> 2043.36s]  you know, one bit for external
[2043.36s -> 2044.84s]  interrupts, like from devices
[2044.84s -> 2047.52s]  like the UART, from software
[2047.52s -> 2049.28s]  interrupts, which I'm not
[2049.28s -> 2050.40s]  really going to talk about it,
[2050.60s -> 2053.08s]  but it is possible from one CPU
[2053.08s -> 2055.12s]  from one RISC-V core to send
[2055.12s -> 2056.52s]  an interrupt to another RISC-V
[2056.52s -> 2062.52s]  core, and timer interrupts. And
[2062.52s -> 2063.32s]  I'm not really going to talk
[2063.32s -> 2065.36s]  about either, you know, the
[2065.44s -> 2067.24s]  supervisor of the software
[2067.24s -> 2068.24s]  interrupts nor the timer
[2068.24s -> 2069.12s]  interrupts, I'm going to focus
[2069.12s -> 2071.84s]  on external interrupts. Then
[2071.84s -> 2073.12s]  there's another register that
[2073.12s -> 2074.24s]  we've seen before, it's called
[2074.24s -> 2077.16s]  the supervisor status register.
[2078.20s -> 2080.56s]  And that has a bit to disable
[2080.56s -> 2086.48s]  and enable interrupts on this
[2086.48s -> 2090.72s]  particular core. So every core
[2090.72s -> 2092.92s]  has, you know, these registers.
[2094.08s -> 2095.84s]  And there's a, in addition to
[2095.84s -> 2096.60s]  these three bits where
[2096.64s -> 2098.12s]  individual control when you want
[2098.12s -> 2100.36s]  to have external interrupts or
[2100.36s -> 2101.32s]  software interrupts or timer
[2101.32s -> 2103.08s]  interrupts, there's one bit
[2103.08s -> 2103.96s]  that basically controls if
[2103.96s -> 2104.48s]  you're going to receive
[2104.48s -> 2105.76s]  interrupts at all. And so you
[2105.76s -> 2108.00s]  can atomically switch from not
[2108.00s -> 2109.16s]  getting interrupts through
[2109.16s -> 2110.36s]  having interrupts or the other
[2110.36s -> 2111.92s]  way around, but just changing
[2111.92s -> 2114.40s]  that one bit in the S stages
[2114.40s -> 2117.28s]  register. And then there's a
[2118.08s -> 2120.16s]  separate register called the
[2120.16s -> 2122.36s]  supervisor interrupt pending
[2122.36s -> 2129.48s]  register. And basically the
[2129.48s -> 2131.48s]  processor can use that, you
[2131.48s -> 2132.24s]  know, once the interrupt is
[2132.24s -> 2132.88s]  going to happen, you know,
[2132.88s -> 2133.68s]  perhaps we can look at the
[2133.68s -> 2136.04s]  SIP to see what, what
[2136.04s -> 2137.44s]  interrupt actually has come in.
[2138.96s -> 2141.40s]  And in addition, there will be
[2141.68s -> 2143.56s]  even interrupt happens in the
[2143.56s -> 2145.08s]  S cause register that we have
[2145.08s -> 2146.24s]  seen a couple of times before
[2146.24s -> 2149.32s]  now. There will be an
[2149.32s -> 2150.96s]  indication of what interrupt
[2151.08s -> 2152.40s]  actually came in, which we'll
[2152.40s -> 2153.88s]  look into in a second. And of
[2153.88s -> 2155.16s]  course there's the STVEC
[2155.20s -> 2158.16s]  register that basically holds
[2158.16s -> 2159.20s]  the program or holds the
[2159.20s -> 2160.24s]  address to which the
[2160.40s -> 2163.32s]  processors switch once either a
[2163.32s -> 2166.92s]  trap or a trap, a system
[2166.92s -> 2169.40s]  call or a page fault happens or
[2169.40s -> 2170.80s]  an interrupt happens because
[2170.80s -> 2171.96s]  basically it uses for all
[2171.96s -> 2172.84s]  three cases, the same
[2172.84s -> 2174.32s]  mechanism. I'm not going to
[2174.32s -> 2176.40s]  talk too much about S cause
[2176.40s -> 2177.36s]  and S fact because, you know,
[2177.36s -> 2180.00s]  we've seen it in, in detail
[2180.00s -> 2183.08s]  before, and the basically
[2183.08s -> 2185.04s]  operates exactly in the same
[2185.56s -> 2192.16s]  way as, as a system calls and
[2192.24s -> 2193.76s]  page faults or other
[2193.76s -> 2199.56s]  exceptions. Okay. So let's see,
[2199.64s -> 2201.28s]  uh, get a little bit of a
[2201.28s -> 2203.64s]  sense, uh, how this stuff is
[2203.64s -> 2204.72s]  sort of initialized, you know,
[2204.72s -> 2205.84s]  so we're not talking even
[2205.84s -> 2207.88s]  about how the, the drivers
[2207.88s -> 2209.20s]  actually work, but just to see
[2209.20s -> 2211.84s]  how XP6 programs, this, uh,
[2212.08s -> 2213.56s]  these registers, uh, so that
[2213.56s -> 2214.32s]  we're going to be into the
[2214.32s -> 2215.56s]  position, you know, to take,
[2215.60s -> 2219.24s]  uh, interrupts, um, questions
[2219.24s -> 2232.56s]  on the chat. Okay, good. I
[2232.56s -> 2233.44s]  got a little bit behind on
[2233.44s -> 2235.64s]  the chat. Um, so let's see
[2235.64s -> 2236.96s]  you a little bit on, uh, what
[2236.96s -> 2240.36s]  the, uh, uh, XP6 programs,
[2240.36s -> 2243.04s]  these registers, uh, pull up
[2243.04s -> 2246.08s]  some code, uh, let me get
[2246.08s -> 2252.56s]  rid of the, uh, this window
[2252.56s -> 2253.60s]  actually, I don't really need
[2253.60s -> 2255.76s]  that either. Um, so I'm not
[2255.76s -> 2257.24s]  going to run, use DDB to
[2257.24s -> 2258.32s]  walk through things. I'm just
[2258.32s -> 2259.72s]  going to look at the
[2259.72s -> 2260.72s]  particular functions that are
[2260.72s -> 2263.36s]  relevant. Uh, so probably the
[2263.36s -> 2265.32s]  first thing is in, uh, start
[2265.32s -> 2267.48s]  dot C. So when the machine
[2267.48s -> 2268.44s]  boots where the processor
[2268.44s -> 2273.72s]  boots, uh, the, um, the start
[2273.72s -> 2274.96s]  function is called, it's runs
[2274.96s -> 2278.96s]  in M mode, uh, and, uh, you
[2278.96s -> 2281.56s]  know, disables paging, uh, so
[2282.04s -> 2283.64s]  in right away, uh, because,
[2283.64s -> 2284.84s]  you know, sort of later on
[2284.84s -> 2285.60s]  the kernel can set up the
[2285.60s -> 2287.64s]  page tables and we see here
[2287.64s -> 2289.36s]  that basically delegates all
[2289.36s -> 2290.44s]  interrupts and exceptions to
[2290.44s -> 2292.72s]  supervisor mode. Um, and
[2292.72s -> 2294.32s]  then, uh, it's, you know,
[2294.36s -> 2296.76s]  programs, the, uh, supervisor
[2296.80s -> 2298.44s]  enabling interrupt enable
[2298.44s -> 2299.92s]  register to, you know, take,
[2300.36s -> 2302.48s]  uh, suffer interrupts, timer
[2302.48s -> 2304.52s]  interrupts and external
[2304.52s -> 2308.04s]  interrupts. Uh, and then for
[2308.04s -> 2310.08s]  good measure, uh, timer
[2310.08s -> 2311.52s]  interrupts actually happened to,
[2311.52s -> 2313.48s]  uh, coming to them, uh, are
[2313.48s -> 2316.48s]  handled in M mode. Uh, the
[2317.52s -> 2319.24s]  M mode code actually programs
[2319.24s -> 2322.00s]  the, uh, uh, time to
[2322.00s -> 2324.08s]  register. And so that, uh,
[2324.12s -> 2325.56s]  timers are, uh, timer
[2325.56s -> 2327.76s]  interrupts are generated. Um,
[2327.76s -> 2328.36s]  and then we're going to want
[2328.36s -> 2329.40s]  to talk about that actually.
[2329.44s -> 2330.36s]  So I'm going to go to the
[2330.36s -> 2336.80s]  main.c. Uh, and so see how
[2336.84s -> 2338.28s]  external devices are handled.
[2338.36s -> 2339.68s]  And so our first external
[2339.68s -> 2341.40s]  device is the console. That's
[2341.40s -> 2343.60s]  like where we print to, and
[2343.60s -> 2344.28s]  you know, we can, we can
[2344.28s -> 2345.60s]  see what console init does.
[2347.32s -> 2349.00s]  Uh, so here's console init,
[2349.32s -> 2351.16s]  uh, you can initialize your
[2351.16s -> 2352.24s]  block. You know, we actually
[2352.24s -> 2353.28s]  care not much about that at
[2353.28s -> 2355.88s]  all. Uh, at least not for
[2355.96s -> 2357.96s]  this lecture. And it actually
[2357.96s -> 2359.56s]  basically calls the UART in
[2359.56s -> 2364.08s]  it. And UART init is right
[2364.08s -> 2368.00s]  here. Uh, it actually sets up
[2368.00s -> 2370.80s]  the UART chip, uh, or
[2370.80s -> 2371.92s]  configures the UART chip so
[2371.92s -> 2374.36s]  that it's ready for use. Uh,
[2374.36s -> 2375.24s]  you know, it first actually
[2375.24s -> 2376.48s]  disables interrupts. You know,
[2376.48s -> 2377.52s]  there's just a sequence you
[2377.52s -> 2378.60s]  have to go through when you
[2378.60s -> 2380.56s]  program it. Uh, then you can
[2380.60s -> 2383.20s]  set the baud rate. Uh, then
[2383.20s -> 2385.20s]  you set it in six or, you
[2385.20s -> 2386.40s]  know, seven bits, you know,
[2386.40s -> 2387.84s]  seven or eight bit bytes or
[2387.84s -> 2392.76s]  repair it or not. Um, and, uh,
[2393.96s -> 2395.24s]  uh, you reset the internal
[2395.24s -> 2398.08s]  FIFOs that the, uh, uh,
[2398.12s -> 2399.24s]  UART has, you know, clear
[2399.24s -> 2400.40s]  out anything that actually
[2400.44s -> 2402.52s]  might be in there. And then,
[2402.52s -> 2405.16s]  uh, we receive, uh, we
[2405.16s -> 2407.16s]  enable, uh, interrupts for
[2407.16s -> 2408.44s]  transmission and interruption.
[2410.60s -> 2412.08s]  Uh, Amir, I think you raised
[2412.08s -> 2415.48s]  your hand. Yeah. I'm wondering
[2415.48s -> 2417.28s]  what the baud rate is exactly.
[2417.80s -> 2418.84s]  Oh, the speed at which, you
[2418.84s -> 2422.96s]  know, the line runs. I see.
[2423.56s -> 2428.72s]  Thanks. Um, okay. So that's
[2428.72s -> 2431.12s]  UART init. Um, now at this
[2431.12s -> 2432.64s]  point, you know, the UART in
[2432.64s -> 2434.44s]  principle can, can generate
[2434.44s -> 2435.92s]  interrupts. Uh, but of
[2435.92s -> 2437.12s]  course, we haven't actually
[2437.12s -> 2438.20s]  programmed the interrupt
[2438.20s -> 2440.52s]  enabling stuff on the, on
[2440.52s -> 2442.00s]  the RISC-V process itself. You
[2442.00s -> 2442.84s]  know, we haven't programmed the
[2442.84s -> 2444.00s]  PLIC yet, you know, so nothing
[2444.00s -> 2446.32s]  really happens, uh, at this
[2446.32s -> 2447.52s]  point yet. And so the next
[2447.52s -> 2448.80s]  thing we're going to look back
[2448.80s -> 2451.36s]  to main.c, uh, you know, we'll
[2451.36s -> 2452.96s]  see a little bit, scroll
[2452.96s -> 2455.00s]  down, uh, we'll see actually
[2455.00s -> 2456.64s]  that the PLIC is initialized.
[2456.76s -> 2460.76s]  And so let's look at that. Uh,
[2460.80s -> 2463.96s]  and basically PLIC init code,
[2464.40s -> 2465.56s]  uh, if you looked at this
[2465.84s -> 2467.32s]  table that I showed you a
[2467.32s -> 2468.96s]  little while ago with the
[2469.08s -> 2470.60s]  physical memory, uh, or the
[2470.72s -> 2471.80s]  memory layout, you know, the
[2471.80s -> 2473.48s]  PLIC is in some particular
[2473.80s -> 2475.44s]  location, correct? And the
[2475.44s -> 2476.52s]  location is in the kernel
[2476.52s -> 2478.76s]  memory layout. Uh, we see that
[2478.76s -> 2479.80s]  the PLIC is here. Oh, zero,
[2479.80s -> 2481.00s]  zero, zero, zero, correct.
[2481.00s -> 2482.12s]  You know, literally copied from
[2482.12s -> 2484.40s]  that document. And you know,
[2484.40s -> 2485.92s]  when the way we write stuff to
[2485.92s -> 2487.48s]  the PLIC is basically, you
[2487.48s -> 2489.12s]  know, take the, the, the
[2489.12s -> 2490.52s]  number or the address for the
[2490.52s -> 2494.08s]  PLIC, uh, uh, passes to, and
[2494.08s -> 2496.12s]  a 32 pointer, uh, integer
[2496.12s -> 2497.52s]  because the PLIC registers are
[2497.52s -> 2499.60s]  32 bit and then, you know,
[2499.60s -> 2500.72s]  basically write a one to it.
[2500.84s -> 2502.72s]  So this causes basically a one
[2502.72s -> 2506.12s]  to be written to the register
[2506.12s -> 2509.40s]  UART zero IRQ. And basically
[2509.40s -> 2511.28s]  what this does is it enables
[2511.28s -> 2513.04s]  interrupt requests from the
[2513.04s -> 2515.12s]  UART. So remember the PLIC,
[2515.12s -> 2517.04s]  you know, basically routes, uh,
[2517.52s -> 2519.00s]  the interrupts. And so the,
[2519.00s -> 2519.96s]  an interrupt might come in
[2519.96s -> 2520.96s]  from the left side, from that
[2520.96s -> 2522.64s]  picture into the PLIC and the
[2522.64s -> 2524.44s]  PLIC says like this programs,
[2524.44s -> 2525.72s]  the PLIC to actually accept
[2525.72s -> 2528.44s]  those interrupts. Similarly,
[2528.44s -> 2529.56s]  it actually programs the PLIC
[2529.56s -> 2530.60s]  to actually accept interrupts
[2530.60s -> 2532.84s]  from the IO disk, uh, which
[2532.84s -> 2533.68s]  I'm not going to talk about at
[2533.68s -> 2537.48s]  all. Okay. And then, uh, we
[2537.48s -> 2539.44s]  go back, you know, to main
[2539.44s -> 2543.76s]  dot C and, uh, there right
[2543.76s -> 2545.16s]  after the PLIC init, you see
[2545.16s -> 2546.44s]  you just PLIC init hard. And
[2546.44s -> 2548.40s]  then basically for every core
[2548.40s -> 2552.44s]  specifically, uh, every core
[2552.44s -> 2553.96s]  individually. So the own one
[2553.96s -> 2555.68s]  core, the first core actually
[2555.68s -> 2557.64s]  initializes this aspect, you
[2557.64s -> 2558.68s]  know, so basically we're taking
[2558.68s -> 2559.88s]  interrupts with those devices.
[2560.40s -> 2561.36s]  And then every core
[2561.36s -> 2563.36s]  individually has to say, I'm
[2563.36s -> 2564.80s]  interested in those devices too.
[2565.64s -> 2567.44s]  Uh, and so for example, here,
[2567.76s -> 2570.00s]  uh, every core actually calls
[2570.00s -> 2571.28s]  this function. So every core
[2571.28s -> 2572.56s]  says, I'm interested in
[2572.76s -> 2574.48s]  interrupts from, uh, the UART
[2574.48s -> 2575.60s]  and I'm interested in, uh,
[2575.60s -> 2576.80s]  the interrupts from the
[2576.80s -> 2578.72s]  virtual IO. And you can see
[2578.72s -> 2580.04s]  here basically this UART zero
[2580.04s -> 2582.56s]  IRQ basically, um, is a
[2582.56s -> 2584.48s]  unique number, you know, for,
[2584.56s -> 2587.40s]  uh, the UART IRQ for the, in,
[2587.40s -> 2589.04s]  uh, for UART. And I think it
[2589.04s -> 2591.36s]  was released on the, on Q mu
[2591.36s -> 2594.60s]  that's number 10. And we're
[2594.60s -> 2596.76s]  basically ignore priorities. And
[2596.76s -> 2597.92s]  so we just set it to zero.
[2599.36s -> 2601.20s]  Okay. And so just every CPU
[2601.20s -> 2602.40s]  over every core individually,
[2602.40s -> 2603.36s]  you know, has to indicate to
[2603.36s -> 2604.28s]  the PLIC that actually is
[2604.28s -> 2606.48s]  interested in, uh, receiving,
[2606.60s -> 2610.00s]  uh, interrupts. Um, now at
[2610.00s -> 2611.28s]  this point, you know, we're,
[2611.32s -> 2612.64s]  you know, the PLIC basically,
[2613.12s -> 2614.24s]  basically have the programs
[2614.32s -> 2615.32s]  the device to generate
[2615.32s -> 2616.40s]  interrupts. We have programmed
[2616.40s -> 2617.72s]  the PLIC, you know, to pass
[2617.72s -> 2618.96s]  interrupts on, you know, to
[2618.96s -> 2621.32s]  individual, uh, CPUs, but the
[2621.32s -> 2622.88s]  CPUs itself have actually are
[2622.88s -> 2624.36s]  not accepting interrupts yet
[2624.68s -> 2626.40s]  because we haven't set the
[2626.40s -> 2628.32s]  bid in the S status yet. And
[2628.32s -> 2631.04s]  so let's go back, uh, to
[2631.04s -> 2636.00s]  main.c and you know, whatever
[2636.00s -> 2637.32s]  main.c does a bunch of more
[2637.32s -> 2639.20s]  immunization. Uh, but the end
[2639.20s -> 2639.80s]  it actually calls the
[2639.80s -> 2642.28s]  scheduler. So let's go look
[2642.44s -> 2646.20s]  at proc.c and you know, the
[2646.20s -> 2653.40s]  scheduler. And what we see
[2653.40s -> 2654.84s]  here is like when the, so
[2654.84s -> 2656.24s]  we're now basically the whole
[2656.24s -> 2657.00s]  machine is sort of the
[2657.00s -> 2658.80s]  processors has been set up and
[2658.80s -> 2660.12s]  the scheduler schedules, uh,
[2660.12s -> 2662.36s]  the virtual process to run.
[2662.36s -> 2664.80s]  But before, uh, you know,
[2664.80s -> 2665.72s]  during any of that, it
[2665.72s -> 2668.04s]  actually enables interrupts. And
[2668.04s -> 2670.36s]  so we look at risk five and
[2670.40s -> 2671.16s]  I'll see, there's a,
[2671.20s -> 2674.72s]  basically this is a C function
[2675.96s -> 2677.08s]  and basically enables
[2677.08s -> 2678.56s]  interrupts. And as you can, not
[2678.56s -> 2679.44s]  surprising, you know,
[2679.44s -> 2680.28s]  basically the only thing it
[2680.28s -> 2682.48s]  does, it sets the interrupt
[2682.48s -> 2683.84s]  enable bid in the S status
[2683.84s -> 2685.88s]  register. So this particular
[2685.88s -> 2688.28s]  point in time, uh, right at
[2688.28s -> 2690.28s]  this instance, if there were an
[2690.28s -> 2691.24s]  interrupt pending at the
[2691.24s -> 2693.32s]  flick, then, you know, the,
[2693.32s -> 2694.64s]  this particular core would be
[2694.64s -> 2696.76s]  interrupted. We'll see that
[2696.76s -> 2698.16s]  in a second later, but this is
[2698.16s -> 2699.40s]  this point, interrupts are
[2699.44s -> 2702.20s]  enabled. And so this is the
[2702.20s -> 2704.32s]  basic setup. Any questions
[2704.32s -> 2704.76s]  about this?
[2709.80s -> 2710.96s]  Oh, sorry. What, what
[2710.96s -> 2712.48s]  coral would be, um,
[2712.60s -> 2715.00s]  interrupted when at that
[2715.00s -> 2717.64s]  point, so every core runs
[2717.64s -> 2718.72s]  the scheduler loop, correct.
[2719.36s -> 2721.48s]  And whatever core calls in
[2721.48s -> 2723.48s]  around upon or all of course
[2723.48s -> 2724.44s]  we'll call interrupt on, but
[2724.44s -> 2725.36s]  let's say there's only, you
[2725.36s -> 2726.48s]  know, one core gets there
[2726.48s -> 2729.88s]  first, uh, like core one. And
[2729.92s -> 2731.28s]  if core one sets, it's
[2731.36s -> 2733.28s]  interrupt enable bit at that
[2733.28s -> 2734.56s]  point, it could receive an
[2734.56s -> 2737.64s]  interrupt. Okay. We'll see
[2737.64s -> 2738.20s]  you in a second. What
[2738.20s -> 2739.04s]  happens exactly at an
[2739.04s -> 2739.44s]  interrupt?
[2740.96s -> 2742.04s]  Makes sense. Thank you.
[2744.24s -> 2746.72s]  Okay. Um, okay. So what I
[2746.72s -> 2749.36s]  want to do is, uh, look at
[2749.36s -> 2751.84s]  this, uh, how to print a
[2751.84s -> 2753.64s]  dollar, you know, the prompt
[2753.64s -> 2755.60s]  that the shell prompt. And
[2755.60s -> 2757.76s]  so, uh, for that, we want
[2757.76s -> 2760.56s]  to go back a little bit and
[2760.56s -> 2761.32s]  I will first want to look
[2761.32s -> 2762.96s]  at, in it again. So this
[2762.96s -> 2764.08s]  was the first process that
[2764.08s -> 2765.20s]  actually is being, you know,
[2765.20s -> 2767.08s]  in a code, uh, execs in
[2767.08s -> 2767.68s]  it. And so that's
[2767.68s -> 2769.20s]  basically the first process
[2769.20s -> 2771.36s]  running. And one of the
[2771.36s -> 2773.40s]  things that it does, it
[2773.72s -> 2775.60s]  makes a device, uh, that
[2775.60s -> 2776.60s]  resets represents the
[2776.60s -> 2779.28s]  console. Uh, so here that
[2779.28s -> 2781.32s]  device is created, uh, using
[2781.32s -> 2783.52s]  the make not operation, uh,
[2783.56s -> 2784.76s]  and returns a file
[2784.76s -> 2785.76s]  descriptor, you know, file
[2785.76s -> 2786.80s]  descriptor zero, because it's
[2786.80s -> 2787.60s]  the first file descriptor
[2787.60s -> 2788.96s]  open and then adopt it, you
[2788.96s -> 2790.16s]  know, for standard out and
[2790.16s -> 2791.32s]  then for standard error and
[2791.32s -> 2792.80s]  does it again. And so this
[2792.80s -> 2794.60s]  basically sets up file
[2794.60s -> 2796.36s]  descriptor zero one and two
[2796.72s -> 2799.04s]  to, uh, correspond to the
[2799.04s -> 2803.80s]  console. Uh, and now, uh, and
[2803.80s -> 2805.56s]  so, you know, then it forks
[2805.56s -> 2808.44s]  off the shell. And so let's
[2808.44s -> 2809.28s]  look at the shell for a
[2809.28s -> 2812.12s]  second. So the shell opens or
[2812.12s -> 2814.76s]  starts running with, uh,
[2815.56s -> 2816.84s]  file descriptors, uh, one,
[2816.84s -> 2818.60s]  two, and three, sorry, zero,
[2818.60s -> 2819.68s]  one and two open, you
[2819.68s -> 2820.36s]  know, pointing to the
[2820.36s -> 2823.16s]  console. And then, uh, the
[2823.16s -> 2825.36s]  shell prints, uh, the
[2825.36s -> 2827.04s]  character dollar in the
[2827.04s -> 2830.48s]  space, uh, to, uh, file
[2830.48s -> 2833.16s]  descriptor two. And so, uh,
[2833.28s -> 2834.40s]  so even though the console
[2834.40s -> 2835.64s]  and the UART, you know,
[2835.64s -> 2836.64s]  are sort of all, you know,
[2836.64s -> 2838.16s]  blow all this to the
[2838.16s -> 2839.44s]  application programmer, like
[2839.44s -> 2840.76s]  the shell or the person who
[2840.76s -> 2841.92s]  wrote the shell, it just
[2841.92s -> 2843.04s]  looked like a regular file.
[2843.40s -> 2844.88s]  So in fact, the shell
[2844.88s -> 2846.64s]  itself, since it writes to
[2846.64s -> 2847.52s]  file descriptors two, there's
[2847.52s -> 2848.76s]  no idea what actually sits
[2848.76s -> 2849.76s]  in the other side, right.
[2849.76s -> 2850.40s]  And we have seen in the
[2850.40s -> 2851.56s]  util app that you can do all
[2851.56s -> 2852.60s]  kinds of cool stuff with it.
[2853.12s -> 2854.24s]  Uh, but here's an example
[2854.24s -> 2855.20s]  where, you know, basically
[2855.20s -> 2856.72s]  the device in Unix is
[2856.72s -> 2858.24s]  represented as a file. It's
[2858.24s -> 2859.36s]  not different than anything
[2859.36s -> 2862.56s]  else. Okay. So let's see,
[2862.64s -> 2863.52s]  you know, how this actually
[2863.52s -> 2866.32s]  printing networks. Uh, so
[2866.36s -> 2869.08s]  there's a printer is in the
[2869.08s -> 2870.00s]  actually six user
[2870.00s -> 2871.16s]  application, the tiny little
[2871.16s -> 2872.52s]  C library, which includes,
[2872.52s -> 2874.72s]  you know, print F and, you
[2874.72s -> 2876.80s]  know, print F as you've seen
[2876.80s -> 2877.96s]  this sort of in the trash
[2877.96s -> 2880.68s]  lab, you know, uh, sort of
[2880.68s -> 2881.76s]  an instinct function in
[2881.76s -> 2883.32s]  itself. But in the end, it
[2883.32s -> 2884.88s]  basically calls the right
[2884.88s -> 2886.80s]  system call. Uh, and in
[2886.80s -> 2887.60s]  our case where I got the
[2887.60s -> 2888.72s]  right system called, we'd be,
[2888.72s -> 2890.00s]  you know, file descriptor two
[2890.04s -> 2893.24s]  and C would be, uh, hold
[2893.28s -> 2894.44s]  the character dollar. And
[2894.44s -> 2896.52s]  so we're past the address of
[2896.52s -> 2898.08s]  the memory location that
[2898.08s -> 2900.36s]  holds the dollar to, uh, the
[2900.36s -> 2902.76s]  file descriptor to write. And
[2902.76s -> 2904.28s]  we ask, you know, to write one
[2904.28s -> 2907.68s]  character. So basically every
[2907.68s -> 2908.92s]  character written by the shell
[2908.92s -> 2909.92s]  when it results in the system
[2909.92s -> 2912.36s]  call. And so now we can go
[2913.68s -> 2915.04s]  and see what actually happens.
[2915.76s -> 2917.64s]  Uh, so we, you know, you
[2917.64s -> 2918.60s]  have seen the system called
[2918.60s -> 2921.24s]  before, uh, but, uh, so she's
[2921.24s -> 2928.32s]  file. She's right. So here's
[2928.32s -> 2929.88s]  the right system call, uh,
[2929.88s -> 2931.84s]  grabs his arguments, uh, the
[2931.84s -> 2933.60s]  file descriptor, the number of
[2933.60s -> 2934.76s]  bytes to be written and the
[2934.76s -> 2937.20s]  address of the, the address
[2937.20s -> 2938.60s]  that contains, you know, the
[2938.60s -> 2940.04s]  character dollar calls then
[2940.04s -> 2946.20s]  file, right. So let's look
[2946.20s -> 2947.56s]  quickly. We look at file
[2947.68s -> 2950.20s]  right. Okay. We're getting
[2950.20s -> 2951.88s]  close to actually where the
[2951.88s -> 2952.68s]  thing that we want to talk
[2952.68s -> 2955.72s]  about. And you know, here in
[2955.72s -> 2956.72s]  file, right, it looks what
[2956.72s -> 2957.76s]  the type of the file
[2957.76s -> 2959.36s]  descriptor is. It's a pipe or
[2959.40s -> 2960.92s]  called the pipe functions. And
[2960.92s -> 2963.28s]  if it's a device, uh, which,
[2963.28s -> 2965.04s]  you know, make not does, then
[2965.04s -> 2966.96s]  it will call, uh, the right
[2966.96s -> 2968.00s]  function for that particular
[2968.00s -> 2971.12s]  device. And so we know that,
[2971.20s -> 2972.08s]  you know, that actually is
[2972.08s -> 2975.44s]  going to call the, uh, right
[2975.44s -> 2978.40s]  function into console. And so
[2978.40s -> 2979.44s]  let's see what happens there.
[2979.48s -> 2982.20s]  So here's console, right. Uh,
[2982.24s -> 2983.24s]  grabs a lock. We don't really
[2983.24s -> 2984.56s]  care about that right now.
[2984.76s -> 2987.08s]  Uh, it copies in the one
[2987.08s -> 2988.92s]  character user either copy in
[2989.60s -> 2991.20s]  uh, and then it calls UART
[2991.20s -> 2994.36s]  to see. So that basically
[2994.36s -> 2996.68s]  calls into the UART. And so
[2996.68s -> 2997.32s]  you can think about it
[2997.32s -> 2998.36s]  together. The console is being
[2998.36s -> 3000.16s]  the driver. Uh, we're looking
[3000.16s -> 3001.28s]  sort of at the top end of the
[3001.28s -> 3004.32s]  driver and now, uh, makes a
[3004.32s -> 3006.96s]  call into UART.C to actually,
[3006.96s -> 3010.16s]  uh, print the character. And
[3010.16s -> 3012.24s]  so here's UART.C. So this
[3012.24s -> 3013.00s]  is going to be a little bit
[3013.00s -> 3016.32s]  interesting. Um, uh, basically
[3016.32s -> 3018.84s]  the internally, the UART keeps
[3018.84s -> 3020.80s]  the buffer. Uh, so let's go
[3020.80s -> 3023.16s]  back, back up a little bit on
[3023.16s -> 3024.60s]  the top. In fact, there's a
[3024.60s -> 3026.68s]  buffer for transmission and
[3026.68s -> 3028.12s]  the buffer size is 32
[3028.16s -> 3029.96s]  characters. And there's a
[3029.96s -> 3031.40s]  pointer, a write pointer and
[3031.40s -> 3034.12s]  the read pointer, uh, that are
[3034.12s -> 3036.08s]  being used to put these
[3036.28s -> 3037.80s]  characters into the circular
[3037.80s -> 3039.08s]  buffer. And I'll talk a little
[3039.08s -> 3039.84s]  bit about that in more
[3039.84s -> 3042.16s]  detail, but, uh, so there's a
[3042.16s -> 3044.36s]  pointer for the producer and
[3044.36s -> 3044.96s]  there's a pointer for the
[3044.96s -> 3047.36s]  consumer. And in this case, you
[3047.40s -> 3049.40s]  know, the shell, if you will,
[3049.40s -> 3052.84s]  is the producer and, uh, it
[3052.84s -> 3053.76s]  actually checks. The first
[3053.76s -> 3054.56s]  thing it does is actually
[3054.56s -> 3055.64s]  check whether the circular
[3055.64s -> 3057.96s]  buffer is full. So, and the
[3057.96s -> 3058.72s]  way it checks with the
[3058.72s -> 3060.04s]  circular buffer is full. So
[3060.20s -> 3061.48s]  it starts out in the original
[3061.48s -> 3062.88s]  state is both the write
[3062.88s -> 3064.12s]  pointer and the read pointer
[3064.12s -> 3065.36s]  is zero, correct? The zero
[3065.36s -> 3067.12s]  index into the buffer. If
[3067.12s -> 3068.20s]  they're equal, you know that
[3068.24s -> 3069.32s]  they're, they're, they're,
[3069.64s -> 3072.56s]  uh, the buffer's empty. Uh,
[3072.60s -> 3073.52s]  but if you add one to the
[3073.52s -> 3074.36s]  write pointer and it's the
[3074.36s -> 3075.68s]  same as the receive pointer.
[3075.72s -> 3077.08s]  So for example, if the, you
[3077.08s -> 3078.24s]  know, you go, you fill in a
[3078.24s -> 3079.16s]  zero one, two, three, four,
[3079.16s -> 3079.88s]  five, six, seven, eight,
[3079.88s -> 3081.20s]  nineteen, thirty one, and
[3081.20s -> 3082.68s]  then you're about to, uh,
[3082.68s -> 3084.04s]  wrap around, you know, you
[3084.04s -> 3087.16s]  add one if then, uh, and
[3087.20s -> 3088.16s]  it's still equal to the
[3088.16s -> 3090.28s]  receive index or the read
[3090.28s -> 3091.00s]  index, you know, that the
[3091.00s -> 3092.80s]  buffer is full. And so
[3092.80s -> 3094.08s]  there's no point, you know,
[3094.08s -> 3095.04s]  you can't write anything at
[3095.04s -> 3096.56s]  that point, uh, because
[3096.72s -> 3097.80s]  apparently you are still
[3097.80s -> 3098.84s]  busy, you know, working
[3098.84s -> 3101.36s]  its way through, uh, trying
[3101.36s -> 3103.20s]  to send off the preceding,
[3103.24s -> 3104.72s]  you know, 31 characters or
[3104.72s -> 3106.40s]  30 characters. So in this
[3106.40s -> 3108.04s]  case, uh, the buffer's full,
[3108.28s -> 3111.52s]  the shell, uh, basically
[3111.52s -> 3113.12s]  would be put to sleep and
[3113.12s -> 3114.80s]  put on the site and the
[3114.80s -> 3115.76s]  kernel would run some other
[3115.76s -> 3119.16s]  program, uh, until, uh, the
[3119.16s -> 3120.24s]  shell's be broken up and
[3120.24s -> 3121.32s]  it's actually ready to send.
[3122.96s -> 3124.20s]  Or you are just ready to
[3124.28s -> 3126.48s]  send more data. Uh, now,
[3126.48s -> 3127.12s]  of course, in this case,
[3127.12s -> 3127.80s]  this is not the case,
[3127.80s -> 3128.48s]  right? Because it's like,
[3128.48s -> 3129.20s]  this is the first few
[3129.20s -> 3130.08s]  characters that are being
[3130.08s -> 3131.40s]  print. Uh, so there's
[3131.40s -> 3132.76s]  space in the buffer. And
[3132.76s -> 3134.32s]  so basically the driver,
[3134.36s -> 3135.60s]  you know, puts, uh, the
[3135.60s -> 3136.84s]  character into the buffer,
[3137.36s -> 3138.72s]  uh, updates the right
[3138.72s -> 3139.80s]  pointer to go to the next
[3139.80s -> 3141.40s]  slot and then calls you at
[3141.40s -> 3144.56s]  start. And basically your
[3144.56s -> 3145.48s]  start is nothing else.
[3145.48s -> 3146.32s]  And sort of kicking the
[3146.32s -> 3147.44s]  device and saying like,
[3147.44s -> 3149.16s]  Hey, go do some work for
[3149.16s -> 3153.72s]  me. Um, and, uh, and
[3153.72s -> 3157.08s]  basically, uh, uh, first
[3157.08s -> 3159.92s]  checks it, uh, the device
[3159.92s -> 3160.96s]  is still busy sending the
[3160.96s -> 3162.76s]  current character that I wrote
[3162.96s -> 3165.72s]  recently. Uh, if, uh, if
[3165.72s -> 3167.12s]  the device is busy, you
[3167.12s -> 3168.08s]  know, we just go back and
[3168.08s -> 3168.84s]  then we'll go to sleep
[3168.88s -> 3171.08s]  probably, uh, we'll go to
[3171.08s -> 3172.64s]  sleep and otherwise we'll
[3172.64s -> 3173.52s]  read the character out of
[3173.52s -> 3176.52s]  the buffer, uh, and put
[3176.52s -> 3178.56s]  it in the transmission
[3178.56s -> 3179.96s]  register that we saw
[3179.96s -> 3182.88s]  earlier. And so the
[3183.00s -> 3184.36s]  transmission register is
[3184.36s -> 3186.36s]  just like as before, uh,
[3186.40s -> 3187.20s]  let's look at that for a
[3187.20s -> 3190.32s]  second. Uh, you know,
[3190.32s -> 3191.16s]  we usually, you write the
[3191.16s -> 3192.96s]  register, you know, cast,
[3193.68s -> 3195.28s]  you know, the particular
[3195.28s -> 3196.40s]  register to the, whatever
[3196.40s -> 3197.88s]  reds type and then writes
[3197.88s -> 3200.48s]  the value into it. And,
[3200.48s -> 3201.68s]  you know, DHR, the
[3201.68s -> 3202.72s]  transmitted holding register
[3202.72s -> 3204.36s]  is register zero, which we
[3204.36s -> 3205.24s]  saw before from the
[3205.24s -> 3209.40s]  documentation. Okay. So, uh,
[3209.92s -> 3211.76s]  so basically, you know, the,
[3212.16s -> 3215.48s]  um, uh, where I was in
[3215.48s -> 3217.88s]  start, uh, you should start
[3217.88s -> 3219.04s]  basically kicks the device
[3219.04s -> 3220.28s]  and saying like, Hey, I got
[3220.28s -> 3221.76s]  a register. I got a bite
[3221.76s -> 3223.44s]  for you available to send
[3223.44s -> 3226.08s]  off. And that's basically
[3226.08s -> 3231.44s]  all, uh, the, uh, basically
[3231.44s -> 3232.88s]  the, if you will, the shell,
[3232.92s -> 3234.08s]  you know, the system call
[3234.08s -> 3235.12s]  that, you know, the shell
[3235.12s -> 3237.16s]  called will do. And, you
[3237.16s -> 3238.44s]  know, once it actually kicked
[3238.44s -> 3239.40s]  the device and this is
[3239.40s -> 3240.20s]  we'll return to user
[3240.20s -> 3241.36s]  space and the shell can go
[3241.36s -> 3242.68s]  on and do whatever it wants
[3242.68s -> 3244.24s]  to do. And presumably the
[3244.24s -> 3245.00s]  next thing the shell will
[3245.00s -> 3245.72s]  do is called the reach
[3245.72s -> 3246.64s]  system call to actually
[3246.64s -> 3247.48s]  reach input from the
[3247.48s -> 3248.96s]  keyboard. Um, and so the
[3248.96s -> 3250.00s]  shell will return to user
[3250.04s -> 3251.32s]  space using the standard
[3251.32s -> 3253.20s]  mechanism that we have seen
[3253.20s -> 3254.84s]  before, like user red and
[3254.84s -> 3255.56s]  just goes off and does
[3255.56s -> 3256.64s]  its thing. And in the
[3256.64s -> 3257.72s]  meantime, correct. The
[3257.72s -> 3259.08s]  device has not gotten a kick
[3259.44s -> 3261.00s]  to actually send some bites
[3261.00s -> 3267.24s]  off. Um, and so, uh, so
[3267.24s -> 3268.44s]  at some point, you know,
[3268.44s -> 3268.84s]  we're going to get an
[3268.84s -> 3271.12s]  interrupt, uh, hopefully,
[3271.12s -> 3271.80s]  you know, because we
[3271.80s -> 3273.76s]  programmed the hardware to
[3273.76s -> 3274.32s]  actually generate
[3274.32s -> 3275.64s]  interrupts. Let's go a
[3275.64s -> 3276.76s]  little bit back and talk
[3276.76s -> 3277.60s]  a little bit about actually
[3277.60s -> 3278.96s]  what happens when the
[3279.00s -> 3285.12s]  interrupt happens. Okay.
[3285.12s -> 3288.96s]  So, um, so what does the
[3288.96s -> 3292.36s]  hardware do in this
[3292.36s -> 3293.20s]  particular case, the race
[3293.20s -> 3295.52s]  five, uh, do when an
[3295.52s -> 3296.84s]  interrupt actually happens.
[3296.84s -> 3297.92s]  So we, we set this
[3297.92s -> 3299.68s]  interrupt enable bid in
[3299.68s -> 3300.80s]  the estate of register.
[3301.08s -> 3302.28s]  So the processor can be
[3302.28s -> 3303.40s]  interrupted. You know,
[3303.40s -> 3304.80s]  let's say the keyboard,
[3304.80s -> 3305.48s]  you know, raises the
[3305.48s -> 3306.68s]  interrupt line, you know,
[3306.76s -> 3307.60s]  go through the click,
[3307.60s -> 3308.24s]  you know, the click,
[3308.24s -> 3308.84s]  you know, routes the
[3308.84s -> 3310.80s]  interrupt to a particular
[3310.80s -> 3312.48s]  core and that core, you
[3312.48s -> 3314.96s]  know, uh, uh, has the, uh,
[3315.36s -> 3318.40s]  SIU bit set. So interrupt
[3318.40s -> 3321.12s]  enable bit set the
[3321.12s -> 3322.80s]  supervisor interrupt enable
[3322.80s -> 3324.32s]  bit set. So if the bid is
[3324.32s -> 3326.08s]  set, the following things
[3326.08s -> 3327.76s]  happen, and this will look
[3327.76s -> 3328.96s]  very similar to, you
[3328.96s -> 3329.52s]  know, what we've seen
[3329.52s -> 3330.88s]  before. Uh, but the first
[3330.88s -> 3332.32s]  thing, uh, the hardware
[3332.32s -> 3335.28s]  does is clear the SIU bit,
[3337.00s -> 3337.92s]  and this stops, you know,
[3337.92s -> 3338.80s]  any further interrupts
[3338.80s -> 3340.48s]  coming in, uh, so that we
[3340.48s -> 3341.32s]  can just deal with this
[3341.32s -> 3342.36s]  interrupt first. And then
[3342.36s -> 3342.92s]  if we want more
[3342.92s -> 3343.72s]  interrupts, you know, we
[3343.72s -> 3344.96s]  have to re-enable that
[3344.96s -> 3346.40s]  bit, but, you know, uh,
[3346.40s -> 3347.68s]  this just stops further
[3347.68s -> 3348.56s]  interrupts and basically
[3348.56s -> 3349.56s]  interrupts interrupting the
[3349.56s -> 3352.88s]  interrupt. Um, then it
[3352.88s -> 3356.64s]  sets the SEPC to, you
[3356.64s -> 3357.84s]  know, the exception program
[3357.84s -> 3359.44s]  counter to the current PC.
[3360.56s -> 3361.32s]  You know, for example, if
[3361.32s -> 3362.28s]  we were interrupted, you
[3362.28s -> 3363.20s]  know, let's say the shell
[3363.20s -> 3364.40s]  returned to user space,
[3364.40s -> 3365.48s]  like happily running user
[3365.48s -> 3366.96s]  space and interrupt comes in
[3366.96s -> 3367.68s]  because of that one
[3367.68s -> 3369.16s]  character was sent, then
[3369.16s -> 3370.08s]  the program counter
[3370.08s -> 3371.28s]  saved is whatever program
[3371.28s -> 3372.08s]  counter was in user
[3372.08s -> 3374.64s]  space, uh, it saves the,
[3375.48s -> 3377.80s]  uh, saves the, uh, current
[3377.80s -> 3381.32s]  mode. So in this case,
[3381.32s -> 3382.00s]  that would be, you know,
[3382.00s -> 3382.96s]  our example would be, you
[3382.96s -> 3383.92s]  know, it would save that
[3383.92s -> 3384.80s]  actually the process in
[3384.80s -> 3386.48s]  supervisor mode of in user
[3386.48s -> 3387.84s]  mode, then it sets the
[3387.84s -> 3388.64s]  mode, you know, to
[3388.64s -> 3395.00s]  supervisor and, uh,
[3395.00s -> 3396.08s]  basically sets the program
[3396.08s -> 3399.32s]  counter to STVEC, whatever
[3399.32s -> 3401.04s]  values in STVEC, right?
[3401.04s -> 3401.56s]  Then that's going to be
[3401.56s -> 3405.32s]  either a user trap or user
[3405.32s -> 3407.92s]  VEC or kernel VEC, depending
[3407.92s -> 3408.76s]  whether the interrupt
[3408.76s -> 3409.92s]  happened, you know, whether
[3409.92s -> 3410.60s]  you know, we're in your
[3410.60s -> 3411.72s]  kernel space or in user
[3411.72s -> 3412.84s]  mode, but in our example,
[3412.84s -> 3414.00s]  where maybe the shell
[3414.00s -> 3416.16s]  returned to user space, uh,
[3416.20s -> 3417.16s]  you know, STVEC will
[3417.16s -> 3420.32s]  contain the, uh, user attack
[3420.32s -> 3422.24s]  address and basically the
[3422.64s -> 3424.12s]  hardware will resume the
[3424.12s -> 3426.12s]  kernel, uh, at the
[3426.12s -> 3428.24s]  instruction, uh, that is
[3428.24s -> 3430.60s]  located STVEC. And then we
[3430.60s -> 3431.36s]  remember from previous
[3431.36s -> 3432.40s]  lecture, you know, basically
[3432.40s -> 3433.48s]  STVEC, you know, it goes
[3433.48s -> 3436.16s]  off and, uh, calls user
[3436.16s -> 3438.64s]  trap. Okay. So in the end,
[3438.64s -> 3439.52s]  we'll basically end up in
[3439.52s -> 3443.64s]  user trap. And that's where
[3443.64s -> 3444.32s]  we sort of pick up the
[3444.32s -> 3445.68s]  story because like, I don't
[3445.68s -> 3446.56s]  really want to talk too much
[3446.56s -> 3447.92s]  about the saving and
[3447.92s -> 3449.88s]  restoring anymore because, uh,
[3449.88s -> 3450.84s]  one, we explained it in
[3450.84s -> 3451.84s]  detail in the previous
[3451.84s -> 3452.96s]  lecture and two, you already
[3452.96s -> 3454.44s]  played with it also in, uh,
[3454.84s -> 3456.24s]  in this last traps, uh,
[3456.24s -> 3457.72s]  radish lab. And so, you
[3457.72s -> 3459.04s]  know, you know exactly
[3459.04s -> 3464.72s]  what's going on. Any
[3464.72s -> 3474.24s]  questions? Okay. So, um, so
[3474.24s -> 3475.12s]  here we're back in user
[3475.12s -> 3476.36s]  trap, you know, the
[3476.36s -> 3477.60s]  function you looked in detail
[3477.60s -> 3481.00s]  at in the traps lab and, uh,
[3481.04s -> 3481.80s]  you know, when you dealt
[3481.84s -> 3483.12s]  with this case of system
[3483.12s -> 3486.36s]  calls, uh, and what we're
[3486.36s -> 3486.92s]  going to do is like,
[3486.92s -> 3488.00s]  basically the only thing
[3488.00s -> 3488.64s]  we're going to do is look
[3488.64s -> 3490.84s]  at this case, uh, which
[3490.84s -> 3492.24s]  is the device interrupt.
[3493.00s -> 3495.24s]  Right. So, um, so we're
[3495.24s -> 3497.48s]  gonna, that's a little bit
[3497.48s -> 3499.16s]  low loader, lower here in
[3499.16s -> 3504.40s]  the file. So here's the
[3504.40s -> 3507.24s]  device interrupt. Um, and
[3507.24s -> 3508.04s]  it looks basically at the
[3508.04s -> 3511.56s]  S cost, uh, register and
[3511.60s -> 3513.00s]  sees if this is an external
[3513.00s -> 3514.76s]  interrupt. And if it's an
[3514.76s -> 3516.48s]  external interrupt, it calls
[3516.48s -> 3517.40s]  the function, the click
[3517.40s -> 3519.68s]  claim, uh, to basically
[3519.80s -> 3521.44s]  claim that particular to
[3521.44s -> 3522.60s]  claim the interrupt. So
[3522.60s -> 3523.80s]  let's go back to a click
[3526.76s -> 3528.88s]  and look at the claim. And
[3528.88s -> 3529.92s]  basically what it boils down
[3529.92s -> 3534.04s]  to is that the, uh, this
[3534.04s -> 3535.32s]  particular CPU will tell
[3535.32s -> 3536.64s]  the plague, Hey, I'm
[3536.64s -> 3538.20s]  claiming, you know, if the
[3538.20s -> 3540.20s]  CPU zero or CPU one, it
[3540.20s -> 3541.88s]  will tell the, uh, click
[3541.88s -> 3544.08s]  that CPU one is claiming
[3544.08s -> 3545.68s]  this particular interrupt.
[3545.76s -> 3547.24s]  And once the claim and
[3547.24s -> 3548.32s]  interrupt and the flick
[3548.32s -> 3549.32s]  returns, which interrupts it
[3549.32s -> 3551.72s]  gets the IRQ for the
[3551.72s -> 3552.72s]  interrupt that actually came
[3552.72s -> 3553.76s]  in. And so in this case,
[3553.76s -> 3555.24s]  that will be, uh, an
[3555.24s -> 3556.44s]  interrupt for the UART and
[3556.44s -> 3558.76s]  the IRQ 10. So clicking
[3558.80s -> 3560.00s]  flame will basically return
[3560.00s -> 3562.80s]  10. Um, and then here in
[3562.80s -> 3564.20s]  this code, you know, we
[3564.20s -> 3565.32s]  look, you say, Hey, is
[3565.32s -> 3567.24s]  this, uh, interrupt 10. If
[3567.24s -> 3568.20s]  it's interrupt 10, then
[3568.20s -> 3569.44s]  must be a UART interrupt.
[3569.84s -> 3571.16s]  And we basically called the
[3571.16s -> 3573.24s]  UART interrupt, uh, function
[3574.08s -> 3575.84s]  and the UART interrupt
[3575.84s -> 3580.32s]  function, uh, uh, uh, runs
[3580.36s -> 3581.40s]  and basically gets the
[3581.40s -> 3583.04s]  character off, you know, the
[3583.04s -> 3584.92s]  UART and way it gets the
[3584.92s -> 3586.00s]  character of UART is
[3586.00s -> 3587.32s]  basically it looks in the,
[3587.76s -> 3589.64s]  uh, first register, the
[3589.92s -> 3592.52s]  receive register and, uh, gets
[3592.52s -> 3593.44s]  the character out of there.
[3594.44s -> 3596.68s]  And, uh, that is, uh, an
[3596.68s -> 3598.48s]  integer. And then it calls,
[3598.52s -> 3601.60s]  uh, console interrupt, uh, to
[3601.60s -> 3602.48s]  do the rest of the work.
[3605.76s -> 3610.00s]  Okay. Actually, sorry. Uh, I
[3610.00s -> 3611.56s]  just did the wrong thing. We
[3611.56s -> 3612.76s]  were talking about transmission.
[3613.32s -> 3619.52s]  Uh, so if there was a
[3619.52s -> 3621.60s]  character, uh, on the read
[3622.08s -> 3624.04s]  site, uh, then, you know, we'll
[3624.04s -> 3625.80s]  call the console interrupt. Uh,
[3625.84s -> 3626.76s]  but there is no character
[3626.80s -> 3627.84s]  correct on the read side
[3627.84s -> 3628.76s]  because, you know, we haven't
[3628.76s -> 3630.08s]  read any, the keyboard hasn't
[3630.08s -> 3631.60s]  done anything yet. Uh, we're
[3631.60s -> 3633.00s]  just transmitting a character.
[3633.36s -> 3634.52s]  Uh, so this will actually
[3634.52s -> 3636.04s]  return minus one fall
[3636.04s -> 3637.92s]  through. And then basically the
[3637.92s -> 3639.00s]  only thing it will do is
[3639.00s -> 3641.60s]  call, uh, it will, uh, uh,
[3642.44s -> 3644.08s]  uh, call UART start, uh, to
[3644.08s -> 3645.36s]  basically send any, any
[3645.36s -> 3646.80s]  other characters that might be
[3646.80s -> 3648.40s]  in the buffer that, uh, the
[3648.48s -> 3649.64s]  shell that might be stuck in
[3649.64s -> 3651.32s]  there. And presumably there's
[3651.32s -> 3652.24s]  another character in there
[3652.24s -> 3653.44s]  because after the dollar is to
[3653.44s -> 3656.12s]  space and, uh, uh, the right
[3656.12s -> 3657.36s]  system call might, you know, to
[3657.36s -> 3658.44s]  write this space might have
[3658.44s -> 3660.00s]  happened, uh, concurrently while
[3660.00s -> 3661.80s]  the device was sending off. And
[3661.80s -> 3663.00s]  so when you interrupt, you
[3663.00s -> 3663.88s]  know, transmit, interrupt,
[3663.88s -> 3666.20s]  complete, uh, it's going off,
[3666.24s -> 3667.36s]  you know, the, it will find
[3667.36s -> 3668.52s]  in the buffer yet another
[3668.52s -> 3669.72s]  character, the space character,
[3669.72s -> 3670.96s]  and we'll send that space
[3670.96s -> 3675.32s]  character off. Okay. Does that
[3675.32s -> 3675.76s]  make sense?
[3678.00s -> 3679.44s]  Uh, I have a high level
[3679.44s -> 3682.08s]  question actually. So I
[3682.08s -> 3685.12s]  understand the URT is like
[3685.12s -> 3686.88s]  useful if I'm like using a
[3686.88s -> 3689.32s]  keyboard, uh, and like
[3689.44s -> 3690.80s]  characters from the keyboard
[3690.80s -> 3692.88s]  go through the UART and then
[3692.88s -> 3694.12s]  through the CPU and then the
[3694.12s -> 3696.00s]  kernel code that we wrote. But
[3696.00s -> 3697.40s]  I, I'm not sure I understand
[3697.40s -> 3698.92s]  what the point of the UART is
[3698.92s -> 3700.60s]  when the shell is printing
[3700.60s -> 3702.28s]  characters, like the keyboard
[3702.28s -> 3703.72s]  isn't being interacted with.
[3704.20s -> 3705.40s]  No, that's correct. But the
[3705.40s -> 3706.96s]  display is right. So there's
[3706.96s -> 3708.68s]  sort of two devices here. One
[3708.68s -> 3709.88s]  is the keyboard and one is the
[3709.88s -> 3712.40s]  display or the console. And,
[3712.44s -> 3714.40s]  uh, and the way, you know,
[3714.40s -> 3715.44s]  QEMU interacts with the
[3715.44s -> 3718.24s]  console is by UART, uh, just
[3718.24s -> 3720.12s]  by sending a character to the
[3720.12s -> 3721.60s]  console. And then the
[3721.60s -> 3723.04s]  console's job is basically to
[3723.04s -> 3724.96s]  draw that character on the
[3725.00s -> 3725.48s]  display.
[3726.76s -> 3728.36s]  Oh, I see. Okay. Thanks.
[3730.60s -> 3731.48s]  And it might take a time.
[3731.76s -> 3732.64s]  That's why, you know, this
[3732.64s -> 3733.44s]  thing, you're sort of
[3733.44s -> 3738.04s]  interrupt driven. Okay. Um, so
[3738.20s -> 3739.36s]  couple of things now, you
[3739.36s -> 3740.16s]  know, I want to step back a
[3740.16s -> 3743.00s]  little bit and, uh, think a
[3743.00s -> 3744.04s]  little bit at higher level
[3744.04s -> 3745.44s]  what's going on. So we sort of
[3745.44s -> 3746.32s]  walked through the code. We
[3746.32s -> 3747.40s]  get sort of a feeling for the
[3747.40s -> 3749.68s]  lay of the land, uh, and like
[3749.68s -> 3753.48s]  how the, you know, the
[3753.48s -> 3755.08s]  details, uh, but it's worthwhile
[3755.08s -> 3756.76s]  to step back a second and
[3756.80s -> 3758.04s]  think a little bit about, you
[3758.04s -> 3760.44s]  know, what it all means. And
[3760.48s -> 3761.52s]  particular, what is
[3761.52s -> 3763.56s]  interesting is interrupting
[3763.56s -> 3764.52s]  concurrency sort of think
[3764.52s -> 3765.28s]  about interrupt from the
[3765.40s -> 3766.52s]  perspective of concurrency.
[3768.40s -> 3772.08s]  Uh, this is one of the things
[3772.08s -> 3773.08s]  that actually makes interrupts,
[3773.16s -> 3775.28s]  uh, tricky or difficult to
[3775.28s -> 3777.72s]  program. So first of all, uh,
[3777.76s -> 3778.36s]  you know, if you mentioned a
[3778.36s -> 3780.32s]  little bit earlier, the device,
[3780.36s -> 3781.20s]  you know, the UART in our
[3781.20s -> 3783.44s]  case, the device and the CPU
[3784.40s -> 3791.20s]  running parallel. So one
[3791.20s -> 3793.12s]  example in this scenario, we
[3793.12s -> 3794.36s]  just talked about, you know,
[3794.36s -> 3796.36s]  the, the, the UART is
[3796.36s -> 3798.00s]  sending off, you know, uh, the
[3798.00s -> 3799.24s]  character, you know, to the
[3799.24s -> 3800.92s]  console. And while that's
[3800.92s -> 3802.76s]  happening, the CPU is just, you
[3802.76s -> 3803.96s]  know, going about its
[3803.96s -> 3805.40s]  business. And in this case,
[3805.40s -> 3806.24s]  you know, returning to the
[3806.24s -> 3807.96s]  shell, the shell may make
[3807.96s -> 3808.96s]  another system call, for
[3808.96s -> 3810.40s]  example, to write that, uh,
[3810.44s -> 3813.08s]  space, uh, character and all
[3813.08s -> 3814.88s]  happens in parallel. And so we
[3814.88s -> 3815.96s]  need to manage that
[3815.96s -> 3817.40s]  parallelism a bit. And we
[3817.40s -> 3818.36s]  already saw it a little bit,
[3818.36s -> 3819.00s]  but I'm gonna talk a little
[3819.00s -> 3820.48s]  bit more in detail. And the
[3820.48s -> 3821.60s]  type of parallelism that
[3821.60s -> 3823.00s]  actually shows up here is
[3823.00s -> 3824.20s]  typically called producer
[3824.20s -> 3837.08s]  consumer parallelism. Let me
[3837.12s -> 3838.20s]  talk about it in a second. So
[3838.20s -> 3839.08s]  that's, we're going to talk
[3839.08s -> 3839.76s]  about that in a little bit
[3839.76s -> 3843.12s]  more detail. The second is, uh,
[3843.16s -> 3850.32s]  that the interrupt stops the
[3850.32s -> 3856.28s]  current running program, or
[3856.28s -> 3857.16s]  the current program that's
[3857.16s -> 3861.24s]  running. So in the case of
[3861.24s -> 3862.44s]  the shell, you know, shell
[3862.44s -> 3863.72s]  might be executing
[3863.72s -> 3865.04s]  extraction, like, you know,
[3865.44s -> 3868.04s]  212 and boom, interrupt comes
[3868.04s -> 3869.24s]  in and immediately at that
[3869.24s -> 3871.84s]  point is just stopped. Uh, and
[3871.84s -> 3872.96s]  it doesn't, you know, for
[3872.96s -> 3874.08s]  the user space code does not
[3874.08s -> 3875.84s]  a particularly big deal, uh,
[3875.88s -> 3876.80s]  because you know, when we
[3876.80s -> 3878.04s]  return from the interrupt, will
[3878.04s -> 3879.72s]  we restore all the state, you
[3879.76s -> 3880.76s]  know, off the user level
[3880.76s -> 3882.68s]  program. And then we'll resume,
[3882.76s -> 3883.84s]  you know, at that, you know,
[3883.88s -> 3885.08s]  address where, which got
[3885.08s -> 3886.36s]  interrupted. And so we have
[3886.36s -> 3887.16s]  seen that, you know, with
[3887.76s -> 3889.04s]  traps and page vaults. And
[3889.04s -> 3891.12s]  so, you know, um, it actually
[3891.12s -> 3892.60s]  works out reasonable well, but
[3892.60s -> 3893.28s]  there's a little bit of a
[3893.28s -> 3895.16s]  tricky case when the kernel
[3895.16s -> 3896.76s]  itself is interrupted. So you're
[3896.76s -> 3898.16s]  running in kernel mode and the
[3898.16s -> 3899.84s]  kernel gets interrupted. That
[3899.84s -> 3901.88s]  means that, uh, and, you
[3901.88s -> 3902.32s]  know, we'll talk a little
[3902.32s -> 3904.20s]  bit more in detail that even
[3904.20s -> 3905.28s]  the kernel doesn't really
[3905.28s -> 3906.40s]  sort of executed straight
[3906.40s -> 3907.44s]  sequentially, you know, if you
[3907.44s -> 3908.72s]  see one kernel instruction
[3908.72s -> 3909.36s]  followed by another
[3909.40s -> 3911.68s]  kernel instruction in those
[3911.68s -> 3912.48s]  between those three
[3912.48s -> 3913.84s]  instructions, an interrupt
[3913.84s -> 3917.04s]  might happen, uh, depending
[3917.28s -> 3918.28s]  whether interrupts are enabled
[3918.28s -> 3921.32s]  or not. And so whether some
[3921.32s -> 3922.56s]  piece of code and it's not
[3922.56s -> 3923.76s]  good to have an interrupt in
[3923.76s -> 3925.24s]  between, uh, and in that
[3925.24s -> 3926.16s]  case, you know, the kernel
[3926.16s -> 3927.44s]  might actually have to disable
[3927.44s -> 3928.88s]  or enable interrupts to make
[3928.88s -> 3930.32s]  basically code sequences
[3930.60s -> 3933.92s]  atomic. Uh, so interrupt
[3933.92s -> 3943.20s]  enable and disable. Talk
[3943.20s -> 3944.04s]  about it in a second, in a
[3944.04s -> 3945.56s]  more detail and then sort of
[3945.56s -> 3946.92s]  deferred, uh, sort of
[3946.92s -> 3948.96s]  concurrency, uh, problem
[3948.96s -> 3952.80s]  that shows up is the interrupt
[3952.80s -> 3955.96s]  handler, or maybe say, let
[3955.96s -> 3957.48s]  me say it differently, the
[3957.48s -> 3962.96s]  top of the driver and the
[3962.96s -> 3965.92s]  bottom of the driver may run
[3966.16s -> 3977.16s]  in parallel. So for example,
[3977.16s -> 3980.92s]  in our example, um, the shell,
[3981.04s -> 3983.12s]  uh, is going to call the, uh,
[3983.16s -> 3984.60s]  write system call again, you
[3984.60s -> 3985.84s]  have to apply the white space
[3985.84s -> 3987.48s]  after it printed the dollar.
[3987.76s -> 3989.32s]  And while we're going to make
[3989.32s -> 3990.72s]  it go back into the top level
[3990.72s -> 3992.40s]  of the driver, uh, it might
[3992.44s -> 3994.72s]  want to add, you know, this
[3994.72s -> 3996.36s]  white space to that queue that
[3996.36s -> 3997.96s]  the, the, you are to actually
[3997.96s -> 3999.88s]  has, but at the same time on
[3999.88s -> 4001.72s]  another CPU, it might actually
[4001.72s -> 4003.80s]  take, uh, the interrupt, you
[4003.80s -> 4006.48s]  know, form the New York and
[4006.48s -> 4008.72s]  basically also, uh, be running
[4008.72s -> 4010.00s]  in parallel and that's sort of
[4010.04s -> 4011.20s]  roughly in the same code and
[4011.20s -> 4013.20s]  looking at the same queue. And
[4013.20s -> 4014.20s]  so it's really true that
[4014.20s -> 4015.36s]  basically the interrupt handler
[4015.36s -> 4016.72s]  can run in parallel with the
[4016.72s -> 4017.76s]  bottom half of the device
[4017.76s -> 4019.12s]  driver might run in parallel
[4019.12s -> 4021.04s]  and different CPUs on the
[4021.04s -> 4022.88s]  different CPU with the top half
[4022.88s -> 4025.28s]  with, uh, of the driver. So we
[4025.28s -> 4027.08s]  have to manage that a bit. Uh,
[4027.12s -> 4028.48s]  and the way, you know, we're
[4028.48s -> 4029.60s]  going to manage that is using
[4029.60s -> 4034.64s]  locks because there's a shared
[4034.64s -> 4035.92s]  data structure here, namely
[4035.92s -> 4038.32s]  the, the buffer. And we're
[4038.32s -> 4039.16s]  going to make sure that, you
[4039.16s -> 4040.16s]  know, the, that buffer is
[4040.16s -> 4042.92s]  updated correctly and to make
[4042.92s -> 4045.56s]  sure that the, uh, only one,
[4045.68s -> 4047.92s]  uh, CPU at a time basically
[4047.92s -> 4049.12s]  manipulates that particular
[4049.12s -> 4049.84s]  buffer. We're going to use
[4049.84s -> 4051.72s]  locks and locks is going to be
[4051.72s -> 4052.80s]  the topic of Wednesday's
[4052.80s -> 4053.84s]  lecture. I'm not going to talk
[4053.84s -> 4055.40s]  much about it at all, but it
[4055.40s -> 4056.28s]  will show up big time on
[4056.28s -> 4059.04s]  Wednesday. The thing I want to
[4059.04s -> 4060.04s]  focus on is actually just
[4060.04s -> 4063.32s]  produce a consumer, uh, uh,
[4065.12s -> 4066.92s]  parallelism. And this is a
[4066.92s -> 4068.24s]  typical thing that shows up in
[4068.24s -> 4069.72s]  the drivers and it is
[4069.80s -> 4072.52s]  extremely common, uh, to see
[4072.52s -> 4075.04s]  this. So, uh, so producer
[4075.08s -> 4081.68s]  consumer, and it's pretty
[4081.68s -> 4083.92s]  straightforward. Uh, so you've
[4083.92s -> 4084.92s]  seen, you know, there's
[4084.92s -> 4086.96s]  basically a buffer in the
[4086.96s -> 4090.20s]  driver, you know, in our case,
[4090.20s -> 4091.44s]  I think there were 32 entries
[4091.44s -> 4096.04s]  in it, so zero to 31 and,
[4096.08s -> 4098.60s]  uh, there's two pointers. Uh,
[4098.60s -> 4099.64s]  there's a read pointer and a
[4099.64s -> 4103.12s]  right pointer. Uh, there's the
[4103.12s -> 4104.92s]  right pointer, the read pointer,
[4105.00s -> 4106.88s]  um, if they're equal, you
[4106.88s -> 4108.56s]  know, the buffer is empty. And
[4108.56s -> 4110.24s]  so when, you know, the shell,
[4110.60s -> 4112.08s]  you know, we do a write, you
[4112.08s -> 4115.36s]  know, or put C that basically
[4115.36s -> 4116.40s]  puts the character like the
[4116.40s -> 4118.48s]  dollar here and bumps up, you
[4118.48s -> 4119.72s]  know, the right pointer to the
[4119.72s -> 4122.68s]  next entry. So that's sort of
[4122.68s -> 4124.20s]  the producer part and the
[4124.20s -> 4125.48s]  producer can keep going, you
[4125.48s -> 4126.48s]  know, filling up, you know,
[4126.48s -> 4128.80s]  all this, uh, characters until,
[4128.84s -> 4131.76s]  you know, it, uh, uh, until
[4131.80s -> 4132.84s]  it hits, you know, the report,
[4133.04s -> 4134.52s]  until, you know, if the next
[4134.52s -> 4135.48s]  increment, we hit the read
[4135.48s -> 4136.52s]  pointer, we know that the,
[4136.52s -> 4138.56s]  this circle buffer is full.
[4138.88s -> 4139.72s]  And at that point, you know,
[4139.72s -> 4141.08s]  the producer must stop. And
[4141.08s -> 4141.68s]  you know, we saw that
[4141.68s -> 4143.36s]  happening in, uh, in the code
[4143.76s -> 4145.48s]  a second ago where the user,
[4145.52s -> 4146.52s]  basically the shortcut called
[4146.52s -> 4148.16s]  sleep, and then we'll put
[4148.16s -> 4151.84s]  this, the shell, uh, on the
[4151.84s -> 4153.56s]  site and start running another
[4153.56s -> 4156.20s]  process. So the interrupt
[4156.20s -> 4157.04s]  handler, you know, like you
[4157.04s -> 4160.88s]  are in it or enter is in this
[4160.88s -> 4162.56s]  case at the consumer. And
[4162.56s -> 4165.04s]  basically every time, uh, uh,
[4165.08s -> 4167.04s]  when it's, uh, or you would
[4167.04s -> 4169.44s]  start basically, uh, when you
[4169.44s -> 4171.24s]  are in, uh, interrupts, it
[4171.24s -> 4172.16s]  will look at, you know, the
[4172.16s -> 4173.92s]  read pointer, uh, if the
[4173.92s -> 4175.32s]  read pointer is behind the
[4175.32s -> 4176.36s]  right pointer. So the right
[4176.36s -> 4177.60s]  pointer already further, let's
[4177.60s -> 4178.68s]  say the space is here too.
[4178.68s -> 4180.00s]  Now I know I can know how to
[4180.00s -> 4181.00s]  draw a space, but here's a
[4181.00s -> 4183.32s]  space. Uh, and so the right
[4183.32s -> 4184.68s]  pointer might now be here.
[4185.36s -> 4186.76s]  So after the dollar is being
[4186.76s -> 4188.28s]  sent, you know, the, you
[4188.28s -> 4189.36s]  are, it sees that, ah, you
[4189.36s -> 4190.44s]  know, I'm behind the right
[4190.44s -> 4191.92s]  pointer. That means I got to
[4191.92s -> 4194.68s]  send the next one. And so, you
[4194.68s -> 4195.40s]  know, you can think about
[4195.40s -> 4196.80s]  this as sort of these right,
[4196.88s -> 4197.92s]  you know, pointer, the read
[4197.92s -> 4199.44s]  pointer, changing the right
[4199.44s -> 4203.24s]  pointer. Um, and, uh, and
[4203.24s -> 4204.20s]  that's what's going on now.
[4204.24s -> 4205.16s]  It could be the case that at
[4205.16s -> 4207.36s]  some point, uh, the, you
[4207.36s -> 4209.20s]  are, uh, keeps up with the
[4209.20s -> 4210.16s]  right pointer, right. And
[4210.16s -> 4211.40s]  then when they're equal and
[4211.40s -> 4212.08s]  then it knows that the
[4212.08s -> 4213.00s]  buffer is empty and there's
[4213.00s -> 4217.20s]  nothing to do. That makes
[4217.20s -> 4221.52s]  sense. Sorry. So this data
[4221.52s -> 4223.68s]  structure is the same for all
[4223.68s -> 4226.96s]  cores. Uh, okay. So let me go
[4226.96s -> 4228.36s]  back to the code, right? And
[4228.36s -> 4229.92s]  then, uh, this is a high
[4229.92s -> 4231.92s]  level picture and let's go
[4231.92s -> 4233.32s]  back to UART. So this data
[4233.32s -> 4235.32s]  structure, uh, that we just
[4235.32s -> 4236.56s]  talked about is this buffer
[4240.28s -> 4241.88s]  and the two pointers, the
[4241.88s -> 4243.00s]  right and the read pointer are
[4243.00s -> 4245.48s]  these two indexes, these
[4245.48s -> 4250.68s]  indices. Okay. And this data
[4250.68s -> 4253.12s]  structure lives in memory. Uh,
[4253.16s -> 4254.24s]  and there's only one RAM,
[4254.56s -> 4256.04s]  right? And so all the course,
[4256.24s -> 4258.08s]  uh, might be interacting with
[4258.08s -> 4259.40s]  this data structure in parallel.
[4260.92s -> 4262.08s]  That's why we need locks.
[4265.20s -> 4266.64s]  Okay. I see. Um, and my
[4266.64s -> 4268.08s]  other question was for
[4268.08s -> 4272.12s]  sleep, how does it know to,
[4272.72s -> 4275.96s]  um, make the shell sleep? Like
[4276.20s -> 4278.08s]  what is written there is just
[4278.08s -> 4280.76s]  the address of this. Yeah. Let
[4280.76s -> 4283.84s]  me, okay. Basically the, uh,
[4284.12s -> 4286.12s]  the sleep color puts the
[4286.12s -> 4288.28s]  current process running on the
[4288.28s -> 4290.16s]  sleep, uh, in a sleep state.
[4290.72s -> 4292.56s]  And we'll talk about it in next
[4292.56s -> 4293.64s]  week or the week after in a
[4293.64s -> 4296.48s]  great amount of detail. Uh, and
[4296.52s -> 4297.76s]  it passes in the thing that
[4297.76s -> 4300.20s]  is waiting for, uh, and in
[4300.20s -> 4302.56s]  this case, that is the dress,
[4302.60s -> 4303.40s]  you know, basically it has a
[4303.40s -> 4305.12s]  channel ID or like a way of
[4305.12s -> 4306.16s]  communicating from what it
[4306.16s -> 4308.32s]  actually sleeping on. And so
[4308.32s -> 4309.80s]  that in this case, it is TxR,
[4310.08s -> 4314.08s]  it's the dress of URTXR and,
[4314.40s -> 4318.28s]  uh, uh, and the start
[4318.28s -> 4320.00s]  function, uh, it wants their
[4320.00s -> 4323.00s]  space again in the buffer. Uh,
[4323.04s -> 4325.16s]  it will wake up. Okay. We'll
[4325.16s -> 4326.28s]  call the corresponding call,
[4326.28s -> 4328.24s]  wake up with the URTHR to
[4328.24s -> 4329.68s]  indicate that any process that
[4329.68s -> 4330.64s]  actually sleeping on this
[4330.64s -> 4335.12s]  address should be woken up. And
[4335.12s -> 4336.32s]  how it was exactly implemented
[4336.32s -> 4337.60s]  is something that we'll see a
[4337.60s -> 4341.52s]  little bit later. Does that
[4341.52s -> 4343.36s]  make sense? So these two
[4343.36s -> 4344.44s]  calls go together, sleep and
[4344.44s -> 4349.84s]  wake up. It's sometimes called
[4349.84s -> 4355.32s]  conditional synchronization. Any
[4355.32s -> 4365.56s]  other questions? Okay. Good.
[4365.64s -> 4368.72s]  Um, let's see. Uh, so let's
[4368.72s -> 4371.96s]  see. Um, uh, so that is
[4371.96s -> 4374.52s]  basically the whole story, uh,
[4374.56s -> 4376.40s]  for printing and dollar. And as
[4376.40s -> 4377.20s]  you can see, it's actually
[4377.20s -> 4379.56s]  quite involved. Uh, there's a
[4379.56s -> 4381.48s]  lot of pieces that, uh, you
[4381.48s -> 4382.28s]  know, working together to
[4382.28s -> 4383.72s]  actually get this dollar out to
[4383.76s -> 4386.12s]  the console. Uh, and something
[4386.12s -> 4387.36s]  similar basically happens on
[4387.36s -> 4390.40s]  the, uh, the read side. So at
[4390.40s -> 4391.28s]  some point, the shell has
[4391.28s -> 4394.68s]  printed the, both the dollar
[4394.68s -> 4396.64s]  and the white space. And then
[4396.64s -> 4398.80s]  it will, uh, call reads to
[4398.80s -> 4400.44s]  basically read input from the
[4400.44s -> 4401.72s]  keyboard. Right. So now we
[4401.72s -> 4403.12s]  want to just see what
[4403.12s -> 4405.60s]  happens, uh, when, uh, that
[4405.60s -> 4407.32s]  happening. So that starts
[4407.32s -> 4409.16s]  basically in the end with file
[4409.16s -> 4411.16s]  again. So now there's, there's
[4411.16s -> 4413.64s]  a read system call, uh, if it's,
[4413.68s -> 4414.72s]  you know, reading from the
[4414.72s -> 4416.44s]  console, it will calls, uh, it
[4416.44s -> 4418.48s]  will actually of course file
[4418.48s -> 4423.28s]  read, sorry, not right. Uh, if
[4423.28s -> 4424.76s]  it's a device, which in this
[4424.76s -> 4425.76s]  case is the case, it's a
[4425.76s -> 4427.00s]  console, then we call the
[4427.00s -> 4429.52s]  read method for that device.
[4429.96s -> 4432.44s]  And that is in console.c. And
[4432.44s -> 4433.40s]  so we're going to go to
[4433.40s -> 4435.08s]  console read is being called.
[4435.68s -> 4437.80s]  Um, and basically it has the
[4437.80s -> 4439.44s]  same structure as this, uh,
[4439.44s -> 4440.36s]  you are, you know, there's a
[4440.36s -> 4443.00s]  sugar color buffer on the top.
[4443.96s -> 4446.68s]  Uh, here it is. It's an input
[4446.68s -> 4448.36s]  buffer from the 28 characters
[4448.44s -> 4450.00s]  in it. And basically it's the
[4450.00s -> 4450.92s]  same game, you know, it's a
[4450.92s -> 4452.36s]  producer consumer parallelism,
[4452.72s -> 4453.96s]  but in this case, the shell
[4453.96s -> 4455.28s]  is the consumer, right? You
[4455.28s -> 4456.52s]  know, it actually is reading,
[4456.56s -> 4457.96s]  you know, uh, characters off
[4458.00s -> 4461.00s]  the buffer and the keyboard is
[4461.00s -> 4462.08s]  the producer. It sticks to
[4462.08s -> 4465.20s]  characters into the buffer. And
[4465.20s -> 4466.88s]  so, you know, let's go back
[4466.88s -> 4469.52s]  to console read. Uh, if
[4469.52s -> 4471.36s]  there's nothing, if the read
[4471.36s -> 4473.00s]  pointer or the read index and
[4473.00s -> 4474.44s]  the write index are the same,
[4474.48s -> 4475.12s]  you know, basically the
[4475.12s -> 4477.12s]  buffer is empty and it goes
[4477.20s -> 4479.68s]  back to sleep again. And so,
[4479.72s -> 4481.60s]  uh, so after it's printed
[4481.60s -> 4483.84s]  dollar in a ampersand, the
[4483.84s -> 4485.76s]  shell is going to go to sleep,
[4486.24s -> 4488.32s]  uh, where the kernel will put
[4488.32s -> 4490.44s]  the shell to sleep, uh, until
[4491.12s -> 4493.48s]  a character comes in. And so
[4493.48s -> 4495.16s]  at some point, let's say, you
[4495.16s -> 4497.52s]  know, a user types in L, you
[4497.52s -> 4498.52s]  know, the first character from
[4498.52s -> 4501.16s]  LS on the keyboard, uh, that
[4501.16s -> 4503.48s]  will cause, you know, the L to
[4503.48s -> 4506.40s]  be sent to the UART, uh, chip
[4506.44s -> 4509.08s]  on the, on the board, uh, that
[4509.08s -> 4510.32s]  will be routed through the
[4510.32s -> 4511.36s]  click, you know, to some
[4511.36s -> 4512.56s]  core, that core will take the
[4512.56s -> 4514.08s]  interrupt. That will go to
[4514.08s -> 4515.80s]  def inner, the def inner. We'll
[4515.80s -> 4516.80s]  see how that was a UART
[4516.80s -> 4518.64s]  interrupt. And then we'll call,
[4518.92s -> 4520.52s]  uh, the function that we
[4520.52s -> 4522.24s]  used, looked at a second ago.
[4522.72s -> 4523.76s]  Uh, let's go back to the
[4523.96s -> 4525.64s]  bottom where I got my confused
[4525.64s -> 4528.00s]  my self is for a second. Uh,
[4528.04s -> 4529.48s]  so in this case, you know, it
[4529.48s -> 4530.88s]  will write, it will get a
[4530.88s -> 4532.32s]  character from the device, from
[4532.32s -> 4533.24s]  the UART device, but it will
[4533.24s -> 4534.84s]  get the character L and we'll
[4534.84s -> 4536.60s]  call the console interrupts
[4536.60s -> 4538.12s]  function using with the
[4538.12s -> 4539.96s]  character L so we can go back
[4539.96s -> 4545.04s]  to console and console inner,
[4545.04s -> 4546.40s]  you know, does, you know,
[4546.40s -> 4547.96s]  gets the character. So now we
[4547.96s -> 4550.04s]  have an L, uh, if it's a
[4550.04s -> 4551.60s]  control P, you know, that
[4551.60s -> 4553.12s]  actually prints a list in the
[4553.12s -> 4555.16s]  processing list, uh, implements
[4555.16s -> 4557.56s]  control H and control U to do
[4557.56s -> 4559.04s]  backspace and control or
[4559.04s -> 4560.96s]  whatever. Uh, but in all other
[4560.96s -> 4562.08s]  cases, you know, basically
[4562.08s -> 4564.16s]  what it does, it echoes the
[4564.16s -> 4566.12s]  character back to the user by
[4566.16s -> 4568.52s]  printing it to the console. Uh,
[4568.60s -> 4569.92s]  and then it basically sticks
[4569.92s -> 4571.12s]  the character into the
[4571.12s -> 4573.24s]  buffer, uh, so that the, uh,
[4573.32s -> 4574.96s]  and wake up, you know, the
[4574.96s -> 4576.36s]  process that's waiting for
[4576.36s -> 4577.48s]  that buffer. If there's a
[4577.48s -> 4580.04s]  process waiting, uh, if it has
[4580.04s -> 4581.68s]  hit new line and there's a
[4581.68s -> 4583.00s]  process waiting, it will wake
[4583.00s -> 4585.16s]  up the waiting process. And
[4585.16s -> 4586.20s]  then the waiting process will
[4586.20s -> 4586.92s]  read, you know, the
[4586.92s -> 4588.00s]  characters out of the buffer.
[4590.24s -> 4591.52s]  Okay. So here again, we see
[4591.52s -> 4593.20s]  this sort of decoupling using
[4593.20s -> 4595.32s]  a buffer between the consumer
[4595.32s -> 4596.40s]  and the producer so that the
[4596.40s -> 4597.48s]  precision and consumer can just
[4597.48s -> 4599.72s]  run in parallel, uh, independent
[4599.76s -> 4601.32s]  each on their own speed. And
[4601.32s -> 4602.80s]  if one goes very fast, you
[4602.80s -> 4603.88s]  know, either the buffer will
[4603.88s -> 4605.08s]  be empty or full, and then
[4605.08s -> 4606.76s]  we'll block, wait until the
[4606.76s -> 4611.28s]  other guy catches up. Any
[4611.28s -> 4623.36s]  questions about this? Okay.
[4625.08s -> 4627.64s]  Um, okay. I want to talk
[4627.64s -> 4629.16s]  basically about one more thing.
[4630.48s -> 4637.24s]  Um, and that is, um, you
[4637.24s -> 4638.88s]  know, I'm mostly being, uh,
[4638.96s -> 4639.72s]  I'm talking a little bit about
[4639.72s -> 4641.28s]  sort of interrupt evolution,
[4641.32s -> 4642.60s]  like what has happened over the
[4642.60s -> 4654.68s]  last decades. Um, so, uh, through
[4654.68s -> 4655.96s]  interrupt used to be relative
[4656.16s -> 4657.16s]  to a processor, reasonable
[4657.16s -> 4660.04s]  fast, you know, particular in
[4660.04s -> 4665.96s]  the, uh, used to be fast. So
[4665.96s -> 4667.24s]  in the times that original
[4667.24s -> 4669.36s]  Unix was developed, uh, you
[4669.40s -> 4670.96s]  know, that was the case. And
[4670.96s -> 4671.96s]  that basically meant like the
[4671.96s -> 4674.44s]  hardware is very simple, uh,
[4674.48s -> 4676.28s]  because it's going to, if any
[4676.28s -> 4677.24s]  really sort of Sears work
[4677.24s -> 4678.52s]  need to be done, the hardware
[4678.52s -> 4679.20s]  could just interrupt the
[4679.20s -> 4680.88s]  processor and, you know, the
[4680.88s -> 4681.68s]  processor would do it on the
[4681.68s -> 4684.04s]  work. And so, uh, but the,
[4684.04s -> 4684.96s]  you know, the hardware itself
[4684.96s -> 4685.56s]  could be reasonable,
[4685.56s -> 4689.00s]  straightforward. Now, interrupts
[4689.08s -> 4691.68s]  are slow compared to the
[4691.68s -> 4693.32s]  processor. I mean, you can, you
[4693.32s -> 4694.24s]  can see that correct because
[4694.24s -> 4695.88s]  the interrupt handler, uh,
[4695.92s -> 4696.88s]  needs to save or restore
[4696.88s -> 4698.56s]  registers. Uh, it needs to
[4698.56s -> 4699.48s]  take the interrupt. So there's
[4699.48s -> 4702.96s]  a couple of, you know, there's
[4702.96s -> 4703.56s]  a small budget of
[4703.56s -> 4704.44s]  instructions that are just
[4704.44s -> 4705.92s]  being used to actually serve
[4705.92s -> 4709.20s]  the interrupt. And so, uh, if
[4709.20s -> 4710.68s]  the device generates interrupts
[4710.68s -> 4711.68s]  at a high speed, you know,
[4711.68s -> 4712.96s]  then the processor is going to
[4712.96s -> 4714.20s]  have a tough time keeping up.
[4715.16s -> 4717.32s]  And so you look at today's
[4717.44s -> 4718.76s]  devices, basically the
[4718.76s -> 4720.44s]  hardware or the device, there's
[4720.44s -> 4728.12s]  a lot more work. Uh, and so
[4728.12s -> 4729.20s]  basically there's a bunch of
[4729.20s -> 4730.44s]  the work actually on the device
[4730.44s -> 4731.76s]  itself before actually
[4731.76s -> 4734.20s]  generating an interrupt. And so,
[4734.60s -> 4736.20s]  uh, and just to avoid
[4736.24s -> 4737.72s]  interrupting the processor too
[4737.72s -> 4740.56s]  much. Uh, now if you really
[4740.56s -> 4741.92s]  have a high performance, uh,
[4741.96s -> 4743.16s]  device, like say you have a
[4743.16s -> 4746.72s]  gigabyte gigabit, uh, even at,
[4748.68s -> 4750.40s]  and you know, that cart
[4750.40s -> 4751.60s]  you should use a lot, a lot
[4751.60s -> 4753.16s]  of small packages, packets,
[4753.60s -> 4754.60s]  then, you know, you can
[4754.60s -> 4757.08s]  actually generate or even
[4757.08s -> 4758.40s]  itself could generate about
[4758.40s -> 4759.76s]  one, five, you know, 1.5
[4759.76s -> 4764.32s]  million packs per second, uh,
[4764.36s -> 4766.04s]  for minimal, like 64 by, uh,
[4766.12s -> 4767.40s]  even at packets, you do at
[4767.40s -> 4768.68s]  the math, you can roughly out
[4768.68s -> 4770.00s]  to basically you're generating
[4770.00s -> 4771.56s]  1.5 million packets per second
[4771.56s -> 4773.40s]  that you could receive. And so
[4773.40s -> 4774.84s]  that basically means, you know,
[4774.84s -> 4778.40s]  one interrupt, if you did it
[4778.40s -> 4780.44s]  for every packet, uh, per
[4780.44s -> 4785.56s]  microsecond, in fact, a little
[4785.56s -> 4789.80s]  bit more than, uh, uh, uh, a
[4789.80s -> 4791.12s]  little bit less than a little
[4791.12s -> 4792.24s]  bit more than, uh, so you
[4792.24s -> 4793.72s]  basically, you know, one way
[4793.72s -> 4794.44s]  to think about it, if there's
[4794.44s -> 4796.12s]  one interrupt per microsecond,
[4796.12s -> 4796.92s]  there's basically the
[4796.92s -> 4798.16s]  operations in the kernel
[4798.40s -> 4799.60s]  basically has a budget of
[4799.60s -> 4800.88s]  like one microsecond
[4800.88s -> 4801.84s]  obstructions to actually
[4801.84s -> 4802.84s]  process that packet. And the
[4802.84s -> 4804.04s]  fact that it's 1.5 million,
[4804.04s -> 4805.00s]  it's like a little bit less
[4805.08s -> 4808.68s]  than a budget of, uh, a
[4808.68s -> 4810.72s]  microsecond. And so you can
[4810.72s -> 4811.40s]  compute out how many
[4811.40s -> 4812.84s]  instructions that is, and
[4812.84s -> 4813.52s]  there's not going to be that
[4813.52s -> 4816.44s]  much. And so, uh, in that case,
[4816.44s -> 4817.92s]  you know, the, you need to
[4817.92s -> 4818.88s]  have a different plan. So like,
[4818.88s -> 4820.04s]  what do you do with like the
[4820.04s -> 4820.92s]  packets where the interrupts
[4820.92s -> 4821.80s]  are, you know, the packets
[4821.80s -> 4823.84s]  are coming in so fast that,
[4824.16s -> 4826.00s]  uh, the pressure really can't
[4826.00s -> 4828.44s]  keep up. And the solution to
[4828.44s -> 4831.80s]  that, uh, is to, uh, for
[4831.80s -> 4833.32s]  these fast devices, it's
[4833.32s -> 4834.44s]  actually something that's used,
[4834.44s -> 4841.32s]  it's called polling. And,
[4841.36s -> 4843.64s]  uh, instead of relying
[4843.64s -> 4845.56s]  interrupts, you know, what the
[4845.60s -> 4847.04s]  CPU also could do is just
[4847.04s -> 4848.76s]  keep reading that control
[4848.76s -> 4850.20s]  register and to see if there's
[4850.20s -> 4851.72s]  a byte there, like in a UART
[4851.72s -> 4852.80s]  register, but you just keep
[4852.80s -> 4855.64s]  reading that LHR register and
[4855.64s -> 4856.84s]  just check if there's a byte
[4856.84s -> 4859.32s]  there. And, uh, and this
[4859.32s -> 4861.00s]  really would, you know, what
[4861.00s -> 4862.12s]  this bio boils down to is
[4862.12s -> 4867.72s]  that the CPU spins, uh, spins
[4867.72s -> 4869.56s]  on the device, you know,
[4869.60s -> 4872.04s]  into all device as input,
[4874.12s -> 4878.92s]  that's data. Um, and you
[4878.92s -> 4880.64s]  know, this waste CPU cycles,
[4880.64s -> 4884.92s]  right? Because, you know,
[4884.92s -> 4886.36s]  while we're sort of checking
[4886.36s -> 4887.60s]  that register over and over
[4887.60s -> 4889.04s]  and over again to see if
[4889.04s -> 4890.56s]  there are actually any data,
[4890.80s -> 4892.20s]  uh, you know, we're not
[4892.20s -> 4893.28s]  using those cycles to run
[4893.28s -> 4894.68s]  another application. Right.
[4894.68s -> 4896.36s]  And, you know, and before
[4896.36s -> 4897.24s]  what you're seeing is that,
[4897.32s -> 4898.08s]  you know, if there's nothing
[4898.08s -> 4899.32s]  there, basically the
[4899.32s -> 4900.28s]  kernel puts the shell to
[4900.28s -> 4901.40s]  sleep so that another
[4901.40s -> 4902.88s]  application could run. But
[4902.88s -> 4904.68s]  if we do polling, then, you
[4904.68s -> 4905.84s]  know, that wouldn't happen.
[4906.36s -> 4908.52s]  Um, now for a slow device,
[4908.88s -> 4910.24s]  you clearly want, you know,
[4910.24s -> 4911.76s]  not spin forever until the
[4911.76s -> 4913.44s]  device finally gets around to
[4913.44s -> 4915.36s]  actually doing its work. Uh,
[4915.40s -> 4917.24s]  we really like to, uh, you
[4917.24s -> 4919.24s]  know, basically switch out the
[4919.24s -> 4920.24s]  shell and so that we can run
[4920.24s -> 4921.40s]  something else. But if the
[4921.40s -> 4923.96s]  device extremely fast, uh,
[4924.00s -> 4925.24s]  then the overhead would be,
[4925.24s -> 4925.84s]  you know, the interrupt
[4925.84s -> 4926.84s]  feature is high and, you
[4926.84s -> 4927.64s]  know, we're better off
[4927.64s -> 4928.60s]  actually wasting, you know,
[4928.64s -> 4929.96s]  basically pulling that device
[4929.96s -> 4931.24s]  because very quickly we're
[4931.24s -> 4934.84s]  going to get success. Uh, and
[4934.84s -> 4936.36s]  so if, but so you have to
[4936.52s -> 4937.68s]  waste CPOs, the device is
[4937.68s -> 4951.52s]  slow, but you know, but if
[4951.52s -> 4958.68s]  the device is fast, it saves,
[4958.76s -> 4961.08s]  uh, save saving your story.
[4964.48s -> 4965.12s]  Let's say it's the whole
[4965.12s -> 4966.84s]  entry, uh, entry and exit
[4966.96s -> 4974.08s]  costs. Uh, and so for
[4974.08s -> 4975.44s]  example, high performance
[4975.44s -> 4976.44s]  network cards, you know,
[4976.44s -> 4978.40s]  we'll, you know, uh, if
[4978.40s -> 4979.36s]  there's a stream of packets
[4979.36s -> 4980.56s]  coming in and actually we'll
[4980.56s -> 4982.64s]  use polling and, you know,
[4982.72s -> 4983.56s]  more, and the most
[4983.56s -> 4985.04s]  sophisticated drivers, you
[4985.04s -> 4985.60s]  know, basically they
[4985.60s -> 4990.76s]  dynamically switch, switch
[4990.76s -> 4991.60s]  between polling and
[4991.60s -> 5008.88s]  interrupts. Uh, okay. Um, any
[5008.88s -> 5012.92s]  questions close to my, uh,
[5013.12s -> 5014.28s]  my, I guess my time budget
[5014.28s -> 5017.56s]  is up and your remaining
[5017.56s -> 5024.00s]  questions. Okay, good. Uh,
[5024.04s -> 5024.80s]  then I'll see you on
[5024.80s -> 5025.76s]  Wednesday and basically
[5025.76s -> 5026.48s]  Wednesday, we're going to
[5026.48s -> 5027.92s]  continue this story of
[5027.92s -> 5028.88s]  concurrency and we're going
[5028.88s -> 5030.00s]  to sort of parallelism. We're
[5030.00s -> 5031.36s]  going to see some mechanisms
[5031.36s -> 5032.40s]  to actually manage the
[5032.40s -> 5033.96s]  parallelism to make sure
[5033.96s -> 5035.00s]  that shared data structures
[5035.00s -> 5037.24s]  get updated correctly. Uh,
[5037.24s -> 5038.20s]  so, uh, see you on
[5038.20s -> 5043.36s]  Wednesday. Oh, I'm sorry.
[5043.36s -> 5044.80s]  I just, I was trying to
[5044.80s -> 5046.08s]  find where my question
[5046.12s -> 5047.72s]  was because I lost it.
[5048.08s -> 5050.12s]  Um, my question was in
[5050.12s -> 5052.36s]  the, um, so I saw it,
[5052.44s -> 5053.80s]  you are in it is just
[5053.80s -> 5056.00s]  being called once. Is
[5056.00s -> 5058.52s]  that why there's just one
[5058.68s -> 5061.96s]  buffer for all the, um,
[5061.96s -> 5064.12s]  course to share together?
[5064.80s -> 5067.04s]  Uh, well, there's
[5067.04s -> 5067.96s]  always the only one you
[5067.96s -> 5072.92s]  are device, right? You
[5072.92s -> 5074.12s]  know, for the corresponds,
[5074.16s -> 5075.68s]  you know, to the one you
[5075.68s -> 5076.76s]  are device that actually
[5076.76s -> 5077.64s]  is being shared between
[5077.64s -> 5079.80s]  all the course, uh, you
[5079.80s -> 5080.84s]  know, like there might be
[5080.84s -> 5082.28s]  a multiple of processes
[5082.28s -> 5082.92s]  are running on different
[5082.92s -> 5083.72s]  course, all trying to
[5083.72s -> 5084.64s]  print to the console.
[5086.20s -> 5088.08s]  Okay. I see. Oh yeah.
[5088.08s -> 5089.16s]  That makes sense. That
[5089.16s -> 5091.56s]  makes sense. Um, so like
[5091.56s -> 5094.56s]  only one core will do
[5094.56s -> 5096.64s]  stuff with your time.
[5097.20s -> 5098.72s]  Yeah. Well, you know,
[5098.72s -> 5099.84s]  it's a slightly complicated,
[5099.88s -> 5100.96s]  uh, but let's look at
[5100.96s -> 5102.24s]  like, so let's say there's
[5102.24s -> 5104.04s]  multiple guys writing just
[5104.04s -> 5105.44s]  to forward, uh, as one
[5105.44s -> 5109.96s]  experiment. Correct. Uh, and,
[5110.40s -> 5113.12s]  uh, and what we see
[5113.12s -> 5114.64s]  there's multiple, let me
[5114.64s -> 5119.76s]  actually, um, so here's
[5119.76s -> 5120.88s]  you are proceeding. The
[5120.88s -> 5121.76s]  first thing you see is
[5121.76s -> 5122.56s]  actually, it actually
[5122.56s -> 5125.24s]  requires a lock. So multiple
[5125.24s -> 5127.40s]  course are trying to put
[5127.40s -> 5128.44s]  the character into the
[5128.48s -> 5129.88s]  buffer and one of them
[5129.88s -> 5130.84s]  is going to get the lock
[5130.88s -> 5131.60s]  and none of the others
[5131.60s -> 5132.92s]  are getting the lock. And
[5132.92s -> 5134.04s]  so that one guy, you
[5134.04s -> 5134.96s]  know, the one CPU that
[5134.96s -> 5135.72s]  actually got the lock
[5135.72s -> 5136.32s]  required to lock
[5136.32s -> 5138.16s]  successfully, uh, is able
[5138.16s -> 5140.12s]  to, you know, go in and
[5140.12s -> 5141.32s]  look at the right pointer,
[5141.76s -> 5143.16s]  uh, stick a character in
[5143.16s -> 5145.16s]  if possible and otherwise
[5145.16s -> 5147.32s]  go to sleep. And, you
[5147.32s -> 5148.44s]  know, and then if it's
[5148.44s -> 5149.80s]  done, you know, releases
[5149.80s -> 5152.24s]  the lock, um, and then
[5152.24s -> 5154.08s]  the next core can go in
[5154.08s -> 5155.28s]  and acquire the lock
[5155.28s -> 5156.60s]  and do its work. And
[5156.60s -> 5157.52s]  so basically this lock
[5157.52s -> 5159.52s]  will serialize the
[5159.76s -> 5161.84s]  current accesses, uh, to
[5161.84s -> 5162.36s]  the, your work.
[5166.08s -> 5167.36s]  That makes sense. Yeah.
[5167.40s -> 5168.12s]  Thank you.
[5169.68s -> 5170.88s]  And we'll on Wednesday,
[5170.88s -> 5171.68s]  we'll talk in detail
[5171.68s -> 5172.28s]  about locks.
[5174.96s -> 5175.68s]  Thank you.
[5177.80s -> 5179.00s]  Any further questions?
[5180.48s -> 5182.92s]  I have a question. So,
[5182.92s -> 5185.28s]  um, I, as far as I
[5185.28s -> 5186.64s]  understand why we need
[5186.64s -> 5187.68s]  the lock inside the
[5187.68s -> 5189.16s]  interrupt is because we,
[5189.24s -> 5190.52s]  there's only one console
[5190.52s -> 5191.64s]  and they can be multiple
[5191.64s -> 5192.48s]  cores, right?
[5194.68s -> 5195.68s]  Uh, you, you mean the,
[5195.68s -> 5196.76s]  where's this lock for?
[5197.52s -> 5198.96s]  Uh, I think so. Right.
[5199.16s -> 5200.24s]  Cause usually we don't
[5200.24s -> 5201.12s]  want to lock things
[5201.12s -> 5202.32s]  inside interrupts. Right?
[5202.48s -> 5203.80s]  Yeah. Yeah. Yeah. You
[5203.80s -> 5204.44s]  asked this question by
[5204.44s -> 5207.24s]  email. Yeah. Yeah. Yes.
[5207.44s -> 5208.64s]  Well, the issue is
[5208.64s -> 5209.36s]  that the, as I
[5209.36s -> 5210.76s]  mentioned earlier, the
[5210.76s -> 5211.84s]  bottom half or the
[5211.84s -> 5212.60s]  interrupt handler could
[5212.60s -> 5214.76s]  run in parallel with,
[5214.88s -> 5217.36s]  uh, the top half. And
[5217.36s -> 5219.36s]  so, uh, one core you
[5219.36s -> 5220.08s]  could be doing, you
[5220.08s -> 5221.88s]  are put C and another
[5221.88s -> 5222.60s]  core could be you
[5222.60s -> 5223.36s]  running, you are an
[5223.36s -> 5226.04s]  inner and we've got to
[5226.04s -> 5226.64s]  make sure that they
[5226.64s -> 5228.08s]  sort of, uh, don't get
[5228.08s -> 5228.92s]  tangled up together.
[5228.92s -> 5229.32s]  Correct. That they
[5229.32s -> 5230.40s]  serialized correctly in
[5230.40s -> 5231.12s]  the walk basically
[5231.12s -> 5231.88s]  ensures that they get
[5231.88s -> 5232.44s]  serialized.
[5233.16s -> 5234.56s]  Okay. That makes sense.
[5234.92s -> 5236.84s]  But, uh, that, that
[5236.84s -> 5237.44s]  does mean that
[5237.44s -> 5238.72s]  sometimes like all
[5238.72s -> 5240.04s]  cores could potentially
[5240.04s -> 5241.20s]  be waiting for one of
[5241.20s -> 5242.40s]  them to be handling
[5242.40s -> 5243.56s]  this. Right? Yeah.
[5244.84s -> 5246.16s]  Yeah. Cause the
[5246.16s -> 5247.28s]  interrupt has to wait
[5247.28s -> 5247.88s]  and then nothing
[5247.88s -> 5248.76s]  else can get
[5248.76s -> 5249.28s]  scheduled.
[5249.92s -> 5251.24s]  Oh, well, you know,
[5251.24s -> 5251.72s]  presumably there's
[5251.72s -> 5252.28s]  some other process
[5252.28s -> 5252.96s]  maybe running. It's
[5252.96s -> 5254.84s]  unlikely. Uh, there's
[5254.84s -> 5255.84s]  no deadlock, you
[5255.84s -> 5256.36s]  know? Okay. There
[5256.36s -> 5256.92s]  isn't a risk of
[5256.92s -> 5258.52s]  deadlock, but that's
[5258.52s -> 5259.76s]  not this one. Uh,
[5259.76s -> 5260.28s]  that's, we'll talk
[5260.28s -> 5261.68s]  about it Wednesday. Um,
[5262.44s -> 5265.88s]  uh, but, uh, you
[5265.88s -> 5266.80s]  know, the presumably
[5266.80s -> 5267.56s]  what this means, like
[5267.56s -> 5268.20s]  if there's multiple
[5268.20s -> 5270.16s]  guys called, you are
[5270.16s -> 5271.64s]  could see in the
[5271.64s -> 5273.16s]  bufferage fool, then
[5273.16s -> 5274.16s]  some point is interrupt.
[5274.20s -> 5274.92s]  They actually will
[5274.92s -> 5278.36s]  release the lock. Uh,
[5278.40s -> 5279.68s]  so for example, let's
[5279.68s -> 5280.40s]  go back to you are
[5280.40s -> 5281.20s]  could see what
[5281.20s -> 5281.92s]  actually will happen
[5281.92s -> 5283.96s]  correct is that, uh,
[5284.48s -> 5285.60s]  they will call sleep
[5286.40s -> 5287.08s]  and sleep actually
[5287.08s -> 5287.84s]  takes the lock as an
[5287.84s -> 5288.96s]  argument and we'll
[5288.96s -> 5290.68s]  see later why, uh, but
[5290.68s -> 5291.40s]  internally it would
[5291.40s -> 5292.88s]  before sleep actually
[5292.88s -> 5293.56s]  puts the process
[5293.56s -> 5294.32s]  definitely to sleep
[5294.32s -> 5295.00s]  and it will release
[5295.00s -> 5295.48s]  the lock.
[5296.64s -> 5297.44s]  Oh, I see. So
[5297.44s -> 5298.32s]  basically you call
[5298.32s -> 5299.44s]  sleep with the lock
[5299.44s -> 5300.12s]  and then that
[5300.12s -> 5301.12s]  means, okay, release
[5301.12s -> 5301.76s]  the lock while you
[5301.76s -> 5302.72s]  sleep. So someone
[5302.72s -> 5304.80s]  else does. Okay.
[5304.84s -> 5306.88s]  Interesting. Yeah. And
[5306.88s -> 5307.80s]  then when you return
[5307.80s -> 5308.88s]  from sleep, you just
[5308.92s -> 5310.44s]  re acquire it. Okay.
[5310.68s -> 5311.24s]  You get the lock
[5311.24s -> 5313.44s]  back. Right. Right.
[5314.04s -> 5315.16s]  Yeah. That makes
[5315.84s -> 5316.48s]  class to sleep. It
[5316.48s -> 5317.28s]  has a separate story
[5317.28s -> 5317.92s]  that we'll talk about
[5317.92s -> 5318.48s]  in a week or two
[5318.48s -> 5320.08s]  weeks. That makes
[5320.08s -> 5322.80s]  sense. Yeah. Um, so I
[5322.80s -> 5325.96s]  guess, um, so, uh, I
[5325.96s -> 5326.92s]  guess that wasn't that
[5326.92s -> 5328.16s]  clear to me, uh, the
[5328.20s -> 5329.84s]  all CPUs get the
[5329.84s -> 5330.68s]  interrupt when
[5330.68s -> 5331.76s]  somebody like send
[5331.76s -> 5332.48s]  something through. You
[5332.48s -> 5334.88s]  are no, uh, well,
[5334.88s -> 5336.56s]  depends, uh, depends
[5336.56s -> 5337.16s]  on how you program
[5337.16s -> 5339.36s]  the blink. Uh, you
[5339.36s -> 5340.04s]  know, the way you
[5340.04s -> 5340.56s]  actually six is
[5340.56s -> 5341.20s]  programmed to blink.
[5341.20s -> 5342.44s]  Is that only one CPU?
[5342.48s -> 5343.60s]  Well, all CPU, it
[5343.60s -> 5344.48s]  might get interrupted,
[5345.64s -> 5347.00s]  uh, but what is
[5347.00s -> 5348.24s]  going to clean the
[5348.24s -> 5352.32s]  interrupt? Okay. So
[5352.32s -> 5353.00s]  if you go back to
[5353.00s -> 5353.60s]  the plate, you know,
[5353.60s -> 5354.40s]  when you get an
[5354.40s -> 5355.08s]  interrupt, you, you
[5355.08s -> 5356.24s]  call this play claim
[5356.28s -> 5358.72s]  and, uh, that CPU,
[5358.72s -> 5359.60s]  that particular core
[5359.60s -> 5360.32s]  is going to get the,
[5360.36s -> 5362.40s]  uh, uh, is going to
[5362.40s -> 5365.04s]  get the, the IRQ. And
[5365.04s -> 5365.88s]  then basically the
[5365.88s -> 5366.92s]  blink will remember
[5366.92s -> 5367.68s]  that, you know, that
[5367.68s -> 5368.52s]  IRQ is now being
[5368.52s -> 5369.44s]  served and won't give
[5369.44s -> 5370.20s]  it to anybody else.
[5372.40s -> 5373.48s]  I see. Okay. So
[5373.48s -> 5374.08s]  we'll just, one of
[5374.08s -> 5375.08s]  them will get it
[5375.92s -> 5376.92s]  randomly or no?
[5377.68s -> 5380.04s]  Oh, you can program
[5380.04s -> 5380.64s]  the blink. You would
[5380.64s -> 5381.80s]  say, uh, you know,
[5381.84s -> 5383.60s]  maybe prayer. Oh, I
[5383.60s -> 5385.64s]  see. I see. I see.
[5385.64s -> 5387.28s]  So inside the, yeah,
[5387.28s -> 5388.20s]  inside the blink is
[5388.20s -> 5389.08s]  the code that actually
[5389.08s -> 5390.12s]  decides on who to,
[5390.12s -> 5392.52s]  who to bother. Yeah.
[5392.52s -> 5392.88s]  The click of
[5392.88s -> 5393.92s]  circuitry. There's no
[5393.92s -> 5394.60s]  code in the click,
[5394.60s -> 5395.96s]  I think. Oh yeah.
[5396.00s -> 5397.48s]  Right. Okay. Okay. I
[5397.48s -> 5399.48s]  was CPU program. Yeah.
[5399.56s -> 5403.16s]  I was. Yeah. Okay.
[5405.04s -> 5405.68s]  Yeah. I was just
[5405.68s -> 5406.40s]  going to say, where
[5406.40s -> 5407.20s]  does the play code
[5407.20s -> 5408.08s]  run? But yeah, it's
[5408.08s -> 5408.76s]  not code. It's
[5408.76s -> 5409.48s]  hardware. Okay. That
[5409.48s -> 5410.72s]  makes sense. All
[5410.72s -> 5411.76s]  right. Thanks. Uh,
[5411.84s -> 5412.24s]  I'll see you on
[5412.24s -> 5413.24s]  Wednesday. Yep.
[5415.08s -> 5415.96s]  Um, so I got a
[5415.96s -> 5416.76s]  question kind of
[5416.76s -> 5417.96s]  related to the, uh,
[5418.20s -> 5418.92s]  thinking about
[5419.40s -> 5419.96s]  multiple course
[5419.96s -> 5420.48s]  running at the same
[5420.48s -> 5423.24s]  time. Um, so I
[5423.24s -> 5424.24s]  think I recall in
[5424.24s -> 5424.72s]  like one of them,
[5424.72s -> 5426.00s]  the labs with say
[5426.00s -> 5426.80s]  the prime's question,
[5426.80s -> 5427.88s]  we saw that print
[5428.12s -> 5428.92s]  actually like enter
[5428.92s -> 5430.00s]  leaves now, but
[5430.08s -> 5431.32s]  often is that
[5431.32s -> 5433.56s]  because, um, the
[5433.56s -> 5434.76s]  locks are only
[5434.76s -> 5435.84s]  around like the put
[5435.84s -> 5438.24s]  C, but the put C
[5438.24s -> 5439.16s]  calls from multiple
[5439.16s -> 5439.88s]  course could enter
[5439.88s -> 5440.68s]  leave, meaning that
[5440.68s -> 5441.40s]  like a single print
[5441.40s -> 5442.40s]  app is not
[5442.40s -> 5442.92s]  guaranteed to be
[5442.92s -> 5444.36s]  atomic. You got it.
[5444.88s -> 5445.80s]  Okay. That makes
[5445.80s -> 5447.48s]  sense. All right.
[5447.48s -> 5448.36s]  Thank you. You're
[5448.36s -> 5449.96s]  welcome. I
[5449.96s -> 5450.36s]  have a quick
[5450.36s -> 5452.84s]  question. Um, so I
[5452.84s -> 5454.08s]  remember reading in
[5454.08s -> 5455.00s]  the, like the
[5455.00s -> 5455.48s]  reading said
[5455.48s -> 5456.08s]  something about the
[5456.08s -> 5457.24s]  timer interrupts being
[5457.24s -> 5458.36s]  handled in machine
[5458.36s -> 5459.88s]  mode. Um, and I
[5459.88s -> 5461.24s]  was wondering where
[5461.24s -> 5462.44s]  that was, um,
[5462.44s -> 5463.40s]  handled when we
[5463.40s -> 5463.92s]  were doing the
[5463.92s -> 5466.08s]  traps lab, um, like
[5466.08s -> 5466.80s]  where, where the
[5466.80s -> 5467.68s]  switch to machine
[5467.68s -> 5468.64s]  mode was happening
[5468.80s -> 5469.92s]  during the traps lab
[5469.92s -> 5471.48s]  and then what we
[5471.48s -> 5472.84s]  were doing. Yeah.
[5472.84s -> 5473.56s]  Okay. So great
[5473.56s -> 5474.52s]  question. Uh, so,
[5475.24s -> 5478.76s]  the, um, so I'm
[5478.76s -> 5479.60s]  pulling up the code.
[5480.00s -> 5481.00s]  Uh, so if you look
[5481.00s -> 5481.68s]  at your start,
[5481.68s -> 5482.32s]  correct, and this is
[5482.32s -> 5483.00s]  the start runs in
[5483.00s -> 5483.56s]  M-mode at the
[5483.56s -> 5484.72s]  beginning of time when
[5484.72s -> 5486.64s]  the machine boots and
[5486.68s -> 5488.44s]  it, uh, programs the
[5488.44s -> 5490.60s]  timer chip. And so
[5490.84s -> 5492.80s]  your timer in it and
[5492.92s -> 5494.44s]  timer in it basically,
[5494.48s -> 5496.32s]  uh, programs to play
[5496.32s -> 5497.48s]  the clint, which is
[5497.48s -> 5499.64s]  the local interruptor to
[5499.64s -> 5501.68s]  generate interrupts when,
[5501.76s -> 5504.32s]  uh, uh, a clock
[5504.36s -> 5505.20s]  interrupt happens.
[5505.64s -> 5508.08s]  And, um, and
[5508.12s -> 5509.52s]  basically here's
[5509.52s -> 5510.76s]  probably the most
[5510.76s -> 5511.88s]  important function here.
[5512.16s -> 5514.48s]  Uh, it sets the,
[5514.56s -> 5516.20s]  uh, machine mode trap
[5516.20s -> 5516.80s]  handler to this
[5516.80s -> 5517.56s]  function called timer
[5517.56s -> 5518.84s]  vac. So that's written
[5518.84s -> 5521.44s]  assembly. And, uh,
[5521.48s -> 5522.36s]  when a timer interrupt
[5522.36s -> 5523.36s]  happens, that function
[5523.36s -> 5525.36s]  is being called. And
[5525.36s -> 5526.44s]  so when you're a
[5526.44s -> 5527.36s]  kernel running user
[5527.36s -> 5528.80s]  mode or in supervisor
[5528.80s -> 5531.80s]  mode and the clint
[5531.84s -> 5532.92s]  generates an interrupt,
[5533.00s -> 5535.28s]  raises the line and,
[5535.32s -> 5537.40s]  uh, it will switch to
[5537.40s -> 5538.52s]  machine mode and call
[5538.52s -> 5539.16s]  this function time
[5539.16s -> 5540.88s]  effect in the same way,
[5540.88s -> 5543.12s]  basically as, uh, almost
[5543.12s -> 5544.08s]  equivalent to what we've
[5544.08s -> 5545.24s]  seen for supervisor mode
[5545.24s -> 5546.60s]  and user mode. Okay.
[5547.04s -> 5548.76s]  Sure. And then if you
[5548.76s -> 5551.20s]  look in, uh, kernel
[5551.20s -> 5553.72s]  vac dot S, uh, we
[5553.72s -> 5554.52s]  looked at kernel vac a
[5554.52s -> 5555.36s]  lot, right? I mean,
[5555.36s -> 5556.00s]  that's that function
[5556.00s -> 5556.44s]  that's safe and
[5556.44s -> 5557.80s]  stores a lot. And
[5557.80s -> 5559.80s]  here's timer vac. It's
[5559.84s -> 5560.96s]  basically the same sort
[5560.96s -> 5562.36s]  of type of idea. Let's
[5562.36s -> 5562.92s]  say it's a couple
[5562.92s -> 5563.88s]  register. So they could
[5563.88s -> 5565.68s]  do a job and the only
[5565.68s -> 5566.80s]  job it does is actually
[5566.80s -> 5567.76s]  these sort of six lines
[5567.76s -> 5570.00s]  of code here, uh, or
[5570.00s -> 5571.72s]  whatever, five, seven
[5571.72s -> 5573.16s]  lines of code. Uh, and
[5573.16s -> 5573.88s]  basically what it does,
[5573.88s -> 5575.40s]  you know, reprograms the
[5575.40s -> 5576.44s]  claims to generate
[5576.44s -> 5577.80s]  future interrupts and
[5577.80s -> 5578.96s]  then basically raises a
[5578.96s -> 5580.84s]  software interrupt, uh,
[5580.84s -> 5582.68s]  to the supervisor. Uh,
[5582.72s -> 5583.40s]  so that's goes to
[5583.40s -> 5585.48s]  supervisor mode. Okay.
[5585.52s -> 5587.68s]  So then at the point
[5588.08s -> 5590.24s]  at M-red M-red, so
[5590.24s -> 5590.88s]  let's say the kernel
[5590.88s -> 5591.88s]  was interrupted, you know,
[5591.92s -> 5592.56s]  during the time of
[5592.56s -> 5593.64s]  chip, during the time of
[5593.64s -> 5594.36s]  chip. So it went to
[5594.36s -> 5595.88s]  machine mode and red
[5595.88s -> 5596.56s]  then returns from
[5596.56s -> 5597.56s]  machine mode back to
[5597.56s -> 5598.80s]  supervisor mode. Right.
[5599.64s -> 5601.24s]  And if the interrupt
[5601.24s -> 5602.04s]  was enabled in
[5602.04s -> 5603.40s]  supervisor mode, at that
[5603.40s -> 5604.36s]  point, immediately that
[5604.40s -> 5605.44s]  supervisor in the
[5605.44s -> 5606.28s]  supervisor software
[5606.28s -> 5607.16s]  interrupt will be
[5607.20s -> 5609.68s]  generated. Oh, okay.
[5609.88s -> 5611.48s]  And now basically the
[5611.48s -> 5612.16s]  kernel will do the same
[5612.16s -> 5613.00s]  thing. Great. Basically
[5613.00s -> 5613.72s]  we'll go to kernel
[5613.72s -> 5615.04s]  vac, you know, save,
[5615.04s -> 5615.60s]  restore all the
[5615.60s -> 5618.76s]  registers, uh, and, uh,
[5618.80s -> 5620.20s]  and then go to, uh,
[5620.20s -> 5621.76s]  kernel trap and the
[5621.76s -> 5622.56s]  kernel trap will see,
[5622.56s -> 5623.48s]  ha, that was a
[5623.48s -> 5624.08s]  timing interrupt.
[5625.00s -> 5626.40s]  I see. And so what
[5626.40s -> 5627.16s]  was the point of
[5627.16s -> 5628.04s]  switching to machine
[5628.04s -> 5628.72s]  mode in the first
[5628.72s -> 5630.12s]  place? Like what
[5630.12s -> 5631.04s]  exactly does it do?
[5633.16s -> 5633.64s]  I don't know what
[5633.64s -> 5634.72s]  the point is, but this
[5634.72s -> 5635.56s]  is like the hardware
[5635.56s -> 5638.08s]  works. Okay. Gotcha.
[5638.68s -> 5641.08s]  I actually do a little
[5641.08s -> 5641.60s]  bit to where, you
[5641.60s -> 5644.32s]  know, uh, there's some
[5644.32s -> 5645.24s]  reasons I think why,
[5645.28s -> 5646.44s]  you know, the, the
[5646.44s -> 5647.04s]  time of chip actually
[5647.04s -> 5648.36s]  goes to, uh, machine
[5648.36s -> 5649.84s]  mode. But, uh, from
[5649.84s -> 5651.24s]  our perspective, you
[5651.24s -> 5652.20s]  know, we'd be great if
[5652.20s -> 5652.80s]  we could have
[5652.80s -> 5653.96s]  delegated the timer
[5653.96s -> 5655.00s]  interrupt straight to
[5655.00s -> 5655.88s]  supervisor mode and
[5655.88s -> 5656.84s]  never had to deal with,
[5656.88s -> 5658.28s]  uh, timer mode, but
[5658.28s -> 5659.76s]  you know, that doesn't
[5659.76s -> 5661.20s]  work for this
[5661.36s -> 5662.96s]  particular chip. Okay.
[5663.20s -> 5664.00s]  That makes sense. Thank
[5664.00s -> 5664.64s]  you so much.
[5665.00s -> 5665.48s]  You're welcome.
[5667.00s -> 5667.84s]  Oh, I actually have a
[5667.84s -> 5669.96s]  follow up on, um, this
[5670.36s -> 5672.04s]  part of the code. Um,
[5672.16s -> 5676.96s]  so yeah. Um, I saw
[5677.28s -> 5680.60s]  it allocates 32, um,
[5681.12s -> 5683.16s]  you went 64, but it
[5683.16s -> 5683.92s]  only seems to be
[5683.92s -> 5686.56s]  using four, no, three
[5686.56s -> 5689.96s]  of them. Right. In
[5689.96s -> 5691.88s]  start does see it
[5693.04s -> 5693.88s]  scratch. Yeah. I
[5693.88s -> 5695.04s]  guess it allocates
[5695.08s -> 5695.80s]  more than is
[5695.80s -> 5698.52s]  necessary. Uh, scratch
[5698.52s -> 5700.68s]  is 32, uh, scratch
[5700.68s -> 5702.40s]  area. Ah, the
[5702.40s -> 5705.76s]  reason, uh, so, uh,
[5707.20s -> 5708.36s]  uh, so for every
[5708.36s -> 5709.96s]  CPU, correct. Uh,
[5710.00s -> 5710.68s]  there has to be some
[5710.68s -> 5712.40s]  scratch space. Uh,
[5712.44s -> 5713.92s]  there, I guess we
[5713.92s -> 5714.96s]  have three or
[5714.96s -> 5715.68s]  something like that
[5715.72s -> 5717.04s]  CPU. So basically
[5717.04s -> 5717.68s]  allocates a little bit
[5717.68s -> 5726.20s]  too much. Uh, but
[5726.20s -> 5727.12s]  there's no harm in
[5727.12s -> 5728.36s]  just allocating too
[5728.36s -> 5731.08s]  much. Okay. Okay.
[5731.08s -> 5731.80s]  It's like it only
[5731.80s -> 5733.40s]  uses scratch zero
[5733.40s -> 5734.40s]  scratch one, scratch
[5734.40s -> 5736.84s]  zero, four. So it
[5736.84s -> 5737.92s]  uses three. Okay.
[5737.92s -> 5739.32s]  So, uh, zero to
[5739.32s -> 5740.36s]  three, that's four,
[5740.68s -> 5741.84s]  four, five, correct.
[5741.84s -> 5744.68s]  So six, uh, six
[5744.68s -> 5747.68s]  integers. Uh, and,
[5747.92s -> 5749.00s]  uh, I guess we
[5749.00s -> 5749.48s]  have, we were
[5749.48s -> 5750.24s]  running, we could
[5750.24s -> 5750.80s]  run with four
[5750.80s -> 5751.60s]  CPUs, but we're
[5751.60s -> 5752.32s]  running with three,
[5752.32s -> 5753.00s]  but we could run
[5753.00s -> 5755.76s]  with four. Uh, so
[5755.76s -> 5756.44s]  six times four is
[5756.44s -> 5758.76s]  24. I guess, you
[5758.76s -> 5759.40s]  definitely allocating
[5759.40s -> 5760.32s]  a bit too much memory.
[5761.80s -> 5762.32s]  I don't remember.
[5762.32s -> 5763.08s]  I thought about this
[5763.08s -> 5763.84s]  a while back ago
[5763.84s -> 5764.96s]  and, uh, I don't
[5764.96s -> 5765.84s]  remember exactly
[5765.84s -> 5770.88s]  where the, uh, 32
[5770.92s -> 5773.16s]  came from. So
[5773.16s -> 5774.04s]  maybe, let me
[5774.04s -> 5776.56s]  double check. See
[5776.56s -> 5777.48s]  if I can reconstruct
[5777.48s -> 5778.16s]  that.
[5807.48s -> 5812.48s]  Oh, and the same resource, they're all four,
[5814.52s -> 5816.20s]  they're all eight bytes, correct?
[5817.32s -> 5818.16s]  Yeah.
[5831.32s -> 5832.84s]  Okay, let me get back to you.
[5832.84s -> 5835.92s]  I can recall right at the top of my head,
[5835.92s -> 5837.12s]  why it is the way it is.
[5838.20s -> 5840.48s]  Okay, makes sense.
[5840.48s -> 5841.84s]  Thank you so much.
[5841.84s -> 5843.76s]  You're welcome, good questions.
[5843.76s -> 5844.60s]  Thank you.
