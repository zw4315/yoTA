# Detected language: en (p=1.00)

[0.00s -> 12.48s]  Can anybody, people hear what I'm saying or?
[12.48s -> 13.48s]  You're good.
[13.48s -> 14.48s]  Awesome.
[14.48s -> 21.54s]  So I just want to get started with similar to last week where we asked you about the
[21.54s -> 22.54s]  util lab.
[22.54s -> 24.94s]  I just want to get started by asking a little bit about syscall lab since that
[24.94s -> 28.52s]  was due on Thursday.
[28.52s -> 33.52s]  So if anybody just has like something particularly interesting they found about the lab or a nasty
[33.52s -> 37.78s]  bug that they found or just a silly mistake they made, anything you want to share about
[37.78s -> 42.18s]  the syscall lab, that'd be great.
[42.18s -> 48.60s]  I somehow managed to delete the part from where, from fork where you have to copy over
[48.60s -> 49.60s]  the mask.
[49.60s -> 52.52s]  So I had that working and then I changed something else and then I tested it.
[52.52s -> 55.64s]  Sorry, I don't know if your audio is like cutting out, I think.
[55.64s -> 56.64s]  Oh, it is.
[56.64s -> 57.64s]  Sorry.
[57.76s -> 61.88s]  You hear me?
[61.88s -> 62.88s]  I hear you.
[62.88s -> 63.88s]  Oh, okay.
[63.88s -> 67.60s]  Yeah, I guess.
[67.60s -> 75.00s]  So basically I deleted somehow the copy of the mask and then my fork didn't work anymore.
[75.00s -> 78.24s]  So then I was just like, I did that, how does it not work?
[78.24s -> 83.16s]  So I spent a lot of time figuring out what I did wrong and I realized I just deleted
[83.16s -> 86.68s]  that line from that.
[86.72s -> 89.32s]  Is anybody having trouble hearing Luca or is that on my end?
[89.32s -> 91.32s]  I think it's on your end.
[91.32s -> 94.32s]  Yeah, I hear him fine.
[94.32s -> 97.32s]  This must be on my end.
[116.68s -> 126.64s]  All right, maybe that'll work better now.
[126.64s -> 127.64s]  Can you hear me now?
[127.64s -> 128.64s]  Yes.
[128.64s -> 129.64s]  Perfect.
[129.64s -> 130.64s]  Okay, great.
[130.64s -> 132.64s]  I was worried that I was just talking to you.
[132.64s -> 133.64s]  No, no, no.
[133.64s -> 135.64s]  It seems to be on my end.
[135.64s -> 136.64s]  All right.
[136.64s -> 137.64s]  Awesome.
[138.60s -> 139.60s]  Awesome.
[139.60s -> 148.24s]  Well, anybody else have anything they'd like to share about you or a syscall?
[148.24s -> 152.84s]  Anything particularly interesting or was the lab absolutely horrendous and you think
[152.84s -> 155.16s]  we should cut it out of the class?
[155.16s -> 157.16s]  Never do it again.
[157.16s -> 159.16s]  I have something.
[159.16s -> 165.20s]  Apparently the order of things matters, which is a general statement.
[165.20s -> 173.84s]  So I tried to determine the mass computation inside the syscall function before determining
[173.84s -> 177.00s]  whether I actually needed to do the tracing.
[177.00s -> 183.40s]  And so all the syscalls were getting correctly traced except the trace call.
[183.40s -> 188.24s]  And I was really getting disturbed by that until I think it was David who pointed out,
[188.24s -> 191.76s]  you know, you should do the computation after you shouldn't trace.
[192.32s -> 194.32s]  He's like, ah, that's fine.
[194.32s -> 196.32s]  All right.
[196.32s -> 199.32s]  I'm glad you were able to catch that.
[199.32s -> 202.32s]  Yeah, order does matter, especially for page tables.
[202.32s -> 205.32s]  You'll find I think that order matters there as well.
[205.32s -> 211.32s]  And generally throughout the class, paying attention to the order of things will be important.
[211.32s -> 215.32s]  It's good to not overwrite things in page table.
[215.32s -> 220.32s]  I also had something which I'm actually still confused about.
[220.88s -> 226.88s]  Well, I had a lot of debugging print statements in the kernel code.
[226.88s -> 231.88s]  I then ran the trace thing with all of the bits set.
[231.88s -> 235.88s]  So basically tracing all the system calls.
[235.88s -> 243.88s]  And I think I saw a lot of tracing for the print statements in the kernel.
[244.44s -> 253.44s]  And then I assumed that my print Fs were trying to read and write to the console,
[253.44s -> 258.44s]  but then I was wondering why are we,
[258.44s -> 263.44s]  I guess I'm just confused why we're able to use print F in the kernel.
[266.44s -> 270.44s]  Yeah, I haven't looked at the print F code recently,
[271.00s -> 275.00s]  but I think there's a file print F dot C that you might be able to look at
[275.00s -> 280.00s]  if you want to figure out what was going on there.
[280.00s -> 285.00s]  So I think the print F function should be implemented in there,
[285.00s -> 287.00s]  at least our version of it.
[287.00s -> 289.00s]  I don't know, perhaps one of the,
[289.00s -> 294.00s]  one of some of the other core staff might know what's going on.
[294.00s -> 298.00s]  The print Fs in the kernel shouldn't show up as in your traces
[298.56s -> 301.56s]  print F in the kernel doesn't call any system calls.
[301.56s -> 303.56s]  Yeah, that's what I thought.
[303.56s -> 308.56s]  Maybe the tracing was not from that.
[308.56s -> 311.56s]  Yeah, I don't think it is from your print Fs in the kernel.
[311.56s -> 313.56s]  Okay.
[316.56s -> 322.56s]  Okay, well, unless anybody has any other burning comments about syscall,
[322.56s -> 327.56s]  I think we can get started with lecture for today.
[328.12s -> 335.12s]  We're talking a little bit about the process of converting C to assembly
[335.12s -> 339.12s]  and processors, and this is more of a kind of a practical lecture today,
[339.12s -> 341.12s]  or at least that's the aim.
[341.12s -> 347.12s]  So the goal here is to get you all familiarized with RISC-V,
[347.12s -> 353.12s]  the processor, the assembly language, and the calling conventions for RISC-V.
[353.12s -> 357.12s]  And this will be important in, not super important for a page table,
[357.68s -> 361.68s]  but certainly for the traps lab, which will be assigned later this week,
[361.68s -> 365.68s]  this will be essential for debugging and implementing things
[365.68s -> 369.68s]  because you'll be working quite intimately with trap frames and the stack
[369.68s -> 371.68s]  and things like that.
[371.68s -> 373.68s]  So that's kind of the goal for today,
[373.68s -> 378.68s]  and my first aim was to, and this might be a little bit of review
[378.68s -> 383.68s]  from 6.004 or any other computer architecture theme classes
[383.68s -> 385.68s]  that you may have taken in the past,
[386.24s -> 391.24s]  but I just want to go over briefly kind of C, the C language,
[391.24s -> 396.24s]  how we get to assembly, and maybe a little bit about processors.
[396.24s -> 400.24s]  So throughout, and then of course throughout this lecture,
[400.24s -> 404.24s]  feel free to interrupt with any questions that you have.
[404.24s -> 409.24s]  So, you know, we have our normal main functions in C,
[409.24s -> 414.24s]  you know, they do something, maybe they print something,
[414.80s -> 415.80s]  then they exit,
[417.80s -> 419.80s]  and this all looks well and good,
[419.80s -> 422.80s]  but as any of you are aware from 6.004,
[422.80s -> 426.80s]  processors don't actually understand the C language,
[426.80s -> 429.80s]  rather they understand what we call assembly,
[429.80s -> 433.80s]  or more specifically, they understand the binary encodings of assembly.
[433.80s -> 438.80s]  And so this here, I've circled a picture of an actual RISC-V processor
[438.80s -> 440.80s]  from a Sci-V board,
[440.80s -> 443.80s]  and when we say a processor is RISC-V,
[444.36s -> 448.36s]  that means that it understands the RISC-V instruction set.
[448.36s -> 454.36s]  So every processor has an associated ISA or instruction,
[454.36s -> 457.36s]  and that's kind of the set of instructions
[457.36s -> 460.36s]  that make sense to that processor.
[460.36s -> 465.36s]  So every instruction has an associated binary encoding or an opcode,
[465.36s -> 470.36s]  and when a processor is running and it sees a particular encoding,
[470.36s -> 472.36s]  it knows what to do.
[472.92s -> 475.92s]  And so, you know, this processor on this board
[475.92s -> 479.92s]  happens to understand the RISC-V assembly,
[479.92s -> 482.92s]  which is what C code is compiled to.
[482.92s -> 487.92s]  So the general process of getting C code to actually run on your processor
[487.92s -> 490.92s]  is we start with C, it gets compiled to assembly,
[490.92s -> 492.92s]  and there's some linking and things like that
[492.92s -> 496.92s]  that happen between the step, but we're not a compilers class,
[496.92s -> 501.92s]  and then the assembly will then be translated into binary.
[502.48s -> 509.48s]  And so this is the object or .o files that you see.
[509.48s -> 515.48s]  So if you've ever paid attention to what's inside of your lab directory
[515.48s -> 517.48s]  after you run makeqmu,
[517.48s -> 520.48s]  you'll see a bunch of .o files lying around,
[520.48s -> 524.48s]  and those are the actual object files that the processor understands.
[524.48s -> 527.48s]  And the ASM files you've also seen,
[527.48s -> 529.48s]  you haven't really written any,
[530.04s -> 536.04s]  if you recall from syscall, usys.pl is compiled to a file called usys.s,
[536.04s -> 540.04s]  and so .s files are assembly language.
[540.04s -> 543.04s]  And so you've seen, you've certainly seen some RISC-V assembly,
[543.04s -> 546.04s]  and if you took 004, I believe you've also seen
[546.04s -> 549.04s]  a good amount of assembly language.
[549.04s -> 554.04s]  And assembly looks, in general, much less structured than C,
[554.04s -> 558.04s]  so you'll just see lines after line after line of instructions,
[558.60s -> 563.60s]  you'll see simple things like add, malt, etc.,
[563.60s -> 565.60s]  and so on and so forth.
[565.60s -> 569.60s]  And this doesn't have, there's no nice control flow,
[569.60s -> 571.60s]  there's no loops, there are functions,
[571.60s -> 574.60s]  but not in the sense that you might know from C.
[574.60s -> 579.60s]  We see labels as opposed to true function definitions.
[579.60s -> 582.60s]  And then assembly, so it's a much lower language,
[582.60s -> 585.60s]  and there are plenty of other languages that are also compiled to assembly.
[586.16s -> 591.16s]  So the same process holds true for things like C++,
[593.16s -> 595.16s]  you know, any language that's compiled
[595.16s -> 599.16s]  will go to the same assembly language at the base.
[600.16s -> 604.16s]  And so that's kind of the basic process
[604.16s -> 608.16s]  of getting our computer to actually understand
[608.16s -> 610.16s]  the C code that we're writing,
[610.16s -> 614.16s]  but you'll notice that we've been referring to
[614.72s -> 618.72s]  a RISC-V assembly throughout the course,
[618.72s -> 620.72s]  and the processor is RISC-V,
[620.72s -> 622.72s]  and that's because it's important
[622.72s -> 624.72s]  because there's many different kinds of assembly.
[624.72s -> 629.72s]  So it's unlikely that you're using RISC-V yourself,
[629.72s -> 632.72s]  like you're not going to be running Linux on it.
[632.72s -> 637.72s]  Instead, most modern computers will run on what's called x86,
[637.72s -> 641.72s]  or you'll sometimes see it as x86-64.
[642.28s -> 644.28s]  And this is a different ISA.
[644.28s -> 646.28s]  This is a different instruction set.
[646.28s -> 648.28s]  It looks pretty similar to RISC-V,
[648.28s -> 652.28s]  but this is what you see in kind of your personal computers often.
[655.28s -> 658.28s]  So if you use an Intel,
[658.28s -> 662.28s]  so Intel CPUs implement x86,
[662.28s -> 665.28s]  and I believe AMD also do.
[666.28s -> 671.28s]  And this is a relatively important distinction between the two.
[671.84s -> 675.84s]  They're not quite as similar as they may look at first,
[675.84s -> 677.84s]  and that comes down to the fact
[677.84s -> 679.84s]  that RISC-V is what we call,
[679.84s -> 682.84s]  so RISC, the RISC part of RISC-V
[682.84s -> 686.84s]  refers to a reduced instruction set.
[686.84s -> 691.84s]  And x86-64 is what's called a CISC,
[691.84s -> 694.84s]  or a complex instruction set.
[695.40s -> 702.40s]  And there's a couple of key differences here.
[702.40s -> 704.40s]  One is just the number of instructions
[704.40s -> 706.40s]  that are present in x86-64.
[706.40s -> 708.40s]  In fact, one of the big motivations
[708.40s -> 713.40s]  for writing, for making RISC-V
[713.40s -> 718.40s]  was how many instructions we actually have
[718.40s -> 721.40s]  in the Intel kind of handbook.
[721.40s -> 724.40s]  So for reference, there's three full books
[724.96s -> 729.96s]  that encompass the ISA and some statistics.
[729.96s -> 733.96s]  I think there's new instructions have been added
[733.96s -> 740.96s]  at a rate of three instructions per month
[741.96s -> 744.96s]  since x86-64 was added,
[744.96s -> 747.96s]  it was first published in the 70s.
[747.96s -> 752.96s]  So I believe there's like north of 15,000 instructions.
[754.96s -> 759.96s]  In x86-64 and RISC-V on the other hand,
[760.96s -> 762.96s]  the assembly for RISC-V can be nicely contained
[762.96s -> 764.96s]  within two documents.
[764.96s -> 767.96s]  And so kind of going off of that,
[767.96s -> 769.96s]  we don't expect you in this course
[769.96s -> 773.96s]  to memorize every single RISC-V instruction.
[773.96s -> 775.96s]  But if you are interested
[775.96s -> 777.96s]  or you ever find yourself confused
[777.96s -> 780.96s]  by what a specific instruction is or does,
[780.96s -> 782.96s]  if you go to the course website
[783.52s -> 786.52s]  and we look under the references tab,
[786.52s -> 788.52s]  under RISC-V, we give you the links
[788.52s -> 790.52s]  to both the privileged
[790.52s -> 793.52s]  and unprivileged instruction sets.
[793.52s -> 795.52s]  So this is kind of the document
[795.52s -> 798.52s]  that gives you a whole bunch of information
[798.52s -> 800.52s]  about the ISA,
[800.52s -> 803.52s]  but you'll note that like this is 240 pages
[803.52s -> 806.52s]  and this is 135 pages.
[806.52s -> 808.52s]  So it's significantly, significantly smaller
[808.52s -> 811.52s]  than the x86 instruction set.
[812.08s -> 814.08s]  And that's one of the nice things
[814.08s -> 817.08s]  about RISC-V.
[817.08s -> 819.08s]  So we have,
[819.08s -> 823.08s]  in RISC-V we have fewer instructions
[823.08s -> 825.08s]  and not only that,
[825.08s -> 828.08s]  the instructions are simpler.
[828.08s -> 832.08s]  So what I mean by that is that
[832.08s -> 834.08s]  there are many instructions
[834.08s -> 836.08s]  in x86-64,
[836.08s -> 838.08s]  by instruction I'm referring to something
[838.08s -> 840.08s]  like AT or MULT or SUB.
[840.64s -> 842.64s]  In x86-64 there's plenty of instructions
[842.64s -> 844.64s]  that do more than one thing.
[844.64s -> 846.64s]  So they perform some complicated
[846.64s -> 848.64s]  set of operations
[848.64s -> 850.64s]  and then get you the result
[850.64s -> 852.64s]  and that's not the case
[852.64s -> 854.64s]  with RISC-V. RISC-V instructions
[854.64s -> 856.64s]  tend to be smaller in scope
[856.64s -> 858.64s]  and so they take less cycles
[858.64s -> 860.64s]  to run each instruction
[860.64s -> 862.64s]  than maybe x86-64 is
[862.64s -> 864.64s]  and this is just a trade-off that the designers
[864.64s -> 866.64s]  chose to undertake.
[866.64s -> 868.64s]  There's nothing,
[869.20s -> 871.20s]  there's no
[871.20s -> 873.20s]  canonical reason
[873.20s -> 875.20s]  why a reduced instruction set
[875.20s -> 877.20s]  is better than
[877.20s -> 879.20s]  a complex instruction set.
[879.20s -> 881.20s]  They each have their own uses
[881.20s -> 883.20s]  and so on and so forth.
[883.20s -> 885.20s]  And another cool thing
[885.20s -> 887.20s]  about RISC-V as opposed to
[887.20s -> 889.20s]  x86 is that
[889.20s -> 891.20s]  this is open source.
[891.20s -> 893.20s]  So it's one of the
[893.20s -> 895.20s]  only open source
[895.20s -> 897.20s]  instruction sets on the market
[897.76s -> 899.76s]  so that means anybody can develop a board
[899.76s -> 901.76s]  for RISC-V
[901.76s -> 903.76s]  and it came out of a research project
[903.76s -> 905.76s]  from UC Berkeley
[905.76s -> 907.76s]  and so that's kind of where RISC-V started
[907.76s -> 909.76s]  and since then it's been picked up and supported
[909.76s -> 911.76s]  by a number of companies.
[911.76s -> 913.76s]  You can find the list online
[913.76s -> 915.76s]  but there's tons of big companies that are interested
[915.76s -> 917.76s]  in supporting an open instruction set.
[917.76s -> 919.76s]  And actually
[919.76s -> 921.76s]  I think quite recently there was an announcement
[921.76s -> 923.76s]  made by Sci-5
[923.76s -> 925.76s]  who are sort of
[926.32s -> 928.32s]  a premier board manufacturer for RISC-V processors
[928.32s -> 930.32s]  that they will be
[930.32s -> 932.32s]  releasing a
[932.32s -> 934.32s]  board for personal computers
[934.32s -> 936.32s]  that should ostensibly, you know,
[936.32s -> 938.32s]  a RISC-V processor designed to run Linux
[938.32s -> 940.32s]  for personal computers.
[940.32s -> 942.32s]  And I think that's been released in the last
[942.32s -> 944.32s]  week or two, the announcement about it.
[944.32s -> 946.32s]  So if you're curious,
[946.32s -> 948.32s]  if you find yourself, you know,
[948.32s -> 950.32s]  absolutely I want to use RISC-V after
[950.32s -> 952.32s]  I finish success081.
[952.32s -> 954.32s]  Hopefully by that time there will be a
[954.88s -> 956.88s]  processor available that you can run Linux on
[956.88s -> 958.88s]  on your own computer.
[958.88s -> 960.88s]  But even in your day-to-day lives
[960.88s -> 962.88s]  you're most likely using reduced
[962.88s -> 964.88s]  instruction sets even if you don't realize it.
[964.88s -> 966.88s]  So the
[966.88s -> 968.88s]  ARM assembly, so
[968.88s -> 970.88s]  that's ARM
[970.88s -> 972.88s]  this is also a reduced
[972.88s -> 974.88s]  instruction set.
[974.88s -> 976.88s]  And ARM is
[976.88s -> 978.88s]  implemented by Qualcomm
[978.88s -> 980.88s]  the Snapdragon
[980.88s -> 982.88s]  series of processors.
[983.44s -> 985.44s]  So if you have an Android phone
[985.44s -> 987.44s]  you are
[987.44s -> 989.44s]  most likely
[989.44s -> 991.44s]  running a reduced
[991.44s -> 993.44s]  instruction set.
[993.44s -> 995.44s]  And even if you're using iOS
[995.44s -> 997.44s]  I think
[997.44s -> 999.44s]  I forget what the name of it is
[999.44s -> 1001.44s]  but Apple has some
[1001.44s -> 1003.44s]  version of
[1003.44s -> 1005.44s]  ARM that they also implement in their
[1005.44s -> 1007.44s]  own processors that runs on
[1007.44s -> 1009.44s]  iPads, iPhones
[1009.44s -> 1011.44s]  and most mobile Apple devices.
[1012.00s -> 1014.00s]  So reduced instruction sets are present
[1014.00s -> 1016.00s]  all over the place and if you're looking for
[1016.00s -> 1018.00s]  RISC-V in the real world
[1018.00s -> 1020.00s]  outside of your
[1020.00s -> 1022.00s]  QEMU
[1022.00s -> 1024.00s]  you'll be able to find that in
[1024.00s -> 1026.00s]  like integrated
[1026.00s -> 1028.00s]  devices.
[1028.00s -> 1030.00s]  So it is present, it's not as
[1030.00s -> 1032.00s]  it's certainly not as ubiquitous as
[1032.00s -> 1034.00s]  something like x86-64
[1034.00s -> 1036.00s]  but it's
[1036.00s -> 1038.00s]  yes, I think Apple is
[1038.00s -> 1040.00s]  as Luca just said in the chat
[1040.56s -> 1042.56s]  moving Macs to ARM
[1042.56s -> 1044.56s]  I believe that's also the case.
[1044.56s -> 1046.56s]  There's been in the last few years, there's definitely been a push
[1046.56s -> 1048.56s]  towards reduced instruction sets
[1048.56s -> 1050.56s]  given
[1050.56s -> 1052.56s]  how big the Intel ISA has gotten.
[1052.56s -> 1054.56s]  And the reason why Intel's ISA
[1054.56s -> 1056.56s]  is so big is because they're
[1056.56s -> 1058.56s]  very concerned with backwards compatibility
[1058.56s -> 1060.56s]  so if you write
[1060.56s -> 1062.56s]  a modern Intel processor
[1062.56s -> 1064.56s]  can run the same instructions
[1064.56s -> 1066.56s]  that Intel code from
[1066.56s -> 1068.56s]  30, 40 years ago
[1069.12s -> 1071.12s]  was written in. So they don't really deprecate
[1071.12s -> 1073.12s]  any instructions so that they maintain
[1073.12s -> 1075.12s]  backwards compatibility. And RISC-V is more
[1075.12s -> 1077.12s]  modern, so that's not a worry.
[1077.12s -> 1079.12s]  RISC-V is also, so if we
[1079.12s -> 1081.12s]  jump back to those manuals
[1081.12s -> 1083.12s]  RISC-V is unique in that it's
[1083.12s -> 1085.12s]  divided, we have
[1085.12s -> 1087.12s]  what's called the base integer instructions set
[1087.12s -> 1089.12s]  which all RISC-V processors
[1089.12s -> 1091.12s]  if we have
[1091.12s -> 1093.12s]  so Gabriel asks in the chat
[1093.12s -> 1095.12s]  if we have 15,000 instructions
[1095.12s -> 1097.12s]  is it nearly impossible to efficiently pipeline them
[1097.68s -> 1099.68s]  why do we need so many? Like I was saying
[1099.68s -> 1101.68s]  we need so many for backwards compatibility
[1101.68s -> 1103.68s]  reasons. It's up to you to decide
[1103.68s -> 1105.68s]  whether you think that that's super
[1105.68s -> 1107.68s]  important but many of those instructions
[1107.68s -> 1109.68s]  I think a ton of them are also
[1109.68s -> 1111.68s]  eaten up by SIMD instructions
[1111.68s -> 1113.68s]  which are their own kind of special
[1113.68s -> 1115.68s]  class of things.
[1115.68s -> 1117.68s]  You won't
[1117.68s -> 1119.68s]  I've never seen Intel assembly code that makes
[1119.68s -> 1121.68s]  full usage out of the
[1121.68s -> 1123.68s]  15,000 instructions. But mostly this comes
[1123.68s -> 1125.68s]  from a need for backwards compatibility
[1126.24s -> 1128.24s]  and SIMD. Like I was saying
[1128.24s -> 1130.24s]  so RISC-V has what's called
[1130.24s -> 1132.24s]  the base integer instruction set
[1132.24s -> 1134.24s]  which contains
[1134.24s -> 1136.24s]  all of the normal
[1136.24s -> 1138.24s]  add and multiply things
[1138.24s -> 1140.24s]  and then processors can choose
[1140.24s -> 1142.24s]  to implement a number of other modules
[1142.24s -> 1144.24s]  which you can see along the side here
[1144.24s -> 1146.24s]  it's probably impossible to read on your
[1146.24s -> 1148.24s]  screen but for example if you want
[1148.24s -> 1150.24s]  a processor that supports
[1150.24s -> 1152.24s]  standard extension for single precision floating
[1152.24s -> 1154.24s]  point then you can include the
[1154.80s -> 1156.80s]  RISC-V module and this makes it easier
[1156.80s -> 1158.80s]  for RISC-V to support
[1158.80s -> 1160.80s]  backwards compatibility because
[1160.80s -> 1162.80s]  if you can just say
[1162.80s -> 1164.80s]  what set of the modules do I include
[1164.80s -> 1166.80s]  and support and the compiler
[1166.80s -> 1168.80s]  can choose then
[1168.80s -> 1170.80s]  the compiler can say okay
[1170.80s -> 1172.80s]  this processor is telling me it supports
[1172.80s -> 1174.80s]  these modules so I can only compile this code
[1174.80s -> 1176.80s]  with these modules.
[1176.80s -> 1178.80s]  Okay, Bibek says
[1178.80s -> 1180.80s]  it seems that the only advantage of using
[1180.80s -> 1182.80s]  x86 instead of RISC-V processor
[1183.36s -> 1185.36s]  is the kind of performance you can get
[1185.36s -> 1187.36s]  however that performance comes as a massive cost
[1187.36s -> 1189.36s]  and complexity and potential security
[1189.36s -> 1191.36s]  my question is why are we still using x86
[1191.36s -> 1193.36s]  instead of moving to something like RISC-V?
[1193.36s -> 1195.36s]  Alright, well
[1195.36s -> 1197.36s]  the big answer to that is the world has run
[1197.36s -> 1199.36s]  on x86 for
[1199.36s -> 1201.36s]  I don't have a great answer for why
[1201.36s -> 1203.36s]  RISC-V is pretty modern too
[1203.36s -> 1205.36s]  so
[1205.36s -> 1207.36s]  the world as a whole pretty much
[1207.36s -> 1209.36s]  runs on x86
[1209.36s -> 1211.36s]  so if you suddenly start
[1211.92s -> 1213.92s]  lowering your processors to
[1213.92s -> 1215.92s]  RISC-V you run the
[1215.92s -> 1217.92s]  risk of
[1217.92s -> 1219.92s]  losing support for a bunch of
[1219.92s -> 1221.92s]  important things. Also there are
[1221.92s -> 1223.92s]  like Intel does do interesting
[1223.92s -> 1225.92s]  things within their processors
[1225.92s -> 1227.92s]  like security-wise
[1227.92s -> 1229.92s]  there are enclaves in Intel
[1229.92s -> 1231.92s]  processors and there's things that
[1231.92s -> 1233.92s]  they've been doing in recent years
[1233.92s -> 1235.92s]  to try and give you
[1235.92s -> 1237.92s]  extra added security
[1237.92s -> 1239.92s]  and some of those instructions
[1240.48s -> 1242.48s]  that Intel does implement which are hyper-specific
[1242.48s -> 1244.48s]  can be really efficient for
[1244.48s -> 1246.48s]  certain computations
[1246.48s -> 1248.48s]  and so they have so many
[1248.48s -> 1250.48s]  instructions that there's often
[1250.48s -> 1252.48s]  a perfect instruction for a situation
[1252.48s -> 1254.48s]  that may be more efficient than
[1254.48s -> 1256.48s]  what exists within RISC-V
[1256.48s -> 1258.48s]  but a more practical
[1258.48s -> 1260.48s]  answer is that RISC-V is relatively new
[1260.48s -> 1262.48s]  and nobody's really making
[1262.48s -> 1264.48s]  processors for personal computers
[1264.48s -> 1266.48s]  I think the Sci-5 announcement is super
[1266.48s -> 1268.48s]  recent
[1269.04s -> 1271.04s]  they're kind of the first people to be doing that
[1271.04s -> 1273.04s]  so on a practical level
[1273.04s -> 1275.04s]  that and the inability to run all the
[1275.04s -> 1277.04s]  software designed for Intel
[1277.04s -> 1279.04s]  is my best answer
[1281.04s -> 1283.04s]  so we've been now chatting
[1283.04s -> 1285.04s]  a little bit about assembly
[1285.04s -> 1287.04s]  so I just wanted to
[1287.04s -> 1289.04s]  take a look at some actual assembly
[1289.04s -> 1291.04s]  code
[1291.04s -> 1293.04s]  so here is the
[1293.04s -> 1295.04s]  C code for what's below
[1295.04s -> 1297.04s]  so this is a simple function
[1297.60s -> 1299.60s]  in an accumulator we loop from
[1299.60s -> 1301.60s]  0 to N and we
[1301.60s -> 1303.60s]  sum up all the numbers
[1303.60s -> 1305.60s]  from 0 to N
[1305.60s -> 1307.60s]  and then return that value
[1307.60s -> 1309.60s]  and at its simplest level
[1309.60s -> 1311.60s]  this is the easiest kind of assembly
[1311.60s -> 1313.60s]  that you can get out of compiling
[1313.60s -> 1315.60s]  that program if you actually
[1315.60s -> 1317.60s]  go into your own
[1317.60s -> 1319.60s]  computer and you write the C code
[1319.60s -> 1321.60s]  and you try to compile it you will end up with
[1321.60s -> 1323.60s]  something that likely looks
[1323.60s -> 1325.60s]  quite different and that's
[1325.60s -> 1327.60s]  true for a variety of reasons
[1327.60s -> 1329.60s]  some of which we'll get to and some of which are
[1329.60s -> 1331.60s]  compiler specific so modern
[1331.60s -> 1333.60s]  compilers make a
[1333.60s -> 1335.60s]  large number of optimizations
[1335.60s -> 1337.60s]  when they
[1337.60s -> 1339.60s]  compile your C2 assembly
[1339.60s -> 1341.60s]  and so your assembly instructions may look different
[1341.60s -> 1343.60s]  for instance while you're
[1343.60s -> 1345.60s]  debugging in GDB you may come across
[1345.60s -> 1347.60s]  something that tells you that some variable
[1347.60s -> 1349.60s]  has been optimized out
[1349.60s -> 1351.60s]  and that means that the compiler decided it
[1351.60s -> 1353.60s]  didn't need that variable
[1353.60s -> 1355.60s]  and so that will be
[1355.60s -> 1357.60s]  effectively from the program
[1357.60s -> 1359.60s]  but yeah at its most straight forward
[1359.60s -> 1361.60s]  we're moving
[1361.60s -> 1363.60s]  the value that's in A0
[1363.60s -> 1365.60s]  to T0 we're setting
[1365.60s -> 1367.60s]  A0 to 0 and then
[1367.60s -> 1369.60s]  we are just adding
[1369.60s -> 1371.60s]  what's in T0 to A0
[1371.60s -> 1373.60s]  for every iteration of a loop until
[1373.60s -> 1375.60s]  T0 reaches 0
[1375.60s -> 1377.60s]  and that's all that's going on in this piece
[1377.60s -> 1379.60s]  Amir are your hands raised?
[1379.60s -> 1381.60s]  I was wondering
[1381.60s -> 1383.60s]  what .section, .text
[1383.60s -> 1385.60s]  and .global do?
[1385.60s -> 1387.60s]  .global means that you can
[1387.60s -> 1389.60s]  include this from other files
[1389.60s -> 1391.60s]  so if we actually hop into
[1391.60s -> 1393.60s]  let's see
[1393.60s -> 1395.60s]  defs.h
[1397.60s -> 1399.60s]  this is the file that you're
[1399.60s -> 1401.60s]  if you aren't already
[1401.60s -> 1403.60s]  you will become quite familiar with
[1403.60s -> 1405.60s]  this includes basically all of the functions
[1405.60s -> 1407.60s]  within the kernel that you may want to be using
[1407.60s -> 1409.60s]  and
[1409.60s -> 1411.60s]  within here you know we can
[1411.60s -> 1413.60s]  see that in my
[1413.60s -> 1415.60s]  file I've included the definitions
[1415.60s -> 1417.60s]  to these functions and so that
[1417.60s -> 1419.60s]  .global makes sure that
[1419.60s -> 1421.60s]  that these
[1421.60s -> 1423.60s]  functions can be called from
[1423.60s -> 1425.60s]  other places and .text
[1425.60s -> 1427.60s]  just says this is code
[1427.60s -> 1429.60s]  so if you recall from
[1429.60s -> 1431.60s]  figure 3.4
[1431.60s -> 1433.60s]  in the book
[1433.60s -> 1435.60s]  so that's if we go to
[1435.60s -> 1437.60s]  the book
[1439.60s -> 1441.60s]  we go into
[1441.60s -> 1443.60s]  page tables
[1443.60s -> 1445.60s]  process address space so in here
[1445.60s -> 1447.60s]  in this diagram
[1447.60s -> 1449.60s]  that's the same thing this is text
[1449.60s -> 1451.60s]  so it just means code
[1451.60s -> 1453.60s]  does that answer your question?
[1453.60s -> 1455.60s]  Thanks
[1457.60s -> 1459.60s]  and so if we want to
[1459.60s -> 1461.60s]  run
[1461.60s -> 1463.60s]  let's say we have some assembly
[1463.60s -> 1465.60s]  also if you will ever find yourself
[1465.60s -> 1467.60s]  interested in what the
[1467.60s -> 1469.60s]  kernel looks like we can go
[1469.60s -> 1471.60s]  inside the after you compile
[1471.60s -> 1473.60s]  you can look in the file
[1473.60s -> 1475.60s]  kernel slash kernel dot asm
[1475.60s -> 1477.60s]  and this is the full
[1477.60s -> 1479.60s]  kind of assembly
[1479.60s -> 1481.60s]  for the kernel
[1481.60s -> 1483.60s]  of xv6
[1483.60s -> 1485.60s]  and each of these numbers on the
[1485.60s -> 1487.60s]  left here is a
[1487.60s -> 1489.60s]  label that tells you where in memory
[1489.60s -> 1491.60s]  this instruction will be
[1491.60s -> 1493.60s]  and that will come in quite handy
[1493.60s -> 1495.60s]  and so here is the
[1495.60s -> 1497.60s]  here's the actual
[1497.60s -> 1499.60s]  here's the actual assembly code
[1499.60s -> 1501.60s]  and you can see the labels for the functions
[1501.60s -> 1503.60s]  and where they're declared
[1503.60s -> 1505.60s]  so this is
[1505.60s -> 1507.60s]  can be really really useful as we're debugging
[1507.60s -> 1509.60s]  code and hopefully I'll be able to show that
[1509.60s -> 1511.60s]  in a second
[1511.60s -> 1513.60s]  but for now we'll jump back
[1513.60s -> 1515.60s]  to this first function sum2
[1515.60s -> 1517.60s]  and we'll just see how we
[1517.60s -> 1519.60s]  can examine that inside
[1519.60s -> 1521.60s]  of GDD
[1521.60s -> 1523.60s]  so the first step is I have my
[1523.60s -> 1525.60s]  two windows here
[1525.60s -> 1527.60s]  what's the difference between .asm and .s files
[1527.60s -> 1529.60s]  I'm
[1529.60s -> 1531.60s]  not 100%
[1531.60s -> 1533.60s]  certain
[1533.60s -> 1535.60s]  they're both assembly I think the
[1535.60s -> 1537.60s]  .asm file includes a bunch of extra
[1537.60s -> 1539.60s]  annotations that aren't included in .s
[1539.60s -> 1541.60s]  so usually when you compile your
[1541.60s -> 1543.60s]  C code to
[1543.60s -> 1545.60s]  .s you'll end up with something
[1545.60s -> 1547.60s]  that doesn't include all those line numbers
[1547.60s -> 1549.60s]  and things like that so
[1549.60s -> 1551.60s]  if you're curious about how we get the .asm file
[1551.60s -> 1553.60s]  I think the .makefile
[1553.60s -> 1555.60s]  will tell you the exact steps
[1555.60s -> 1557.60s]  used to get that
[1559.60s -> 1561.60s]  and so if we're
[1561.60s -> 1563.60s]  in our terminal we have our two
[1563.60s -> 1565.60s]  two windows so the first thing to do
[1565.60s -> 1567.60s]  is of course
[1567.60s -> 1569.60s]  get QEMU up and running
[1569.60s -> 1571.60s]  so we can
[1571.60s -> 1573.60s]  start it within GDD
[1573.60s -> 1575.60s]  mode so now we're frozen here
[1575.60s -> 1577.60s]  and then we can start GDD
[1577.60s -> 1579.60s]  and
[1579.60s -> 1581.60s]  what Professor
[1581.60s -> 1583.60s]  Kasia showed last week
[1583.60s -> 1585.60s]  which I think some people were
[1585.60s -> 1587.60s]  excited about if you type TUI
[1587.60s -> 1589.60s]  enable you get this nice
[1589.60s -> 1591.60s]  window which is empty for now but will come in
[1591.60s -> 1593.60s]  quite useful as you're debugging
[1593.60s -> 1595.60s]  so we can set a breakpoint
[1595.60s -> 1597.60s]  and I should note that all this
[1597.60s -> 1599.60s]  code is living inside the kernel
[1599.60s -> 1601.60s]  none of this is in user space so we don't
[1601.60s -> 1603.60s]  have any of those annoying problems setting breakpoints
[1603.60s -> 1605.60s]  so I can set a breakpoint
[1605.60s -> 1607.60s]  in the function sum2
[1607.60s -> 1609.60s]  and then just continue running
[1609.60s -> 1611.60s]  and run that
[1611.60s -> 1613.60s]  function and now
[1613.60s -> 1615.60s]  so the first window
[1615.60s -> 1617.60s]  that you see in TUI is
[1617.60s -> 1619.60s]  the source window
[1619.60s -> 1621.60s]  yes
[1621.60s -> 1623.60s]  as David is saying those numbers
[1623.60s -> 1625.60s]  on the left of kernel.asm
[1625.60s -> 1627.60s]  are really useful when
[1627.60s -> 1629.60s]  you're debugging things and you
[1629.60s -> 1631.60s]  get an address it'll tell
[1631.60s -> 1633.60s]  you so you can see now even here
[1633.60s -> 1635.60s]  we can see that the program so PC here
[1635.60s -> 1637.60s]  in GDB is the program
[1637.60s -> 1639.60s]  counter so we can see this address
[1639.60s -> 1641.60s]  800 so on and so forth
[1641.60s -> 1643.60s]  if we go
[1643.60s -> 1645.60s]  into kernel.asm
[1645.60s -> 1647.60s]  and we search for that specific address
[1647.60s -> 1649.60s]  we can see that it's the
[1649.60s -> 1651.60s]  well it
[1651.60s -> 1653.60s]  comes up twice because it's a function call
[1653.60s -> 1655.60s]  but if we look here this is that address
[1655.60s -> 1657.60s]  it's the top of the sum2 function
[1657.60s -> 1659.60s]  so if you see
[1659.60s -> 1661.60s]  any time you see one of these
[1661.60s -> 1663.60s]  all the kernel addresses will look something like
[1663.60s -> 1665.60s]  0x8000
[1667.60s -> 1669.60s]  some numbers
[1669.60s -> 1671.60s]  those addresses
[1671.60s -> 1673.60s]  you can jump straight into kernel.asm
[1673.60s -> 1675.60s]  and find the exact line
[1675.60s -> 1677.60s]  of assembly where the problem is occurring
[1677.60s -> 1679.60s]  and then you can set your breakpoints accordingly
[1679.60s -> 1681.60s]  but for now
[1681.60s -> 1683.60s]  that top window in TUI
[1683.60s -> 1685.60s]  is source and if we want to
[1685.60s -> 1687.60s]  look at specifically the assembly
[1687.60s -> 1689.60s]  we can do layout
[1689.60s -> 1691.60s]  in gdbasm
[1691.60s -> 1693.60s]  and that'll give us all of the assembly
[1693.60s -> 1695.60s]  instructions and
[1695.60s -> 1697.60s]  we can also look at the registers
[1697.60s -> 1699.60s]  if we type layout reg we'll get assembly
[1699.60s -> 1701.60s]  and registers
[1701.60s -> 1703.60s]  and if you find yourself you know wanting to scroll through
[1703.60s -> 1705.60s]  things now that we
[1705.60s -> 1707.60s]  have three windows we need to specify which one is
[1707.60s -> 1709.60s]  focused so if I want to look through all the registers
[1709.60s -> 1711.60s]  I'm going to focus reg
[1711.60s -> 1713.60s]  and now my focus is on the register
[1713.60s -> 1715.60s]  window so if I move the
[1715.60s -> 1717.60s]  arrow keys or scroll it'll start
[1717.60s -> 1719.60s]  scrolling that window
[1719.60s -> 1721.60s]  and for now we can focus on the
[1721.60s -> 1723.60s]  assembly window
[1723.60s -> 1725.60s]  and once we're here we can see all of the things
[1725.60s -> 1727.60s]  so let's see we can see
[1727.60s -> 1729.60s]  in the register window
[1729.60s -> 1731.60s]  we can see that T0 contains this value
[1731.60s -> 1733.60s]  we can see that A0
[1733.60s -> 1735.60s]  contains this value
[1735.60s -> 1737.60s]  and as we step through the assembly
[1737.60s -> 1739.60s]  we can watch
[1739.60s -> 1741.60s]  T0 just
[1741.60s -> 1743.60s]  got the value of A0 which was
[1743.60s -> 1745.60s]  5 and it's nicely highlighted the register
[1745.60s -> 1747.60s]  that's changed here
[1747.60s -> 1749.60s]  and we can just keep remember if we
[1749.60s -> 1751.60s]  push enter we get the most
[1751.60s -> 1753.60s]  recently executed instruction so we can
[1753.60s -> 1755.60s]  go through we set A0
[1755.60s -> 1757.60s]  to 0 and now we can just kind of
[1757.60s -> 1759.60s]  watch ourselves go through this loop
[1759.60s -> 1761.60s]  and
[1761.60s -> 1763.60s]  sum up the values
[1763.60s -> 1765.60s]  and again this is like a complete
[1765.60s -> 1767.60s]  toy function and then we can
[1767.60s -> 1769.60s]  continue and
[1769.60s -> 1771.60s]  live our lives and if you're ever curious
[1771.60s -> 1773.60s]  about what
[1773.60s -> 1775.60s]  kind of breakpoints you've set or you
[1775.60s -> 1777.60s]  lose track of what you were doing
[1777.60s -> 1779.60s]  if you type info
[1779.60s -> 1781.60s]  break or breakpoints
[1781.60s -> 1783.60s]  you can see all of the breakpoints that
[1783.60s -> 1785.60s]  you've set in your code and
[1785.60s -> 1787.60s]  you can even see okay this breakpoint has
[1787.60s -> 1789.60s]  already been hit one time and you
[1789.60s -> 1791.60s]  get lots of useful information
[1791.60s -> 1793.60s]  doing that
[1793.60s -> 1795.60s]  if you don't want to have the register window
[1795.60s -> 1797.60s]  but you do want to look at the registers
[1797.60s -> 1799.60s]  info reg
[1799.60s -> 1801.60s]  or info registers or ireg
[1801.60s -> 1803.60s]  or any of the numerous
[1803.60s -> 1805.60s]  GDB shortenings
[1805.60s -> 1807.60s]  will bring up the register window
[1807.60s -> 1809.60s]  as well
[1809.60s -> 1811.60s]  so with that is there any
[1811.60s -> 1813.60s]  are there any questions about GDB
[1813.60s -> 1815.60s]  simple ones I know it's been
[1815.60s -> 1817.60s]  there's been lots of
[1817.60s -> 1819.60s]  posts on Piazza about it so
[1819.60s -> 1821.60s]  now is a good time to just ask some
[1821.60s -> 1823.60s]  straightforward and we'll I'll be showing more
[1823.60s -> 1825.60s]  usage of DDB
[1825.60s -> 1827.60s]  what command did you use to open the multiple
[1827.60s -> 1829.60s]  windows so I use TMUX
[1829.60s -> 1831.60s]  so I can show just from scratch
[1831.60s -> 1833.60s]  if we go here and I
[1833.60s -> 1835.60s]  open a new terminal so here's just
[1835.60s -> 1837.60s]  a blank terminal
[1837.60s -> 1839.60s]  if you type TMUX and this is available
[1839.60s -> 1841.60s]  on Athena
[1843.60s -> 1845.60s]  I'll address the next question in a second
[1845.60s -> 1847.60s]  so now I'm in TMUX which you can tell
[1847.60s -> 1849.60s]  by this green bar at the
[1849.60s -> 1851.60s]  bottom and if you want
[1851.60s -> 1853.60s]  to get so there's a couple ways you can do
[1853.60s -> 1855.60s]  multiple windows in TMUX
[1855.60s -> 1857.60s]  if you're so you can type
[1857.60s -> 1859.60s]  control B C and
[1859.60s -> 1861.60s]  I know that sometimes
[1861.60s -> 1863.60s]  if you're used to using Emacs that will make a lot
[1863.60s -> 1865.60s]  of sense but
[1865.60s -> 1867.60s]  normal people who don't use Emacs
[1867.60s -> 1869.60s]  that's hitting control and
[1869.60s -> 1871.60s]  then B and then hitting C
[1871.60s -> 1873.60s]  on its own afterwards that will get
[1873.60s -> 1875.60s]  you a second window which you can then navigate
[1875.60s -> 1877.60s]  between with control B and then
[1877.60s -> 1879.60s]  P control B and then N
[1879.60s -> 1881.60s]  to go previous and next
[1881.60s -> 1883.60s]  yeah and David just posted a TMUX cheat sheet
[1883.60s -> 1885.60s]  which is useful and if you want
[1885.60s -> 1887.60s]  to split the windows I think it's control B
[1887.60s -> 1889.60s]  and then the percent sign will split them
[1889.60s -> 1891.60s]  vertically
[1891.60s -> 1893.60s]  and then
[1893.60s -> 1895.60s]  control B and then double
[1895.60s -> 1897.60s]  quote will split them
[1897.60s -> 1899.60s]  horizontally
[1899.60s -> 1901.60s]  and so that's how we get them and if we're in this state
[1901.60s -> 1903.60s]  we can use control B and O
[1903.60s -> 1905.60s]  to jump between our windows
[1905.60s -> 1907.60s]  so that's what's
[1907.60s -> 1909.60s]  that's how I got multiple windows
[1909.60s -> 1911.60s]  yeah I don't care
[1911.60s -> 1913.60s]  and then Ahmed asked
[1913.60s -> 1915.60s]  why is this displaying assembly addresses
[1915.60s -> 1917.60s]  again instead of C line numbers
[1917.60s -> 1919.60s]  so because the
[1919.60s -> 1921.60s]  function
[1921.60s -> 1923.60s]  so if we go back to the
[1923.60s -> 1925.60s]  assembly function this is implemented
[1925.60s -> 1927.60s]  entirely in assembly and not at all in C
[1927.60s -> 1929.60s]  and so there just aren't any associated
[1929.60s -> 1931.60s]  C line numbers for this
[1931.60s -> 1933.60s]  if we were
[1933.60s -> 1935.60s]  to set a breakpoint
[1935.60s -> 1937.60s]  so if you type
[1937.60s -> 1939.60s]  delete you'll delete all your breakpoints
[1939.60s -> 1941.60s]  so I cleared the old one if I
[1941.60s -> 1943.60s]  now set a breakpoint in
[1943.60s -> 1945.60s]  demo one so that's a C breakpoint
[1945.60s -> 1947.60s]  and continue
[1947.60s -> 1949.60s]  and run this now if I go here
[1949.60s -> 1951.60s]  and type layout split I'll get
[1951.60s -> 1953.60s]  the C and the assembly
[1953.60s -> 1955.60s]  or if I just want the C source
[1955.60s -> 1957.60s]  I can do layout source and I'll just get the C
[1957.60s -> 1959.60s]  so that's
[1959.60s -> 1961.60s]  that's what's going on it's just a
[1961.60s -> 1963.60s]  a quirk of the fact that this doesn't have
[1963.60s -> 1965.60s]  associated C code and so we don't see C line
[1965.60s -> 1967.60s]  numbers
[1967.60s -> 1969.60s]  any other
[1969.60s -> 1971.60s]  any other questions
[1971.60s -> 1973.60s]  about GDB
[1973.60s -> 1975.60s]  Tmux
[1975.60s -> 1977.60s]  and that sort of thing
[1977.60s -> 1979.60s]  so layout split is the one that you use to bring
[1979.60s -> 1981.60s]  up this extra window of the source
[1981.60s -> 1983.60s]  and assembly and so on right?
[1983.60s -> 1985.60s]  yes yes so layout
[1985.60s -> 1987.60s]  if you do layout split that'll get you
[1987.60s -> 1989.60s]  source and assembly layout source
[1989.60s -> 1991.60s]  will get you just source ASM
[1991.60s -> 1993.60s]  will get you just assembly and the registers
[1993.60s -> 1995.60s]  are their own thing where if you type layout reg
[1995.60s -> 1997.60s]  I think yeah that'll bring up the
[1997.60s -> 1999.60s]  registers but unfortunately
[1999.60s -> 2001.60s]  I don't know of a way to get
[2001.60s -> 2003.60s]  the register with the assembly
[2003.60s -> 2005.60s]  and the C code all at the same time
[2005.60s -> 2007.60s]  outside of using info reg with layout
[2007.60s -> 2009.60s]  split I have a question
[2009.60s -> 2011.60s]  so when we set the
[2011.60s -> 2013.60s]  breakpoint at a line
[2013.60s -> 2015.60s]  right it displays
[2015.60s -> 2017.60s]  the address of the
[2017.60s -> 2019.60s]  like in this case breakpoint to
[2019.60s -> 2021.60s]  add 0x8
[2021.60s -> 2023.60s]  what
[2023.60s -> 2025.60s]  any instruction might have multiple
[2025.60s -> 2027.60s]  any line
[2027.60s -> 2029.60s]  of code in C might have multiple
[2029.60s -> 2031.60s]  instructions so which one does it
[2031.60s -> 2033.60s]  show? I believe it shows the
[2033.60s -> 2035.60s]  first one
[2035.60s -> 2037.60s]  and it's TU for the
[2037.60s -> 2039.60s]  person who asked to start the TUI
[2039.60s -> 2041.60s]  I think it's TUI
[2041.60s -> 2043.60s]  enable not enable TUI
[2043.60s -> 2045.60s]  sorry
[2045.60s -> 2047.60s]  I think
[2047.60s -> 2049.60s]  yeah
[2049.60s -> 2051.60s]  yeah
[2051.60s -> 2053.60s]  yeah again
[2053.60s -> 2055.60s]  there's like a hundred cheat sheets out here
[2055.60s -> 2057.60s]  for GDB and for
[2057.60s -> 2059.60s]  Tmux as well so if you ever find yourself
[2059.60s -> 2061.60s]  lost GDB
[2061.60s -> 2063.60s]  even has its own inbuilt
[2063.60s -> 2065.60s]  its own
[2065.60s -> 2067.60s]  thing called apropos
[2067.60s -> 2069.60s]  so if you look for apropos
[2069.60s -> 2071.60s]  TUI it'll actually show you
[2071.60s -> 2073.60s]  all of the commands
[2073.60s -> 2075.60s]  that involve TUI
[2075.60s -> 2077.60s]  so
[2077.60s -> 2079.60s]  yeah this can be quite
[2079.60s -> 2081.60s]  useful but it can also be a little bit
[2081.60s -> 2083.60s]  overwhelming
[2083.60s -> 2085.60s]  if you do apropos-d
[2085.60s -> 2087.60s]  it'll give you even more information I think
[2087.60s -> 2089.60s]  I don't
[2089.60s -> 2091.60s]  remember
[2091.60s -> 2093.60s]  I don't use it often myself but if you
[2093.60s -> 2095.60s]  do find or if you forget the
[2095.60s -> 2097.60s]  exact way to type a command in GDB
[2097.60s -> 2099.60s]  and you don't feel like googling an apropos
[2099.60s -> 2101.60s]  will often be able to
[2101.60s -> 2103.60s]  find exactly what you're looking for in addition
[2103.60s -> 2105.60s]  to a whole bunch of stuff you weren't looking for
[2105.60s -> 2107.60s]  yeah
[2107.60s -> 2109.60s]  so that can be quite useful
[2109.60s -> 2111.60s]  GDB is extremely well documented
[2111.60s -> 2113.60s]  as well so
[2113.60s -> 2115.60s]  yeah if you ever find yourself lost
[2115.60s -> 2117.60s]  you know Google is your friend
[2119.60s -> 2121.60s]  so now that we've kind of
[2121.60s -> 2123.60s]  been over assembly and
[2123.60s -> 2125.60s]  and risk five and these
[2125.60s -> 2127.60s]  sort of things I want to dive a little bit
[2127.60s -> 2129.60s]  more into the specifics
[2129.60s -> 2131.60s]  of what you really
[2131.60s -> 2133.60s]  need to know for the
[2133.60s -> 2135.60s]  lab coming up and also
[2135.60s -> 2137.60s]  this will be a little bit of review from the document
[2137.60s -> 2139.60s]  that you've all of course as diligent
[2139.60s -> 2141.60s]  students read through
[2141.60s -> 2143.60s]  thoroughly
[2143.60s -> 2145.60s]  in preparation for this lecture
[2147.60s -> 2149.60s]  so this table will of course
[2149.60s -> 2151.60s]  be wildly familiar to you all
[2151.60s -> 2153.60s]  and
[2153.60s -> 2155.60s]  from both 004 and from what you've
[2155.60s -> 2157.60s]  read and this is the table
[2157.60s -> 2159.60s]  of registers and registers
[2159.60s -> 2161.60s]  are little
[2161.60s -> 2163.60s]  locations on the CPU
[2163.60s -> 2165.60s]  or on the processor
[2165.60s -> 2167.60s]  predefined that
[2167.60s -> 2169.60s]  it can use to store values
[2169.60s -> 2171.60s]  and this is important because
[2171.60s -> 2173.60s]  assembly operations
[2173.60s -> 2175.60s]  if we remember from the assembly code
[2175.60s -> 2177.60s]  assembly doesn't operate on memory
[2177.60s -> 2179.60s]  it operates on registers so when we do
[2179.60s -> 2181.60s]  add when we do subtract
[2181.60s -> 2183.60s]  we're operating on registers
[2183.60s -> 2185.60s]  and so what you'll often
[2185.60s -> 2187.60s]  see as the pattern for
[2187.60s -> 2189.60s]  for writing assembly is we'll have
[2189.60s -> 2191.60s]  some kind of a load
[2191.60s -> 2193.60s]  so we'll load some value
[2193.60s -> 2195.60s]  to a register
[2195.60s -> 2197.60s]  and
[2197.60s -> 2199.60s]  that value can be from memory or it can be from
[2199.60s -> 2201.60s]  another register
[2201.60s -> 2203.60s]  and here
[2203.60s -> 2205.60s]  I'm referring to load in general not the load instruction
[2205.60s -> 2207.60s]  and then
[2207.60s -> 2209.60s]  we'll operate
[2209.60s -> 2211.60s]  so we'll perform some operation
[2211.60s -> 2213.60s]  on the register and then if
[2213.60s -> 2215.60s]  we care about the result of that operation
[2215.60s -> 2217.60s]  outside of the return address
[2217.60s -> 2219.60s]  we'll store
[2219.60s -> 2221.60s]  that register
[2221.60s -> 2223.60s]  to somewhere
[2223.60s -> 2225.60s]  we'll store that
[2225.60s -> 2227.60s]  register to some location
[2227.60s -> 2229.60s]  be that in memory or
[2229.60s -> 2231.60s]  to another register
[2231.60s -> 2233.60s]  and so that's generally the way
[2233.60s -> 2235.60s]  things work and registers are the
[2235.60s -> 2237.60s]  absolute fastest way to perform
[2237.60s -> 2239.60s]  any sort of calculation
[2239.60s -> 2241.60s]  or to access any value and that's why
[2241.60s -> 2243.60s]  it's important to
[2243.60s -> 2245.60s]  use them and also why
[2245.60s -> 2247.60s]  we prefer using registers over
[2247.60s -> 2249.60s]  using memory so if you remember from
[2249.60s -> 2251.60s]  the reading when we call
[2251.60s -> 2253.60s]  functions so you can see here that registers
[2253.60s -> 2255.60s]  a 0 to 7
[2255.60s -> 2257.60s]  and
[2257.60s -> 2259.60s]  in general when we speak about registers
[2259.60s -> 2261.60s]  we will be
[2261.60s -> 2263.60s]  referring to them by their ABI name
[2263.60s -> 2265.60s]  not only
[2265.60s -> 2267.60s]  is it less confusing it's just a standard and
[2267.60s -> 2269.60s]  it's also the way that you'll write assembly code
[2269.60s -> 2271.60s]  this
[2271.60s -> 2273.60s]  these actual numbers are not
[2273.60s -> 2275.60s]  super important the only
[2275.60s -> 2277.60s]  case where it does matter is
[2277.60s -> 2279.60s]  for the compressed
[2279.60s -> 2281.60s]  version of RISC-V
[2281.60s -> 2283.60s]  instructions and if you want to know more about that
[2283.60s -> 2285.60s]  feel free to read up
[2285.60s -> 2287.60s]  about it the basic idea is that
[2287.60s -> 2289.60s]  RISC-V normal instructions
[2289.60s -> 2291.60s]  are 64 bits but there's also
[2291.60s -> 2293.60s]  a compressed version in which instructions are 16
[2293.60s -> 2295.60s]  bits and we use less registers
[2295.60s -> 2297.60s]  and the registers we use in that
[2297.60s -> 2299.60s]  case are
[2299.60s -> 2301.60s]  8 through 15 those are the registers
[2301.60s -> 2303.60s]  that are available to us so I think somebody
[2303.60s -> 2305.60s]  had a question about you know why is
[2305.60s -> 2307.60s]  this S1 register X9
[2307.60s -> 2309.60s]  why is it separated
[2309.60s -> 2311.60s]  from all of the other S registers
[2311.60s -> 2313.60s]  and my guess is that that's why
[2313.60s -> 2315.60s]  that
[2315.60s -> 2317.60s]  we separate it from all of the other ones because
[2317.60s -> 2319.60s]  it's available in compressed
[2319.60s -> 2321.60s]  instruction mode whereas
[2321.60s -> 2323.60s]  S2 to 11 are not
[2323.60s -> 2325.60s]  and so that's the idea so that's
[2325.60s -> 2327.60s]  for compressed but outside of that registers
[2327.60s -> 2329.60s]  will all be referred to
[2329.60s -> 2331.60s]  by their ABI name
[2331.60s -> 2333.60s]  and so A0 to A7 are used
[2333.60s -> 2335.60s]  for function arguments but if we have a
[2335.60s -> 2337.60s]  function that takes more than
[2337.60s -> 2339.60s]  the 8 arguments that those registers give
[2339.60s -> 2341.60s]  us access to we
[2341.60s -> 2343.60s]  do need to use memory but that's
[2343.60s -> 2345.60s]  this is kind of an illustration of the fact that we don't want
[2345.60s -> 2347.60s]  to use memory when we can use registers
[2347.60s -> 2349.60s]  we only use
[2349.60s -> 2351.60s]  a memory if we have to
[2351.60s -> 2353.60s]  and this column
[2353.60s -> 2355.60s]  here the saver column
[2355.60s -> 2357.60s]  this is also extremely important
[2357.60s -> 2359.60s]  when we're discussing registers caller
[2359.60s -> 2361.60s]  versus callee saved
[2361.60s -> 2363.60s]  and the
[2363.60s -> 2365.60s]  terms are I confuse
[2365.60s -> 2367.60s]  them regularly caller
[2367.60s -> 2369.60s]  and callee they only differ by one letter
[2369.60s -> 2371.60s]  the easiest way that
[2371.60s -> 2373.60s]  I've found to remember them is that
[2373.60s -> 2375.60s]  caller saved registers
[2375.60s -> 2377.60s]  are not
[2377.60s -> 2379.60s]  preserved
[2379.60s -> 2381.60s]  across
[2381.60s -> 2383.60s]  a
[2383.60s -> 2385.60s]  function call
[2385.60s -> 2387.60s]  so and callee
[2387.60s -> 2389.60s]  saved registers
[2389.60s -> 2391.60s]  are preserved
[2391.60s -> 2393.60s]  what I mean
[2393.60s -> 2395.60s]  by this
[2395.60s -> 2397.60s]  is that
[2397.60s -> 2399.60s]  a caller
[2399.60s -> 2401.60s]  saved register can be
[2401.60s -> 2403.60s]  overwritten by
[2403.60s -> 2405.60s]  the function so let's say
[2405.60s -> 2407.60s]  I have function A which calls function
[2407.60s -> 2409.60s]  B any registers being
[2409.60s -> 2411.60s]  used by function A that are caller
[2411.60s -> 2413.60s]  saved call function
[2413.60s -> 2415.60s]  B can overwrite when it gets called
[2415.60s -> 2417.60s]  and I think a good illustration
[2417.60s -> 2419.60s]  of this is the return address
[2419.60s -> 2421.60s]  because you know you can see
[2421.60s -> 2423.60s]  that the return address is caller saved
[2423.60s -> 2425.60s]  and that's important
[2425.60s -> 2427.60s]  because every function
[2427.60s -> 2429.60s]  needs to use the return address
[2429.60s -> 2431.60s]  so when A calls B it's
[2431.60s -> 2433.60s]  important that B be able to
[2433.60s -> 2435.60s]  overwrite the value in the return
[2435.60s -> 2437.60s]  address hence why it's caller saved
[2437.60s -> 2439.60s]  and callee saved registers
[2439.60s -> 2441.60s]  are just our convention
[2441.60s -> 2443.60s]  that we use
[2443.60s -> 2445.60s]  the frame pointer is important for
[2445.60s -> 2447.60s]  that reason
[2447.60s -> 2449.60s]  and those are preserved across a function
[2449.60s -> 2451.60s]  call so basically any register that is caller
[2451.60s -> 2453.60s]  saved the function that is making
[2453.60s -> 2455.60s]  the call needs to worry about those registers
[2455.60s -> 2457.60s]  and if they're callee saved
[2457.60s -> 2459.60s]  the function that is being called
[2459.60s -> 2461.60s]  needs to worry about preserving the value
[2461.60s -> 2463.60s]  in those registers
[2463.60s -> 2465.60s]  and again you know I regularly
[2465.60s -> 2467.60s]  confuse the two and find
[2467.60s -> 2469.60s]  myself returning to this table
[2469.60s -> 2471.60s]  to
[2471.60s -> 2473.60s]  remind myself about what they do
[2473.60s -> 2475.60s]  and so
[2475.60s -> 2477.60s]  you know if you remember
[2477.60s -> 2479.60s]  from the reading all of these registers
[2479.60s -> 2481.60s]  are 64 bits wide
[2481.60s -> 2483.60s]  so they have 64 places where
[2483.60s -> 2485.60s]  we can put things and
[2485.60s -> 2487.60s]  the various data types
[2487.60s -> 2489.60s]  are made to fit into those 64
[2489.60s -> 2491.60s]  bits based on the
[2491.60s -> 2493.60s]  calling convention so if we have a 32 bit
[2493.60s -> 2495.60s]  integer depending on how it's
[2495.60s -> 2497.60s]  whether or not it's sign extended
[2497.60s -> 2499.60s]  so we'll either add 0s or 1s to the front
[2499.60s -> 2501.60s]  of that integer in order to make it 64
[2501.60s -> 2503.60s]  bits to put in these registers
[2503.60s -> 2505.60s]  so before we move on
[2505.60s -> 2507.60s]  does anybody have questions about
[2507.60s -> 2509.60s]  registers or
[2509.60s -> 2511.60s]  things of that nature?
[2521.60s -> 2523.60s]  I have a question
[2523.60s -> 2525.60s]  can you have
[2525.60s -> 2527.60s]  a return value in A1?
[2527.60s -> 2529.60s]  Yes
[2529.60s -> 2531.60s]  that's a good question
[2531.60s -> 2533.60s]  so I think in theory
[2533.60s -> 2535.60s]  you can
[2535.60s -> 2537.60s]  the reason why we say A0 to
[2537.60s -> 2539.60s]  A1 is if a function
[2539.60s -> 2541.60s]  returns a long long
[2541.60s -> 2543.60s]  which is 128 bits
[2543.60s -> 2545.60s]  so if you remember from the reading
[2545.60s -> 2547.60s]  if a function argument is 100
[2547.60s -> 2549.60s]  is more than a pointer
[2549.60s -> 2551.60s]  so when we refer to kernel word size
[2551.60s -> 2553.60s]  we're saying 64 bits
[2553.60s -> 2555.60s]  that's the size of a pointer word
[2555.60s -> 2557.60s]  we can put that
[2557.60s -> 2559.60s]  in a register pair
[2559.60s -> 2561.60s]  and so the same convention holds true
[2561.60s -> 2563.60s]  for return addresses where if we have something
[2563.60s -> 2565.60s]  that's the size of twice a pointer
[2565.60s -> 2567.60s]  word we can stick that in A0
[2567.60s -> 2569.60s]  and A1 and use that as the return address
[2569.60s -> 2571.60s]  I think you'll run into problems if you
[2571.60s -> 2573.60s]  only try to put something in A1
[2573.60s -> 2575.60s]  makes sense, thanks
[2575.60s -> 2577.60s]  no problem
[2579.60s -> 2581.60s]  why are the
[2581.60s -> 2583.60s]  registers not continuous
[2583.60s -> 2585.60s]  so why is A0 and A1
[2585.60s -> 2587.60s]  separate from
[2587.60s -> 2589.60s]  sorry that's a bad
[2589.60s -> 2591.60s]  example, why is S1
[2591.60s -> 2593.60s]  separate from S2
[2593.60s -> 2595.60s]  why are the A's in between
[2595.60s -> 2597.60s]  is there any point in that?
[2597.60s -> 2599.60s]  I mentioned this briefly earlier
[2599.60s -> 2601.60s]  but there is a compressed
[2601.60s -> 2603.60s]  this is a guess, I don't know for sure
[2603.60s -> 2605.60s]  but there's a compressed version
[2605.60s -> 2607.60s]  of the RISC-V
[2607.60s -> 2609.60s]  instructions which are
[2609.60s -> 2611.60s]  16 bits in size as opposed to 64
[2611.60s -> 2613.60s]  and
[2613.60s -> 2615.60s]  you would use that to try to
[2615.60s -> 2617.60s]  make your code take less space in memory
[2617.60s -> 2619.60s]  and when you use
[2619.60s -> 2621.60s]  those 16 bit instructions you only
[2621.60s -> 2623.60s]  have access to registers
[2623.60s -> 2625.60s]  8 through 15
[2625.60s -> 2627.60s]  so I think S1 is separate
[2627.60s -> 2629.60s]  from S2 to 11
[2629.60s -> 2631.60s]  because they want to make it clear that
[2631.60s -> 2633.60s]  S1 is available to you
[2633.60s -> 2635.60s]  in the compressed instruction mode
[2635.60s -> 2637.60s]  whereas S2 to 11 aren't
[2637.60s -> 2639.60s]  and the reason
[2639.60s -> 2641.60s]  I don't know why they picked
[2641.60s -> 2643.60s]  X8 to 15
[2643.60s -> 2645.60s]  but I suspect that that's just
[2645.60s -> 2647.60s]  they looked at a bunch of code and were like
[2647.60s -> 2649.60s]  these are the most commonly used registers
[2659.60s -> 2661.60s]  any other questions?
[2663.60s -> 2665.60s]  I had a question
[2665.60s -> 2667.60s]  besides the frame pointer
[2667.60s -> 2669.60s]  the stack pointer and all
[2669.60s -> 2671.60s]  I don't know why we would need
[2671.60s -> 2673.60s]  more callee save registers
[2673.60s -> 2675.60s]  but we do have
[2675.60s -> 2677.60s]  like a bunch of them
[2677.60s -> 2679.60s]  yeah
[2679.60s -> 2681.60s]  the S1s to 11s
[2681.60s -> 2683.60s]  those are just for
[2683.60s -> 2685.60s]  I believe used there for freedom for the compiler
[2685.60s -> 2687.60s]  or for the programmer to use
[2687.60s -> 2689.60s]  so maybe there are certain cases
[2689.60s -> 2691.60s]  where you want
[2691.60s -> 2693.60s]  to guarantee that something is still around
[2693.60s -> 2695.60s]  after
[2695.60s -> 2697.60s]  after your function call
[2697.60s -> 2699.60s]  the compiler can choose to use
[2699.60s -> 2701.60s]  S1 to 11 to do that
[2703.60s -> 2705.60s]  I don't have like
[2705.60s -> 2707.60s]  on hand a specific example of where that's useful
[2707.60s -> 2709.60s]  but I'm sure it shows up
[2709.60s -> 2711.60s]  where
[2711.60s -> 2713.60s]  having a callee save value is important
[2717.60s -> 2719.60s]  but these are basically
[2719.60s -> 2721.60s]  programmer or compiler's choice to use
[2721.60s -> 2723.60s]  S1 to 11
[2725.60s -> 2727.60s]  and I should note that these floating point
[2727.60s -> 2729.60s]  registers they're for floating point arithmetic
[2731.60s -> 2733.60s]  as far as I'm aware you won't see them
[2733.60s -> 2735.60s]  in this class
[2735.60s -> 2737.60s]  and so you don't really need to worry about them
[2741.60s -> 2743.60s]  okay
[2743.60s -> 2745.60s]  so we started talking a little bit
[2745.60s -> 2747.60s]  about
[2747.60s -> 2749.60s]  function calls
[2749.60s -> 2751.60s]  and so with that
[2751.60s -> 2753.60s]  I want to move us into
[2753.60s -> 2755.60s]  discussion of
[2755.60s -> 2757.60s]  the stack
[2757.60s -> 2759.60s]  so this is
[2759.60s -> 2761.60s]  this is
[2761.60s -> 2763.60s]  we're talking about the stack
[2763.60s -> 2765.60s]  and the stack
[2765.60s -> 2767.60s]  if you've seen it
[2767.60s -> 2769.60s]  likely before, the reason
[2769.60s -> 2771.60s]  why the stack is important is
[2771.60s -> 2773.60s]  it's what keeps our functions
[2773.60s -> 2775.60s]  organized
[2775.60s -> 2777.60s]  and sane
[2777.60s -> 2779.60s]  it allows what makes functions work
[2779.60s -> 2781.60s]  it's what makes return work
[2781.60s -> 2783.60s]  and it's also
[2783.60s -> 2785.60s]  where often we'll find ourselves
[2785.60s -> 2787.60s]  saving our registers
[2787.60s -> 2789.60s]  and things like that
[2793.60s -> 2795.60s]  so
[2795.60s -> 2797.60s]  here I've given just a
[2797.60s -> 2799.60s]  pretty simple
[2799.60s -> 2801.60s]  layout of
[2801.60s -> 2803.60s]  what a stack looks like
[2803.60s -> 2805.60s]  and so each of these
[2805.60s -> 2807.60s]  here is what we refer to
[2807.60s -> 2809.60s]  as a
[2809.60s -> 2811.60s]  stack frame
[2811.60s -> 2813.60s]  and every
[2813.60s -> 2815.60s]  time we get
[2815.60s -> 2817.60s]  which are generated by
[2817.60s -> 2819.60s]  function calls
[2823.60s -> 2825.60s]  every time
[2825.60s -> 2827.60s]  we call a function, that function
[2827.60s -> 2829.60s]  makes for itself
[2829.60s -> 2831.60s]  its own stack frame
[2831.60s -> 2833.60s]  which it
[2833.60s -> 2835.60s]  uses itself and it does that by
[2835.60s -> 2837.60s]  moving around the stack pointer
[2837.60s -> 2839.60s]  so here's the stack pointer
[2839.60s -> 2841.60s]  and this is
[2841.60s -> 2843.60s]  it's very important to remember
[2843.60s -> 2845.60s]  with stacks
[2845.60s -> 2847.60s]  we start from high addresses
[2847.60s -> 2849.60s]  and we grow downwards
[2849.60s -> 2851.60s]  to low addresses
[2851.60s -> 2853.60s]  so the stack grows down
[2853.60s -> 2855.60s]  always
[2855.60s -> 2857.60s]  and so you'll see that the
[2857.60s -> 2859.60s]  arithmetic for a stack pointer is
[2859.60s -> 2861.60s]  usually done via subtraction
[2861.60s -> 2863.60s]  when we want to make a new stack frame
[2863.60s -> 2865.60s]  in assembly, so the stack grows downwards
[2865.60s -> 2867.60s]  and stack frames
[2867.60s -> 2869.60s]  for a function contain
[2869.60s -> 2871.60s]  saved registers, local variables
[2871.60s -> 2873.60s]  also
[2873.60s -> 2875.60s]  like I was saying, if you run out
[2875.60s -> 2877.60s]  of argument registers
[2877.60s -> 2879.60s]  additional arguments will show up on the stack
[2879.60s -> 2881.60s]  and so stack frames are not
[2881.60s -> 2883.60s]  all the same size, even though
[2883.60s -> 2885.60s]  they are in this diagram, that's not the case
[2885.60s -> 2887.60s]  different functions have different numbers of local
[2887.60s -> 2889.60s]  variables, different saved registers
[2889.60s -> 2891.60s]  so on and so forth
[2891.60s -> 2893.60s]  and so stack frames will be different sizes
[2893.60s -> 2895.60s]  but the two things that you can definitely
[2895.60s -> 2897.60s]  count on which are important
[2897.60s -> 2899.60s]  is that the return address
[2899.60s -> 2901.60s]  will always be on the first thing
[2901.60s -> 2903.60s]  and the frame pointer, the previous
[2903.60s -> 2905.60s]  frame's frame pointer is also going
[2905.60s -> 2907.60s]  to show up on the stack at a predictable
[2907.60s -> 2909.60s]  location
[2909.60s -> 2911.60s]  the two important registers
[2911.60s -> 2913.60s]  here are sp which
[2913.60s -> 2915.60s]  as we discussed is used for
[2915.60s -> 2917.60s]  this is the bottom of the stack
[2918.60s -> 2920.60s]  or generally
[2920.60s -> 2922.60s]  it's the location of the stack
[2922.60s -> 2924.60s]  and then fp is our also
[2924.60s -> 2926.60s]  important
[2926.60s -> 2928.60s]  register and this points to
[2928.60s -> 2930.60s]  the top of the current
[2931.60s -> 2933.60s]  frame
[2933.60s -> 2935.60s]  and this is important because
[2935.60s -> 2937.60s]  that means that the return address
[2937.60s -> 2939.60s]  and the previous fp
[2939.60s -> 2941.60s]  will always be at a fixed
[2941.60s -> 2943.60s]  location from
[2943.60s -> 2945.60s]  the current frame pointer
[2945.60s -> 2947.60s]  so that means that
[2947.60s -> 2949.60s]  if I want to find my return address
[2949.60s -> 2951.60s]  or I want to find the previous frame
[2951.60s -> 2953.60s]  I can always get to those values
[2953.60s -> 2955.60s]  by looking at the current
[2955.60s -> 2957.60s]  frame pointer
[2957.60s -> 2959.60s]  and the reason why we store the previous frame
[2959.60s -> 2961.60s]  pointer is to allow us
[2961.60s -> 2963.60s]  to jump back so once this function
[2963.60s -> 2965.60s]  returns we can move this into
[2965.60s -> 2967.60s]  fp and all of a sudden
[2967.60s -> 2969.60s]  fp again will go from pointing
[2969.60s -> 2971.60s]  to this stack frame
[2971.60s -> 2973.60s]  to now pointing to this stack frame
[2973.60s -> 2975.60s]  and so we use the frame pointer
[2975.60s -> 2977.60s]  to manipulate our stack frames
[2977.60s -> 2979.60s]  and make sure we're always pointing to the one
[2979.60s -> 2981.60s]  corresponding to
[2981.60s -> 2983.60s]  the correct function
[2983.60s -> 2985.60s]  and that's kind of
[2985.60s -> 2987.60s]  how things are done
[2987.60s -> 2989.60s]  and these
[2989.60s -> 2991.60s]  pieces of the stack
[2991.60s -> 2993.60s]  need to be created by
[2993.60s -> 2995.60s]  assembly and so everything
[2995.60s -> 2997.60s]  in that calling conventions
[2997.60s -> 2999.60s]  document that you read about
[2999.60s -> 3001.60s]  that's all enforced
[3001.60s -> 3003.60s]  effectively by the
[3003.60s -> 3005.60s]  compiler so the compiler adheres
[3005.60s -> 3007.60s]  to the calling convention
[3007.60s -> 3009.60s]  and it's what generates
[3009.60s -> 3011.60s]  the assembly code
[3011.60s -> 3013.60s]  that makes our stack frames
[3013.60s -> 3015.60s]  look correct so often
[3015.60s -> 3017.60s]  at the top of a function you'll see
[3017.60s -> 3019.60s]  what's called a function
[3019.60s -> 3021.60s]  prologue
[3023.60s -> 3025.60s]  and then
[3025.60s -> 3027.60s]  there will be the body of the function
[3027.60s -> 3029.60s]  and then there will be
[3029.60s -> 3031.60s]  an epilogue
[3031.60s -> 3033.60s]  that shows up after that
[3033.60s -> 3035.60s]  so this is kind of like
[3035.60s -> 3037.60s]  what an assembly
[3037.60s -> 3039.60s]  function
[3039.60s -> 3041.60s]  will often look like
[3041.60s -> 3043.60s]  and we'll take a look at that
[3043.60s -> 3045.60s]  now
[3045.60s -> 3047.60s]  so here I have another function
[3047.60s -> 3049.60s]  so you'll note
[3049.60s -> 3051.60s]  that some tubes not have
[3051.60s -> 3053.60s]  any of these things
[3053.60s -> 3055.60s]  that it should if it was a proper function
[3055.60s -> 3057.60s]  and this works fine because it's simple
[3057.60s -> 3059.60s]  enough so it does all of its computations
[3059.60s -> 3061.60s]  on A0 and so things are
[3061.60s -> 3063.60s]  good and we're also not
[3063.60s -> 3065.60s]  it's a leaf function
[3065.60s -> 3067.60s]  so if you see the term
[3067.60s -> 3069.60s]  leaf function that's a function that doesn't call another
[3069.60s -> 3071.60s]  function and leaf functions
[3071.60s -> 3073.60s]  are special in that they
[3073.60s -> 3075.60s]  don't need to worry about
[3075.60s -> 3077.60s]  saving their own
[3077.60s -> 3079.60s]  return address or saving
[3079.60s -> 3081.60s]  really any of the caller saved registers
[3081.60s -> 3083.60s]  because
[3083.60s -> 3085.60s]  they're going to
[3085.60s -> 3087.60s]  make another function call so they don't have to be
[3087.60s -> 3089.60s]  as careful. SumThenDouble
[3089.60s -> 3091.60s]  on the other hand is
[3091.60s -> 3093.60s]  not a leaf function so you can see here
[3093.60s -> 3095.60s]  it calls
[3095.60s -> 3097.60s]  sum2
[3097.60s -> 3099.60s]  and so it does need to include
[3099.60s -> 3101.60s]  that prologue and so we see
[3101.60s -> 3103.60s]  here that we are subtracting
[3103.60s -> 3105.60s]  16 from the stack pointer
[3105.60s -> 3107.60s]  so we're making space
[3107.60s -> 3109.60s]  on our stack, we're storing
[3109.60s -> 3111.60s]  the return address for SumThenDouble
[3111.60s -> 3113.60s]  on the stack
[3113.60s -> 3115.60s]  and then we make our call to sum2
[3115.60s -> 3117.60s]  and after that all this function
[3117.60s -> 3119.60s]  does is it calls sum2 and then
[3119.60s -> 3121.60s]  doubles the result
[3121.60s -> 3123.60s]  doubles the result returned by
[3123.60s -> 3125.60s]  sum2 and here you can see
[3125.60s -> 3127.60s]  the epilogue so we load
[3127.60s -> 3129.60s]  the return address
[3129.60s -> 3131.60s]  back into RA
[3131.60s -> 3133.60s]  and delete our stack
[3133.60s -> 3135.60s]  frame and then jump out of the
[3135.60s -> 3137.60s]  function
[3137.60s -> 3139.60s]  and so we can run that
[3139.60s -> 3141.60s]  to make sure it does what we would expect
[3143.60s -> 3145.60s]  here
[3147.60s -> 3149.60s]  we can run
[3149.60s -> 3151.60s]  so if we run demo1
[3151.60s -> 3153.60s]  we got a result of 15
[3153.60s -> 3155.60s]  with a sum and I'll tell you that demo2
[3155.60s -> 3157.60s]  just calls SumThenDouble
[3157.60s -> 3159.60s]  and indeed it happily
[3159.60s -> 3161.60s]  doubles the sum
[3161.60s -> 3163.60s]  returned by sum2
[3163.60s -> 3165.60s]  and so
[3165.60s -> 3167.60s]  a question I have for anybody
[3167.60s -> 3169.60s]  what happens
[3169.60s -> 3171.60s]  if we delete
[3171.60s -> 3173.60s]  this prologue
[3173.60s -> 3175.60s]  and epilogue
[3175.60s -> 3177.60s]  what happens if we just have this
[3177.60s -> 3179.60s]  as our function SumThenDouble
[3179.60s -> 3181.60s]  can anybody predict what's going to happen
[3185.60s -> 3187.60s]  I mean one thing is that SumThenDouble
[3187.60s -> 3189.60s]  wouldn't know the return
[3189.60s -> 3191.60s]  address that it should return to
[3191.60s -> 3193.60s]  so upon calling sum2
[3193.60s -> 3195.60s]  that's going to override
[3195.60s -> 3197.60s]  the return address to be SumThenDouble
[3197.60s -> 3199.60s]  so at the end of SumThenDouble
[3199.60s -> 3201.60s]  it's not going to return to its original call
[3201.60s -> 3203.60s]  yeah exactly
[3203.60s -> 3205.60s]  and we can see
[3205.60s -> 3207.60s]  that that's what happens
[3207.60s -> 3209.60s]  again so
[3209.60s -> 3211.60s]  if we exit out of this
[3211.60s -> 3213.60s]  and we exit out of this
[3213.60s -> 3215.60s]  and we recompile
[3215.60s -> 3217.60s]  now with our broken function
[3217.60s -> 3219.60s]  we can take a look
[3219.60s -> 3221.60s]  at exactly what's going to happen
[3221.60s -> 3223.60s]  so we can actually set our breakpoint
[3223.60s -> 3225.60s]  for SumThenDouble
[3225.60s -> 3227.60s]  and
[3227.60s -> 3229.60s]  set up
[3229.60s -> 3231.60s]  tui
[3231.60s -> 3233.60s]  and let it continue
[3233.60s -> 3235.60s]  so if we now run demo2
[3235.60s -> 3237.60s]  okay we're at SumThenDouble
[3237.60s -> 3239.60s]  and again this is an
[3239.60s -> 3241.60s]  assembly only function so
[3241.60s -> 3243.60s]  we're going to want to look at it in assembly
[3243.60s -> 3245.60s]  so we'll do layout asm
[3245.60s -> 3247.60s]  layout reg
[3247.60s -> 3249.60s]  because it's important what's in the registers in this case
[3249.60s -> 3251.60s]  and you'll see that
[3251.60s -> 3253.60s]  gdb knows a whole bunch of extra information
[3253.60s -> 3255.60s]  and so we can see that
[3257.60s -> 3259.60s]  we can see that ra
[3259.60s -> 3261.60s]  currently so the return address currently
[3261.60s -> 3263.60s]  points to demo2
[3263.60s -> 3265.60s]  plus 18 so
[3265.60s -> 3267.60s]  it points effectively into the function
[3267.60s -> 3269.60s]  demo2
[3269.60s -> 3271.60s]  and now we can run
[3271.60s -> 3273.60s]  we can just kind of
[3273.60s -> 3275.60s]  step through our function and see what happens
[3277.60s -> 3279.60s]  so we've called sum2
[3279.60s -> 3281.60s]  and immediately we can see that the return address
[3281.60s -> 3283.60s]  was overwritten by
[3283.60s -> 3285.60s]  sum2 to now point to
[3285.60s -> 3287.60s]  SumThenDouble plus 4 which makes
[3287.60s -> 3289.60s]  sense you know that's what we'd expect if
[3289.60s -> 3291.60s]  we go back into our code we call sum2
[3291.60s -> 3293.60s]  and so sum2 should return
[3293.60s -> 3295.60s]  to here
[3295.60s -> 3297.60s]  and now we can
[3297.60s -> 3299.60s]  step through
[3299.60s -> 3301.60s]  you know so on
[3301.60s -> 3303.60s]  and then we get
[3303.60s -> 3305.60s]  back into
[3305.60s -> 3307.60s]  whoops
[3307.60s -> 3309.60s]  the wrong
[3309.60s -> 3311.60s]  s
[3317.60s -> 3319.60s]  okay so now we're here and now
[3319.60s -> 3321.60s]  when SumThenDouble returns
[3321.60s -> 3323.60s]  as exactly as Amir pointed out
[3323.60s -> 3325.60s]  its return
[3325.60s -> 3327.60s]  it has not restored its own return address
[3327.60s -> 3329.60s]  and instead its return address
[3329.60s -> 3331.60s]  is still the one that was used by
[3331.60s -> 3333.60s]  sum2
[3333.60s -> 3335.60s]  and so we will get
[3335.60s -> 3337.60s]  into an infinite loop where we
[3337.60s -> 3339.60s]  just keep doing this
[3339.60s -> 3341.60s]  over and over and over again
[3341.60s -> 3343.60s]  and we'll never terminate from it
[3343.60s -> 3345.60s]  and so this is a I think this is
[3345.60s -> 3347.60s]  a good illustration of why it's important
[3347.60s -> 3349.60s]  to keep track of our caller versus
[3349.60s -> 3351.60s]  callee saved registers
[3351.60s -> 3353.60s]  and hopefully this also shows that you can
[3353.60s -> 3355.60s]  use kind of gdb to
[3355.60s -> 3357.60s]  debug these sorts of
[3357.60s -> 3359.60s]  these sorts of problems so let's
[3359.60s -> 3361.60s]  restore what we had
[3361.60s -> 3363.60s]  and we'll go into some
[3363.60s -> 3365.60s]  other demos to
[3365.60s -> 3367.60s]  talk about
[3367.60s -> 3369.60s]  to illustrate
[3369.60s -> 3371.60s]  somebody asked why are we subtracting
[3371.60s -> 3373.60s]  16 that's to put
[3373.60s -> 3375.60s]  space to get our stack frame
[3375.60s -> 3377.60s]  so this is
[3377.60s -> 3379.60s]  subtracting 16 from the stack pointer
[3379.60s -> 3381.60s]  so it's moving it down basically in memory
[3381.60s -> 3383.60s]  moving
[3383.60s -> 3385.60s]  it down so that we now have space for our own
[3385.60s -> 3387.60s]  stack frame and then we can stick stuff there
[3387.60s -> 3389.60s]  so because at this
[3389.60s -> 3391.60s]  point in stack we don't want to override
[3391.60s -> 3393.60s]  what's at the stack pointer
[3393.60s -> 3395.60s]  why not for
[3395.60s -> 3397.60s]  just
[3397.60s -> 3399.60s]  for
[3399.60s -> 3401.60s]  we need to do 16
[3401.60s -> 3403.60s]  because instructions are 64
[3407.60s -> 3409.60s]  yeah I guess I guess we wouldn't
[3409.60s -> 3411.60s]  actually need to do 16
[3411.60s -> 3413.60s]  but that's generally what you'll see
[3413.60s -> 3415.60s]  you'll generally
[3415.60s -> 3417.60s]  just I don't think yeah
[3417.60s -> 3419.60s]  you can't you can't do 4
[3419.60s -> 3421.60s]  because you need 8
[3421.60s -> 3423.60s]  the 4 doesn't work but I think you can do
[3423.60s -> 3425.60s]  you need the
[3425.60s -> 3427.60s]  instruction size and the size of the
[3427.60s -> 3429.60s]  register right so registers are 64
[3429.60s -> 3431.60s]  yeah and then so the convention why
[3431.60s -> 3433.60s]  you usually see 16 is because if we
[3433.60s -> 3435.60s]  jump back to our document usually
[3435.60s -> 3437.60s]  we have the return address and the frame pointer
[3437.60s -> 3439.60s]  but we're not doing that
[3439.60s -> 3441.60s]  here because we're being
[3441.60s -> 3443.60s]  not super careful
[3443.60s -> 3445.60s]  with our assembly
[3445.60s -> 3447.60s]  so normally if we if we look in
[3447.60s -> 3449.60s]  I'm sure if we
[3449.60s -> 3451.60s]  look in kernel.asm we'll see
[3451.60s -> 3453.60s]  yeah so if we look in
[3453.60s -> 3455.60s]  kernel.asm we see
[3455.60s -> 3457.60s]  it's also you know 16 this is generally what
[3457.60s -> 3459.60s]  you'll see with the compiler
[3461.60s -> 3463.60s]  okay
[3463.60s -> 3465.60s]  so now we can
[3467.60s -> 3469.60s]  go back to this
[3469.60s -> 3471.60s]  fix our function
[3471.60s -> 3473.60s]  and now we can look at some C code
[3475.60s -> 3477.60s]  all right
[3477.60s -> 3479.60s]  so here we have
[3479.60s -> 3481.60s]  demo 4 which
[3481.60s -> 3483.60s]  is just basically
[3483.60s -> 3485.60s]  a copy of a main function
[3485.60s -> 3487.60s]  like an imitation of
[3487.60s -> 3489.60s]  the main function so
[3489.60s -> 3491.60s]  we have our
[3491.60s -> 3493.60s]  args which is an array of
[3493.60s -> 3495.60s]  strings and we have
[3495.60s -> 3497.60s]  dummy main which takes
[3497.60s -> 3499.60s]  a number of arguments and the
[3499.60s -> 3501.60s]  argument string and just prints it out
[3501.60s -> 3503.60s]  for us
[3503.60s -> 3505.60s]  and so that's all that's that's all that's happening
[3505.60s -> 3507.60s]  here it's pretty straightforward
[3507.60s -> 3509.60s]  if we set
[3509.60s -> 3511.60s]  a breakpoint in
[3511.60s -> 3513.60s]  dummy main
[3513.60s -> 3515.60s]  and we
[3515.60s -> 3517.60s]  hop over
[3517.60s -> 3519.60s]  let this
[3519.60s -> 3521.60s]  okay we let this continue
[3521.60s -> 3523.60s]  and we start this we run
[3523.60s -> 3525.60s]  down before okay so we
[3525.60s -> 3527.60s]  now we've hit dummy main
[3527.60s -> 3529.60s]  and there's a couple of
[3529.60s -> 3531.60s]  important things
[3531.60s -> 3533.60s]  to remember
[3533.60s -> 3535.60s]  about
[3535.60s -> 3537.60s]  that you can use UDB for regarding
[3537.60s -> 3539.60s]  stack frames so if we type
[3539.60s -> 3541.60s]  i so again that's info
[3541.60s -> 3543.60s]  if we type iframe
[3543.60s -> 3545.60s]  we can see a whole bunch of useful
[3545.60s -> 3547.60s]  information about the current
[3547.60s -> 3549.60s]  stack frame so we can see we're at
[3549.60s -> 3551.60s]  stack level zero level zero means
[3551.60s -> 3553.60s]  it's furthest down in
[3553.60s -> 3555.60s]  the call stack that we can go
[3555.60s -> 3557.60s]  and the frame is at this
[3557.60s -> 3559.60s]  address
[3559.60s -> 3561.60s]  we have a program counter which
[3561.60s -> 3563.60s]  is okay that's all well and good
[3563.60s -> 3565.60s]  we have a safe program counter as well
[3565.60s -> 3567.60s]  and if we again if we
[3567.60s -> 3569.60s]  take this address and we
[3569.60s -> 3571.60s]  jump into
[3571.60s -> 3573.60s]  kernel.asm
[3573.60s -> 3575.60s]  and we search for that address
[3575.60s -> 3577.60s]  we can indeed
[3577.60s -> 3579.60s]  that that address
[3579.60s -> 3581.60s]  is inside of
[3581.60s -> 3583.60s]  inside
[3583.60s -> 3585.60s]  of demo4 which is exactly where we
[3585.60s -> 3587.60s]  expect the program
[3587.60s -> 3589.60s]  to and it was called
[3589.60s -> 3591.60s]  by a frame at this address
[3591.60s -> 3593.60s]  source language C you know that's
[3593.60s -> 3595.60s]  that's nice to know and
[3595.60s -> 3597.60s]  then we have the argument list also
[3597.60s -> 3599.60s]  starts at this address
[3599.60s -> 3601.60s]  of course in this case
[3601.60s -> 3603.60s]  we have most of our arguments
[3603.60s -> 3605.60s]  in registers and
[3605.60s -> 3607.60s]  then we can even see what the args are
[3607.60s -> 3609.60s]  we mean argc is
[3609.60s -> 3611.60s]  three and argv
[3611.60s -> 3613.60s]  is this address
[3613.60s -> 3615.60s]  and if we want a more
[3615.60s -> 3617.60s]  in-depth examine things
[3617.60s -> 3619.60s]  we can look at things like
[3619.60s -> 3621.60s]  info.arsc which
[3621.60s -> 3623.60s]  will tell us information about the arguments
[3623.60s -> 3625.60s]  to the function we can
[3625.60s -> 3627.60s]  look at but more
[3627.60s -> 3629.60s]  importantly we can
[3629.60s -> 3631.60s]  type if we type backtrace
[3631.60s -> 3633.60s]  or bt works as well
[3633.60s -> 3635.60s]  we get a full backtrace
[3635.60s -> 3637.60s]  of all of the
[3637.60s -> 3639.60s]  stacks the all of the
[3639.60s -> 3641.60s]  stack frames from the call
[3641.60s -> 3643.60s]  stack so you can see you know something questionable
[3643.60s -> 3645.60s]  happened here that's when we invoked a system
[3645.60s -> 3647.60s]  call then we get
[3647.60s -> 3649.60s]  to the user trap function then
[3649.60s -> 3651.60s]  to the syscall function then
[3651.60s -> 3653.60s]  to sysdemo then to demo4
[3653.60s -> 3655.60s]  and then
[3655.60s -> 3657.60s]  finally to dummy main
[3657.60s -> 3659.60s]  and if we want to investigate
[3659.60s -> 3661.60s]  any of these stack frames more in
[3661.60s -> 3663.60s]  depth we can do frame
[3663.60s -> 3665.60s]  and then whatever number
[3665.60s -> 3667.60s]  is along the side here so let's say I want
[3667.60s -> 3669.60s]  to look at what was my stack frame
[3669.60s -> 3671.60s]  when syscall got called I can go to frame
[3671.60s -> 3673.60s]  three and so now
[3673.60s -> 3675.60s]  inside of gdb I'm looking at that stack
[3675.60s -> 3677.60s]  frame so if I type info frame
[3677.60s -> 3679.60s]  I can get this
[3679.60s -> 3681.60s]  and here we get a lot more
[3681.60s -> 3683.60s]  information we have a bunch of saved
[3683.60s -> 3685.60s]  registers
[3685.60s -> 3687.60s]  we have some local
[3687.60s -> 3689.60s]  variables we don't have any
[3689.60s -> 3691.60s]  arguments to this function we
[3691.60s -> 3693.60s]  can see where the program counter where we're
[3693.60s -> 3695.60s]  supposed to jump back to all
[3695.60s -> 3697.60s]  kinds of things like that so this is super super
[3697.60s -> 3699.60s]  useful for if you're debugging things
[3699.60s -> 3701.60s]  in fact it's so useful we make you
[3701.60s -> 3703.60s]  implement your own version
[3703.60s -> 3705.60s]  nowhere near as
[3705.60s -> 3707.60s]  in depth as what gdb tells you
[3707.60s -> 3709.60s]  but one of the exercises
[3709.60s -> 3711.60s]  on the next lab will be to implement
[3711.60s -> 3713.60s]  your own backtrace
[3713.60s -> 3715.60s]  helper function for use when debugging
[3715.60s -> 3717.60s]  things inside the lab
[3717.60s -> 3719.60s]  and so backtrace is
[3719.60s -> 3721.60s]  quite useful and then if we type frame
[3721.60s -> 3723.60s]  zero we go back to where we
[3723.60s -> 3725.60s]  were supposed to be
[3725.60s -> 3727.60s]  and if we
[3727.60s -> 3729.60s]  want to investigate you probably noticed it's not
[3729.60s -> 3731.60s]  super helpful you know argv is a string
[3731.60s -> 3733.60s]  as an array of
[3733.60s -> 3735.60s]  strings and so we just get a
[3735.60s -> 3737.60s]  we just get an address
[3737.60s -> 3739.60s]  for where that's actually stored
[3739.60s -> 3741.60s]  and if we want to look at what's in there there's a couple
[3741.60s -> 3743.60s]  ways of doing this
[3743.60s -> 3745.60s]  the easiest is if we
[3745.60s -> 3747.60s]  type print p is for print
[3747.60s -> 3749.60s]  and then if we
[3749.60s -> 3751.60s]  dereference the address
[3751.60s -> 3753.60s]  so we go look at what's at the address
[3753.60s -> 3755.60s]  we can do that
[3755.60s -> 3757.60s]  and you know as you would expect
[3757.60s -> 3759.60s]  we get the first element
[3759.60s -> 3761.60s]  of that array because
[3761.60s -> 3763.60s]  when it tries to print a string it'll go
[3763.60s -> 3765.60s]  as c says it'll go until it hits
[3765.60s -> 3767.60s]  the null character so we get
[3767.60s -> 3769.60s]  foo which is the first element in that array and if we want to get
[3769.60s -> 3771.60s]  more things we can
[3771.60s -> 3773.60s]  put in the length so if we do
[3773.60s -> 3775.60s]  s and then a number it'll go up to a certain
[3775.60s -> 3777.60s]  index so then we can see
[3777.60s -> 3779.60s]  both of the strings here
[3779.60s -> 3781.60s]  and again
[3781.60s -> 3783.60s]  gdb is quite smart so we can
[3783.60s -> 3785.60s]  even use argc
[3785.60s -> 3787.60s]  to print out the whole argument
[3787.60s -> 3789.60s]  array and so
[3789.60s -> 3791.60s]  all of that information is
[3791.60s -> 3793.60s]  available to you
[3793.60s -> 3795.60s]  however you want to get
[3795.60s -> 3797.60s]  it so gdb is a super powerful tool
[3797.60s -> 3799.60s]  why does gdb
[3799.60s -> 3801.60s]  or sorry why does the compiler
[3801.60s -> 3803.60s]  sometimes optimize out
[3803.60s -> 3805.60s]  argc and
[3805.60s -> 3807.60s]  argv that has happened to me before
[3807.60s -> 3809.60s]  yeah that just means that the
[3809.60s -> 3811.60s]  compiler found a more efficient way
[3811.60s -> 3813.60s]  likely it just got rid of the variable
[3813.60s -> 3815.60s]  and it's doing all of its operations
[3815.60s -> 3817.60s]  directly via
[3817.60s -> 3819.60s]  it might be doing all of its operations
[3819.60s -> 3821.60s]  on a0 for example
[3821.60s -> 3823.60s]  it might just be doing all of its computations
[3823.60s -> 3825.60s]  on the return address it's pretty common
[3825.60s -> 3827.60s]  to see something like that if you
[3827.60s -> 3829.60s]  if it's a variable that's not
[3829.60s -> 3831.60s]  100% necessary
[3831.60s -> 3833.60s]  if you
[3833.60s -> 3835.60s]  we don't give you control over
[3835.60s -> 3837.60s]  the compiler but if you ever find that in your day
[3837.60s -> 3839.60s]  to day you can try setting
[3839.60s -> 3841.60s]  the optimization flag for
[3841.60s -> 3843.60s]  the compiler to 0
[3843.60s -> 3845.60s]  but even then the compiler
[3845.60s -> 3847.60s]  will do some level
[3847.60s -> 3849.60s]  of optimization
[3849.60s -> 3851.60s]  bibek your hand is raised
[3851.60s -> 3853.60s]  yeah
[3853.60s -> 3855.60s]  what's the address besides
[3855.60s -> 3857.60s]  that $1 or $2
[3857.60s -> 3859.60s]  you know like before foo
[3859.60s -> 3861.60s]  or bar? $this
[3861.60s -> 3863.60s]  yeah so what's that address
[3863.60s -> 3865.60s]  is that the address where
[3865.60s -> 3867.60s]  foo is?
[3867.60s -> 3869.60s]  yeah
[3869.60s -> 3871.60s]  but then argv points to
[3871.60s -> 3873.60s]  some other address shouldn't those be the
[3873.60s -> 3875.60s]  same?
[3875.60s -> 3877.60s]  so argv is on the
[3877.60s -> 3879.60s]  stack
[3879.60s -> 3881.60s]  and it'll
[3881.60s -> 3883.60s]  so the reason why if you look at these
[3883.60s -> 3885.60s]  addresses we can see that they're in the kernel
[3885.60s -> 3887.60s]  just by the
[3887.60s -> 3889.60s]  8000
[3889.60s -> 3891.60s]  which makes sense because
[3891.60s -> 3893.60s]  they're declared statically right so
[3893.60s -> 3895.60s]  in demos if I go here they're declared here
[3895.60s -> 3897.60s]  and so they're basically they're sitting somewhere in the kernel
[3897.60s -> 3899.60s]  and they're all car stars
[3899.60s -> 3901.60s]  argv
[3901.60s -> 3903.60s]  is an array of car stars
[3903.60s -> 3905.60s]  and so I imagine each element
[3905.60s -> 3907.60s]  points to
[3907.60s -> 3909.60s]  points to
[3909.60s -> 3911.60s]  disown string right
[3911.60s -> 3913.60s]  it's an array of pointers
[3913.60s -> 3915.60s]  I see
[3925.60s -> 3927.60s]  I also have a question about this
[3927.60s -> 3929.60s]  the $3 version of
[3929.60s -> 3931.60s]  the array
[3931.60s -> 3933.60s]  has
[3933.60s -> 3935.60s]  if I look at these addresses
[3935.60s -> 3937.60s]  the first one is
[3937.60s -> 3939.60s]  suffixed by 38
[3939.60s -> 3941.60s]  the second one is suffixed by 40
[3941.60s -> 3943.60s]  and the third one is
[3943.60s -> 3945.60s]  48
[3945.60s -> 3947.60s]  which is not uniform
[3947.60s -> 3949.60s]  even though the length of each
[3949.60s -> 3951.60s]  the three arguments
[3951.60s -> 3953.60s]  is 3
[3953.60s -> 3955.60s]  why are they different
[3955.60s -> 3957.60s]  I'm not 100%
[3957.60s -> 3959.60s]  certain my guess is that this
[3959.60s -> 3961.60s]  is an attempt to align things
[3961.60s -> 3963.60s]  right
[3963.60s -> 3965.60s]  so to get them
[3965.60s -> 3967.60s]  on a reasonable alignment
[3967.60s -> 3969.60s]  it is uniform
[3969.60s -> 3971.60s]  as people are pointing out
[3971.60s -> 3973.60s]  oh
[3973.60s -> 3975.60s]  right yeah that makes sense
[3975.60s -> 3977.60s]  oh yes I see it now
[3977.60s -> 3979.60s]  right thanks
[3979.60s -> 3981.60s]  so you'll sometimes see where things are
[3981.60s -> 3983.60s]  laid out strangely
[3983.60s -> 3985.60s]  where there might be two things at strange offsets
[3985.60s -> 3987.60s]  and that's just because not everything is
[3987.60s -> 3989.60s]  naturally the same size
[3989.60s -> 3991.60s]  okay
[3991.60s -> 3993.60s]  any other questions
[3999.60s -> 4001.60s]  okay
[4001.60s -> 4003.60s]  we can skip the fifth demo
[4003.60s -> 4005.60s]  and
[4005.60s -> 4007.60s]  so another useful function that we get
[4007.60s -> 4009.60s]  from GDB are
[4009.60s -> 4011.60s]  instead
[4011.60s -> 4013.60s]  of just breakpoints
[4013.60s -> 4015.60s]  there are also watchpoints
[4015.60s -> 4017.60s]  and we can also set
[4017.60s -> 4019.60s]  conditional breakpoints
[4019.60s -> 4021.60s]  so
[4021.60s -> 4023.60s]  I'll just briefly go over that
[4025.60s -> 4027.60s]  we run demo6
[4027.60s -> 4029.60s]  so we can set
[4029.60s -> 4031.60s]  inside this function we can watch
[4031.60s -> 4033.60s]  so we can set a watchpoint
[4033.60s -> 4035.60s]  I think here you'll see
[4035.60s -> 4037.60s]  um
[4037.60s -> 4039.60s]  yeah
[4039.60s -> 4041.60s]  so here you'll see what
[4041.60s -> 4043.60s]  Luca was talking about where
[4043.60s -> 4045.60s]  we see that sum has been optimized
[4045.60s -> 4047.60s]  out likely because it's just being
[4047.60s -> 4049.60s]  put in a zero or something
[4049.60s -> 4051.60s]  we can look even at
[4051.60s -> 4053.60s]  the assembly for this right so we can
[4053.60s -> 4055.60s]  layout
[4055.60s -> 4057.60s]  splits and
[4057.60s -> 4059.60s]  indeed we can see that it's all just being
[4059.60s -> 4061.60s]  it's all just being done on the stack
[4061.60s -> 4063.60s]  it looks like to me
[4063.60s -> 4065.60s]  oh no it's all just being done in S0
[4065.60s -> 4067.60s]  S013 so here you
[4067.60s -> 4069.60s]  can see that the
[4069.60s -> 4071.60s]  compiler decided
[4071.60s -> 4073.60s]  even to use the quality saved registers
[4073.60s -> 4075.60s]  and
[4075.60s -> 4077.60s]  so we can set things like
[4077.60s -> 4079.60s]  we can do watch
[4079.60s -> 4081.60s]  on I
[4081.60s -> 4083.60s]  or we haven't declared
[4083.60s -> 4085.60s]  I yet because we're not inside
[4085.60s -> 4087.60s]  we're not inside
[4087.60s -> 4089.60s]  the for loop so if we
[4089.60s -> 4091.60s]  step through the C instructions
[4091.60s -> 4093.60s]  now if we do
[4093.60s -> 4095.60s]  the locals we see we get
[4095.60s -> 4097.60s]  I we can even watch
[4097.60s -> 4099.60s]  watchpoint on
[4099.60s -> 4101.60s]  sum so
[4101.60s -> 4103.60s]  now anytime that sum changes
[4103.60s -> 4105.60s]  we'll actually get
[4105.60s -> 4107.60s]  a notification so we can continue
[4107.60s -> 4109.60s]  and then
[4109.60s -> 4111.60s]  we'll get a delete here because sum
[4111.60s -> 4113.60s]  has been removed so we can't
[4113.60s -> 4115.60s]  we can't actually watch it
[4115.60s -> 4117.60s]  we can even do things like
[4117.60s -> 4119.60s]  breakpoint
[4119.60s -> 4121.60s]  on sum two so this is a conditional
[4121.60s -> 4123.60s]  breakpoint if
[4123.60s -> 4125.60s]  well let's actually see what is
[4125.60s -> 4127.60s]  I currently so I is currently one
[4127.60s -> 4129.60s]  let's say I think my
[4129.60s -> 4131.60s]  loop is breaking and whenever I
[4131.60s -> 4133.60s]  is five well if I want to
[4133.60s -> 4135.60s]  specifically debug that case
[4135.60s -> 4137.60s]  I can set a breakpoint
[4137.60s -> 4139.60s]  on
[4139.60s -> 4141.60s]  sum two
[4141.60s -> 4143.60s]  if I
[4143.60s -> 4145.60s]  equals five
[4145.60s -> 4147.60s]  so now we have
[4147.60s -> 4149.60s]  this breakpoint and if we continue
[4149.60s -> 4151.60s]  along we'll get to sum two
[4151.60s -> 4153.60s]  and we can see that
[4153.60s -> 4155.60s]  it actually printed out the
[4155.60s -> 4157.60s]  first couple values and so we
[4157.60s -> 4159.60s]  only break now on sum two
[4159.60s -> 4161.60s]  if
[4161.60s -> 4163.60s]  I if we hit that breakpoint condition
[4163.60s -> 4165.60s]  and so that's
[4165.60s -> 4167.60s]  this can be again it's going to be useful if you
[4167.60s -> 4169.60s]  want to debug specific edge cases of your
[4169.60s -> 4171.60s]  code and watchpoints can be useful
[4171.60s -> 4173.60s]  if for instance
[4173.60s -> 4175.60s]  you think that something shouldn't be changing
[4175.60s -> 4177.60s]  what you suspect that it is
[4177.60s -> 4179.60s]  or you think that something is going wrong
[4179.60s -> 4181.60s]  every time you change a certain
[4181.60s -> 4183.60s]  variable
[4183.60s -> 4185.60s]  and so that's one
[4185.60s -> 4187.60s]  usage for that
[4187.60s -> 4189.60s]  and the last thing I want to talk about
[4189.60s -> 4191.60s]  today is structs
[4191.60s -> 4193.60s]  structs are pretty important
[4193.60s -> 4195.60s]  and they'll come up in
[4195.60s -> 4197.60s]  in the labs
[4197.60s -> 4199.60s]  often and
[4199.60s -> 4201.60s]  also
[4201.60s -> 4203.60s]  I'll talk a little bit about
[4203.60s -> 4205.60s]  the way structs are laid out in
[4205.60s -> 4207.60s]  memory
[4207.60s -> 4209.60s]  and so a struct is basically
[4209.60s -> 4211.60s]  it's a continuous
[4211.60s -> 4213.60s]  area of memory so if we have some struct
[4213.60s -> 4215.60s]  and
[4215.60s -> 4217.60s]  we have like field one
[4217.60s -> 4219.60s]  field two field three
[4219.60s -> 4221.60s]  when we make that
[4221.60s -> 4223.60s]  struct those fields are going to be aligned
[4223.60s -> 4225.60s]  next to each other
[4225.60s -> 4227.60s]  in memory so you can kind of think of this
[4227.60s -> 4229.60s]  like an array but F1
[4229.60s -> 4231.60s]  F2 and F3 can all be different types
[4231.60s -> 4233.60s]  and
[4233.60s -> 4235.60s]  we can pass them
[4235.60s -> 4237.60s]  as functions usually they're passed
[4237.60s -> 4239.60s]  pass them as arguments to functions
[4239.60s -> 4241.60s]  usually they're passed by reference
[4241.60s -> 4243.60s]  so here I've made a struct person
[4243.60s -> 4245.60s]  with two integer arguments
[4245.60s -> 4247.60s]  and
[4247.60s -> 4249.60s]  I'm passing them
[4249.60s -> 4251.60s]  passing a person as an argument to print person
[4251.60s -> 4253.60s]  and
[4253.60s -> 4255.60s]  printing out some of that information
[4255.60s -> 4257.60s]  so if we hop into
[4257.60s -> 4259.60s]  GDB and let's delete all of our
[4259.60s -> 4261.60s]  watchpoints and now we can
[4261.60s -> 4263.60s]  set a breakpoint as
[4263.60s -> 4265.60s]  person
[4265.60s -> 4267.60s]  and
[4267.60s -> 4269.60s]  one
[4269.60s -> 4271.60s]  demo
[4271.60s -> 4273.60s]  we can see that now we're here and so if we type
[4273.60s -> 4275.60s]  iframe we can see
[4275.60s -> 4277.60s]  that we have an
[4277.60s -> 4279.60s]  argument P
[4279.60s -> 4281.60s]  and indeed
[4281.60s -> 4283.60s]  if we do print
[4283.60s -> 4285.60s]  P
[4285.60s -> 4287.60s]  we can even tell that it's a struct person
[4287.60s -> 4289.60s]  with its address
[4289.60s -> 4291.60s]  and we can
[4291.60s -> 4293.60s]  if we dereference it
[4293.60s -> 4295.60s]  GDB will tell us exactly
[4295.60s -> 4297.60s]  what P looks like
[4297.60s -> 4299.60s]  it has id 1215
[4299.60s -> 4301.60s]  age is 22
[4301.60s -> 4303.60s]  and just to show kind of how things
[4303.60s -> 4305.60s]  are laid out
[4305.60s -> 4307.60s]  we can take this address
[4307.60s -> 4309.60s]  and we do x
[4309.60s -> 4311.60s]  e at this address
[4311.60s -> 4313.60s]  we look
[4313.60s -> 4315.60s]  8
[4315.60s -> 4317.60s]  x 8
[4317.60s -> 4319.60s]  I can't remember exactly
[4319.60s -> 4321.60s]  should be
[4325.60s -> 4327.60s]  so if we again so we can use
[4327.60s -> 4329.60s]  this to debug our structures
[4329.60s -> 4331.60s]  in
[4331.60s -> 4333.60s]  in the code
[4333.60s -> 4335.60s]  we can take a look at what's
[4335.60s -> 4337.60s]  going on with
[4337.60s -> 4339.60s]  structures this way so GDB
[4339.60s -> 4341.60s]  is a super powerful tool
[4341.60s -> 4343.60s]  not just for stepping
[4343.60s -> 4345.60s]  through code but also for examining
[4345.60s -> 4347.60s]  all kinds of
[4347.60s -> 4349.60s]  potentially problematic
[4349.60s -> 4351.60s]  pieces in your code and looking
[4351.60s -> 4353.60s]  at arguments and stack frames and things
[4353.60s -> 4355.60s]  like that and this will be
[4355.60s -> 4357.60s]  hopefully will be useful in the next
[4357.60s -> 4359.60s]  lab when you have
[4359.60s -> 4361.60s]  to work with stack
[4361.60s -> 4363.60s]  frames and with assembly code
[4363.60s -> 4365.60s]  so that's
[4365.60s -> 4367.60s]  mostly what I wanted to talk about today so
[4367.60s -> 4369.60s]  with the last kind of
[4369.60s -> 4371.60s]  seven minutes of lecture
[4371.60s -> 4373.60s]  I'll open it up to any
[4373.60s -> 4375.60s]  any other questions that you guys have
[4381.60s -> 4383.60s]  I had a bit of a
[4383.60s -> 4385.60s]  tangential question
[4385.60s -> 4387.60s]  who is in who manages
[4387.60s -> 4389.60s]  the creation of compilers
[4389.60s -> 4391.60s]  from like to get from C to various
[4391.60s -> 4393.60s]  instruction set architectures
[4393.60s -> 4395.60s]  is that the creator of the instruction set
[4395.60s -> 4397.60s]  architecture or is it a third party something like that
[4397.60s -> 4399.60s]  I believe
[4399.60s -> 4401.60s]  that it is
[4401.60s -> 4403.60s]  not the creator of the instruction set
[4403.60s -> 4405.60s]  so it's often a third party
[4405.60s -> 4407.60s]  so the two big C compilers
[4407.60s -> 4409.60s]  that you'll see referred to are GCC
[4409.60s -> 4411.60s]  which is maintained by I think
[4411.60s -> 4413.60s]  the GNU Foundation
[4413.60s -> 4415.60s]  and CLang
[4415.60s -> 4417.60s]  or LLVM which is
[4417.60s -> 4419.60s]  its own thing so I think
[4419.60s -> 4421.60s]  you know you can find I believe
[4421.60s -> 4423.60s]  LLVM is even open source so you
[4423.60s -> 4425.60s]  can find
[4425.60s -> 4427.60s]  you can find the code specifically that does this
[4427.60s -> 4429.60s]  when a new instruction
[4429.60s -> 4431.60s]  set is released such as
[4431.60s -> 4433.60s]  RISC-V that calling convention
[4433.60s -> 4435.60s]  document as well as all of those
[4435.60s -> 4437.60s]  instruction documents I
[4437.60s -> 4439.60s]  think are carefully but I assume there's like a high level
[4439.60s -> 4441.60s]  of cooperation between the compiler designer
[4441.60s -> 4443.60s]  and the instruction set designer
[4443.60s -> 4445.60s]  but yeah
[4445.60s -> 4447.60s]  short answer is I believe it's
[4447.60s -> 4449.60s]  a third party who does it likely
[4449.60s -> 4451.60s]  with a lot of cooperation
[4451.60s -> 4453.60s]  from the people who make the instruction set
[4453.60s -> 4455.60s]  RISC-V is probably
[4455.60s -> 4457.60s]  RISC-V might be an exception
[4457.60s -> 4459.60s]  where because it came out of a research project
[4459.60s -> 4461.60s]  they may have written the
[4461.60s -> 4463.60s]  compiler for it themselves
[4463.60s -> 4465.60s]  as well I
[4465.60s -> 4467.60s]  don't think Intel has for example
[4467.60s -> 4469.60s]  has input in
[4469.60s -> 4471.60s]  GCC or LLVM
[4483.60s -> 4485.60s]  other questions?
[4499.60s -> 4501.60s]  okay well
[4501.60s -> 4503.60s]  thanks for listening in that case
[4503.60s -> 4505.60s]  and I guess we can
[4505.60s -> 4507.60s]  we can end the lecture here
[4507.60s -> 4509.60s]  five minutes to spare
[4509.60s -> 4511.60s]  so have a nice rest
[4513.60s -> 4515.60s]  thank you
