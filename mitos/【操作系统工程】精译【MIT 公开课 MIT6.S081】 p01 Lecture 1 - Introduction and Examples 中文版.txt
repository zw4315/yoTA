# Detected language: en (p=1.00)

[0.00s -> 10.60s]  All right.
[10.60s -> 15.16s]  Welcome to 6S081, Operating Systems.
[15.16s -> 15.88s]  I'm Robert.
[15.88s -> 20.48s]  I'll be co-lecturing with Franz and David and Nicholas
[20.48s -> 23.40s]  of the TAs.
[23.40s -> 25.84s]  Please, during these Zoom lectures, ask questions.
[25.84s -> 28.16s]  You can either interrupt me by audio
[28.16s -> 31.28s]  or enter something into the chat window,
[31.28s -> 36.28s]  and one of the staff will see and ask a question for you.
[36.28s -> 38.28s]  By the way, we'll be recording these lectures,
[38.28s -> 39.84s]  and we'll post the recordings later
[39.84s -> 42.56s]  so you can review them more for people
[42.56s -> 44.96s]  who can't make this time so they can nevertheless
[44.96s -> 47.04s]  see the lectures.
[47.04s -> 50.52s]  I want to start by laying out some
[50.52s -> 51.88s]  of the goals of the course.
[51.88s -> 60.04s]  So number one is to understand the design and implementation
[60.04s -> 61.72s]  of operating systems.
[61.72s -> 67.40s]  And the design is sort of high-level structure,
[67.40s -> 70.28s]  and implementation is really about what the code looks
[70.28s -> 74.40s]  like, and we'll be spending a lot of time with both.
[74.40s -> 78.88s]  And in the interest of getting a deep understanding of what's
[78.88s -> 88.48s]  going on, you'll get hands-on experience with a small
[88.48s -> 93.12s]  operating system, the XV6 operating system.
[93.12s -> 95.56s]  And in addition to actually looking at an existing
[95.56s -> 99.52s]  operating system, you'll be in the labs,
[99.52s -> 102.08s]  get a bunch of experience extending the operating system,
[102.08s -> 104.40s]  modifying its, improving its behavior,
[104.40s -> 109.32s]  and writing system software that uses the operating system
[109.32s -> 112.72s]  interfaces, if it were an application.
[112.72s -> 115.44s]  So this is what you're going to be doing in the course.
[119.12s -> 122.40s]  We're also interested in what the purpose of the operating
[122.40s -> 124.20s]  system itself is, as well as of the course.
[127.12s -> 130.92s]  So for that, I have a list of a couple of things,
[130.92s -> 135.40s]  which even though there's lots of different operating
[135.40s -> 137.88s]  systems out there, they typically
[137.88s -> 139.20s]  have a common set of purposes.
[142.48s -> 145.40s]  One of them is to abstract the hardware.
[148.44s -> 150.40s]  That is, what you're given typically
[150.40s -> 152.52s]  as a kind of starting point is you buy a computer,
[152.52s -> 154.20s]  a computer has a CPU and memory,
[154.20s -> 158.04s]  but that's a very low-level set of resources.
[158.04s -> 161.28s]  It's fantastic to have much higher-level interfaces
[161.28s -> 162.72s]  and abstractions that applications
[162.72s -> 167.04s]  can use, such as processes or file systems,
[167.04s -> 170.60s]  both for convenience and for portability.
[170.60s -> 174.04s]  Another very important task of an operating system
[174.04s -> 178.84s]  is to multiplex the hardware among many applications.
[178.84s -> 182.56s]  You might be running a text editor and a compiler,
[182.56s -> 187.52s]  or maybe multiple different database servers or something
[187.52s -> 188.64s]  on your operating system.
[188.64s -> 191.32s]  It's fantastic to be able to have the operating system run
[191.32s -> 193.36s]  both of them at the same time, or all the things
[193.36s -> 194.96s]  are going on at the same time
[194.96s -> 197.72s]  without having them interfere.
[197.72s -> 200.60s]  So that's often called multiplexing.
[200.60s -> 202.88s]  Because there may be a lot of things happening
[202.88s -> 204.68s]  on the operating system at the same time,
[204.68s -> 208.12s]  it's critical that they not interfere unintentionally,
[208.12s -> 209.72s]  even if they have bugs.
[209.72s -> 213.28s]  And that task is called isolation,
[213.32s -> 218.04s]  the idea that different activities should not
[218.04s -> 219.36s]  be allowed to interfere.
[219.36s -> 222.04s]  On the other hand, there are times when different activities
[222.04s -> 223.60s]  would like to interfere or would like
[223.60s -> 225.04s]  to interact or cooperate.
[225.04s -> 228.48s]  So for example, if I create a file with a text editor
[228.48s -> 231.20s]  and I'd like my compiler to read the file,
[231.20s -> 234.36s]  we definitely want to allow that kind of sharing.
[234.36s -> 237.88s]  So we want to allow sharing when it's
[237.88s -> 239.12s]  what the user has in mind.
[239.12s -> 242.28s]  But in many circumstances, the user doesn't want sharing.
[242.28s -> 244.24s]  Maybe you're logged into a timesharing machine
[244.24s -> 246.60s]  like Athena, and you don't want other people
[246.60s -> 248.16s]  to read your files.
[248.16s -> 249.60s]  So we also need as well sharing.
[249.60s -> 252.96s]  We want to not share when we don't want to,
[252.96s -> 256.32s]  which we could call security or a permission system
[256.32s -> 259.92s]  or an access control system.
[259.92s -> 262.08s]  Another thing that people value in operating systems
[262.08s -> 264.24s]  is if you spend a lot of money on hardware
[264.24s -> 266.12s]  or on a computer, you'd like your application
[266.12s -> 267.12s]  to be able to share.
[267.16s -> 269.12s]  On a computer, you'd like your application
[269.12s -> 271.84s]  to be able to get the sort of full performance
[271.84s -> 275.80s]  that the hardware ought to be able to provide.
[275.80s -> 280.20s]  And a lot of that is just application programming.
[280.20s -> 282.60s]  But inevitably, unfortunately, some of it
[282.60s -> 284.64s]  is the operating system has to make sure
[284.64s -> 288.84s]  that whatever services it provides
[288.84s -> 290.88s]  don't get in the way of applications
[290.88s -> 292.52s]  getting high performance.
[292.52s -> 294.44s]  So you want to at least not get in the way
[294.44s -> 296.68s]  and maybe even help applications
[296.68s -> 298.76s]  achieve good performance.
[302.92s -> 307.24s]  Finally, most operating systems have
[307.24s -> 309.40s]  to support a wide range of different applications.
[309.40s -> 312.12s]  Maybe it's a laptop running a text editor.
[312.12s -> 314.04s]  Maybe it's running games.
[314.04s -> 315.32s]  Maybe your operating system needs
[315.32s -> 319.16s]  to support database servers or cloud computation.
[319.16s -> 321.08s]  And usually because operating systems
[321.12s -> 324.92s]  are quite expensive to design and build,
[324.92s -> 326.44s]  people use the same operating systems
[326.44s -> 327.84s]  for many different tasks.
[327.84s -> 329.96s]  Like Linux, for example, which I'm sure many of you
[329.96s -> 333.00s]  are running, is used in all of the situations I mentioned.
[333.00s -> 334.44s]  So the same operating system really
[334.44s -> 339.00s]  has to be able to support a range of often quite
[339.00s -> 339.64s]  different uses.
[343.12s -> 346.28s]  So we're hoping to be able to support
[346.28s -> 350.32s]  all these different goals simultaneously.
[350.32s -> 354.04s]  And we'll hear more about all of them during the course.
[354.04s -> 354.76s]  All right.
[354.76s -> 358.00s]  Operating systems, people have worked out
[358.00s -> 361.80s]  a set of design ideas over the decades
[361.80s -> 366.24s]  that have worked pretty well as ways of organizing things.
[366.24s -> 374.16s]  And I'm going to lay out for you this classic organization,
[374.16s -> 377.92s]  the standard deal for this course.
[377.92s -> 382.32s]  And it's actually quite common around
[382.32s -> 383.52s]  for many operating systems.
[383.52s -> 386.52s]  So this is sort of OS internal organization.
[389.52s -> 391.96s]  The way I think about it is in terms
[391.96s -> 395.96s]  of a box for the computer.
[395.96s -> 398.80s]  The computer sort of comes with a bunch
[398.80s -> 400.96s]  of hardware resources, which I'll put at the bottom.
[400.96s -> 405.52s]  Maybe there's CPU and RAM and a disk for storage
[405.52s -> 408.24s]  and maybe a network interface.
[408.24s -> 412.40s]  This is sort of hardware that's the lowest layer.
[412.40s -> 415.84s]  So if at the top you want to run various applications,
[415.84s -> 417.08s]  maybe a text editor.
[417.08s -> 419.76s]  I happen to use VI as a text editor.
[419.76s -> 421.76s]  If you're going to run a C compiler,
[421.76s -> 424.92s]  CC, maybe run lots of other things.
[424.92s -> 427.08s]  We're going to talk a lot today about the shell, which
[427.08s -> 430.56s]  is the command line interface.
[430.56s -> 433.96s]  So we have all these different programs that are running.
[433.96s -> 437.56s]  And this is the sort of world in which applications run
[437.56s -> 440.72s]  is usually called user space.
[440.72s -> 442.80s]  And as distinct from that, there's
[442.80s -> 447.48s]  a single program, a special program that's always
[447.48s -> 449.40s]  running called the kernel.
[449.40s -> 451.56s]  And the kernel is sort of the guardian
[451.56s -> 453.44s]  of the resources of the computer.
[453.44s -> 456.92s]  It's what first boots up when you turn on the computer.
[456.92s -> 459.80s]  There's just one of it, it maintains data
[459.80s -> 462.40s]  to help it manage each of these processes.
[462.40s -> 464.52s]  And the kernel also maintains lots of data structures
[464.52s -> 470.08s]  to help it interface and all the different kinds of hardware
[470.08s -> 475.68s]  that these user programs need to use.
[475.68s -> 479.64s]  The kernel also has built in a bunch of services.
[479.64s -> 482.08s]  And so for example, there's typically
[482.08s -> 486.28s]  a file system implementation inside the kernel that
[486.28s -> 489.92s]  implements things like file names and file contents
[489.92s -> 492.44s]  and directories and understands
[492.44s -> 494.04s]  how to store the files in the disk.
[494.04s -> 495.52s]  So your programs are going to talk
[495.52s -> 497.12s]  to the file system inside the kernel
[497.12s -> 498.80s]  and the file system implementation
[498.80s -> 501.56s]  is going to talk to the disk.
[501.56s -> 505.44s]  And in this course, what we mostly focus on
[505.44s -> 508.64s]  is all the things that have to happen inside the kernel
[508.64s -> 513.76s]  and on the interfaces between user programs and the kernel,
[513.76s -> 516.80s]  as well as the sort of structure of the software
[516.80s -> 518.28s]  inside the kernel.
[518.28s -> 524.76s]  So we care a lot about these services inside the kernel.
[524.76s -> 526.52s]  One of them is the file system I mentioned.
[526.52s -> 530.64s]  There's also management of processes.
[530.64s -> 533.44s]  Each of these running programs is called a process
[533.44s -> 536.32s]  and it has things like its own memory, for example,
[536.32s -> 539.80s]  as well as a share of the CPU time.
[539.80s -> 547.04s]  So the kernel manages processes as a kernel service.
[548.04s -> 551.76s]  The kernel manages the allocation of memory.
[551.76s -> 554.20s]  The different processes need different amounts of memory.
[554.20s -> 559.64s]  The kernel multiplexes and divides up the memory,
[559.64s -> 564.04s]  allocates the memory among all the different processes.
[570.52s -> 572.80s]  The kernel, as I mentioned, influence the file system.
[572.80s -> 574.96s]  File system really comes in two or three
[575.72s -> 577.16s]  or a bunch of logical parts.
[577.16s -> 579.16s]  But for now, we can think of it in terms
[579.16s -> 582.60s]  of managing file content that's inside files,
[582.60s -> 587.08s]  figuring out where on disk each file's content ought to live.
[587.08s -> 590.52s]  The file system also somewhat separately manages a namespace.
[590.52s -> 592.40s]  Each file has a name and there's
[592.40s -> 594.88s]  a hierarchy of directories.
[594.88s -> 596.80s]  Every directory has a bunch of files in it.
[596.80s -> 600.76s]  All that's managed by the file system.
[600.76s -> 603.56s]  There's typically some sort of security arrangement.
[603.60s -> 607.92s]  Maybe we'll call it access control,
[607.92s -> 610.88s]  by which the kernel decides that when a given process wants
[610.88s -> 614.68s]  to use some resource, maybe read something from the disk
[614.68s -> 616.96s]  or use some memory, the access control machinery
[616.96s -> 619.48s]  inside the kernel is what gets to decide, yes, is that allowed?
[619.48s -> 620.32s]  Is that not allowed?
[620.32s -> 621.76s]  And that can get pretty complicated
[621.76s -> 623.60s]  if we're talking about timesharing systems
[623.60s -> 627.04s]  like Athena systems where each of these processes
[627.04s -> 628.60s]  may be run by a different user
[628.60s -> 630.40s]  and have different access control
[630.40s -> 633.16s]  rules applied to what it's allowed to get at.
[635.04s -> 637.88s]  And in a real full-blown operating system,
[637.88s -> 640.40s]  turns out to be many, many other services.
[640.40s -> 642.84s]  There's typically some way for different processes
[642.84s -> 646.48s]  to talk to each other called inter-process communication.
[646.48s -> 648.80s]  There's typically a whole bunch of software associated
[648.80s -> 652.32s]  with the network, things like the TCP IP protocols
[652.32s -> 654.08s]  for talking to the network.
[656.16s -> 658.48s]  There's typically support for sound cards.
[658.48s -> 661.04s]  There may be drivers for hundreds of different disks
[661.04s -> 662.72s]  and hundreds of different network cards.
[662.72s -> 664.28s]  So in a full-blown operating system,
[664.28s -> 666.36s]  there's a huge amount of stuff here.
[666.36s -> 668.04s]  And this may run to millions of lines
[668.04s -> 669.92s]  of code inside the kernel.
[672.56s -> 673.68s]  So that's sort of a quick overview
[673.68s -> 675.84s]  of what's inside the kernel.
[675.84s -> 678.48s]  We're also interested in how applications
[678.48s -> 682.04s]  interact with the kernel and what that interface looks like.
[682.04s -> 687.04s]  So the usual, so this is the API for the kernel,
[696.84s -> 699.44s]  how applications get out the kernel.
[699.44s -> 701.56s]  Typically that's done with something called system calls.
[701.56s -> 704.16s]  And these are things that look like function calls
[704.16s -> 707.36s]  that programs can make,
[707.36s -> 709.16s]  but actually jump into the kernel
[709.16s -> 713.88s]  and execute a system call implementation in the kernel.
[713.88s -> 715.24s]  I'll talk a bunch about that
[715.24s -> 717.44s]  in the latter part of this lecture.
[717.44s -> 719.52s]  For now, just to give you a flavor here,
[719.52s -> 721.64s]  what a couple of different system calls might look like
[721.64s -> 723.96s]  in the source code of an application.
[726.52s -> 730.96s]  One might be that if an application wants to open a file,
[730.96s -> 733.60s]  it calls the open system call
[733.60s -> 736.92s]  and tells the open system call the name of the file.
[736.96s -> 740.40s]  So maybe it wants to open a file for writing called out
[740.40s -> 742.96s]  and there'll be an extra argument here saying,
[742.96s -> 745.20s]  one in this case saying, I wanna write that file.
[745.20s -> 747.88s]  And so this thing that looks like a function call,
[748.88s -> 751.24s]  it opens the system call is actually special code
[751.24s -> 752.68s]  that jumps into the kernel
[752.68s -> 754.96s]  and the kernel can retrieve these arguments,
[754.96s -> 756.92s]  executes some kernel code that implements open,
[756.92s -> 759.68s]  maybe talks to the disk and then returns a value.
[759.68s -> 761.56s]  And that's this file descriptor
[762.48s -> 765.08s]  as FD stands for file descriptor,
[765.08s -> 768.20s]  which is the program can then use this sort of a handle
[768.20s -> 770.56s]  to refer to this open file.
[772.12s -> 773.32s]  If you wanna write to a file,
[773.32s -> 777.40s]  the system call to do that is called write.
[777.40s -> 779.52s]  You have to pass it one of these file descriptors,
[779.52s -> 781.42s]  the same as was returned by open.
[782.56s -> 785.96s]  These are now arguments that are passed in the system call
[785.96s -> 788.32s]  from the program into the kernel.
[788.32s -> 791.56s]  You give it a pointer to a buffer of characters.
[791.56s -> 794.52s]  So an easy way to do that in the C programming language,
[794.80s -> 797.40s]  which these examples are written by is the double quotes
[797.40s -> 801.08s]  and then the string, the bytes of the string,
[801.08s -> 803.24s]  this backslash n is a new line.
[803.24s -> 806.00s]  And the third argument is the count of characters
[807.16s -> 808.32s]  you wanna write.
[808.32s -> 811.96s]  And so this really gets passed as an address in memory.
[811.96s -> 812.80s]  So you're telling the kernel,
[812.80s -> 815.80s]  look, please write six bytes from this address
[815.80s -> 818.64s]  to the file that this file descriptor refers to.
[820.60s -> 823.52s]  And much more exciting system call that you encounter
[823.52s -> 825.28s]  is the fork system call.
[825.28s -> 828.64s]  Fork is the system call that creates a new process
[830.34s -> 832.64s]  and returns, actually creates a process
[832.64s -> 834.48s]  that's identical to the caller
[834.48s -> 838.84s]  and fork returns an identifier, the process identifier,
[838.84s -> 842.04s]  or PID of the new process.
[842.04s -> 843.36s]  It's actually a little more complicated than that
[843.36s -> 845.58s]  and we'll hear more about this.
[847.08s -> 849.74s]  So again, these are all look like function calls,
[850.60s -> 851.92s]  but the system calls are special
[851.96s -> 854.44s]  because they jumped into the kernel.
[854.44s -> 856.92s]  Now that's just taste, we'll see more later.
[861.96s -> 863.88s]  That is a sort of quick overview.
[865.48s -> 869.52s]  I wanna just mention why I find operating,
[869.52s -> 871.48s]  the study of operating systems
[871.48s -> 876.44s]  to be both challenging and interesting.
[876.68s -> 880.68s]  And why it's maybe worth,
[882.60s -> 885.56s]  intellectually worth taking a course in this area.
[885.56s -> 886.68s]  So one reason why it's hard
[886.68s -> 889.04s]  is that the environment's unforgiving,
[889.96s -> 892.52s]  the programming environment inside the kernel's unforgiving
[892.52s -> 897.52s]  because when you're programming,
[898.04s -> 899.96s]  when you're modifying the kernel or extending the kernel
[899.96s -> 901.96s]  or writing a new operating system kernel,
[901.96s -> 903.52s]  you're providing the infrastructure
[903.52s -> 906.12s]  that everybody else assumes is already present
[906.64s -> 908.28s]  to run their programs.
[908.28s -> 909.72s]  Everybody else gets an operating system
[909.72s -> 910.80s]  under their program
[910.80s -> 912.68s]  when they write ordinary application programs,
[912.68s -> 915.16s]  but when we build operating systems,
[915.16s -> 916.60s]  what we get is the hardware
[916.60s -> 919.48s]  underneath our operating system,
[919.48s -> 921.84s]  which turns out to be more difficult to deal with.
[921.84s -> 926.64s]  In this course, we get to use a hardware simulator
[926.64s -> 931.64s]  called QMU that simulates a CPU and a computer
[932.16s -> 933.38s]  and that makes life a little bit better,
[933.38s -> 936.58s]  but it's still a kind of a difficult environment
[936.58s -> 937.42s]  to program in.
[938.54s -> 940.10s]  Another reason why it's hard and interesting
[940.10s -> 942.78s]  is because if you're designing an operating system,
[942.78s -> 946.54s]  you have to satisfy a bunch of tensions
[946.54s -> 948.14s]  that require real design thought.
[948.14s -> 951.02s]  So one is that you'd like your operating system
[951.02s -> 952.46s]  to be both efficient,
[953.82s -> 955.74s]  which often means that it sort of operates
[955.74s -> 957.90s]  at a low level close to the hardware,
[957.90s -> 959.46s]  but for ease of use
[959.46s -> 962.74s]  and because real live people have to write programs
[962.74s -> 964.10s]  that use your operating system,
[964.10s -> 967.26s]  we'd like it also to be abstract,
[967.26s -> 970.30s]  high level, portable interfaces.
[970.30s -> 973.26s]  And it's a neat trick to provide abstract interfaces
[973.26s -> 975.74s]  that are simple and portable,
[975.74s -> 977.14s]  but that are also efficient.
[978.78s -> 981.66s]  Another tension is that we'd like to provide
[981.66s -> 984.38s]  a very powerful operating system services
[984.38s -> 986.34s]  so that the operating system can shoulder
[986.34s -> 990.54s]  a lot of the burden of running programs.
[990.54s -> 994.02s]  So we'd like a powerful operating system services,
[995.62s -> 999.22s]  but we also wanna have simple interfaces.
[1001.38s -> 1004.26s]  That is we don't want a tremendously complex,
[1004.26s -> 1006.74s]  hard to understand interfaces for programmers to use
[1006.74s -> 1008.78s]  because then they're not gonna understand them
[1008.78s -> 1010.90s]  and they may find it hard to use.
[1012.98s -> 1014.54s]  So this is really simple API.
[1014.54s -> 1019.30s]  And so this is possible to do to provide simple interfaces
[1019.30s -> 1022.66s]  that have powerful machinery inside them.
[1022.66s -> 1026.22s]  And so always be searching for sort of simple interfaces
[1027.10s -> 1030.94s]  that provide powerful services.
[1030.94s -> 1033.90s]  Hey, Robert, we have a question in the chat.
[1033.90s -> 1035.98s]  What is unique slash different about saying
[1035.98s -> 1037.86s]  system calls jump into the kernel,
[1037.86s -> 1040.10s]  i.e. as opposed to a standard function call
[1040.10s -> 1041.70s]  that jumps to another function?
[1044.26s -> 1048.70s]  Well, the kernel is a piece of code
[1048.74s -> 1051.90s]  that's always resident that has special privileges
[1051.90s -> 1055.94s]  that because the machine booted the kernel,
[1056.90s -> 1058.78s]  the kernel has special privileges
[1058.78s -> 1061.46s]  it can get directly at all kinds of hardware
[1061.46s -> 1063.02s]  like the disk device
[1063.02s -> 1065.50s]  that ordinary user programs can't get at.
[1065.50s -> 1068.10s]  So if you make an ordinary function call,
[1070.10s -> 1071.54s]  the function you're calling
[1071.54s -> 1074.18s]  doesn't get any special privileges
[1074.18s -> 1075.74s]  with respect to the hardware.
[1075.74s -> 1078.34s]  Whereas if you make a system call into the kernel,
[1078.86s -> 1080.18s]  we'll talk about how this works,
[1080.18s -> 1084.46s]  but that ends up when the system call
[1084.46s -> 1086.22s]  jumps into the kernel,
[1086.22s -> 1088.10s]  the system call implementation in the kernel
[1088.10s -> 1089.74s]  then gets all these special privileges
[1089.74s -> 1094.42s]  so that it can modify all kinds of sensitive
[1094.42s -> 1097.66s]  and protected hardware resources.
[1097.66s -> 1100.42s]  Like for example, getting directly at the hard disk.
[1102.30s -> 1104.98s]  We'll see a lot more detail for all this shortly.
[1105.98s -> 1108.82s]  Okay, so a final tension that we wanna,
[1108.82s -> 1110.94s]  that all operating systems needs to satisfy
[1110.94s -> 1113.26s]  is you wanna give programs as much flexibility as you can.
[1113.26s -> 1114.66s]  You don't wanna constrain them.
[1114.66s -> 1119.46s]  So you wanna have very flexible interfaces,
[1119.46s -> 1121.46s]  but you do need to constrain programs somewhat
[1121.46s -> 1124.34s]  because you absolutely have to have some notion of security.
[1127.58s -> 1130.50s]  We'd love for programs to be programmer's complete freedom,
[1130.50s -> 1132.66s]  but it can't be complete, can't be really complete
[1132.66s -> 1134.18s]  because we don't want programs
[1134.66s -> 1135.98s]  to get directly at the hardware
[1135.98s -> 1137.66s]  or to interfere with other programs
[1137.66s -> 1140.38s]  or to sort of be able to interfere
[1140.38s -> 1143.14s]  with the operation of the operating system itself.
[1144.38s -> 1148.98s]  So these are all, it's possible to do a good job
[1148.98s -> 1150.02s]  and we'll talk a lot about it,
[1150.02s -> 1151.62s]  but it's always a bit of a puzzle
[1151.62s -> 1154.54s]  to provide sort of both of these,
[1154.54s -> 1156.58s]  the properties in both of these columns.
[1158.06s -> 1160.46s]  Another thing that makes OS design hard and interesting
[1160.46s -> 1162.90s]  is that operating systems provide a lot of features
[1162.90s -> 1163.86s]  and a lot of services,
[1164.38s -> 1166.10s]  but they actually tend to interact
[1166.10s -> 1168.90s]  and sometimes in odd ways that require a lot of thought.
[1168.90s -> 1171.30s]  So even in the simple examples I gave
[1173.02s -> 1175.34s]  with open and fork, those two interact actually.
[1175.34s -> 1178.86s]  If a program allocates a file descriptor
[1178.86s -> 1180.86s]  with the open system call
[1180.86s -> 1184.82s]  and then that same program forks
[1186.26s -> 1188.18s]  and the semantics of fork just turn out to be
[1188.18s -> 1189.82s]  that you create a new process
[1189.82s -> 1192.10s]  that's a copy of the current process.
[1192.10s -> 1194.10s]  This file descriptor you opened,
[1195.82s -> 1197.46s]  if that's truly to be a copy,
[1197.46s -> 1200.26s]  this file descriptor still has to be present
[1200.26s -> 1202.42s]  and usable in the child.
[1202.42s -> 1204.78s]  And so that has to be thought through,
[1204.78s -> 1207.06s]  that is the open and file descriptors
[1207.06s -> 1210.06s]  interact with fork in this interesting way.
[1210.06s -> 1211.70s]  And somebody has to figure out,
[1211.70s -> 1214.14s]  oh, should the child be able to get at
[1214.14s -> 1217.14s]  the file descriptors created before fork was called?
[1217.14s -> 1218.74s]  And the answer happens to be yes
[1218.74s -> 1220.94s]  in the operating systems we're gonna look at.
[1223.10s -> 1226.38s]  And so other things that turn out to be interesting,
[1226.38s -> 1228.50s]  I already mentioned that operating systems
[1228.50s -> 1231.06s]  have to cater to a wide variety of uses,
[1231.06s -> 1234.58s]  the same OS used both for database servers
[1234.58s -> 1239.42s]  and smartphones, for example, and operating systems.
[1239.42s -> 1243.50s]  As time goes on, the hardware that you run,
[1243.50s -> 1246.34s]  the hardware you get with typical computers changes.
[1246.34s -> 1248.78s]  I mean, you get super vast SSD storage
[1248.78s -> 1251.34s]  instead of mechanical hard drives, for example.
[1251.54s -> 1255.06s]  And about 15 years ago, multi-core computers
[1255.06s -> 1258.90s]  went from being rare curiosities to being pervasive.
[1260.18s -> 1263.46s]  And recently we've seen order of magnitude speed ups
[1263.46s -> 1265.34s]  in how fast networks operate.
[1265.34s -> 1269.78s]  And so all of these require rethinks periodically
[1269.78s -> 1271.74s]  of how operating systems are designed.
[1272.74s -> 1277.66s]  Now, so those are sort of intellectually
[1277.66s -> 1278.66s]  why you might take the course.
[1278.66s -> 1280.54s]  There's also some even more practical reasons
[1280.58s -> 1283.94s]  why you might be glad to have taken this course.
[1283.94s -> 1286.02s]  One is if you're interested in what happens
[1286.02s -> 1289.82s]  inside computers, what goes on under the hood,
[1289.82s -> 1292.10s]  sort of in secret when you turn on your computer,
[1292.10s -> 1293.70s]  this is a good course to take.
[1293.70s -> 1295.42s]  Similarly, if you like infrastructure,
[1295.42s -> 1299.38s]  that is if you enjoy building sort of services
[1299.38s -> 1301.62s]  that other programs can then use,
[1302.66s -> 1304.98s]  this is of course essentially all about infrastructure
[1304.98s -> 1307.30s]  because that's what operating systems are.
[1308.66s -> 1310.14s]  If you ever need to spend a lot of time
[1310.66s -> 1312.82s]  tracking down bugs in application code
[1312.82s -> 1314.98s]  or tracking down security problems,
[1314.98s -> 1317.58s]  often that involves understanding
[1317.58s -> 1319.86s]  what was going on inside the operating system.
[1319.86s -> 1321.42s]  Cause it's ultimately the operating system
[1321.42s -> 1323.82s]  that enforces a lot of security.
[1323.82s -> 1326.14s]  And when things go wrong,
[1326.14s -> 1327.14s]  it's sort of the operating system
[1327.14s -> 1328.22s]  that has to pick up the pieces.
[1328.22s -> 1332.38s]  So that's often involved in tracking down bugs.
[1332.38s -> 1334.14s]  And finally, yes.
[1334.14s -> 1335.58s]  Two more questions from the chat.
[1335.58s -> 1337.54s]  So the first is how important is it
[1337.54s -> 1340.22s]  for application developers to truly deeply understand
[1340.22s -> 1341.74s]  the operating systems they're developing
[1341.74s -> 1343.26s]  their applications for?
[1343.26s -> 1346.02s]  Do they necessarily need to be experts?
[1346.02s -> 1347.54s]  You don't have to be an expert,
[1347.54s -> 1350.58s]  but if you spend a lot of time developing
[1350.58s -> 1352.90s]  and maintaining and debugging applications,
[1352.90s -> 1355.26s]  you'll eventually end up knowing a lot
[1355.26s -> 1356.42s]  about the operating system,
[1356.42s -> 1358.66s]  whether you meant to or not.
[1358.66s -> 1363.66s]  It just comes up and you're often forced to understand.
[1364.50s -> 1367.22s]  And the second question is,
[1367.22s -> 1370.10s]  do high-level programming languages like Python
[1370.10s -> 1371.42s]  use system calls directly
[1371.42s -> 1374.86s]  or are there built-ins slash wrappers for convenience?
[1374.86s -> 1376.06s]  A lot of high-level languages
[1376.06s -> 1379.70s]  are sort of at one remove from system calls.
[1379.70s -> 1380.62s]  That's absolutely true.
[1380.62s -> 1385.46s]  So, but partially because a lot of languages
[1385.46s -> 1388.90s]  want to provide portable environment
[1388.90s -> 1390.54s]  that works on many different operating systems.
[1390.54s -> 1392.22s]  So they can't necessarily commit
[1392.26s -> 1395.58s]  to the specific system calls of any one operating system.
[1397.54s -> 1399.22s]  So the answer to the question, I think,
[1399.22s -> 1400.94s]  is if you use Python,
[1400.94s -> 1404.94s]  you're somewhat insulated from the system call interface.
[1404.94s -> 1405.78s]  You know, internally, of course,
[1405.78s -> 1409.58s]  Python has to make system calls to get its work done.
[1409.58s -> 1412.54s]  And certainly in Python and in many other languages,
[1412.54s -> 1416.86s]  there is usually a way to get directly at the system calls
[1416.86s -> 1420.02s]  of whatever operating system you're running on.
[1421.02s -> 1422.82s]  And folks for questions,
[1422.82s -> 1424.54s]  you can just feel free to jump in yourself
[1424.54s -> 1425.38s]  and ask questions.
[1425.38s -> 1426.98s]  You don't need to go through the chat.
[1429.54s -> 1433.38s]  Okay, all right, sorry.
[1436.82s -> 1438.42s]  I'm gonna spend a couple of minutes now
[1438.42s -> 1443.42s]  talking about the class structure of 6S081
[1443.42s -> 1448.42s]  before switching back to actual technical content.
[1451.62s -> 1454.54s]  So there's a website for the course,
[1454.54s -> 1455.98s]  which I don't want to write out just now,
[1455.98s -> 1460.46s]  but you can find it by looking for 6S081 on Google.
[1460.46s -> 1465.46s]  And the website has the schedule.
[1470.14s -> 1472.50s]  It has the assignments on the schedule.
[1472.58s -> 1474.94s]  It has the lab assignments,
[1474.94s -> 1477.98s]  and it has the sort of information about course structure,
[1477.98s -> 1479.86s]  like the grading policy on it.
[1481.02s -> 1484.22s]  The other big resource you're gonna want to keep track of
[1484.22s -> 1485.22s]  is Piazza.
[1486.50s -> 1489.46s]  I guess everybody who's here got here by way of Piazza.
[1489.46s -> 1491.18s]  But as well as,
[1492.22s -> 1494.34s]  so we used Piazza really for two main things.
[1494.34s -> 1497.06s]  One is as a way of people being able to ask questions
[1497.06s -> 1498.50s]  about the lab assignments
[1498.50s -> 1502.38s]  and the course staff will try to answer these questions,
[1503.22s -> 1504.06s]  but you should feel absolutely free
[1504.06s -> 1506.86s]  to answer each other's questions as well.
[1506.86s -> 1508.46s]  And the other big thing that happens on Piazza,
[1508.46s -> 1509.74s]  if there's announcements,
[1509.74s -> 1512.14s]  if there's any announcements about the course,
[1512.14s -> 1513.70s]  we'll put the announcements on Piazza.
[1513.70s -> 1515.86s]  So you should keep an eye on Piazza for announcements,
[1515.86s -> 1518.78s]  even if you're not using it for lab help.
[1523.50s -> 1526.34s]  One of the big parts of the course is these lectures.
[1526.34s -> 1531.34s]  The lectures will cover basic ideas in operating systems.
[1536.42s -> 1540.22s]  Some of the lectures will be devoted to detailed study
[1540.22s -> 1542.46s]  of the code in XV6,
[1542.46s -> 1545.54s]  which is our small teaching operating system.
[1545.54s -> 1547.46s]  And so we'll talk about how it works.
[1547.46s -> 1548.54s]  We'll look at the code
[1548.54s -> 1551.98s]  and sort of show the code executing during lectures.
[1551.98s -> 1553.98s]  And in addition, before many of the lectures,
[1553.98s -> 1555.06s]  there'll be assignments,
[1555.06s -> 1557.30s]  reading assignments from a book
[1557.30s -> 1560.26s]  that sort of describes how XV6 operates
[1560.26s -> 1562.86s]  and why it's designed that way.
[1562.86s -> 1565.54s]  So you should do the readings before the class
[1565.54s -> 1568.66s]  so that you'll understand the discussion in the class.
[1568.66s -> 1571.10s]  Some of the lectures are devoted to background
[1571.10s -> 1573.30s]  to help you do the labs.
[1573.30s -> 1574.98s]  Sort of explanations about C-Works,
[1574.98s -> 1576.86s]  of how the RISC-V,
[1576.86s -> 1579.90s]  which is the microprocessor that we'll be using,
[1579.90s -> 1581.10s]  that you'll find helpful
[1581.10s -> 1583.98s]  in understanding how to do the labs.
[1583.98s -> 1586.26s]  And towards the end of the course,
[1586.26s -> 1588.02s]  we'll spend some lectures
[1588.02s -> 1591.26s]  discussing some operating system papers,
[1591.26s -> 1594.54s]  research papers and some classic papers in the field,
[1594.54s -> 1597.50s]  which we'll ask that you read before the lectures
[1597.50s -> 1599.86s]  and then we'll sort of talk about the papers
[1599.86s -> 1601.26s]  during the lecture.
[1601.26s -> 1603.54s]  For all the lectures or almost all the lectures,
[1603.54s -> 1606.30s]  we ask that you submit a question about the reading
[1607.22s -> 1611.46s]  for the lecture before the actual time of the lecture,
[1611.46s -> 1614.46s]  which many or all of you did for this lecture,
[1614.46s -> 1616.02s]  for which thank you.
[1616.02s -> 1618.26s]  And we will read those questions to help us,
[1619.38s -> 1620.98s]  guide us about what to talk about
[1620.98s -> 1623.70s]  and we'll try to answer as many of the questions
[1623.70s -> 1626.70s]  as we can, although there's rarely time, unfortunately,
[1626.70s -> 1628.26s]  for us to answer all of them.
[1629.70s -> 1632.58s]  The next big part of the course is the labs.
[1632.58s -> 1637.14s]  There's a programming lab due almost every week.
[1638.06s -> 1639.06s]  And the point of the labs
[1639.06s -> 1640.78s]  is to help you get hands-on experience
[1640.78s -> 1645.78s]  with implementing and using operating systems.
[1647.94s -> 1649.86s]  The lab that's due next week
[1649.86s -> 1653.18s]  is actually about using, about writing applications
[1653.18s -> 1655.14s]  that make the call, the system calls
[1655.14s -> 1656.38s]  we'll be talking about.
[1657.70s -> 1661.34s]  Whereas most of those labs after that involve you
[1661.34s -> 1663.94s]  either implementing basic operating system features
[1663.94s -> 1668.94s]  or adding kernel extensions to the XV6 operating system.
[1670.90s -> 1673.38s]  The very last lab is one in which you actually add
[1673.38s -> 1675.58s]  a network stack and a network driver.
[1675.58s -> 1677.58s]  So you'll be able to connect in over the network
[1677.58s -> 1679.54s]  to the operating system that you run.
[1681.70s -> 1684.50s]  You should, if you have problems with the labs,
[1684.50s -> 1688.94s]  there'll be office hours that the TAs will hold.
[1688.94s -> 1692.46s]  In addition, you can post questions to Piazza
[1692.46s -> 1694.58s]  and very often you'll be able to get useful answers
[1694.58s -> 1698.06s]  from Piazza more quickly than from office hours.
[1699.06s -> 1702.10s]  We welcome you discussing the labs,
[1702.10s -> 1703.02s]  talking about the labs,
[1703.02s -> 1706.54s]  talking about how to design the lab solutions.
[1706.54s -> 1708.10s]  But we ask you please do not look
[1708.10s -> 1710.30s]  at other people's solutions for the labs.
[1710.30s -> 1712.50s]  Please, all the code you write should be your own
[1712.50s -> 1716.74s]  and you shouldn't share code or look at other solutions.
[1718.86s -> 1722.82s]  The grading for the course
[1724.62s -> 1727.70s]  will be mostly determined from the labs this year.
[1728.22s -> 1730.18s]  70% of the grade will be
[1732.94s -> 1735.42s]  based on whether or not that your lab,
[1735.42s -> 1737.38s]  the lab you submit passes the tests.
[1737.38s -> 1740.98s]  And for grading, we run the same tests that we supply you.
[1740.98s -> 1743.90s]  So if your lab passes all the tests that we give you,
[1743.90s -> 1746.50s]  then chance to show you that full credit for the lab.
[1747.74s -> 1752.58s]  20% of the grade is gonna be from lab checkoff meetings.
[1754.18s -> 1755.90s]  For each of you, we'll pick a couple
[1755.94s -> 1757.50s]  of randomly selected labs
[1757.50s -> 1759.46s]  and one of the teams will talk to you
[1759.46s -> 1761.14s]  and ask you questions about your implementation
[1761.14s -> 1764.46s]  just to make sure that you really understand
[1764.46s -> 1765.34s]  what's going on.
[1766.26s -> 1768.18s]  So this is the lab checkoffs.
[1770.02s -> 1774.22s]  There's 10% remaining, is there a question?
[1774.22s -> 1777.98s]  Will the lab checkoffs kind of be like a yes or no,
[1777.98s -> 1779.42s]  one or zero type of thing,
[1779.42s -> 1783.82s]  or would they be like, could someone get,
[1783.82s -> 1786.22s]  like if they answered some of the questions right,
[1786.22s -> 1787.66s]  but not all the questions right,
[1787.66s -> 1789.18s]  would they get in between?
[1791.46s -> 1793.06s]  I haven't thought this through.
[1794.86s -> 1797.50s]  There's certainly room for partial credit, but.
[1797.50s -> 1799.62s]  It's not a, it won't be binary.
[1799.62s -> 1803.26s]  It'll definitely be, you can receive partial credit.
[1803.26s -> 1804.10s]  Okay.
[1806.30s -> 1809.18s]  The last 10% is gonna be driven by the homework
[1809.18s -> 1812.90s]  and participation during lecture and in Piazza.
[1814.78s -> 1819.78s]  There'll be no exam or quizzes this year.
[1822.30s -> 1825.26s]  And so what that means is that most of the,
[1825.26s -> 1829.34s]  90% of the grade is being driven by the labs.
[1829.34s -> 1833.66s]  So you should spend a lot of time in the labs,
[1833.66s -> 1835.74s]  make sure that you start early
[1835.74s -> 1838.10s]  and have enough time to complete them
[1838.10s -> 1841.22s]  and work out bugs in order to get full credit.
[1841.22s -> 1845.06s]  And, you know, as a result of that,
[1845.06s -> 1848.14s]  this is gonna be a very kind of hands-on
[1848.14s -> 1849.74s]  software oriented course.
[1850.74s -> 1854.78s]  All right, any questions about the machinery of the course?
[1860.26s -> 1862.82s]  We got a couple of questions in chat.
[1862.82s -> 1865.22s]  So the first is a logistical question.
[1865.22s -> 1867.58s]  Currently 6-SOA-1 isn't listed as usable
[1867.58s -> 1870.14s]  for the systems concentration in the MEng.
[1870.18s -> 1872.38s]  Are there plans to add it to the list of classes later?
[1872.38s -> 1875.94s]  I think for that, because it's not an AAGS,
[1875.94s -> 1877.14s]  it's an AUS.
[1877.14s -> 1879.78s]  It can't be used to fulfill MEng requirements
[1879.78s -> 1881.74s]  as it's not a graduate level class.
[1886.78s -> 1888.34s]  And then we have, is the only homework
[1888.34s -> 1890.22s]  to submit questions looking at the calendar
[1890.22s -> 1891.78s]  that appears to be the case?
[1894.58s -> 1896.22s]  Unless I'm forgetting something.
[1897.46s -> 1899.06s]  I think that's the case, yes.
[1901.06s -> 1905.38s]  So have, are there gonna be cutoffs for grades
[1905.38s -> 1908.82s]  like X% gets an A, Y% gets a B, et cetera?
[1910.06s -> 1910.90s]  No, no.
[1914.30s -> 1918.90s]  You know, we're gonna try to pre-student estimate
[1920.70s -> 1924.22s]  our impression of how well you've understood the material
[1925.46s -> 1926.62s]  and assign a grade based on that.
[1926.62s -> 1929.14s]  So there's no predetermined cutoffs.
[1930.74s -> 1935.74s]  All right, anything else?
[1939.82s -> 1940.94s]  All right.
[1940.94s -> 1944.58s]  Just real quick, for folks in the chat
[1944.58s -> 1949.06s]  asking about the concentration requirement,
[1949.06s -> 1953.02s]  I'm not 100% certain, but 6-SOA-1 is not,
[1953.02s -> 1954.30s]  it's like a temporary number
[1954.30s -> 1956.10s]  before the class gets the official one.
[1956.10s -> 1959.38s]  So it certainly won't be listed anywhere.
[1959.42s -> 1961.30s]  If you need it to fulfill a concentration,
[1961.30s -> 1963.50s]  I think your best bet is probably to fill out a petition
[1963.50s -> 1966.90s]  or to email somebody like Katrina Wieckertz
[1966.90s -> 1969.46s]  to see what the status is.
[1969.46s -> 1972.02s]  We don't control, you know,
[1972.02s -> 1976.22s]  what classes fill these kind of requirements, unfortunately.
[1977.42s -> 1978.78s]  And for what language we'll be using,
[1978.78s -> 1980.02s]  the class will be in C.
[1980.02s -> 1985.02s]  All right.
[1988.66s -> 1990.06s]  All right, for the rest of the lecture,
[1990.06s -> 1993.86s]  I wanna talk about what system calls
[1993.86s -> 1996.10s]  look like to applications.
[1997.50s -> 1999.82s]  And, you know, since the system calls
[1999.82s -> 2002.42s]  are the interface to the services
[2002.42s -> 2003.98s]  that the operating system provides,
[2003.98s -> 2005.78s]  it's actually pretty important
[2005.78s -> 2007.06s]  what those system calls look like,
[2007.06s -> 2009.38s]  what applications expect from system calls
[2009.62s -> 2010.46s]  and how they behave.
[2010.46s -> 2012.18s]  So it's sort of worth understanding
[2012.18s -> 2013.74s]  what the interface looks like.
[2015.86s -> 2017.14s]  You'll be using the system calls
[2017.14s -> 2019.50s]  we talked about in the first lab
[2019.50s -> 2023.30s]  and extending and improving the implementation,
[2023.30s -> 2025.30s]  internal implementation of these system calls
[2025.30s -> 2027.34s]  in subsequent labs.
[2027.34s -> 2030.70s]  What we're gonna do is show some simple examples
[2030.70s -> 2035.70s]  of little programs that call system calls,
[2036.70s -> 2039.90s]  and then I'll run them in XV6 for you.
[2041.90s -> 2045.62s]  Gonna run them, the XV6 is a UNIX,
[2045.62s -> 2047.74s]  a simplified UNIX-like operating system.
[2047.74s -> 2050.26s]  And UNIX is a old operating system
[2050.26s -> 2053.62s]  that's sort of at least intellectual basis
[2053.62s -> 2055.42s]  for many present-day operating systems,
[2055.42s -> 2057.58s]  such as Linux and OS X.
[2057.58s -> 2059.22s]  So it's in very common use.
[2060.74s -> 2065.14s]  XV6, our teaching operating system is much simpler.
[2066.02s -> 2067.78s]  It's sort of inspired by UNIX
[2067.78s -> 2069.54s]  and has the same overall structure,
[2069.54s -> 2071.58s]  but is dramatically simpler
[2071.58s -> 2074.18s]  than any real UNIX operating system.
[2076.90s -> 2079.10s]  And it's simple enough that hopefully,
[2081.02s -> 2082.82s]  it would be relatively straightforward
[2082.82s -> 2084.82s]  for you to read all of the source code
[2084.82s -> 2087.78s]  as well as read the book in a couple of weeks,
[2087.78s -> 2088.90s]  certainly during the semester
[2088.90s -> 2090.54s]  in order to kind of understand
[2090.54s -> 2093.34s]  all of what happens inside XV6.
[2095.82s -> 2100.82s]  XV6 runs on the RISC-V processor, RISC-V microprocessor,
[2101.06s -> 2102.78s]  and this is the same microprocessor
[2102.78s -> 2106.14s]  that's the focus of recent 6004.
[2106.14s -> 2109.34s]  So many of you may actually know quite a bit
[2109.34s -> 2111.22s]  about the RISC-V instruction set.
[2112.82s -> 2117.66s]  In theory, you could run XV6 on top of a RISC-V computer,
[2117.66s -> 2119.02s]  and people have done that,
[2120.70s -> 2125.06s]  but we're gonna run it under the QEMU machine emulator,
[2125.10s -> 2126.06s]  so just to write this down,
[2126.06s -> 2129.46s]  we got our operating system is XV6.
[2130.46s -> 2134.42s]  It runs on RISC-V microprocessor,
[2134.42s -> 2136.50s]  and not just RISC-V microprocessor,
[2136.50s -> 2139.02s]  but we assume a certain amount of surrounding hardware,
[2139.02s -> 2142.46s]  like memory and a disk
[2142.46s -> 2145.34s]  and a console interface for us to talk to it.
[2146.90s -> 2150.90s]  We actually run under the QEMU machine simulator,
[2151.82s -> 2153.34s]  which runs under Linux,
[2153.34s -> 2157.94s]  so that all of you can actually run XV6
[2157.94s -> 2160.18s]  without having to have hardware.
[2160.18s -> 2164.34s]  Okay, so I'm gonna switch to showing the code.
[2181.82s -> 2186.82s]  All right, so first thing is I've set up XV6 on my laptop,
[2189.62s -> 2191.86s]  and I'm gonna run it, and type make QEMU,
[2191.86s -> 2193.30s]  which you'll find yourself doing quite a bit
[2193.30s -> 2196.18s]  during the labs, which compiles XV6.
[2196.18s -> 2200.26s]  It's written in C, so it's compiled with a C compiler.
[2200.26s -> 2203.14s]  Maybe I'll make clean for you
[2203.14s -> 2205.22s]  so you can see the actual compilation,
[2205.22s -> 2206.78s]  and I'll type make QEMU,
[2206.78s -> 2210.90s]  which has the effect of compiling and building XV6 kernel
[2210.90s -> 2212.70s]  and all the user processes,
[2213.74s -> 2216.14s]  and then running them under the QEMU emulator.
[2218.02s -> 2220.02s]  This takes a moment to run the compiles,
[2222.14s -> 2225.22s]  and now we're up and running XV6,
[2225.22s -> 2228.38s]  and the dollar sign prompt you see is the shell,
[2228.38s -> 2232.10s]  which is the command line interface to XV6
[2232.10s -> 2234.50s]  modeled after the shell in Unix,
[2234.54s -> 2238.34s]  which is, if you log into an Athena workstation,
[2238.34s -> 2241.98s]  it's like the shell that Athena shows you.
[2244.34s -> 2246.26s]  XV6 is itself tiny,
[2246.26s -> 2249.26s]  and it comes with a small number of utility programs,
[2249.26s -> 2252.10s]  and including, for example, the LS program,
[2252.10s -> 2254.42s]  which I'm about to run, run LS,
[2254.42s -> 2257.90s]  and it gives me a list of all the files in XV6,
[2257.90s -> 2260.26s]  of which there are only about two dozen,
[2260.26s -> 2263.18s]  including things like grep, and kill,
[2263.22s -> 2265.70s]  and make dear, and rm,
[2265.70s -> 2269.62s]  which may be familiar to you as Unix utilities.
[2271.14s -> 2272.74s]  Okay, the first program I'm gonna show you
[2272.74s -> 2277.74s]  to illustrate system calls is a program called copy.
[2288.06s -> 2290.10s]  And here's the source, it's just a page.
[2294.18s -> 2297.10s]  And so what you're seeing here is a program
[2297.10s -> 2298.94s]  that starts on line eight at main,
[2298.94s -> 2301.62s]  is that sort of convention for C programs.
[2301.62s -> 2304.06s]  It sits in a loop at line 12,
[2304.06s -> 2305.86s]  and over and over again,
[2305.86s -> 2309.90s]  it reads some data as input on line 13,
[2309.90s -> 2312.50s]  and then writes the data it just read
[2312.50s -> 2314.46s]  to its output on line 16.
[2314.46s -> 2319.46s]  So if I run copy in XV6,
[2320.50s -> 2321.66s]  just waiting to read input,
[2321.70s -> 2324.30s]  if I type some input,
[2324.30s -> 2326.42s]  it reads it and spits it back out to me.
[2326.42s -> 2329.70s]  So it's a very simple program, just does I have.
[2331.46s -> 2333.34s]  It's written in C, as I mentioned.
[2333.34s -> 2335.06s]  If you don't already know C,
[2335.06s -> 2338.38s]  it's worthwhile getting the standard
[2338.38s -> 2341.38s]  C programming language book by Kernahan and Ritchie,
[2341.38s -> 2344.86s]  and I think there's a more full reference to it
[2344.86s -> 2347.02s]  on the course website,
[2347.02s -> 2350.30s]  which explains to you in a very straightforward way
[2350.34s -> 2351.34s]  how to program in C.
[2354.38s -> 2356.30s]  As I mentioned before, read and write,
[2356.30s -> 2359.22s]  this program makes two, really three system calls,
[2359.22s -> 2362.22s]  read, write, and exit are system calls.
[2363.44s -> 2366.26s]  If you look at the call to read on line 13,
[2366.26s -> 2367.80s]  it takes three arguments.
[2368.66s -> 2370.14s]  The first argument's a file descriptor,
[2370.14s -> 2373.54s]  which is really a reference to a previously opened file,
[2373.54s -> 2378.38s]  and the shell ensures that when a program starts
[2378.38s -> 2381.02s]  by default, its file descriptor zero
[2381.02s -> 2383.02s]  is connected to the console input,
[2383.02s -> 2386.02s]  and its file descriptor one is connected
[2386.02s -> 2387.60s]  to the console output,
[2387.60s -> 2391.06s]  and that's why I was able to type to this copy program
[2391.06s -> 2392.90s]  and see the output.
[2395.70s -> 2398.82s]  Of course, these file descriptors are expected,
[2398.82s -> 2400.62s]  the program expects that these file descriptors
[2400.62s -> 2403.78s]  have been previously opened and set up by the shell for it
[2403.78s -> 2408.78s]  and this 01 file descriptors is a pervasive Unix convention.
[2409.62s -> 2412.30s]  Many, many Unix programs expect to read
[2412.30s -> 2415.78s]  in file descriptor one and read in file descriptor zero
[2415.78s -> 2417.48s]  and write to file descriptor one.
[2419.42s -> 2422.70s]  The second argument to read is a pointer to some memory
[2423.60s -> 2425.66s]  where the program is asking the operating system
[2425.66s -> 2428.86s]  to read data into that address in memory,
[2428.86s -> 2430.78s]  so that's the buff argument,
[2430.78s -> 2435.06s]  and line 10 allocates 64 bytes of memory on the stack
[2436.50s -> 2437.86s]  for read to read into,
[2437.86s -> 2440.30s]  and the third argument to read is the maximum number
[2440.30s -> 2442.62s]  of bytes that the program wants to read,
[2442.62s -> 2446.88s]  and the size of buff says just 60, maximum 64 bytes.
[2446.88s -> 2448.98s]  So the read call reads up to 64 bytes
[2448.98s -> 2452.02s]  from whatever is connected to file descriptor zero,
[2452.02s -> 2454.98s]  and that was my terminal in this example.
[2454.98s -> 2457.22s]  The return value from read,
[2457.22s -> 2461.18s]  it may return the number of bytes read,
[2461.18s -> 2466.00s]  which would be six in the case of me typing X, Y, Z, Z, Y.
[2467.34s -> 2468.98s]  Read might be reading from a file,
[2468.98s -> 2470.22s]  if it gets to the end of the file
[2470.22s -> 2473.38s]  and there's no more bytes, read will return zero,
[2473.38s -> 2475.02s]  and some other error occurred,
[2475.02s -> 2477.58s]  like the file descriptor doesn't exist,
[2477.58s -> 2479.94s]  read may return minus one,
[2479.94s -> 2483.82s]  and so in many of these examples, like on line 16 there,
[2484.50s -> 2487.26s]  I don't, my example code doesn't check
[2487.26s -> 2489.44s]  system call returns for errors,
[2490.72s -> 2492.72s]  but you should be more careful than me.
[2494.22s -> 2496.90s]  You should figure out how system calls reflect errors,
[2496.90s -> 2499.14s]  it's usually a minus one return value,
[2499.14s -> 2502.64s]  and check all system call returns for errors.
[2503.50s -> 2506.62s]  And if you wanna know what the system call arguments
[2506.62s -> 2509.10s]  and return values are, there's a table in,
[2509.10s -> 2511.30s]  I think chapter two in the book,
[2511.30s -> 2513.78s]  that explains all of the XV6.
[2513.78s -> 2517.78s]  System call arguments and return values.
[2518.94s -> 2521.66s]  The question regarding the read syscall,
[2521.66s -> 2525.02s]  what if we set the max read bytes to size of buff
[2525.02s -> 2527.66s]  to one plus size of buff or bigger?
[2527.66s -> 2529.22s]  So what if we try to read more than the size of buff?
[2529.22s -> 2533.06s]  Yeah, then if there was 65 bytes to read,
[2533.06s -> 2535.50s]  then the operating system would happily,
[2535.50s -> 2538.82s]  well, just copy those 65 bytes
[2538.82s -> 2540.94s]  to the memory that you provide,
[2540.94s -> 2543.14s]  and of course, there's something else
[2543.14s -> 2546.30s]  in the stack up there, maybe the return program counter
[2546.30s -> 2547.78s]  or an argument or something.
[2547.78s -> 2551.62s]  And so if you pass 65, then you're inviting the kernel
[2551.62s -> 2556.46s]  to write junk to an unexpected place in your stack.
[2556.46s -> 2559.34s]  And so that's a bug, and it may cause your program
[2559.34s -> 2562.58s]  to crash or do something else unexpected.
[2563.54s -> 2565.74s]  So as a programmer, you have to be careful here,
[2565.74s -> 2569.10s]  there's nobody writing in C with these kind of interfaces,
[2569.14s -> 2573.06s]  there's, it's very, very easy to write code
[2573.06s -> 2575.34s]  that the compiler is happy with and will run,
[2575.34s -> 2577.26s]  but absolutely does the wrong thing.
[2579.42s -> 2583.38s]  So that's too bad, but it's the way it is.
[2586.70s -> 2590.86s]  Okay, one thing to note is that this copy program,
[2590.86s -> 2592.90s]  and indeed the read and write system calls,
[2592.90s -> 2594.62s]  they don't care about the format of data
[2594.62s -> 2596.06s]  they're reading or writing.
[2596.06s -> 2598.50s]  They're just read and write, and read and write,
[2598.94s -> 2601.78s]  and this copy program just deal with eight bit bytes,
[2601.78s -> 2603.62s]  with streams of eight bit bytes.
[2604.78s -> 2607.38s]  How you interpret them is totally up to the application.
[2607.38s -> 2611.74s]  So the application may be parses as data records
[2611.74s -> 2613.90s]  or as C source code or who knows what,
[2615.14s -> 2620.14s]  the operating system only thinks in terms
[2620.18s -> 2622.42s]  of a stream of eight bit bytes.
[2622.42s -> 2626.06s]  Okay, so copy assume this code, my copy program assume
[2626.10s -> 2629.02s]  that the file descriptors are already set up,
[2629.02s -> 2632.46s]  but we need to have a way to create file descriptors.
[2632.46s -> 2634.42s]  And the most straightforward way to do that
[2634.42s -> 2637.86s]  is with the open system call.
[2637.86s -> 2641.90s]  And so here's the source for a program called open
[2641.90s -> 2646.42s]  that uses the open system call.
[2646.42s -> 2647.78s]  Good question from the chat.
[2647.78s -> 2650.86s]  What do you mean by a stream of bytes?
[2650.86s -> 2655.86s]  I just mean that if a file contains a bunch of bytes,
[2658.38s -> 2660.54s]  then read and successive,
[2660.54s -> 2663.02s]  building a file contains a million bytes.
[2663.02s -> 2667.34s]  If you make a sequence of read calls each 400 bytes,
[2667.34s -> 2669.06s]  you'll just read the first 100 bytes
[2669.06s -> 2670.18s]  and then the second 100 bytes
[2670.18s -> 2672.14s]  and then the third 100 bytes.
[2674.14s -> 2675.14s]  That's all I mean.
[2675.14s -> 2680.14s]  All right, so this program called open,
[2681.14s -> 2683.14s]  first I'll run it for you.
[2683.14s -> 2686.94s]  What it does is opens, creates a new file called
[2686.94s -> 2690.26s]  output.txt and then writes some bytes to it.
[2691.10s -> 2691.94s]  And then it finishes.
[2691.94s -> 2692.78s]  So we don't see anything
[2692.78s -> 2695.18s]  because it broke data to this file open,
[2695.18s -> 2699.66s]  but we can look at this output.txt file that it created
[2699.66s -> 2703.58s]  and see the OOO that it wrote there.
[2703.58s -> 2708.58s]  So line 11 in the program makes the open system call,
[2708.74s -> 2710.86s]  gives it a file name, output.txt.
[2710.86s -> 2715.02s]  And the O underscore stuff in the second argument to open
[2715.02s -> 2719.50s]  are flags that tell the open system call implementation
[2719.50s -> 2721.86s]  in the kernel that we'd like to create a file
[2721.86s -> 2725.02s]  with its name and that we're gonna write it.
[2725.02s -> 2727.94s]  Open returns a newly allocated file descriptor.
[2729.90s -> 2731.86s]  And the file descriptor is just a small number.
[2731.94s -> 2734.58s]  It's probably two or three or four or something.
[2734.58s -> 2737.42s]  And then we pass that same file descriptor to write
[2737.42s -> 2740.86s]  along with a buffer and a number of bytes to write
[2740.86s -> 2744.02s]  and that writes data to the file
[2744.02s -> 2745.98s]  that the file descriptor refers to.
[2747.58s -> 2749.54s]  What that file descriptor is actually doing
[2749.54s -> 2752.70s]  is indexing into a little table inside the kernel.
[2752.70s -> 2755.54s]  The kernel maintains state for each process
[2755.54s -> 2757.78s]  that's running, each program that you run.
[2757.78s -> 2758.74s]  And among other things,
[2758.74s -> 2762.18s]  the kernel remembers a table for every running process
[2762.18s -> 2764.98s]  of index by file descriptors.
[2764.98s -> 2767.50s]  And the table sort of tells the kernel
[2767.50s -> 2769.66s]  what each file descriptor refers to.
[2774.74s -> 2778.38s]  A critical point is that each process has its own
[2778.38s -> 2780.42s]  sort of space of file descriptors.
[2780.42s -> 2783.54s]  So if we're running two different processes,
[2783.54s -> 2785.74s]  two different programs in different processes,
[2785.74s -> 2787.10s]  and they both open a file,
[2787.14s -> 2789.14s]  they may actually get the same number back
[2789.14s -> 2790.54s]  as a file descriptor.
[2790.54s -> 2793.50s]  But because the kernel maintains a separate file descriptor
[2793.50s -> 2797.30s]  for each process, the same file descriptor number
[2797.30s -> 2800.86s]  may refer to different files in different processes.
[2803.22s -> 2806.42s]  Any questions about open, about this little program?
[2806.42s -> 2807.74s]  Yeah, we had a question in the chat.
[2807.74s -> 2810.18s]  A question from someone not familiar with C.
[2810.18s -> 2812.22s]  How are these files being described
[2812.22s -> 2813.98s]  different from normal C programs?
[2813.98s -> 2816.58s]  Is it because we're only using kernel calls,
[2817.06s -> 2820.10s]  i.e. couldn't we also open or write a file in Python?
[2825.58s -> 2826.98s]  I don't think I understand.
[2828.14s -> 2830.74s]  It's a C program that's opening and writing a file.
[2841.78s -> 2843.18s]  I think I'm gonna move on.
[2846.82s -> 2851.82s]  All right, so you might ask what actually happens when...
[2852.46s -> 2856.26s]  Maybe the question is, is doing it in C
[2856.26s -> 2859.38s]  any different than doing it in Python minus the syntax?
[2860.62s -> 2863.38s]  Well, it's not really.
[2866.86s -> 2868.58s]  There's certainly ways to...
[2870.58s -> 2874.46s]  Python provides nice function calls for opening
[2874.46s -> 2875.90s]  and doing all these things.
[2876.98s -> 2880.46s]  For opening files, for example, and reading and writing files,
[2880.46s -> 2882.46s]  there are sort of a layer of...
[2882.46s -> 2885.22s]  There are somewhat higher level functions typically,
[2885.22s -> 2887.94s]  not pointers to memory, for example.
[2889.86s -> 2892.66s]  And Python does more error checking for you.
[2894.30s -> 2895.90s]  But when you open a file in Python
[2895.90s -> 2897.14s]  or write a file in Python,
[2897.14s -> 2899.30s]  the Python calls you make
[2900.50s -> 2904.14s]  boil down to system calls just like these.
[2904.14s -> 2907.42s]  Is that a good answer?
[2912.02s -> 2913.22s]  I think so.
[2913.22s -> 2914.06s]  All right.
[2917.42s -> 2921.50s]  All right, I've been over here talking
[2921.50s -> 2926.50s]  to the XV6's Unix-like shell,
[2929.58s -> 2931.22s]  and the shell's what people often call
[2931.22s -> 2933.54s]  the command line interface,
[2933.58s -> 2936.94s]  as opposed to some more graphical user interface.
[2938.62s -> 2940.58s]  The shell turns, if you haven't used the shell,
[2940.58s -> 2943.58s]  the shell turns out to be a pretty useful interface
[2943.58s -> 2946.58s]  for things like system management of Unix systems.
[2947.62s -> 2949.10s]  It provides a lot of utilities
[2949.10s -> 2951.30s]  for messing around with files
[2951.30s -> 2952.62s]  and for programming development
[2952.62s -> 2955.66s]  and for writing scripts to do all these things.
[2955.66s -> 2958.62s]  So you saw me before run...
[2958.62s -> 2960.94s]  I just want to demonstrate a few shell features.
[2960.94s -> 2962.74s]  Ordinarily, when you type things,
[2963.94s -> 2966.22s]  you're telling the shell to run a program.
[2966.22s -> 2968.62s]  So when I type LS, what that means is
[2968.62s -> 2971.70s]  I'm asking the shell to run the program
[2971.70s -> 2972.90s]  whose name is LS.
[2972.90s -> 2975.94s]  And what that really means is there's a file
[2975.94s -> 2977.86s]  in the file system called LS
[2977.86s -> 2979.78s]  that contains some instructions,
[2979.78s -> 2981.38s]  some machine instructions,
[2981.38s -> 2984.42s]  and I'm asking the shell to run the instructions
[2984.42s -> 2986.66s]  that are in the file called LS.
[2986.66s -> 2987.70s]  And I'll run LS now.
[2987.70s -> 2989.58s]  LS, what it actually does is
[2991.06s -> 2993.38s]  get a listing of the files in the current directory.
[2993.38s -> 2995.78s]  And you can see up there on the fourth line
[2995.78s -> 3000.54s]  that among the other files that LS says exists
[3000.54s -> 3002.86s]  in its list is a file called LS,
[3002.86s -> 3005.70s]  which is in fact the file containing the instructions
[3005.70s -> 3006.54s]  I just ran.
[3008.50s -> 3010.02s]  The shell does a few other things for you
[3010.02s -> 3012.22s]  other than running programs.
[3012.22s -> 3014.66s]  It allows you to redirect IO.
[3014.66s -> 3017.26s]  So for example, if I say LS greater than out,
[3017.26s -> 3019.58s]  what that means is I'm asking the shell
[3019.62s -> 3021.18s]  to run the LS command,
[3021.18s -> 3024.82s]  but with its output redirected to the file called out.
[3024.82s -> 3025.98s]  And I run LS.
[3027.26s -> 3028.54s]  We don't see any output
[3028.54s -> 3030.30s]  because the output all went to out.
[3032.14s -> 3034.62s]  Now I can, out contains a bunch of data.
[3035.54s -> 3039.26s]  We could, the cat command reads a file
[3039.26s -> 3041.50s]  and displays the contents of the file.
[3041.50s -> 3043.34s]  So I say cat out.
[3043.34s -> 3047.34s]  Just gonna see now this is the saved output of LS.
[3047.34s -> 3048.94s]  You can also run a command like grep
[3049.18s -> 3052.66s]  and I can give it an argument X and what grep X is.
[3052.66s -> 3055.30s]  The grep command searches for patterns.
[3055.30s -> 3059.02s]  Again, if I run grep X,
[3059.02s -> 3063.54s]  it's gonna search for lines of input that contain X.
[3063.54s -> 3066.30s]  I can redirect, tell the shell to redirect its input
[3066.30s -> 3070.14s]  from the file out in order to look for instances of X
[3070.14s -> 3071.98s]  in that saved LS output.
[3073.34s -> 3075.30s]  And it turns out there's three files
[3076.18s -> 3078.18s]  whose names contain Xs.
[3078.94s -> 3083.74s]  So we're gonna spend a bunch of time with the shell.
[3085.58s -> 3089.54s]  The shell is sort of the most traditional
[3089.54s -> 3092.86s]  and fundamental interface to UNIX
[3092.86s -> 3095.18s]  because when UNIX was first developed,
[3095.18s -> 3097.02s]  all there was was simple terminal interfaces
[3097.02s -> 3098.46s]  like the one we're using.
[3098.46s -> 3102.46s]  And the main use of UNIX originally was time sharing
[3102.46s -> 3104.70s]  a bunch of people logging into the same machine,
[3104.70s -> 3108.06s]  much like Athena, and talking to shells.
[3109.94s -> 3113.98s]  One question about system calls and the compiler.
[3113.98s -> 3115.86s]  How does the compiler handle system calls?
[3115.86s -> 3118.14s]  Does assembly generate to make a procedure call
[3118.14s -> 3121.46s]  to some code segment defined by the operating system?
[3123.46s -> 3125.94s]  There's a special in RISC-V instruction
[3125.94s -> 3127.10s]  that a program can call
[3127.10s -> 3128.98s]  that transfers control into the kernel.
[3128.98s -> 3131.50s]  So indeed, when you write C code
[3131.50s -> 3133.74s]  that makes the system call like open or write,
[3134.74s -> 3136.42s]  I mean, technically what actually happens
[3136.42s -> 3140.38s]  is open is a C function in the C library.
[3141.34s -> 3143.82s]  But the instructions in that function
[3143.82s -> 3145.78s]  are really machine instructions.
[3145.78s -> 3147.94s]  It's not open.
[3147.94s -> 3149.34s]  The open function that we're calling
[3149.34s -> 3150.30s]  isn't a C function.
[3150.30s -> 3152.10s]  It's implemented in assembler
[3152.10s -> 3157.10s]  and the assembly code consists of this special instruction.
[3158.30s -> 3161.10s]  It's actually called E call on the RISC-V,
[3161.10s -> 3163.70s]  the special instruction that transfers control
[3163.70s -> 3165.50s]  into the kernel.
[3165.50s -> 3167.78s]  And then the kernel looks at the process's memory
[3167.78s -> 3171.14s]  and registers to figure out what the arguments were.
[3176.74s -> 3177.58s]  All right.
[3178.90s -> 3180.06s]  The next example I wanna look at
[3180.06s -> 3182.94s]  is an example program that calls fork
[3184.58s -> 3186.02s]  to create a new process.
[3187.62s -> 3190.82s]  So this is the very simple use of fork
[3190.82s -> 3193.02s]  at line 12 of calling fork.
[3193.06s -> 3196.22s]  And what fork does is creates a copy
[3196.22s -> 3198.78s]  of the memory of instructions and data
[3198.78s -> 3200.62s]  of the calling process.
[3200.62s -> 3204.18s]  Now we have two processes with identical memory.
[3204.18s -> 3208.74s]  Fork, the fork system call returns in both processes.
[3208.74s -> 3210.58s]  In the original process,
[3210.58s -> 3213.22s]  the fork system call returns the process ID,
[3213.22s -> 3216.86s]  which is an integer greater than zero.
[3218.62s -> 3219.58s]  In the original process,
[3219.58s -> 3222.90s]  fork returns the process ID of the newly created process.
[3222.90s -> 3226.82s]  And then the newly created process fork returns zero.
[3227.78s -> 3228.74s]  So we sort of break,
[3228.74s -> 3231.74s]  even though the processes have identical memory,
[3231.74s -> 3235.10s]  kind of break the symmetry of old versus new process
[3235.10s -> 3237.10s]  by the return value from fork.
[3237.10s -> 3238.58s]  Then in line 16,
[3238.58s -> 3240.42s]  you can see code that checks
[3240.42s -> 3242.22s]  and says if the process ID is equal to zero,
[3242.22s -> 3243.34s]  it must be the child.
[3243.34s -> 3245.22s]  It must now be running in the child.
[3246.66s -> 3247.78s]  Of course, there's two processes
[3247.78s -> 3250.82s]  and then the other process in the calling process,
[3250.82s -> 3252.50s]  which is usually called the parent,
[3253.02s -> 3255.50s]  the process ID is greater than zero.
[3255.50s -> 3257.30s]  So the child will print child
[3257.30s -> 3259.34s]  and the parent will print parent.
[3260.58s -> 3262.98s]  And then they'll both exit.
[3262.98s -> 3266.78s]  So when I run fork, here's what we get.
[3268.98s -> 3270.54s]  So it may look like garbage,
[3271.42s -> 3273.78s]  but what's actually happening is that after the fork,
[3273.78s -> 3275.38s]  both of these processes are running.
[3275.38s -> 3277.26s]  They're both running at the same time.
[3277.26s -> 3282.26s]  And QEMU is actually emulating a multi-core microprocessor
[3282.70s -> 3283.54s]  for me.
[3283.54s -> 3286.34s]  So they really are running at the very same time.
[3286.34s -> 3288.02s]  And so when they produce output,
[3288.02s -> 3289.78s]  they're producing each byte of their output
[3289.78s -> 3291.42s]  at the same time as the other process
[3291.42s -> 3293.86s]  is producing the corresponding byte of its output.
[3293.86s -> 3298.62s]  So the outputs in the two processes are interleaved.
[3298.62s -> 3300.62s]  You can see that they're both typing F.
[3301.58s -> 3303.58s]  They're both gonna type fork returned.
[3304.42s -> 3305.90s]  So you can see the F from both of them
[3305.90s -> 3306.74s]  and the O for both of them
[3306.74s -> 3309.14s]  and the R for both of them and so on.
[3309.14s -> 3310.06s]  And one of them,
[3310.94s -> 3313.26s]  you can see the zero at the end of that first line
[3313.26s -> 3315.98s]  is in the child fork returned zero.
[3316.94s -> 3321.14s]  And I'm guessing that the parent fork returned 19,
[3321.14s -> 3323.98s]  that is the child's process ID is 19.
[3323.98s -> 3326.66s]  Under xv6, that basically means the 19th process
[3326.66s -> 3329.06s]  that was created since boot.
[3329.06s -> 3332.06s]  And then one of them prints child,
[3332.06s -> 3333.78s]  and you can see the C-H-I-L-D,
[3333.78s -> 3335.74s]  and interleaved with that is the other one
[3335.74s -> 3336.86s]  printing parent.
[3336.86s -> 3340.74s]  So this is sort of a silly use of fork,
[3340.74s -> 3343.46s]  but we can see sort of vividly in this output
[3343.46s -> 3345.14s]  that it's created two processes
[3345.14s -> 3347.74s]  that are, and both of them are running,
[3347.74s -> 3350.94s]  fork return in both processes, and they're both running.
[3350.94s -> 3354.66s]  But also note that one printed child and the other parent.
[3354.66s -> 3357.34s]  So it's important that fork returns differently
[3358.26s -> 3359.46s]  in the two processes.
[3359.46s -> 3360.30s]  Okay.
[3365.86s -> 3367.38s]  Good question.
[3367.38s -> 3369.54s]  Is the child process as a result of fork
[3369.54s -> 3371.42s]  always identical to the parent process,
[3371.42s -> 3372.78s]  or could they be different?
[3377.54s -> 3379.46s]  In xv6, they're identical,
[3380.66s -> 3383.66s]  except for the return value in fork.
[3383.66s -> 3386.10s]  So the instructions are the same, the data's the same,
[3386.10s -> 3388.02s]  the stack is the same.
[3388.98s -> 3391.30s]  And also both processes,
[3392.58s -> 3393.66s]  the processes are copies,
[3393.66s -> 3397.34s]  and they both have their own separate address spaces.
[3397.34s -> 3399.38s]  That is, they both have,
[3399.38s -> 3401.66s]  they both think that their memory starts at zero
[3401.66s -> 3403.10s]  and goes on up from there.
[3404.30s -> 3405.98s]  But it's different.
[3405.98s -> 3409.82s]  It's different memory for the two of them.
[3411.18s -> 3412.82s]  In a more sophisticated operating system,
[3412.82s -> 3414.62s]  there are some details
[3414.62s -> 3417.18s]  which we definitely don't care about.
[3417.18s -> 3420.34s]  They may occasionally cause parent and child to differ,
[3420.34s -> 3423.10s]  but in xv6, they're the same except the return value.
[3424.46s -> 3425.54s]  So the memory's the same.
[3425.54s -> 3430.54s]  In addition, the file descriptor table is copied.
[3431.38s -> 3434.90s]  So if the parent had some files open,
[3435.86s -> 3439.46s]  then the child sees the same set of file descriptors,
[3440.30s -> 3443.34s]  although the child is seeing them in a copy
[3443.34s -> 3445.90s]  of the table of file descriptor information.
[3447.70s -> 3449.82s]  And so we'll see in a moment that it's quite important
[3449.82s -> 3454.30s]  that fork copies the table of open file descriptors
[3454.30s -> 3455.38s]  as well as the memory.
[3457.54s -> 3461.10s]  Okay, so fork creates a new process,
[3461.10s -> 3463.70s]  but when we run stuff in the shell,
[3465.18s -> 3467.10s]  the shell indeed creates a new process
[3467.10s -> 3469.70s]  to run each command that you type.
[3469.70s -> 3471.46s]  But it needs to actually run the command in it.
[3471.46s -> 3473.30s]  So if I type ls,
[3473.30s -> 3476.94s]  we need the shell forks to create a process to run ls,
[3477.54s -> 3481.50s]  but there needs to be some way for that new process
[3481.50s -> 3484.62s]  to actually run the instructions from the ls program.
[3484.62s -> 3487.22s]  Below those instructions from the file called ls.
[3488.46s -> 3491.74s]  And the example program I'm gonna show you in a minute
[3491.74s -> 3492.58s]  uses echo.
[3492.58s -> 3493.82s]  Echo is a very simple command
[3493.82s -> 3497.18s]  that just takes whatever arguments you pass to it
[3497.18s -> 3498.82s]  and writes them to its output.
[3500.02s -> 3502.74s]  And I prepared for you a program called exec.
[3506.94s -> 3511.94s]  Which makes the exec system call,
[3514.50s -> 3517.58s]  which replaces the calling process
[3517.58s -> 3522.22s]  with the instructions read from the file you specify
[3522.22s -> 3525.38s]  and loads the instructions from that file
[3525.38s -> 3526.54s]  over the current process,
[3526.54s -> 3529.14s]  sort of discarding its current memory
[3529.14s -> 3531.66s]  and then starts executing those instructions.
[3531.66s -> 3535.66s]  So the call to exec, the system call exec on line 12
[3537.94s -> 3540.86s]  is gonna have the effect of the operating system
[3540.86s -> 3544.10s]  loading the instructions from the file called echo
[3544.10s -> 3545.18s]  into the current process,
[3545.18s -> 3548.82s]  sort of replacing the memory of the current process
[3548.82s -> 3552.46s]  and then starting to execute those instructions.
[3552.46s -> 3554.54s]  And in addition, you can pass arguments,
[3554.54s -> 3555.66s]  command line arguments.
[3555.66s -> 3558.86s]  Echo exec allows you to pass an array
[3558.86s -> 3562.14s]  of command line arguments with just an array of pointers
[3562.14s -> 3566.90s]  and see line 10 sets up an array of character pointers
[3567.82s -> 3568.74s]  which are essentially strings
[3568.74s -> 3573.26s]  and initializes that array to contain the strings,
[3573.26s -> 3574.74s]  echo, this is echo.
[3575.62s -> 3578.70s]  And that's equivalent to running the echo command
[3578.70s -> 3581.46s]  with the three arguments, this is echo.
[3581.46s -> 3585.78s]  And so when I run exec, indeed,
[3586.78s -> 3588.10s]  I see this output, this is echo.
[3588.10s -> 3592.10s]  But even though I ran the exec program,
[3592.10s -> 3595.62s]  what the exec program does is call the exec system call
[3595.62s -> 3597.22s]  to replace itself with echo.
[3597.22s -> 3601.22s]  And so it was really the echo program producing this output.
[3604.78s -> 3607.50s]  And something about the exec system call
[3607.50s -> 3611.62s]  that's important for us is that exec preserves
[3611.62s -> 3614.54s]  the current table of file descriptors.
[3614.54s -> 3617.78s]  So whatever files descriptor zero, one, two, et cetera
[3617.78s -> 3621.30s]  referred to before exec, they refer to the same thing
[3621.30s -> 3625.26s]  in this new program whose instructions we've loaded.
[3626.38s -> 3629.74s]  Another point is that ordinarily exec does not return
[3629.74s -> 3634.74s]  because exec replaces the current process's memory entirely.
[3635.38s -> 3637.26s]  There's nothing for exec to return to.
[3637.26s -> 3640.74s]  So exec reads the instructions from that file
[3640.74s -> 3642.82s]  and executes them and then that's it.
[3642.82s -> 3646.54s]  The only time exec returns is if some error occurred
[3646.54s -> 3648.22s]  that prevented the operating system
[3648.22s -> 3650.06s]  from running that program for you.
[3650.06s -> 3653.74s]  So for example, if the program doesn't exist at all,
[3654.30s -> 3657.66s]  exec can't find a file called echo, for example,
[3657.66s -> 3659.50s]  then exec would return negative one
[3659.50s -> 3664.30s]  to signal that there's something wrong,
[3664.30s -> 3665.50s]  it couldn't find the file.
[3665.50s -> 3667.70s]  So ordinarily, exec does not return,
[3667.70s -> 3671.38s]  it only returns if the kernel
[3671.38s -> 3673.42s]  couldn't actually run the file for you.
[3676.62s -> 3677.70s]  Questions about exec?
[3678.82s -> 3679.82s]  One question in the chat is,
[3679.82s -> 3682.34s]  what is the last to zero for in arc B?
[3684.74s -> 3686.90s]  It marks the end of the array.
[3687.78s -> 3692.78s]  C is so low level that there's no,
[3693.54s -> 3698.54s]  the C array scheme doesn't have a way for code
[3700.90s -> 3703.34s]  to find out how long the array is.
[3703.34s -> 3707.10s]  And so to tell the kernel that, you know,
[3707.10s -> 3709.30s]  we meant that the array contains echo,
[3709.30s -> 3711.10s]  this is echo and nothing more.
[3712.02s -> 3717.02s]  We put a zero as the last pointer.
[3717.02s -> 3718.82s]  Each of those strings in double quotes
[3718.82s -> 3721.10s]  is actually a pointer to some memory
[3721.10s -> 3722.86s]  that contains those bytes.
[3722.86s -> 3724.70s]  That fifth element of the array
[3724.70s -> 3727.46s]  is a pointer whose value is zero.
[3727.46s -> 3729.82s]  The convention is that a pointer whose value is zero
[3729.82s -> 3731.38s]  or what's called a null pointer
[3733.26s -> 3736.86s]  sort of signifies nothing with it.
[3737.82s -> 3738.66s]  We're done.
[3739.66s -> 3740.98s]  And so the code in the kernel
[3740.98s -> 3742.66s]  has actually walked through this array
[3742.66s -> 3746.06s]  until it finds an element whose value is zero.
[3750.82s -> 3755.58s]  Okay, right, so this is how a program can replace itself
[3756.86s -> 3758.14s]  with another program from a file.
[3758.14s -> 3759.82s]  But actually when we run stuff in the shell,
[3759.82s -> 3764.10s]  like echo ABC or LS or anything else,
[3764.98s -> 3766.46s]  we don't wanna replace the shell.
[3766.54s -> 3768.90s]  We don't wanna have the shell just call exec
[3770.10s -> 3772.78s]  because that would replace the shell with the echo command.
[3772.78s -> 3775.42s]  And then when echo exited, that would be it.
[3776.54s -> 3778.14s]  We don't want echo to replace the shell.
[3778.14s -> 3781.10s]  So what the shell actually does is fork
[3781.10s -> 3782.90s]  and then the child calls exec.
[3782.90s -> 3786.50s]  And that's an extremely common Unix idiom.
[3786.50s -> 3789.66s]  These programs that wanna run a program
[3789.66s -> 3792.26s]  but regain control, what they do is call fork
[3792.26s -> 3794.18s]  and have the child call exec.
[3794.18s -> 3796.14s]  So here's a simple example.
[3796.98s -> 3798.26s]  This fork exec program.
[3800.30s -> 3803.70s]  So in this program, call fork on line 12
[3803.70s -> 3805.46s]  and the child start at line 14.
[3805.46s -> 3807.34s]  We call exec much like before.
[3807.34s -> 3812.34s]  So the child process has to replace itself
[3812.42s -> 3815.74s]  with the echo command and echo does its thing
[3815.74s -> 3817.78s]  and then exits.
[3817.78s -> 3819.82s]  And then the parent process gains control
[3819.82s -> 3823.82s]  because when the fork returns
[3823.82s -> 3825.98s]  the greater than zero value in the parent process.
[3826.42s -> 3828.86s]  So the parent process then continues to execute at 19
[3828.86s -> 3832.90s]  and Unix provides a wait system call line 20
[3832.90s -> 3835.74s]  for a process to wait for a child
[3835.74s -> 3837.22s]  that it created with fork.
[3837.22s -> 3841.50s]  Because when I run a command, here on the command line,
[3842.70s -> 3847.58s]  we want the shell to wait for the command to finish
[3847.58s -> 3849.38s]  before it prints the prompt again,
[3849.38s -> 3850.98s]  before it prints this dollar sign prompt
[3850.98s -> 3852.86s]  asking me for more input.
[3852.86s -> 3855.02s]  And so it's the wait system call
[3855.02s -> 3856.22s]  that allows a process to wait
[3856.22s -> 3858.70s]  for any of its children to return.
[3858.70s -> 3863.70s]  This status argument is a way for an exiting child
[3865.54s -> 3870.54s]  to communicate one integer, 32-bit value
[3870.58s -> 3873.38s]  from the exiting child to the waiting parent.
[3873.38s -> 3875.82s]  So on line 17, that argument to exit,
[3875.82s -> 3878.22s]  that one that's the argument to exit,
[3878.22s -> 3881.70s]  the operating system passes that one
[3881.70s -> 3885.74s]  from the exiting child to the call to wait at line 20.
[3885.74s -> 3888.14s]  So wait, the ampersand in wait
[3889.18s -> 3892.26s]  is passing the address of the status variable
[3892.26s -> 3894.70s]  to the kernel, the kernel fills in that address
[3894.70s -> 3897.78s]  with the child's argument to exit.
[3898.90s -> 3900.82s]  And the convention in Unix is that
[3900.82s -> 3903.38s]  if a program completes successfully
[3903.38s -> 3906.74s]  it exits with state of zero,
[3906.74s -> 3910.14s]  but if it encountered an error as at line 17,
[3911.14s -> 3914.46s]  then the Unix convention is that you pass one to exit.
[3914.46s -> 3916.62s]  And so if you care, the calling process
[3916.62s -> 3918.42s]  can look at the status from wait
[3918.42s -> 3923.42s]  and decide whether the child completed successfully or not.
[3924.70s -> 3926.62s]  Professor Morris, quick question.
[3926.62s -> 3927.46s]  Yes.
[3927.46s -> 3931.14s]  About the exec call on line 15,
[3931.14s -> 3934.02s]  we mentioned a bit ago that exec
[3934.02s -> 3936.42s]  will completely go into the echo program
[3936.42s -> 3938.58s]  and not return to fork exec.
[3939.54s -> 3943.14s]  So would it ever reach line 16 and 17?
[3944.34s -> 3947.34s]  Well, not for this exact code
[3947.34s -> 3950.34s]  because there happens to be a program called echo,
[3950.34s -> 3952.74s]  but if I modified that code here,
[3952.74s -> 3954.74s]  let me just modify this code for you.
[3955.70s -> 3957.86s]  Okay, so first let me just run fork exec.
[3959.78s -> 3962.90s]  It actually does execute echo with those arguments.
[3962.90s -> 3965.38s]  We see the output, this is echo,
[3965.38s -> 3967.54s]  and we see the child exited to show
[3967.54s -> 3971.18s]  that echo exited successfully,
[3971.18s -> 3972.62s]  and the parent waited for it.
[3972.62s -> 3974.98s]  Let me just modify the program for you.
[3976.10s -> 3977.22s]  Instead of echo,
[3977.22s -> 3979.62s]  I'm gonna run some command that doesn't exist.
[3981.86s -> 3986.86s]  Actually I have to exit out of Qemu with Control-A-X
[3986.98s -> 3988.18s]  and then rebuild the whole thing
[3988.18s -> 3992.46s]  in order to recompile my modified fork exec.
[3992.46s -> 3993.82s]  And I run fork exec again
[3993.82s -> 3995.98s]  after modifying and compiling it.
[3995.98s -> 3998.54s]  And this time, because the program we're asking to,
[3999.66s -> 4004.66s]  actually, the program we're asking to execute
[4004.66s -> 4007.50s]  doesn't exist, exec does return.
[4007.50s -> 4012.06s]  We see the exec failed output and the exit one,
[4012.06s -> 4014.58s]  you see the one there is communicated back to the parent,
[4014.58s -> 4016.78s]  which says the child exited the status one.
[4018.54s -> 4022.38s]  So exec returns back to the calling function
[4022.38s -> 4023.94s]  when something went wrong?
[4023.94s -> 4024.78s]  Yes.
[4026.98s -> 4027.82s]  All right.
[4034.86s -> 4035.70s]  Okay, good.
[4040.90s -> 4044.10s]  All right, something to note here
[4044.10s -> 4046.42s]  that actually I think many of you have already noted
[4046.42s -> 4049.54s]  is that this is a common idiom here,
[4049.54s -> 4052.34s]  this fork followed by an exec and the child.
[4053.38s -> 4054.82s]  And it's potentially a bit wasteful.
[4054.86s -> 4058.46s]  The fork copies the entire parent process,
[4058.46s -> 4061.94s]  but exec throws away all that copied memory
[4061.94s -> 4066.50s]  and replaces it with whatever is in the file
[4066.50s -> 4067.34s]  that you're running.
[4067.34s -> 4070.50s]  So if you're worried about this kind of stuff,
[4070.50s -> 4075.50s]  the copy implied by the fork is, in some sense,
[4075.58s -> 4077.62s]  mostly wasted because all that copied memory
[4077.62s -> 4080.34s]  is just thrown away and replaced by the exec.
[4081.42s -> 4083.34s]  And this effect actually would be significant
[4083.34s -> 4084.18s]  for big programs.
[4084.18s -> 4087.22s]  If you have a multi-gigabyte program that calls fork
[4087.22s -> 4089.34s]  and it did indeed copy all the memory,
[4089.34s -> 4091.74s]  it would actually take a fair fraction of a second,
[4091.74s -> 4095.50s]  perhaps, to do the copy, which could be a problem.
[4099.34s -> 4100.82s]  But later in the course,
[4100.82s -> 4103.50s]  you'll actually implement some optimizations,
[4103.50s -> 4106.22s]  in particular, something called copy-on-write fork,
[4106.22s -> 4111.22s]  which will eliminate almost all of the apparent inefficiency
[4111.54s -> 4115.34s]  of fork copying only to have exec throw away the copy.
[4115.34s -> 4116.70s]  It turns out with a bunch of tricks
[4116.70s -> 4118.70s]  involving a virtual memory system,
[4120.06s -> 4122.90s]  you can build a fork that's lazy about the copy
[4122.90s -> 4125.58s]  and that doesn't do, in the common case,
[4125.58s -> 4127.82s]  a fork immediately followed by exec,
[4127.82s -> 4129.46s]  where you don't actually have to do the copy
[4129.46s -> 4132.46s]  because the child doesn't actually use most of the memory.
[4134.30s -> 4137.26s]  I think you'll find that's a fun and interesting lab.
[4137.26s -> 4138.98s]  Question from chat.
[4138.98s -> 4142.26s]  Why does the parent process print parent waiting completely
[4142.26s -> 4144.10s]  before the child calls exec?
[4146.86s -> 4149.02s]  It's just chance.
[4153.98s -> 4155.98s]  The observation is that
[4159.66s -> 4161.42s]  it could be that the parent's output
[4161.42s -> 4163.70s]  could be interleaved with the child's output
[4163.70s -> 4165.26s]  in the same way that we saw before
[4165.26s -> 4167.30s]  with the simpler fork example.
[4168.26s -> 4169.78s]  It just happens not to be.
[4169.78s -> 4173.10s]  There's no guarantee that this is the output we would see.
[4173.10s -> 4175.50s]  In fact, we shouldn't be surprised
[4175.50s -> 4178.18s]  if we saw the lines of the output in the other order
[4178.18s -> 4179.82s]  or interleaved.
[4179.82s -> 4181.86s]  I suspect what's going on
[4181.86s -> 4185.90s]  is that it takes a bit of time and effort.
[4185.90s -> 4187.90s]  The exec system calls a little bit expensive
[4187.90s -> 4190.06s]  because it has to load all those instructions,
[4190.06s -> 4192.86s]  it has to access the file system and access the disk
[4192.86s -> 4195.98s]  and read the contents of a file called echo off the disk
[4195.98s -> 4199.30s]  into memory after allocating some memory
[4199.30s -> 4201.94s]  and that even after freeing some memory from the old process.
[4201.94s -> 4204.30s]  So there's quite a bit of machinery involved
[4204.30s -> 4207.02s]  in the exec system call.
[4207.02s -> 4209.46s]  And apparently, that takes long enough
[4209.46s -> 4212.74s]  that the parent can complete producing the output
[4212.74s -> 4216.46s]  before the exec is finished and started running echo.
[4216.46s -> 4217.54s]  Does that make sense?
[4221.46s -> 4222.46s]  I have another question.
[4222.46s -> 4223.94s]  Is it a convention that the child
[4223.94s -> 4225.34s]  can't wait for the parent?
[4227.70s -> 4230.58s]  There's not a way.
[4230.58s -> 4234.38s]  Unix doesn't have a way for the child.
[4234.38s -> 4236.14s]  There's no straightforward way for the child
[4236.14s -> 4238.10s]  to wait for the parent.
[4238.10s -> 4243.22s]  The wait system call is the only mechanism available.
[4243.22s -> 4248.02s]  Well, the wait system call waits for your children,
[4248.02s -> 4249.90s]  and that's it.
[4249.90s -> 4255.26s]  So what wait does is if you have any children,
[4255.26s -> 4258.90s]  and one of them has already exited or does exit,
[4258.90s -> 4260.46s]  then wait will return.
[4260.46s -> 4262.22s]  But if you don't have any children, say,
[4262.22s -> 4268.54s]  because you are, because in this simple case where it was
[4268.54s -> 4273.06s]  just a parent and a child, if the child called wait,
[4273.06s -> 4275.42s]  the child doesn't have any children, and in that case,
[4275.42s -> 4278.62s]  wait just returns immediately with a minus 1 error return
[4278.66s -> 4281.50s]  saying this process doesn't have any children.
[4281.50s -> 4284.78s]  Anyway, the short answer is there's no way for a child
[4284.78s -> 4287.98s]  to wait for its parent to exit.
[4287.98s -> 4288.94s]  And another question.
[4288.94s -> 4291.94s]  When we say the child copies all the memory
[4291.94s -> 4294.06s]  from the parent process, what exactly
[4294.06s -> 4295.46s]  do we refer to by that?
[4295.46s -> 4299.06s]  I thought the child is going to define the variables again.
[4299.06s -> 4313.22s]  Well, when you compile a, after compilation,
[4313.22s -> 4316.50s]  your C program is just a bunch of instructions
[4316.50s -> 4318.50s]  in memory that live in RAM.
[4321.10s -> 4323.98s]  And so those can be copied because they're just
[4323.98s -> 4325.06s]  bytes living in RAM.
[4325.06s -> 4328.42s]  Those can be copied somewhere else.
[4328.46s -> 4330.34s]  And with appropriate tricks having
[4330.34s -> 4335.46s]  to do with setting up a sort of virtual memory mappings
[4335.46s -> 4337.18s]  and make the mappings look the same when
[4337.18s -> 4338.58s]  the child is in the parent, you
[4338.58s -> 4341.18s]  can just copy the parent's memory image to the child
[4341.18s -> 4343.58s]  and execute it in the child.
[4346.74s -> 4348.46s]  Even though we're looking at C programs,
[4348.46s -> 4350.82s]  you should think of them as just a bunch of machine
[4350.82s -> 4354.62s]  instructions, which are just bytes in memory
[4354.62s -> 4357.34s]  that can be copied.
[4357.42s -> 4359.50s]  If a parent has multiple children,
[4359.50s -> 4362.14s]  would WAIT just return as soon as the first child finishes,
[4362.14s -> 4363.74s]  meaning that there could be some more
[4363.74s -> 4366.42s]  interleaving with the parent and unfinished children?
[4366.42s -> 4368.22s]  Would there need to be multiple separate WAITs
[4368.22s -> 4370.62s]  to ensure all children finish?
[4370.62s -> 4371.62s]  Yes.
[4371.62s -> 4373.86s]  If you call fork more than one,
[4373.86s -> 4379.46s]  if a given process calls fork twice,
[4379.46s -> 4382.10s]  and it wants to wait for both children, it has to call WAIT
[4382.10s -> 4382.86s]  twice.
[4382.86s -> 4385.10s]  And each call to WAIT will return
[4385.10s -> 4387.66s]  as soon as one of the children exits.
[4387.66s -> 4389.62s]  When WAIT returns, you don't necessarily
[4389.62s -> 4394.14s]  know which child has exited, but WAIT returns the child's
[4394.14s -> 4396.14s]  process ID as its return value, so you
[4396.14s -> 4400.58s]  can tell after WAIT returns which one it was that exited.
[4408.82s -> 4414.70s]  As a final example, I'd like to show
[4414.94s -> 4419.82s]  how all of these facilities combine
[4419.82s -> 4423.66s]  to implement IO redirection.
[4423.66s -> 4426.50s]  So if you remember, the shell provides us
[4426.50s -> 4428.38s]  with this handy syntax.
[4428.38s -> 4431.50s]  And I can say echo hello greater than out.
[4431.50s -> 4434.18s]  And that runs the echo command, that argument sending
[4434.18s -> 4437.90s]  its first, but sends its output to the file out
[4437.90s -> 4442.06s]  and we look it out, or better yet,
[4442.06s -> 4444.46s]  on the cap command with its input
[4444.46s -> 4447.62s]  connected from the out file.
[4447.62s -> 4452.26s]  We can see that saved output from the echo command.
[4452.26s -> 4457.34s]  The way the shell sets this up is as follows.
[4461.38s -> 4466.22s]  It, the shell first forks, like on line 13,
[4466.22s -> 4468.90s]  and then in the child, the shell
[4468.90s -> 4471.58s]  changes the way the file descriptors are set up
[4471.62s -> 4475.30s]  so that the child's file descriptor one, which
[4475.30s -> 4479.58s]  by convention, most programs use for that output,
[4479.58s -> 4483.54s]  the shell changes the child's file descriptor one
[4483.54s -> 4487.86s]  to refer to this output file, and then runs whatever
[4487.86s -> 4488.70s]  command you wanted.
[4488.70s -> 4491.98s]  And that leaves the parent shell's file descriptor
[4491.98s -> 4493.62s]  one unchanged.
[4493.62s -> 4497.70s]  So this idiom of forking and then the child changing
[4497.70s -> 4500.74s]  around the file descriptors is the usual way
[4500.74s -> 4505.46s]  in UNIX to redirect input and output for a command
[4505.46s -> 4508.14s]  that you run, but not affect the input and output
[4508.14s -> 4510.50s]  for the calling program.
[4510.50s -> 4514.02s]  Because we don't want to redirect the shell's output.
[4514.02s -> 4518.74s]  We only want to redirect the child program's output.
[4518.74s -> 4520.30s]  Anyway, the way this works, we
[4520.30s -> 4522.34s]  call fork in the usual way.
[4522.34s -> 4524.94s]  Line 15 only executes in the child.
[4524.94s -> 4527.42s]  The reason for the close one on line 15
[4527.42s -> 4531.86s]  is that in this program, we're redirecting just the output
[4531.86s -> 4532.74s]  of the echo command.
[4532.74s -> 4536.18s]  So when I run this redirect program,
[4536.18s -> 4537.78s]  it produces no output itself, but it
[4537.78s -> 4541.70s]  ran echo with its output directed to output.txt.
[4541.70s -> 4547.90s]  So when I look at output.txt, I see this expected output.
[4547.90s -> 4551.10s]  The reason for the close one on line 15
[4551.10s -> 4555.86s]  is that we want one sort of conventional output file
[4555.90s -> 4558.14s]  descriptor to refer to something else.
[4558.14s -> 4562.50s]  It happens so we don't want to use the file descriptor
[4562.50s -> 4566.06s]  one that the shell had that's connected to the console.
[4566.06s -> 4569.42s]  The call to open on line 16 is guaranteed to return one
[4569.42s -> 4572.26s]  because the semantics of open are
[4572.26s -> 4575.26s]  that open returns the lowest file descriptor
[4575.26s -> 4579.62s]  number that's not currently in use in the calling process.
[4579.62s -> 4582.26s]  Since we just closed one and file descriptor
[4582.26s -> 4585.66s]  zero is still connected to the console,
[4585.66s -> 4590.54s]  that means open is guaranteed to return one.
[4590.54s -> 4593.90s]  So after the line 16, file descriptor one
[4593.90s -> 4596.34s]  is connected to this file.
[4596.34s -> 4597.82s]  And when we exec echo, echo just
[4597.82s -> 4600.70s]  writes its output to file descriptor one,
[4600.70s -> 4602.02s]  and now it goes to this file.
[4602.02s -> 4603.22s]  The cool thing about this is that echo
[4603.22s -> 4604.94s]  had no idea what's going on.
[4604.94s -> 4607.78s]  Echo doesn't need to know about IoT direction at all.
[4607.78s -> 4612.02s]  It just writes its output to file descriptor one.
[4612.02s -> 4618.62s]  Only the shell knows about IoT direction.
[4618.62s -> 4624.06s]  This example also illustrates the sort of neatness
[4624.06s -> 4626.18s]  of the separation between fork and exec.
[4626.18s -> 4628.82s]  The fact that fork and exec are separate system
[4628.82s -> 4634.62s]  calls, separate functions, means
[4634.62s -> 4636.54s]  that there's a period of time in the child
[4636.54s -> 4640.38s]  between the fork returns and the child and exec
[4640.38s -> 4642.58s]  in which we're still running the calling
[4642.58s -> 4643.90s]  process's instructions.
[4643.90s -> 4648.42s]  So the calling process, even though its instructions
[4648.42s -> 4650.14s]  are running in the child, it's still
[4650.14s -> 4651.90s]  the calling process's instructions
[4651.90s -> 4653.10s]  that are executing.
[4653.10s -> 4655.90s]  And so the calling process is still
[4655.90s -> 4660.54s]  able to change things still in control up until line 19.
[4660.54s -> 4663.10s]  And this sort of interval between fork and exec
[4663.10s -> 4665.14s]  gives the shell a chance to change
[4665.14s -> 4669.38s]  what the file descriptors refer to, for example.
[4669.42s -> 4671.90s]  Any questions about this redirect example?
[4681.30s -> 4684.02s]  All right.
[4684.02s -> 4686.50s]  We got out of time.
[4686.50s -> 4687.54s]  I'll just wrap up.
[4687.54s -> 4693.06s]  We looked at Unix's a bunch of the interfaces to Unix's IO
[4693.06s -> 4695.50s]  and process abstractions.
[4695.50s -> 4696.82s]  A thing to take away from this
[4696.82s -> 4698.90s]  is that the interfaces are relatively simple.
[4698.94s -> 4702.62s]  You just pass integers like file descriptors and process IDs
[4702.62s -> 4705.30s]  back and forth across as arguments in these system
[4705.30s -> 4707.02s]  calls.
[4707.02s -> 4710.78s]  But the functionality inside the interfaces
[4710.78s -> 4714.58s]  is relatively sophisticated, like creating new processes
[4714.58s -> 4716.78s]  and copying the current process.
[4716.78s -> 4718.94s]  And furthermore, I show some examples
[4718.94s -> 4720.74s]  of ways in which the abstractions,
[4720.74s -> 4724.66s]  though individually simple, combine in useful ways,
[4724.70s -> 4730.18s]  for example, to produce IO redirection.
[4730.18s -> 4733.10s]  There's a lab due at the end of next week.
[4733.10s -> 4736.26s]  And that lab involves writing more simple utilities
[4736.26s -> 4738.30s]  like the ones I showed that use the system calls
[4738.30s -> 4740.30s]  that we discussed.
[4740.30s -> 4741.54s]  So have fun with that lab.
[4741.54s -> 4743.74s]  And I'll see you in class next week.
[4747.70s -> 4748.50s]  And that's it.
[4754.66s -> 4761.46s]  Since I'm the one recording, how do I end this?
[4761.46s -> 4763.34s]  The first time recording is in lecture.
[4763.34s -> 4765.14s]  I think we exit.
[4765.14s -> 4765.78s]  OK.
[4765.78s -> 4766.46s]  And nothing special.
[4766.46s -> 4769.14s]  I can just exit and it'll be saved somewhere?
[4769.14s -> 4769.94s]  Yes.
[4769.94s -> 4770.46s]  Awesome.
[4775.06s -> 4778.10s]  Zoom will create some directory and stick
[4778.10s -> 4779.42s]  the file in that directory.
[4784.74s -> 4788.10s]  There's also office hours right after this, right?
[4788.10s -> 4789.02s]  Yes.
[4789.02s -> 4791.38s]  Perfect.
[4791.38s -> 4791.90s]  Cool.
[4796.62s -> 4797.82s]  All right.
[4797.82s -> 4798.66s]  All right.
[4798.66s -> 4799.18s]  Thank you.
[4799.18s -> 4800.82s]  And we'll see you next week.
[4800.82s -> 4801.34s]  Thanks.
